use convert_case::{Casing, Case};
use syn::*;
use syn::parse::*;
use quote::*;
use syn::spanned::Spanned;

use crate::config::{Config, ConfigLock};


#[derive(Debug)]
struct JsBindAttrs {
	mode: String,
}

impl Parse for JsBindAttrs {
	fn parse(input: ParseStream) -> Result<Self> {
		// Parse attribute like `mode = "web"`
		let mode = input.parse::<Ident>()?.to_string();
		input.parse::<Token![=]>()?;
		let mode_value = input.parse::<LitStr>()?.value();
		Ok(Self {
			mode: mode_value,
		})
		// Ok(Self {
		// 	js_mod_name: input.parse::<LitStr>()?.value(),
		// 	js_method_name: input.parse::<LitStr>().ok().map(|s| s.value()),
		// })
	}
}

fn convert_from_snake_case_to_camel_case(name: String) -> String {
	name.to_case(Case::Camel)
}

pub fn _js_bind_impl(_attr: proc_macro2::TokenStream, _input: proc_macro2::TokenStream) -> proc_macro2::TokenStream {
	let _input: ItemFn = syn::parse2(_input).expect("Cannot parse input as a function");
	let attr: JsBindAttrs = syn::parse2(_attr).expect(r##"Cannot parse attributes as `method = "something"`"##);

	let mut cwd = std::env::current_dir().expect("Cannot get current working directory");
	let config = Config::from_config_dir(&mut cwd).expect("Cannot parse config");
	let mode = config.modes.get(&attr.mode).expect(&format!(r##"Cannot find mode "{}" in config"##, &attr.mode));
	let lock = ConfigLock::from_config_dir(&mut cwd).expect("Cannot parse config lock");
	
	quote!{pub fn works() -> i32 {42}}.into()
}

// pub fn _js_bind_impl2(attr: proc_macro2::TokenStream, input: proc_macro2::TokenStream) -> proc_macro2::TokenStream {
// 	let item = syn::parse::<ItemFn>(input.into()).map_err(|e| e.to_compile_error()).expect("ItemFn to parse properly");
// 	// eprintln!("Item: {:#?}", item);
	
// 	let sig = &item.sig;
// 	let sig_str = quote!(#sig);
// 	// eprintln!("Sig str: {:?}", sig_str.to_string());
// 	let sig_name = &sig.ident;


// 	// handle_doc_comments(&item);

// 	// let attr = parse_macro_input!(attr as LitStr);
// 	// let attr_indent = format_ident!("{}", attr.value());
// 	// // eprintln!("Attr: {:#?}", attr);
// 	// let module_name = attr_indent;
// 	// let module_name_underscore = format_ident!("_{}", &module_name);

// 	// let attrs = parse_macro_input!(attr as JsBindAttrs);
// 	let attrs = syn::parse::<JsBindAttrs>(attr.into()).map_err(|e| e.to_compile_error()).expect("ItemFn to parse properly");
	
// 	// eprintln!("Attr: {:#?}", attrs);
// 	let js_mod_name = Ident::new(&attrs.js_mod_name, sig.span());
// 	let js_mod_name_str = format!(r"{}", js_mod_name.to_string());
// 	let _js_mod_name = format_ident!("_{}", &js_mod_name);
// 	let js_method_name_str = format!(r#"{}"#, attrs.js_method_name.unwrap_or(convert_from_snake_case_to_camel_case(sig_name.to_string())));

// 	let sig_inputs = &sig.inputs;
// 	// eprintln!("Sig inputs: {:#?}", sig_inputs);

// 	let passed_parameters = sig_inputs.iter().map(|arg| {
// 		match arg {
// 			FnArg::Receiver(_) => panic!("Cannot use receiver in js_bind"),
// 			FnArg::Typed(pat_type) => {
// 				let pat = &pat_type.pat;
// 				// let ty = &pat_type.ty;
// 				// quote!(#pat: #ty)
// 				quote!(#pat)
// 			}
// 		}
// 	});

// 	let function_wrapper = quote! {
// 		pub #sig_str {
// 			// #module_name_underscore::#attr_indent(#(#sig_inputs),*)
// 			// #module_name_underscore::#sig_name()
// 			// #[cfg(feature = "verbose-logging")]
// 			::log::info!("Calling function: {}::{}(<parameters pass not implemented yet>)", stringify!(#_js_mod_name), stringify!(#sig_name));
// 			#_js_mod_name::#sig_name(#(#passed_parameters),*)
// 		}
// 	};

// 	let _internal_docs = format!(r##"This is an internal function, generated by the #[js_bind] macro. By design, the module is private"##);
// 	let internal_docs = quote! {
// 		#[doc = #_internal_docs]
// 	};

// 	#[cfg(feature = "strict-feature-checks")]
// 	let feature_checks = quote! {
// 		// If no feature enabled
// 		#[cfg(all(not(feature = "node-not-web"), not(feature = "web-not-node")))]
// 		compile_error!("Must enable either feature `web-not-node` or `node-not-web`");
// 		// If both features enabled
// 		#[cfg(all(feature = "node-not-web", feature = "web-not-node"))]
// 		compile_error!("Most not enable both features `web-not-node` and `node-not-web`");
// 	};
// 	#[cfg(not(feature = "strict-feature-checks"))]
// 	let feature_checks = quote! {
// 		// If no feature enabled
// 		#[cfg(all(not(feature = "node-not-web"), not(feature = "web-not-node")))]
// 		eprintln!("[strict-feature-checks=false => no error] Must enable either feature `web-not-node` or `node-not-web`");
// 		// If both features enabled
// 		#[cfg(all(feature = "node-not-web", feature = "web-not-node"))]
// 		eprintln!("[strict-feature-checks=false => no error] Most not enable both features `web-not-node` and `node-not-web`");
// 	};

// 	let expanded = quote! {
// 		#feature_checks

// 		// use wasm_bindgen::prelude::wasm_bindgen;
// 		// If either feature is enabled
// 		#[cfg_attr(
// 			all(feature = "web-not-node", not(feature = "node-not-web")),
// 			::wasm_bindgen::prelude::wasm_bindgen(module = "/js/bundle-es.js")
// 		)]
// 		#[cfg_attr(
// 			all(feature = "node-not-web", not(feature = "web-not-node")),
// 			::wasm_bindgen::prelude::wasm_bindgen(module = "/js/bundle-cjs.js")
// 		)]
// 		extern "C" {
// 			#[allow(non_camel_case_types)]
// 			#[::wasm_bindgen::prelude::wasm_bindgen(js_name = #js_mod_name_str)]
// 			type #_js_mod_name;

// 			#[::wasm_bindgen::prelude::wasm_bindgen(catch, static_method_of = #_js_mod_name, js_name = #js_method_name_str)]
// 			#internal_docs
// 			#sig_str;
// 		}

// 		#function_wrapper
// 	};

// 	// eprintln!("Expanded: {}", expanded.to_string());

// 	expanded.into()
// }