function wrapper(name, callback) {
    return (...args) => {
        console.info(`firebase-js-sys: Calling '${name}' with args:`, args);
        const returned = callback(...args);
        if (returned) {
            console.info(`firebase-js-sys: '${name}' returned:`, returned);
        }
        return returned;
    };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
const CONSTANTS = {
    /**
     * @define {boolean} Whether this is the client Node.js SDK.
     */
    NODE_CLIENT: false,
    /**
     * @define {boolean} Whether this is the Admin Node.js SDK.
     */
    NODE_ADMIN: false,
    /**
     * Firebase SDK Version
     */
    SDK_VERSION: '${JSCORE_VERSION}'
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Throws an error if the provided assertion is falsy
 */
const assert = function (assertion, message) {
    if (!assertion) {
        throw assertionError(message);
    }
};
/**
 * Returns an Error object suitable for throwing.
 */
const assertionError = function (message) {
    return new Error('Firebase Database (' +
        CONSTANTS.SDK_VERSION +
        ') INTERNAL ASSERT FAILED: ' +
        message);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function (str) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if ((c & 0xfc00) === 0xd800 &&
            i + 1 < str.length &&
            (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            // Surrogate Pair
            c = 0x10000 + ((c & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param bytes Array of numbers representing characters.
 * @return Stringification of the array.
 */
const byteArrayToString = function (bytes) {
    // TODO(user): Use native implementations if/when available
    const out = [];
    let pos = 0, c = 0;
    while (pos < bytes.length) {
        const c1 = bytes[pos++];
        if (c1 < 128) {
            out[c++] = String.fromCharCode(c1);
        }
        else if (c1 > 191 && c1 < 224) {
            const c2 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
        }
        else if (c1 > 239 && c1 < 365) {
            // Surrogate Pair
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            const c4 = bytes[pos++];
            const u = (((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63)) -
                0x10000;
            out[c++] = String.fromCharCode(0xd800 + (u >> 10));
            out[c++] = String.fromCharCode(0xdc00 + (u & 1023));
        }
        else {
            const c2 = bytes[pos++];
            const c3 = bytes[pos++];
            out[c++] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
        }
    }
    return out.join('');
};
// We define it as an object literal instead of a class because a class compiled down to es5 can't
// be treeshaked. https://github.com/rollup/rollup/issues/1691
// Static lookup maps, lazily populated by init_()
const base64 = {
    /**
     * Maps bytes to characters.
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeByteArray(input, webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        const byteToCharMap = webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        const output = [];
        for (let i = 0; i < input.length; i += 3) {
            const byte1 = input[i];
            const haveByte2 = i + 1 < input.length;
            const byte2 = haveByte2 ? input[i + 1] : 0;
            const haveByte3 = i + 2 < input.length;
            const byte3 = haveByte3 ? input[i + 2] : 0;
            const outByte1 = byte1 >> 2;
            const outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            let outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            let outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeString(input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */
    decodeString(input, webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */
    decodeStringToByteArray(input, webSafe) {
        this.init_();
        const charToByteMap = webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        const output = [];
        for (let i = 0; i < input.length;) {
            const byte1 = charToByteMap[input.charAt(i++)];
            const haveByte2 = i < input.length;
            const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            const haveByte3 = i < input.length;
            const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            const haveByte4 = i < input.length;
            const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw new DecodeBase64StringError();
            }
            const outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 !== 64) {
                const outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 !== 64) {
                    const outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_() {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (let i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * An error encountered while decoding base64 string.
 */
class DecodeBase64StringError extends Error {
    constructor() {
        super(...arguments);
        this.name = 'DecodeBase64StringError';
    }
}
/**
 * URL-safe base64 encoding
 */
const base64Encode = function (str) {
    const utf8Bytes = stringToByteArray$1(str);
    return base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 encoding (without "." padding in the end).
 * e.g. Used in JSON Web Token (JWT) parts.
 */
const base64urlEncodeWithoutPadding = function (str) {
    // Use base64url encoding and remove padding in the end (dot characters).
    return base64Encode(str).replace(/\./g, '');
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param str To be decoded
 * @return Decoded result, if possible
 */
const base64Decode = function (str) {
    try {
        return base64.decodeString(str, true);
    }
    catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 *
 * Note: we don't merge __proto__ to prevent prototype pollution
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            const dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (const prop in source) {
        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202
        if (!source.hasOwnProperty(prop) || !isValidKey$1(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
function isValidKey$1(key) {
    return key !== '__proto__';
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Polyfill for `globalThis` object.
 * @returns the `globalThis` object for the given environment.
 * @public
 */
function getGlobal() {
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof global !== 'undefined') {
        return global;
    }
    throw new Error('Unable to locate global object.');
}

/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
/**
 * Attempt to read defaults from a JSON string provided to
 * process(.)env(.)__FIREBASE_DEFAULTS__ or a JSON file whose path is in
 * process(.)env(.)__FIREBASE_DEFAULTS_PATH__
 * The dots are in parens because certain compilers (Vite?) cannot
 * handle seeing that variable in comments.
 * See https://github.com/firebase/firebase-js-sdk/issues/6838
 */
const getDefaultsFromEnvVariable = () => {
    if (typeof process === 'undefined' || typeof process.env === 'undefined') {
        return;
    }
    const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
    if (defaultsJsonString) {
        return JSON.parse(defaultsJsonString);
    }
};
const getDefaultsFromCookie = () => {
    if (typeof document === 'undefined') {
        return;
    }
    let match;
    try {
        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
    }
    catch (e) {
        // Some environments such as Angular Universal SSR have a
        // `document` object but error on accessing `document.cookie`.
        return;
    }
    const decoded = match && base64Decode(match[1]);
    return decoded && JSON.parse(decoded);
};
/**
 * Get the __FIREBASE_DEFAULTS__ object. It checks in order:
 * (1) if such an object exists as a property of `globalThis`
 * (2) if such an object was provided on a shell environment variable
 * (3) if such an object exists in a cookie
 * @public
 */
const getDefaults = () => {
    try {
        return (getDefaultsFromGlobal() ||
            getDefaultsFromEnvVariable() ||
            getDefaultsFromCookie());
    }
    catch (e) {
        /**
         * Catch-all for being unable to get __FIREBASE_DEFAULTS__ due
         * to any environment case we have not accounted for. Log to
         * info instead of swallowing so we can find these unknown cases
         * and add paths for them if needed.
         */
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
        return;
    }
};
/**
 * Returns emulator host stored in the __FIREBASE_DEFAULTS__ object
 * for the given product.
 * @returns a URL host formatted like `127.0.0.1:9999` or `[::1]:4000` if available
 * @public
 */
const getDefaultEmulatorHost = (productName) => { var _a, _b; return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName]; };
/**
 * Returns emulator hostname and port stored in the __FIREBASE_DEFAULTS__ object
 * for the given product.
 * @returns a pair of hostname and port like `["::1", 4000]` if available
 * @public
 */
const getDefaultEmulatorHostnameAndPort = (productName) => {
    const host = getDefaultEmulatorHost(productName);
    if (!host) {
        return undefined;
    }
    const separatorIndex = host.lastIndexOf(':'); // Finding the last since IPv6 addr also has colons.
    if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
        throw new Error(`Invalid host ${host} with no separate hostname and port!`);
    }
    // eslint-disable-next-line no-restricted-globals
    const port = parseInt(host.substring(separatorIndex + 1), 10);
    if (host[0] === '[') {
        // Bracket-quoted `[ipv6addr]:port` => return "ipv6addr" (without brackets).
        return [host.substring(1, separatorIndex - 1), port];
    }
    else {
        return [host.substring(0, separatorIndex), port];
    }
};
/**
 * Returns Firebase app config stored in the __FIREBASE_DEFAULTS__ object.
 * @public
 */
const getDefaultAppConfig = () => { var _a; return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config; };

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred {
    constructor() {
        this.reject = () => { };
        this.resolve = () => { };
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     */
    wrapCallback(callback) {
        return (error, value) => {
            if (error) {
                this.reject(error);
            }
            else {
                this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                this.promise.catch(() => { });
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                }
                else {
                    callback(error, value);
                }
            }
        };
    }
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createMockUserToken(token, projectId) {
    if (token.uid) {
        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
    }
    // Unsecured JWTs use "none" as the algorithm.
    const header = {
        alg: 'none',
        type: 'JWT'
    };
    const project = projectId || 'demo-project';
    const iat = token.iat || 0;
    const sub = token.sub || token.user_id;
    if (!sub) {
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
    }
    const payload = Object.assign({ 
        // Set all required fields to decent defaults
        iss: `https://securetoken.google.com/${project}`, aud: project, iat, exp: iat + 3600, auth_time: iat, sub, user_id: sub, firebase: {
            sign_in_provider: 'custom',
            identities: {}
        } }, token);
    // Unsecured JWTs use the empty string as a signature.
    const signature = '';
    return [
        base64urlEncodeWithoutPadding(JSON.stringify(header)),
        base64urlEncodeWithoutPadding(JSON.stringify(payload)),
        signature
    ].join('.');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return user agent string
 */
function getUA() {
    if (typeof navigator !== 'undefined' &&
        typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    }
    else {
        return '';
    }
}
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap
 * in the Ripple emulator) nor Cordova `onDeviceReady`, which would normally
 * wait for a callback.
 */
function isMobileCordova() {
    return (typeof window !== 'undefined' &&
        // @ts-ignore Setting up an broadly applicable index signature for Window
        // just to deal with this case would probably be a bad idea.
        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&
        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA()));
}
/**
 * Detect React Native.
 *
 * @return true if ReactNative environment is detected.
 */
function isReactNative() {
    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');
}
/**
 * Detect whether the current SDK build is the Node version.
 *
 * @return true if it's the Node SDK build.
 */
function isNodeSdk() {
    return CONSTANTS.NODE_ADMIN === true;
}
/**
 * This method checks if indexedDB is supported by current browser/service worker context
 * @return true if indexedDB is supported by current browser/service worker context
 */
function isIndexedDBAvailable() {
    try {
        return typeof indexedDB === 'object';
    }
    catch (e) {
        return false;
    }
}
/**
 * This method validates browser/sw context for indexedDB by opening a dummy indexedDB database and reject
 * if errors occur during the database open operation.
 *
 * @throws exception if current browser/sw context can't run idb.open (ex: Safari iframe, Firefox
 * private browsing)
 */
function validateIndexedDBOpenable() {
    return new Promise((resolve, reject) => {
        try {
            let preExist = true;
            const DB_CHECK_NAME = 'validate-browser-context-for-indexeddb-analytics-module';
            const request = self.indexedDB.open(DB_CHECK_NAME);
            request.onsuccess = () => {
                request.result.close();
                // delete database only when it doesn't pre-exist
                if (!preExist) {
                    self.indexedDB.deleteDatabase(DB_CHECK_NAME);
                }
                resolve(true);
            };
            request.onupgradeneeded = () => {
                preExist = false;
            };
            request.onerror = () => {
                var _a;
                reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || '');
            };
        }
        catch (error) {
            reject(error);
        }
    });
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Standardized Firebase Error.
 *
 * Usage:
 *
 *   // Typescript string literals for type-safe codes
 *   type Err =
 *     'unknown' |
 *     'object-not-found'
 *     ;
 *
 *   // Closure enum for type-safe error codes
 *   // at-enum {string}
 *   var Err = {
 *     UNKNOWN: 'unknown',
 *     OBJECT_NOT_FOUND: 'object-not-found',
 *   }
 *
 *   let errors: Map<Err, string> = {
 *     'generic-error': "Unknown error",
 *     'file-not-found': "Could not find file: {$file}",
 *   };
 *
 *   // Type-safe function - must pass a valid error code as param.
 *   let error = new ErrorFactory<Err>('service', 'Service', errors);
 *
 *   ...
 *   throw error.create(Err.GENERIC);
 *   ...
 *   throw error.create(Err.FILE_NOT_FOUND, {'file': fileName});
 *   ...
 *   // Service: Could not file file: foo.txt (service/file-not-found).
 *
 *   catch (e) {
 *     assert(e.message === "Could not find file: foo.txt.");
 *     if ((e as FirebaseError)?.code === 'service/file-not-found') {
 *       console.log("Could not read file: " + e['file']);
 *     }
 *   }
 */
const ERROR_NAME = 'FirebaseError';
// Based on code from:
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
class FirebaseError extends Error {
    constructor(
    /** The error code for this error. */
    code, message, 
    /** Custom data for this error. */
    customData) {
        super(message);
        this.code = code;
        this.customData = customData;
        /** The custom name for all FirebaseErrors. */
        this.name = ERROR_NAME;
        // Fix For ES5
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, FirebaseError.prototype);
        // Maintains proper stack trace for where our error was thrown.
        // Only available on V8.
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ErrorFactory.prototype.create);
        }
    }
}
class ErrorFactory {
    constructor(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
    }
    create(code, ...data) {
        const customData = data[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template = this.errors[code];
        const message = template ? replaceTemplate(template, customData) : 'Error';
        // Service Name: Error message (service/code).
        const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
        const error = new FirebaseError(fullCode, fullMessage, customData);
        return error;
    }
}
function replaceTemplate(template, data) {
    return template.replace(PATTERN, (_, key) => {
        const value = data[key];
        return value != null ? String(value) : `<${key}?>`;
    });
}
const PATTERN = /\{\$([^}]+)}/g;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
    return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
    return JSON.stringify(data);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const decode = function (token) {
    let header = {}, claims = {}, data = {}, signature = '';
    try {
        const parts = token.split('.');
        header = jsonEval(base64Decode(parts[0]) || '');
        claims = jsonEval(base64Decode(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    }
    catch (e) { }
    return {
        header,
        claims,
        data,
        signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isValidFormat = function (token) {
    const decoded = decode(token), claims = decoded.claims;
    return !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 */
const isAdmin = function (token) {
    const claims = decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function safeGet(obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
    }
    else {
        return undefined;
    }
}
function isEmpty(obj) {
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}
function map(obj, fn, contextObj) {
    const res = {};
    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            res[key] = fn.call(contextObj, obj[key], key, obj);
        }
    }
    return res;
}
/**
 * Deep equal two objects. Support Arrays and Objects.
 */
function deepEqual(a, b) {
    if (a === b) {
        return true;
    }
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);
    for (const k of aKeys) {
        if (!bKeys.includes(k)) {
            return false;
        }
        const aProp = a[k];
        const bProp = b[k];
        if (isObject(aProp) && isObject(bProp)) {
            if (!deepEqual(aProp, bProp)) {
                return false;
            }
        }
        else if (aProp !== bProp) {
            return false;
        }
    }
    for (const k of bKeys) {
        if (!aKeys.includes(k)) {
            return false;
        }
    }
    return true;
}
function isObject(thing) {
    return thing !== null && typeof thing === 'object';
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a
 * params object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 */
function querystring(querystringParams) {
    const params = [];
    for (const [key, value] of Object.entries(querystringParams)) {
        if (Array.isArray(value)) {
            value.forEach(arrayVal => {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        }
        else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    }
    return params.length ? '&' + params.join('&') : '';
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @final
 * @struct
 */
class Sha1 {
    constructor() {
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @private
         */
        this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @private
         */
        this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @private
         */
        this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @private
         */
        this.pad_ = [];
        /**
         * @private {number}
         */
        this.inbuf_ = 0;
        /**
         * @private {number}
         */
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (let i = 1; i < this.blockSize; ++i) {
            this.pad_[i] = 0;
        }
        this.reset();
    }
    reset() {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    }
    /**
     * Internal compress helper function.
     * @param buf Block to compress.
     * @param offset Offset of the block in the buffer.
     * @private
     */
    compress_(buf, offset) {
        if (!offset) {
            offset = 0;
        }
        const W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (let i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] =
                    (buf.charCodeAt(offset) << 24) |
                        (buf.charCodeAt(offset + 1) << 16) |
                        (buf.charCodeAt(offset + 2) << 8) |
                        buf.charCodeAt(offset + 3);
                offset += 4;
            }
        }
        else {
            for (let i = 0; i < 16; i++) {
                W[i] =
                    (buf[offset] << 24) |
                        (buf[offset + 1] << 16) |
                        (buf[offset + 2] << 8) |
                        buf[offset + 3];
                offset += 4;
            }
        }
        // expand to 80 words
        for (let i = 16; i < 80; i++) {
            const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
        }
        let a = this.chain_[0];
        let b = this.chain_[1];
        let c = this.chain_[2];
        let d = this.chain_[3];
        let e = this.chain_[4];
        let f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (let i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ (b & (c ^ d));
                    k = 0x5a827999;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            }
            else {
                if (i < 60) {
                    f = (b & c) | (d & (b | c));
                    k = 0x8f1bbcdc;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            const t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
            e = d;
            d = c;
            c = ((b << 30) | (b >>> 2)) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
    }
    update(bytes, length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (length === undefined) {
            length = bytes.length;
        }
        const lengthMinusBlock = length - this.blockSize;
        let n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        const buf = this.buf_;
        let inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf === 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf === this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
            else {
                while (n < length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf === this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += length;
    }
    /** @override */
    digest() {
        const digest = [];
        let totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        }
        else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (let i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        let n = 0;
        for (let i = 0; i < 5; i++) {
            for (let j = 24; j >= 0; j -= 8) {
                digest[n] = (this.chain_[i] >> j) & 255;
                ++n;
            }
        }
        return digest;
    }
}
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param fnName The function name
 * @param argName The name of the argument
 * @return The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argName) {
    return `${fnName} failed: ${argName} argument `;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
const stringToByteArray = function (str) {
    const out = [];
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            const high = c - 0xd800; // the high 10 bits.
            i++;
            assert(i < str.length, 'Surrogate pair missing trail surrogate.');
            const low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if (c < 65536) {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
const stringLength = function (str) {
    let p = 0;
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        }
        else if (c < 2048) {
            p += 2;
        }
        else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        }
        else {
            p += 3;
        }
    }
    return p;
};

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getModularInstance(service) {
    if (service && service._delegate) {
        return service._delegate;
    }
    else {
        return service;
    }
}

/**
 * Component for service name T, e.g. `auth`, `auth-internal`
 */
class Component {
    /**
     *
     * @param name The public service name, e.g. app, auth, firestore, database
     * @param instanceFactory Service factory responsible for creating the public interface
     * @param type whether the service provided by the component is public or private
     */
    constructor(name, instanceFactory, type) {
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */
        this.serviceProps = {};
        this.instantiationMode = "LAZY" /* InstantiationMode.LAZY */;
        this.onInstanceCreated = null;
    }
    setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
    }
    setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
    }
    setServiceProps(props) {
        this.serviceProps = props;
        return this;
    }
    setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME$1 = '[DEFAULT]';

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
 * NameServiceMapping[T] is an alias for the type of the instance
 */
class Provider {
    constructor(name, container) {
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
    }
    /**
     * @param identifier A provider can provide mulitple instances of a service
     * if this.component.multipleInstances is true.
     */
    get(identifier) {
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
            const deferred = new Deferred();
            this.instancesDeferred.set(normalizedIdentifier, deferred);
            if (this.isInitialized(normalizedIdentifier) ||
                this.shouldAutoInitialize()) {
                // initialize the service if it can be auto-initialized
                try {
                    const instance = this.getOrInitializeService({
                        instanceIdentifier: normalizedIdentifier
                    });
                    if (instance) {
                        deferred.resolve(instance);
                    }
                }
                catch (e) {
                    // when the instance factory throws an exception during get(), it should not cause
                    // a fatal error. We just return the unresolved promise in this case.
                }
            }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
    }
    getImmediate(options) {
        var _a;
        // if multipleInstances is not supported, use the default name
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) ||
            this.shouldAutoInitialize()) {
            try {
                return this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
            }
            catch (e) {
                if (optional) {
                    return null;
                }
                else {
                    throw e;
                }
            }
        }
        else {
            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
            if (optional) {
                return null;
            }
            else {
                throw Error(`Service ${this.name} is not available`);
            }
        }
    }
    getComponent() {
        return this.component;
    }
    setComponent(component) {
        if (component.name !== this.name) {
            throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
        }
        if (this.component) {
            throw Error(`Component for ${this.name} has already been provided`);
        }
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) {
            return;
        }
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) {
            try {
                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME$1 });
            }
            catch (e) {
                // when the instance factory for an eager Component throws an exception during the eager
                // initialization, it should not cause a fatal error.
                // TODO: Investigate if we need to make it configurable, because some component may want to cause
                // a fatal error in this case?
            }
        }
        // Create service instances for the pending promises and resolve them
        // NOTE: if this.multipleInstances is false, only the default instance will be created
        // and all promises with resolve with it regardless of the identifier.
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
            const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try {
                // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
                const instance = this.getOrInitializeService({
                    instanceIdentifier: normalizedIdentifier
                });
                instanceDeferred.resolve(instance);
            }
            catch (e) {
                // when the instance factory throws an exception, it should not cause
                // a fatal error. We just leave the promise unresolved.
            }
        }
    }
    clearInstance(identifier = DEFAULT_ENTRY_NAME$1) {
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
    }
    // app.delete() will call this method on every provider to delete the services
    // TODO: should we mark the provider as deleted?
    async delete() {
        const services = Array.from(this.instances.values());
        await Promise.all([
            ...services
                .filter(service => 'INTERNAL' in service) // legacy services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service.INTERNAL.delete()),
            ...services
                .filter(service => '_delete' in service) // modularized services
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                .map(service => service._delete())
        ]);
    }
    isComponentSet() {
        return this.component != null;
    }
    isInitialized(identifier = DEFAULT_ENTRY_NAME$1) {
        return this.instances.has(identifier);
    }
    getOptions(identifier = DEFAULT_ENTRY_NAME$1) {
        return this.instancesOptions.get(identifier) || {};
    }
    initialize(opts = {}) {
        const { options = {} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
            throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
        }
        if (!this.isComponentSet()) {
            throw Error(`Component ${this.name} has not been registered yet`);
        }
        const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier,
            options
        });
        // resolve any pending promise waiting for the service instance
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
            const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) {
                instanceDeferred.resolve(instance);
            }
        }
        return instance;
    }
    /**
     *
     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
     *
     * @param identifier An optional instance identifier
     * @returns a function to unregister the callback
     */
    onInit(callback, identifier) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
            callback(existingInstance, normalizedIdentifier);
        }
        return () => {
            existingCallbacks.delete(callback);
        };
    }
    /**
     * Invoke onInit callbacks synchronously
     * @param instance the service instance`
     */
    invokeOnInitCallbacks(instance, identifier) {
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
            return;
        }
        for (const callback of callbacks) {
            try {
                callback(instance, identifier);
            }
            catch (_a) {
                // ignore errors in the onInit callback
            }
        }
    }
    getOrInitializeService({ instanceIdentifier, options = {} }) {
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
            instance = this.component.instanceFactory(this.container, {
                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
                options
            });
            this.instances.set(instanceIdentifier, instance);
            this.instancesOptions.set(instanceIdentifier, options);
            /**
             * Invoke onInit listeners.
             * Note this.component.onInstanceCreated is different, which is used by the component creator,
             * while onInit listeners are registered by consumers of the provider.
             */
            this.invokeOnInitCallbacks(instance, instanceIdentifier);
            /**
             * Order is important
             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
             * makes `isInitialized()` return true.
             */
            if (this.component.onInstanceCreated) {
                try {
                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
                }
                catch (_a) {
                    // ignore errors in the onInstanceCreatedCallback
                }
            }
        }
        return instance || null;
    }
    normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME$1) {
        if (this.component) {
            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
        }
        else {
            return identifier; // assume multiple instances are supported before the component is provided.
        }
    }
    shouldAutoInitialize() {
        return (!!this.component &&
            this.component.instantiationMode !== "EXPLICIT" /* InstantiationMode.EXPLICIT */);
    }
}
// undefined should be passed to the service factory for the default instance
function normalizeIdentifierForFactory(identifier) {
    return identifier === DEFAULT_ENTRY_NAME$1 ? undefined : identifier;
}
function isComponentEager(component) {
    return component.instantiationMode === "EAGER" /* InstantiationMode.EAGER */;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
 */
class ComponentContainer {
    constructor(name) {
        this.name = name;
        this.providers = new Map();
    }
    /**
     *
     * @param component Component being added
     * @param overwrite When a component with the same name has already been registered,
     * if overwrite is true: overwrite the existing component with the new component and create a new
     * provider with the new component. It can be useful in tests where you want to use different mocks
     * for different tests.
     * if overwrite is false: throw an exception
     */
    addComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
            throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
        }
        provider.setComponent(component);
    }
    addOrOverwriteComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
            // delete the existing provider from the container, so we can register the new component
            this.providers.delete(component.name);
        }
        this.addComponent(component);
    }
    /**
     * getProvider provides a type safe interface where it can only be called with a field name
     * present in NameServiceMapping interface.
     *
     * Firebase SDKs providing services should extend NameServiceMapping interface to register
     * themselves.
     */
    getProvider(name) {
        if (this.providers.has(name)) {
            return this.providers.get(name);
        }
        // create a Provider for a service that hasn't registered with Firebase
        const provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
    }
    getProviders() {
        return Array.from(this.providers.values());
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The JS SDK supports 5 log levels and also allows a user the ability to
 * silence the logs altogether.
 *
 * The order is a follows:
 * DEBUG < VERBOSE < INFO < WARN < ERROR
 *
 * All of the log types above the current log level will be captured (i.e. if
 * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
 * `VERBOSE` logs will not)
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
    'debug': LogLevel.DEBUG,
    'verbose': LogLevel.VERBOSE,
    'info': LogLevel.INFO,
    'warn': LogLevel.WARN,
    'error': LogLevel.ERROR,
    'silent': LogLevel.SILENT
};
/**
 * The default log level
 */
const defaultLogLevel = LogLevel.INFO;
/**
 * By default, `console.debug` is not displayed in the developer console (in
 * chrome). To avoid forcing users to have to opt-in to these logs twice
 * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
 * logs to the `console.log` function.
 */
const ConsoleMethod = {
    [LogLevel.DEBUG]: 'log',
    [LogLevel.VERBOSE]: 'log',
    [LogLevel.INFO]: 'info',
    [LogLevel.WARN]: 'warn',
    [LogLevel.ERROR]: 'error'
};
/**
 * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
 * messages on to their corresponding console counterparts (if the log method
 * is supported by the current log level)
 */
const defaultLogHandler = (instance, logType, ...args) => {
    if (logType < instance.logLevel) {
        return;
    }
    const now = new Date().toISOString();
    const method = ConsoleMethod[logType];
    if (method) {
        console[method](`[${now}]  ${instance.name}:`, ...args);
    }
    else {
        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
    }
};
class Logger {
    /**
     * Gives you an instance of a Logger to capture messages according to
     * Firebase's logging scheme.
     *
     * @param name The name that the logs will be associated with
     */
    constructor(name) {
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */
        this._logLevel = defaultLogLevel;
        /**
         * The main (internal) log handler for the Logger instance.
         * Can be set to a new function in internal package code but not by user.
         */
        this._logHandler = defaultLogHandler;
        /**
         * The optional, additional, user-defined log handler for the Logger instance.
         */
        this._userLogHandler = null;
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(val) {
        if (!(val in LogLevel)) {
            throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
    }
    // Workaround for setter/getter having to be the same type.
    setLogLevel(val) {
        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;
    }
    get logHandler() {
        return this._logHandler;
    }
    set logHandler(val) {
        if (typeof val !== 'function') {
            throw new TypeError('Value assigned to `logHandler` must be a function');
        }
        this._logHandler = val;
    }
    get userLogHandler() {
        return this._userLogHandler;
    }
    set userLogHandler(val) {
        this._userLogHandler = val;
    }
    /**
     * The functions below are all based on the `console` interface
     */
    debug(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
        this._logHandler(this, LogLevel.DEBUG, ...args);
    }
    log(...args) {
        this._userLogHandler &&
            this._userLogHandler(this, LogLevel.VERBOSE, ...args);
        this._logHandler(this, LogLevel.VERBOSE, ...args);
    }
    info(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
        this._logHandler(this, LogLevel.INFO, ...args);
    }
    warn(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
        this._logHandler(this, LogLevel.WARN, ...args);
    }
    error(...args) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
        this._logHandler(this, LogLevel.ERROR, ...args);
    }
}

const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);

let idbProxyableTypes;
let cursorAdvanceMethods;
// This is a function to prevent it throwing up in node environments.
function getIdbProxyableTypes() {
    return (idbProxyableTypes ||
        (idbProxyableTypes = [
            IDBDatabase,
            IDBObjectStore,
            IDBIndex,
            IDBCursor,
            IDBTransaction,
        ]));
}
// This is a function to prevent it throwing up in node environments.
function getCursorAdvanceMethods() {
    return (cursorAdvanceMethods ||
        (cursorAdvanceMethods = [
            IDBCursor.prototype.advance,
            IDBCursor.prototype.continue,
            IDBCursor.prototype.continuePrimaryKey,
        ]));
}
const cursorRequestMap = new WeakMap();
const transactionDoneMap = new WeakMap();
const transactionStoreNamesMap = new WeakMap();
const transformCache = new WeakMap();
const reverseTransformCache = new WeakMap();
function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
        const unlisten = () => {
            request.removeEventListener('success', success);
            request.removeEventListener('error', error);
        };
        const success = () => {
            resolve(wrap(request.result));
            unlisten();
        };
        const error = () => {
            reject(request.error);
            unlisten();
        };
        request.addEventListener('success', success);
        request.addEventListener('error', error);
    });
    promise
        .then((value) => {
        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval
        // (see wrapFunction).
        if (value instanceof IDBCursor) {
            cursorRequestMap.set(value, request);
        }
        // Catching to avoid "Uncaught Promise exceptions"
    })
        .catch(() => { });
    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This
    // is because we create many promises from a single IDBRequest.
    reverseTransformCache.set(promise, request);
    return promise;
}
function cacheDonePromiseForTransaction(tx) {
    // Early bail if we've already created a done promise for this transaction.
    if (transactionDoneMap.has(tx))
        return;
    const done = new Promise((resolve, reject) => {
        const unlisten = () => {
            tx.removeEventListener('complete', complete);
            tx.removeEventListener('error', error);
            tx.removeEventListener('abort', error);
        };
        const complete = () => {
            resolve();
            unlisten();
        };
        const error = () => {
            reject(tx.error || new DOMException('AbortError', 'AbortError'));
            unlisten();
        };
        tx.addEventListener('complete', complete);
        tx.addEventListener('error', error);
        tx.addEventListener('abort', error);
    });
    // Cache it for later retrieval.
    transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
    get(target, prop, receiver) {
        if (target instanceof IDBTransaction) {
            // Special handling for transaction.done.
            if (prop === 'done')
                return transactionDoneMap.get(target);
            // Polyfill for objectStoreNames because of Edge.
            if (prop === 'objectStoreNames') {
                return target.objectStoreNames || transactionStoreNamesMap.get(target);
            }
            // Make tx.store return the only store in the transaction, or undefined if there are many.
            if (prop === 'store') {
                return receiver.objectStoreNames[1]
                    ? undefined
                    : receiver.objectStore(receiver.objectStoreNames[0]);
            }
        }
        // Else transform whatever we get back.
        return wrap(target[prop]);
    },
    set(target, prop, value) {
        target[prop] = value;
        return true;
    },
    has(target, prop) {
        if (target instanceof IDBTransaction &&
            (prop === 'done' || prop === 'store')) {
            return true;
        }
        return prop in target;
    },
};
function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
    // Due to expected object equality (which is enforced by the caching in `wrap`), we
    // only create one new func per func.
    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.
    if (func === IDBDatabase.prototype.transaction &&
        !('objectStoreNames' in IDBTransaction.prototype)) {
        return function (storeNames, ...args) {
            const tx = func.call(unwrap(this), storeNames, ...args);
            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
            return wrap(tx);
        };
    }
    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In
    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the
    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense
    // with real promises, so each advance methods returns a new promise for the cursor object, or
    // undefined if the end of the cursor has been reached.
    if (getCursorAdvanceMethods().includes(func)) {
        return function (...args) {
            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
            // the original object.
            func.apply(unwrap(this), args);
            return wrap(cursorRequestMap.get(this));
        };
    }
    return function (...args) {
        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use
        // the original object.
        return wrap(func.apply(unwrap(this), args));
    };
}
function transformCachableValue(value) {
    if (typeof value === 'function')
        return wrapFunction(value);
    // This doesn't return, it just creates a 'done' promise for the transaction,
    // which is later returned for transaction.done (see idbObjectHandler).
    if (value instanceof IDBTransaction)
        cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
        return new Proxy(value, idbProxyTraps);
    // Return the same value back if we're not going to transform it.
    return value;
}
function wrap(value) {
    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because
    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.
    if (value instanceof IDBRequest)
        return promisifyRequest(value);
    // If we've already transformed this value before, reuse the transformed value.
    // This is faster, but it also provides object equality.
    if (transformCache.has(value))
        return transformCache.get(value);
    const newValue = transformCachableValue(value);
    // Not all types are transformed.
    // These may be primitive types, so they can't be WeakMap keys.
    if (newValue !== value) {
        transformCache.set(value, newValue);
        reverseTransformCache.set(newValue, value);
    }
    return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);

/**
 * Open a database.
 *
 * @param name Name of the database.
 * @param version Schema version.
 * @param callbacks Additional callbacks.
 */
function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
        request.addEventListener('upgradeneeded', (event) => {
            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));
        });
    }
    if (blocked)
        request.addEventListener('blocked', () => blocked());
    openPromise
        .then((db) => {
        if (terminated)
            db.addEventListener('close', () => terminated());
        if (blocking)
            db.addEventListener('versionchange', () => blocking());
    })
        .catch(() => { });
    return openPromise;
}

const readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];
const writeMethods = ['put', 'add', 'delete', 'clear'];
const cachedMethods = new Map();
function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase &&
        !(prop in target) &&
        typeof prop === 'string')) {
        return;
    }
    if (cachedMethods.get(prop))
        return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, '');
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||
        !(isWrite || readMethods.includes(targetFuncName))) {
        return;
    }
    const method = async function (storeName, ...args) {
        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(
        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');
        let target = tx.store;
        if (useIndex)
            target = target.index(args.shift());
        // Must reject if op rejects.
        // If it's a write operation, must reject if tx.done rejects.
        // Must reject with op rejection first.
        // Must resolve with op value.
        // Must handle both promises (no unhandled rejections)
        return (await Promise.all([
            target[targetFuncName](...args),
            isWrite && tx.done,
        ]))[0];
    };
    cachedMethods.set(prop, method);
    return method;
}
replaceTraps((oldTraps) => ({
    ...oldTraps,
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),
}));

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
    constructor(container) {
        this.container = container;
    }
    // In initial implementation, this will be called by installations on
    // auth token refresh, and installations will send this string.
    getPlatformInfoString() {
        const providers = this.container.getProviders();
        // Loop through providers and get library/version pairs from any that are
        // version components.
        return providers
            .map(provider => {
            if (isVersionServiceProvider(provider)) {
                const service = provider.getImmediate();
                return `${service.library}/${service.version}`;
            }
            else {
                return null;
            }
        })
            .filter(logString => logString)
            .join(' ');
    }
}
/**
 *
 * @param provider check if this provider provides a VersionService
 *
 * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider
 * provides VersionService. The provider is not necessarily a 'app-version'
 * provider.
 */
function isVersionServiceProvider(provider) {
    const component = provider.getComponent();
    return (component === null || component === void 0 ? void 0 : component.type) === "VERSION" /* ComponentType.VERSION */;
}

const name$o = "@firebase/app";
const version$1$1 = "0.9.8";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger$1 = new Logger('@firebase/app');

const name$n = "@firebase/app-compat";

const name$m = "@firebase/analytics-compat";

const name$l = "@firebase/analytics";

const name$k = "@firebase/app-check-compat";

const name$j = "@firebase/app-check";

const name$i = "@firebase/auth";

const name$h = "@firebase/auth-compat";

const name$g = "@firebase/database";

const name$f = "@firebase/database-compat";

const name$e = "@firebase/functions";

const name$d = "@firebase/functions-compat";

const name$c = "@firebase/installations";

const name$b = "@firebase/installations-compat";

const name$a = "@firebase/messaging";

const name$9 = "@firebase/messaging-compat";

const name$8 = "@firebase/performance";

const name$7 = "@firebase/performance-compat";

const name$6 = "@firebase/remote-config";

const name$5 = "@firebase/remote-config-compat";

const name$4 = "@firebase/storage";

const name$3 = "@firebase/storage-compat";

const name$2 = "@firebase/firestore";

const name$1$1 = "@firebase/firestore-compat";

const name$p = "firebase";
const version$2 = "9.20.0";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The default app name
 *
 * @internal
 */
const DEFAULT_ENTRY_NAME = '[DEFAULT]';
const PLATFORM_LOG_STRING = {
    [name$o]: 'fire-core',
    [name$n]: 'fire-core-compat',
    [name$l]: 'fire-analytics',
    [name$m]: 'fire-analytics-compat',
    [name$j]: 'fire-app-check',
    [name$k]: 'fire-app-check-compat',
    [name$i]: 'fire-auth',
    [name$h]: 'fire-auth-compat',
    [name$g]: 'fire-rtdb',
    [name$f]: 'fire-rtdb-compat',
    [name$e]: 'fire-fn',
    [name$d]: 'fire-fn-compat',
    [name$c]: 'fire-iid',
    [name$b]: 'fire-iid-compat',
    [name$a]: 'fire-fcm',
    [name$9]: 'fire-fcm-compat',
    [name$8]: 'fire-perf',
    [name$7]: 'fire-perf-compat',
    [name$6]: 'fire-rc',
    [name$5]: 'fire-rc-compat',
    [name$4]: 'fire-gcs',
    [name$3]: 'fire-gcs-compat',
    [name$2]: 'fire-fst',
    [name$1$1]: 'fire-fst-compat',
    'fire-js': 'fire-js',
    [name$p]: 'fire-js-all'
};

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
const _apps = new Map();
/**
 * Registered components.
 *
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const _components = new Map();
/**
 * @param component - the component being added to this app's container
 *
 * @internal
 */
function _addComponent(app, component) {
    try {
        app.container.addComponent(component);
    }
    catch (e) {
        logger$1.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
    }
}
/**
 *
 * @param component - the component to register
 * @returns whether or not the component is registered successfully
 *
 * @internal
 */
function _registerComponent(component) {
    const componentName = component.name;
    if (_components.has(componentName)) {
        logger$1.debug(`There were multiple attempts to register component ${componentName}.`);
        return false;
    }
    _components.set(componentName, component);
    // add the component to existing app instances
    for (const app of _apps.values()) {
        _addComponent(app, component);
    }
    return true;
}
/**
 *
 * @param app - FirebaseApp instance
 * @param name - service name
 *
 * @returns the provider for the service with the matching name
 *
 * @internal
 */
function _getProvider(app, name) {
    const heartbeatController = app.container
        .getProvider('heartbeat')
        .getImmediate({ optional: true });
    if (heartbeatController) {
        void heartbeatController.triggerHeartbeat();
    }
    return app.container.getProvider(name);
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
    ["no-app" /* AppError.NO_APP */]: "No Firebase App '{$appName}' has been created - " +
        'call Firebase App.initializeApp()',
    ["bad-app-name" /* AppError.BAD_APP_NAME */]: "Illegal App name: '{$appName}",
    ["duplicate-app" /* AppError.DUPLICATE_APP */]: "Firebase App named '{$appName}' already exists with different options or config",
    ["app-deleted" /* AppError.APP_DELETED */]: "Firebase App named '{$appName}' already deleted",
    ["no-options" /* AppError.NO_OPTIONS */]: 'Need to provide options, when not being deployed to hosting via source.',
    ["invalid-app-argument" /* AppError.INVALID_APP_ARGUMENT */]: 'firebase.{$appName}() takes either no argument or a ' +
        'Firebase App instance.',
    ["invalid-log-argument" /* AppError.INVALID_LOG_ARGUMENT */]: 'First argument to `onLog` must be null or a function.',
    ["idb-open" /* AppError.IDB_OPEN */]: 'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-get" /* AppError.IDB_GET */]: 'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-set" /* AppError.IDB_WRITE */]: 'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',
    ["idb-delete" /* AppError.IDB_DELETE */]: 'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.'
};
const ERROR_FACTORY = new ErrorFactory('app', 'Firebase', ERRORS);

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
    constructor(options, config, container) {
        this._isDeleted = false;
        this._options = Object.assign({}, options);
        this._config = Object.assign({}, config);
        this._name = config.name;
        this._automaticDataCollectionEnabled =
            config.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new Component('app', () => this, "PUBLIC" /* ComponentType.PUBLIC */));
    }
    get automaticDataCollectionEnabled() {
        this.checkDestroyed();
        return this._automaticDataCollectionEnabled;
    }
    set automaticDataCollectionEnabled(val) {
        this.checkDestroyed();
        this._automaticDataCollectionEnabled = val;
    }
    get name() {
        this.checkDestroyed();
        return this._name;
    }
    get options() {
        this.checkDestroyed();
        return this._options;
    }
    get config() {
        this.checkDestroyed();
        return this._config;
    }
    get container() {
        return this._container;
    }
    get isDeleted() {
        return this._isDeleted;
    }
    set isDeleted(val) {
        this._isDeleted = val;
    }
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    checkDestroyed() {
        if (this.isDeleted) {
            throw ERROR_FACTORY.create("app-deleted" /* AppError.APP_DELETED */, { appName: this._name });
        }
    }
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The current SDK version.
 *
 * @public
 */
const SDK_VERSION$1 = version$2;
function initializeApp(_options, rawConfig = {}) {
    let options = _options;
    if (typeof rawConfig !== 'object') {
        const name = rawConfig;
        rawConfig = { name };
    }
    const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
    const name = config.name;
    if (typeof name !== 'string' || !name) {
        throw ERROR_FACTORY.create("bad-app-name" /* AppError.BAD_APP_NAME */, {
            appName: String(name)
        });
    }
    options || (options = getDefaultAppConfig());
    if (!options) {
        throw ERROR_FACTORY.create("no-options" /* AppError.NO_OPTIONS */);
    }
    const existingApp = _apps.get(name);
    if (existingApp) {
        // return the existing app if options and config deep equal the ones in the existing app.
        if (deepEqual(options, existingApp.options) &&
            deepEqual(config, existingApp.config)) {
            return existingApp;
        }
        else {
            throw ERROR_FACTORY.create("duplicate-app" /* AppError.DUPLICATE_APP */, { appName: name });
        }
    }
    const container = new ComponentContainer(name);
    for (const component of _components.values()) {
        container.addComponent(component);
    }
    const newApp = new FirebaseAppImpl(options, config, container);
    _apps.set(name, newApp);
    return newApp;
}
/**
 * Retrieves a {@link @firebase/app#FirebaseApp} instance.
 *
 * When called with no arguments, the default app is returned. When an app name
 * is provided, the app corresponding to that name is returned.
 *
 * An exception is thrown if the app being retrieved has not yet been
 * initialized.
 *
 * @example
 * ```javascript
 * // Return the default app
 * const app = getApp();
 * ```
 *
 * @example
 * ```javascript
 * // Return a named app
 * const otherApp = getApp("otherApp");
 * ```
 *
 * @param name - Optional name of the app to return. If no name is
 *   provided, the default is `"[DEFAULT]"`.
 *
 * @returns The app corresponding to the provided app name.
 *   If no app name is provided, the default app is returned.
 *
 * @public
 */
function getApp(name = DEFAULT_ENTRY_NAME) {
    const app = _apps.get(name);
    if (!app && name === DEFAULT_ENTRY_NAME) {
        return initializeApp();
    }
    if (!app) {
        throw ERROR_FACTORY.create("no-app" /* AppError.NO_APP */, { appName: name });
    }
    return app;
}
/**
 * Registers a library's name and version for platform logging purposes.
 * @param library - Name of 1p or 3p library (e.g. firestore, angularfire)
 * @param version - Current version of that library.
 * @param variant - Bundle variant, e.g., node, rn, etc.
 *
 * @public
 */
function registerVersion(libraryKeyOrName, version, variant) {
    var _a;
    // TODO: We can use this check to whitelist strings when/if we set up
    // a good whitelist system.
    let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
    if (variant) {
        library += `-${variant}`;
    }
    const libraryMismatch = library.match(/\s|\//);
    const versionMismatch = version.match(/\s|\//);
    if (libraryMismatch || versionMismatch) {
        const warning = [
            `Unable to register library "${library}" with version "${version}":`
        ];
        if (libraryMismatch) {
            warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
        }
        if (libraryMismatch && versionMismatch) {
            warning.push('and');
        }
        if (versionMismatch) {
            warning.push(`version name "${version}" contains illegal characters (whitespace or "/")`);
        }
        logger$1.warn(warning.join(' '));
        return;
    }
    _registerComponent(new Component(`${library}-version`, () => ({ library, version }), "VERSION" /* ComponentType.VERSION */));
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = 'firebase-heartbeat-database';
const DB_VERSION = 1;
const STORE_NAME = 'firebase-heartbeat-store';
let dbPromise = null;
function getDbPromise() {
    if (!dbPromise) {
        dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade: (db, oldVersion) => {
                // We don't use 'break' in this switch statement, the fall-through
                // behavior is what we want, because if there are multiple versions between
                // the old version and the current version, we want ALL the migrations
                // that correspond to those versions to run, not only the last one.
                // eslint-disable-next-line default-case
                switch (oldVersion) {
                    case 0:
                        db.createObjectStore(STORE_NAME);
                }
            }
        }).catch(e => {
            throw ERROR_FACTORY.create("idb-open" /* AppError.IDB_OPEN */, {
                originalErrorMessage: e.message
            });
        });
    }
    return dbPromise;
}
async function readHeartbeatsFromIndexedDB(app) {
    try {
        const db = await getDbPromise();
        return db
            .transaction(STORE_NAME)
            .objectStore(STORE_NAME)
            .get(computeKey(app));
    }
    catch (e) {
        if (e instanceof FirebaseError) {
            logger$1.warn(e.message);
        }
        else {
            const idbGetError = ERROR_FACTORY.create("idb-get" /* AppError.IDB_GET */, {
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
            });
            logger$1.warn(idbGetError.message);
        }
    }
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
    try {
        const db = await getDbPromise();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const objectStore = tx.objectStore(STORE_NAME);
        await objectStore.put(heartbeatObject, computeKey(app));
        return tx.done;
    }
    catch (e) {
        if (e instanceof FirebaseError) {
            logger$1.warn(e.message);
        }
        else {
            const idbGetError = ERROR_FACTORY.create("idb-set" /* AppError.IDB_WRITE */, {
                originalErrorMessage: e === null || e === void 0 ? void 0 : e.message
            });
            logger$1.warn(idbGetError.message);
        }
    }
}
function computeKey(app) {
    return `${app.name}!${app.options.appId}`;
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
// 30 days
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1000;
class HeartbeatServiceImpl {
    constructor(container) {
        this.container = container;
        /**
         * In-memory cache for heartbeats, used by getHeartbeatsHeader() to generate
         * the header string.
         * Stores one record per date. This will be consolidated into the standard
         * format of one record per user agent string before being sent as a header.
         * Populated from indexedDB when the controller is instantiated and should
         * be kept in sync with indexedDB.
         * Leave public for easier testing.
         */
        this._heartbeatsCache = null;
        const app = this.container.getProvider('app').getImmediate();
        this._storage = new HeartbeatStorageImpl(app);
        this._heartbeatsCachePromise = this._storage.read().then(result => {
            this._heartbeatsCache = result;
            return result;
        });
    }
    /**
     * Called to report a heartbeat. The function will generate
     * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
     * to IndexedDB.
     * Note that we only store one heartbeat per day. So if a heartbeat for today is
     * already logged, subsequent calls to this function in the same day will be ignored.
     */
    async triggerHeartbeat() {
        const platformLogger = this.container
            .getProvider('platform-logger')
            .getImmediate();
        // This is the "Firebase user agent" string from the platform logger
        // service, not the browser user agent.
        const agent = platformLogger.getPlatformInfoString();
        const date = getUTCDateString();
        if (this._heartbeatsCache === null) {
            this._heartbeatsCache = await this._heartbeatsCachePromise;
        }
        // Do not store a heartbeat if one is already stored for this day
        // or if a header has already been sent today.
        if (this._heartbeatsCache.lastSentHeartbeatDate === date ||
            this._heartbeatsCache.heartbeats.some(singleDateHeartbeat => singleDateHeartbeat.date === date)) {
            return;
        }
        else {
            // There is no entry for this date. Create one.
            this._heartbeatsCache.heartbeats.push({ date, agent });
        }
        // Remove entries older than 30 days.
        this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(singleDateHeartbeat => {
            const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
            const now = Date.now();
            return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
        });
        return this._storage.overwrite(this._heartbeatsCache);
    }
    /**
     * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
     * It also clears all heartbeats from memory as well as in IndexedDB.
     *
     * NOTE: Consuming product SDKs should not send the header if this method
     * returns an empty string.
     */
    async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null) {
            await this._heartbeatsCachePromise;
        }
        // If it's still null or the array is empty, there is no data to send.
        if (this._heartbeatsCache === null ||
            this._heartbeatsCache.heartbeats.length === 0) {
            return '';
        }
        const date = getUTCDateString();
        // Extract as many heartbeats from the cache as will fit under the size limit.
        const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
        const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
        // Store last sent date to prevent another being logged/sent for the same day.
        this._heartbeatsCache.lastSentHeartbeatDate = date;
        if (unsentEntries.length > 0) {
            // Store any unsent entries if they exist.
            this._heartbeatsCache.heartbeats = unsentEntries;
            // This seems more likely than emptying the array (below) to lead to some odd state
            // since the cache isn't empty and this will be called again on the next request,
            // and is probably safest if we await it.
            await this._storage.overwrite(this._heartbeatsCache);
        }
        else {
            this._heartbeatsCache.heartbeats = [];
            // Do not wait for this, to reduce latency.
            void this._storage.overwrite(this._heartbeatsCache);
        }
        return headerString;
    }
}
function getUTCDateString() {
    const today = new Date();
    // Returns date format 'YYYY-MM-DD'
    return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
    // Heartbeats grouped by user agent in the standard format to be sent in
    // the header.
    const heartbeatsToSend = [];
    // Single date format heartbeats that are not sent.
    let unsentEntries = heartbeatsCache.slice();
    for (const singleDateHeartbeat of heartbeatsCache) {
        // Look for an existing entry with the same user agent.
        const heartbeatEntry = heartbeatsToSend.find(hb => hb.agent === singleDateHeartbeat.agent);
        if (!heartbeatEntry) {
            // If no entry for this user agent exists, create one.
            heartbeatsToSend.push({
                agent: singleDateHeartbeat.agent,
                dates: [singleDateHeartbeat.date]
            });
            if (countBytes(heartbeatsToSend) > maxSize) {
                // If the header would exceed max size, remove the added heartbeat
                // entry and stop adding to the header.
                heartbeatsToSend.pop();
                break;
            }
        }
        else {
            heartbeatEntry.dates.push(singleDateHeartbeat.date);
            // If the header would exceed max size, remove the added date
            // and stop adding to the header.
            if (countBytes(heartbeatsToSend) > maxSize) {
                heartbeatEntry.dates.pop();
                break;
            }
        }
        // Pop unsent entry from queue. (Skipped if adding the entry exceeded
        // quota and the loop breaks early.)
        unsentEntries = unsentEntries.slice(1);
    }
    return {
        heartbeatsToSend,
        unsentEntries
    };
}
class HeartbeatStorageImpl {
    constructor(app) {
        this.app = app;
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
    }
    async runIndexedDBEnvironmentCheck() {
        if (!isIndexedDBAvailable()) {
            return false;
        }
        else {
            return validateIndexedDBOpenable()
                .then(() => true)
                .catch(() => false);
        }
    }
    /**
     * Read all heartbeats.
     */
    async read() {
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return { heartbeats: [] };
        }
        else {
            const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
            return idbHeartbeatObject || { heartbeats: [] };
        }
    }
    // overwrite the storage with the provided heartbeats
    async overwrite(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: heartbeatsObject.heartbeats
            });
        }
    }
    // add heartbeats
    async add(heartbeatsObject) {
        var _a;
        const canUseIndexedDB = await this._canUseIndexedDBPromise;
        if (!canUseIndexedDB) {
            return;
        }
        else {
            const existingHeartbeatsObject = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
                heartbeats: [
                    ...existingHeartbeatsObject.heartbeats,
                    ...heartbeatsObject.heartbeats
                ]
            });
        }
    }
}
/**
 * Calculate bytes of a HeartbeatsByUserAgent array after being wrapped
 * in a platform logging header JSON object, stringified, and converted
 * to base 64.
 */
function countBytes(heartbeatsCache) {
    // base64 has a restricted set of characters, all of which should be 1 byte.
    return base64urlEncodeWithoutPadding(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })).length;
}

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
    _registerComponent(new Component('platform-logger', container => new PlatformLoggerServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */));
    _registerComponent(new Component('heartbeat', container => new HeartbeatServiceImpl(container), "PRIVATE" /* ComponentType.PRIVATE */));
    // Register `app` package.
    registerVersion(name$o, version$1$1, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name$o, version$1$1, 'esm2017');
    // Register platform SDK identifier (no version).
    registerVersion('fire-js', '');
}

/**
 * Firebase App
 *
 * @remarks This package coordinates the communication between the different Firebase components
 * @packageDocumentation
 */
registerCoreComponents('');

var name$1 = "firebase";
var version$1 = "9.20.0";

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerVersion(name$1, version$1, 'app');

const _app = {};
_app.initializeApp = wrapper("initializeApp", initializeApp);
const app$1 = _app;

const name = "@firebase/database";
const version = "0.14.4";

/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** The semver (www.semver.org) version of the SDK. */
let SDK_VERSION = '';
/**
 * SDK_VERSION should be set before any database instance is created
 * @internal
 */
function setSDKVersion(version) {
    SDK_VERSION = version;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 */
class DOMStorageWrapper {
    /**
     * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)
     */
    constructor(domStorage_) {
        this.domStorage_ = domStorage_;
        // Use a prefix to avoid collisions with other stuff saved by the app.
        this.prefix_ = 'firebase:';
    }
    /**
     * @param key - The key to save the value under
     * @param value - The value being stored, or null to remove the key.
     */
    set(key, value) {
        if (value == null) {
            this.domStorage_.removeItem(this.prefixedName_(key));
        }
        else {
            this.domStorage_.setItem(this.prefixedName_(key), stringify(value));
        }
    }
    /**
     * @returns The value that was stored under this key, or null
     */
    get(key) {
        const storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) {
            return null;
        }
        else {
            return jsonEval(storedVal);
        }
    }
    remove(key) {
        this.domStorage_.removeItem(this.prefixedName_(key));
    }
    prefixedName_(name) {
        return this.prefix_ + name;
    }
    toString() {
        return this.domStorage_.toString();
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 */
class MemoryStorage {
    constructor() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
    }
    set(key, value) {
        if (value == null) {
            delete this.cache_[key];
        }
        else {
            this.cache_[key] = value;
        }
    }
    get(key) {
        if (contains(this.cache_, key)) {
            return this.cache_[key];
        }
        return null;
    }
    remove(key) {
        delete this.cache_[key];
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param domStorageName - Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @returns Turning off type information until a common interface is defined.
 */
const createStoragefor = function (domStorageName) {
    try {
        // NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
        // so it must be inside the try/catch.
        if (typeof window !== 'undefined' &&
            typeof window[domStorageName] !== 'undefined') {
            // Need to test cache. Just because it's here doesn't mean it works
            const domStorage = window[domStorageName];
            domStorage.setItem('firebase:sentinel', 'cache');
            domStorage.removeItem('firebase:sentinel');
            return new DOMStorageWrapper(domStorage);
        }
    }
    catch (e) { }
    // Failed to create wrapper.  Just return in-memory storage.
    // TODO: log?
    return new MemoryStorage();
};
/** A storage object that lasts across sessions */
const PersistentStorage = createStoragefor('localStorage');
/** A storage object that only lasts one session */
const SessionStorage = createStoragefor('sessionStorage');

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new Logger('@firebase/database');
/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 */
const LUIDGenerator = (function () {
    let id = 1;
    return function () {
        return id++;
    };
})();
/**
 * Sha1 hash of the input string
 * @param str - The string to hash
 * @returns {!string} The resulting hash
 */
const sha1 = function (str) {
    const utf8Bytes = stringToByteArray(str);
    const sha1 = new Sha1();
    sha1.update(utf8Bytes);
    const sha1Bytes = sha1.digest();
    return base64.encodeByteArray(sha1Bytes);
};
const buildLogMessage_ = function (...varArgs) {
    let message = '';
    for (let i = 0; i < varArgs.length; i++) {
        const arg = varArgs[i];
        if (Array.isArray(arg) ||
            (arg &&
                typeof arg === 'object' &&
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                typeof arg.length === 'number')) {
            message += buildLogMessage_.apply(null, arg);
        }
        else if (typeof arg === 'object') {
            message += stringify(arg);
        }
        else {
            message += arg;
        }
        message += ' ';
    }
    return message;
};
/**
 * Use this for all debug messages in Firebase.
 */
let logger = null;
/**
 * Flag to check for log availability on first log message
 */
let firstLog_ = true;
/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param logger_ - A flag to turn on logging, or a custom logger
 * @param persistent - Whether or not to persist logging settings across refreshes
 */
const enableLogging$1 = function (logger_, persistent) {
    assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
    if (logger_ === true) {
        logClient.logLevel = LogLevel.VERBOSE;
        logger = logClient.log.bind(logClient);
        if (persistent) {
            SessionStorage.set('logging_enabled', true);
        }
    }
    else if (typeof logger_ === 'function') {
        logger = logger_;
    }
    else {
        logger = null;
        SessionStorage.remove('logging_enabled');
    }
};
const log = function (...varArgs) {
    if (firstLog_ === true) {
        firstLog_ = false;
        if (logger === null && SessionStorage.get('logging_enabled') === true) {
            enableLogging$1(true);
        }
    }
    if (logger) {
        const message = buildLogMessage_.apply(null, varArgs);
        logger(message);
    }
};
const logWrapper = function (prefix) {
    return function (...varArgs) {
        log(prefix, ...varArgs);
    };
};
const error = function (...varArgs) {
    const message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_(...varArgs);
    logClient.error(message);
};
const fatal = function (...varArgs) {
    const message = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;
    logClient.error(message);
    throw new Error(message);
};
const warn = function (...varArgs) {
    const message = 'FIREBASE WARNING: ' + buildLogMessage_(...varArgs);
    logClient.warn(message);
};
/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */
const warnIfPageIsSecure = function () {
    // Be very careful accessing browser globals. Who knows what may or may not exist.
    if (typeof window !== 'undefined' &&
        window.location &&
        window.location.protocol &&
        window.location.protocol.indexOf('https:') !== -1) {
        warn('Insecure Firebase access from a secure page. ' +
            'Please use https in calls to new Firebase().');
    }
};
/**
 * Returns true if data is NaN, or +/- Infinity.
 */
const isInvalidJSONNumber = function (data) {
    return (typeof data === 'number' &&
        (data !== data || // NaN
            data === Number.POSITIVE_INFINITY ||
            data === Number.NEGATIVE_INFINITY));
};
const executeWhenDOMReady = function (fn) {
    if (document.readyState === 'complete') {
        fn();
    }
    else {
        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
        // fire before onload), but fall back to onload.
        let called = false;
        const wrappedFn = function () {
            if (!document.body) {
                setTimeout(wrappedFn, Math.floor(10));
                return;
            }
            if (!called) {
                called = true;
                fn();
            }
        };
        if (document.addEventListener) {
            document.addEventListener('DOMContentLoaded', wrappedFn, false);
            // fallback to onload.
            window.addEventListener('load', wrappedFn, false);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        else if (document.attachEvent) {
            // IE.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            document.attachEvent('onreadystatechange', () => {
                if (document.readyState === 'complete') {
                    wrappedFn();
                }
            });
            // fallback to onload.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            window.attachEvent('onload', wrappedFn);
            // jQuery has an extra hack for IE that we could employ (based on
            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
            // I'm hoping we don't need it.
        }
    }
};
/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 */
const MIN_NAME = '[MIN_NAME]';
/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 */
const MAX_NAME = '[MAX_NAME]';
/**
 * Compares valid Firebase key names, plus min and max name
 */
const nameCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a === MIN_NAME || b === MAX_NAME) {
        return -1;
    }
    else if (b === MIN_NAME || a === MAX_NAME) {
        return 1;
    }
    else {
        const aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
        if (aAsInt !== null) {
            if (bAsInt !== null) {
                return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
            }
            else {
                return -1;
            }
        }
        else if (bAsInt !== null) {
            return 1;
        }
        else {
            return a < b ? -1 : 1;
        }
    }
};
/**
 * @returns {!number} comparison result.
 */
const stringCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
};
const requireKey = function (key, obj) {
    if (obj && key in obj) {
        return obj[key];
    }
    else {
        throw new Error('Missing required key (' + key + ') in object: ' + stringify(obj));
    }
};
const ObjectToUniqueKey = function (obj) {
    if (typeof obj !== 'object' || obj === null) {
        return stringify(obj);
    }
    const keys = [];
    // eslint-disable-next-line guard-for-in
    for (const k in obj) {
        keys.push(k);
    }
    // Export as json, but with the keys sorted.
    keys.sort();
    let key = '{';
    for (let i = 0; i < keys.length; i++) {
        if (i !== 0) {
            key += ',';
        }
        key += stringify(keys[i]);
        key += ':';
        key += ObjectToUniqueKey(obj[keys[i]]);
    }
    key += '}';
    return key;
};
/**
 * Splits a string into a number of smaller segments of maximum size
 * @param str - The string
 * @param segsize - The maximum number of chars in the string.
 * @returns The string, split into appropriately-sized chunks
 */
const splitStringBySize = function (str, segsize) {
    const len = str.length;
    if (len <= segsize) {
        return [str];
    }
    const dataSegs = [];
    for (let c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
            dataSegs.push(str.substring(c, len));
        }
        else {
            dataSegs.push(str.substring(c, c + segsize));
        }
    }
    return dataSegs;
};
/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param obj - The object or array to iterate over
 * @param fn - The function to apply
 */
function each(obj, fn) {
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            fn(key, obj[key]);
        }
    }
}
/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param v - A double
 *
 */
const doubleToIEEE754String = function (v) {
    assert(!isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL
    const ebits = 11, fbits = 52;
    const bias = (1 << (ebits - 1)) - 1;
    let s, e, f, ln, i;
    // Compute sign, exponent, fraction
    // Skip NaN / Infinity handling --MJL.
    if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
    }
    else {
        s = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) {
            // Normalized
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        }
        else {
            // Denormalized
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
        }
    }
    // Pack sign, exponent, fraction
    const bits = [];
    for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    const str = bits.join('');
    // Return the data as a hex string. --MJL
    let hexByteString = '';
    for (i = 0; i < 64; i += 8) {
        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1) {
            hexByte = '0' + hexByte;
        }
        hexByteString = hexByteString + hexByte;
    }
    return hexByteString.toLowerCase();
};
/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 */
const isChromeExtensionContentScript = function () {
    return !!(typeof window === 'object' &&
        window['chrome'] &&
        window['chrome']['extension'] &&
        !/^chrome/.test(window.location.href));
};
/**
 * Used to detect if we're in a Windows 8 Store app.
 */
const isWindowsStoreApp = function () {
    // Check for the presence of a couple WinRT globals
    return typeof Windows === 'object' && typeof Windows.UI === 'object';
};
/**
 * Converts a server error code to a Javascript Error
 */
function errorForServerCode(code, query) {
    let reason = 'Unknown Error';
    if (code === 'too_big') {
        reason =
            'The data requested exceeds the maximum size ' +
                'that can be accessed with a single request.';
    }
    else if (code === 'permission_denied') {
        reason = "Client doesn't have permission to access the desired data.";
    }
    else if (code === 'unavailable') {
        reason = 'The service is unavailable';
    }
    const error = new Error(code + ' at ' + query._path.toString() + ': ' + reason);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error.code = code.toUpperCase();
    return error;
}
/**
 * Used to test for integer-looking strings
 */
const INTEGER_REGEXP_ = new RegExp('^-?(0*)\\d{1,10}$');
/**
 * For use in keys, the minimum possible 32-bit integer.
 */
const INTEGER_32_MIN = -2147483648;
/**
 * For use in kyes, the maximum possible 32-bit integer.
 */
const INTEGER_32_MAX = 2147483647;
/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 */
const tryParseInt = function (str) {
    if (INTEGER_REGEXP_.test(str)) {
        const intVal = Number(str);
        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
            return intVal;
        }
    }
    return null;
};
/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param fn - The code to guard.
 */
const exceptionGuard = function (fn) {
    try {
        fn();
    }
    catch (e) {
        // Re-throw exception when it's safe.
        setTimeout(() => {
            // It used to be that "throw e" would result in a good console error with
            // relevant context, but as of Chrome 39, you just get the firebase.js
            // file/line number where we re-throw it, which is useless. So we log
            // e.stack explicitly.
            const stack = e.stack || '';
            warn('Exception was thrown by user callback.', stack);
            throw e;
        }, Math.floor(0));
    }
};
/**
 * @returns {boolean} true if we think we're currently being crawled.
 */
const beingCrawled = function () {
    const userAgent = (typeof window === 'object' &&
        window['navigator'] &&
        window['navigator']['userAgent']) ||
        '';
    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
    // believe to support JavaScript/AJAX rendering.
    // NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
    // would have seen the page" is flaky if we don't treat it as a crawler.
    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);
};
/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param fn - Function to run.
 * @param time - Milliseconds to wait before running.
 * @returns The setTimeout() return value.
 */
const setTimeoutNonBlocking = function (fn, time) {
    const timeout = setTimeout(fn, time);
    // Note: at the time of this comment, unrefTimer is under the unstable set of APIs. Run with --unstable to enable the API.
    if (typeof timeout === 'number' &&
        // @ts-ignore Is only defined in Deno environments.
        typeof Deno !== 'undefined' &&
        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.
        Deno['unrefTimer']) {
        // @ts-ignore Deno and unrefTimer are only defined in Deno environments.
        Deno.unrefTimer(timeout);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    else if (typeof timeout === 'object' && timeout['unref']) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        timeout['unref']();
    }
    return timeout;
};

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction around AppCheck's token fetching capabilities.
 */
class AppCheckTokenProvider {
    constructor(appName_, appCheckProvider) {
        this.appName_ = appName_;
        this.appCheckProvider = appCheckProvider;
        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });
        if (!this.appCheck) {
            appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(appCheck => (this.appCheck = appCheck));
        }
    }
    getToken(forceRefresh) {
        if (!this.appCheck) {
            return new Promise((resolve, reject) => {
                // Support delayed initialization of FirebaseAppCheck. This allows our
                // customers to initialize the RTDB SDK before initializing Firebase
                // AppCheck and ensures that all requests are authenticated if a token
                // becomes available before the timoeout below expires.
                setTimeout(() => {
                    if (this.appCheck) {
                        this.getToken(forceRefresh).then(resolve, reject);
                    }
                    else {
                        resolve(null);
                    }
                }, 0);
            });
        }
        return this.appCheck.getToken(forceRefresh);
    }
    addTokenChangeListener(listener) {
        var _a;
        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then(appCheck => appCheck.addTokenListener(listener));
    }
    notifyForInvalidToken() {
        warn(`Provided AppCheck credentials for the app named "${this.appName_}" ` +
            'are invalid. This usually indicates your app was not initialized correctly.');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */
class FirebaseAuthTokenProvider {
    constructor(appName_, firebaseOptions_, authProvider_) {
        this.appName_ = appName_;
        this.firebaseOptions_ = firebaseOptions_;
        this.authProvider_ = authProvider_;
        this.auth_ = null;
        this.auth_ = authProvider_.getImmediate({ optional: true });
        if (!this.auth_) {
            authProvider_.onInit(auth => (this.auth_ = auth));
        }
    }
    getToken(forceRefresh) {
        if (!this.auth_) {
            return new Promise((resolve, reject) => {
                // Support delayed initialization of FirebaseAuth. This allows our
                // customers to initialize the RTDB SDK before initializing Firebase
                // Auth and ensures that all requests are authenticated if a token
                // becomes available before the timoeout below expires.
                setTimeout(() => {
                    if (this.auth_) {
                        this.getToken(forceRefresh).then(resolve, reject);
                    }
                    else {
                        resolve(null);
                    }
                }, 0);
            });
        }
        return this.auth_.getToken(forceRefresh).catch(error => {
            // TODO: Need to figure out all the cases this is raised and whether
            // this makes sense.
            if (error && error.code === 'auth/token-not-initialized') {
                log('Got auth/token-not-initialized error.  Treating as null token.');
                return null;
            }
            else {
                return Promise.reject(error);
            }
        });
    }
    addTokenChangeListener(listener) {
        // TODO: We might want to wrap the listener and call it with no args to
        // avoid a leaky abstraction, but that makes removing the listener harder.
        if (this.auth_) {
            this.auth_.addAuthTokenListener(listener);
        }
        else {
            this.authProvider_
                .get()
                .then(auth => auth.addAuthTokenListener(listener));
        }
    }
    removeTokenChangeListener(listener) {
        this.authProvider_
            .get()
            .then(auth => auth.removeAuthTokenListener(listener));
    }
    notifyForInvalidToken() {
        let errorMessage = 'Provided authentication credentials for the app named "' +
            this.appName_ +
            '" are invalid. This usually indicates your app was not ' +
            'initialized correctly. ';
        if ('credential' in this.firebaseOptions_) {
            errorMessage +=
                'Make sure the "credential" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else if ('serviceAccount' in this.firebaseOptions_) {
            errorMessage +=
                'Make sure the "serviceAccount" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else {
            errorMessage +=
                'Make sure the "apiKey" and "databaseURL" properties provided to ' +
                    'initializeApp() match the values provided for your app at ' +
                    'https://console.firebase.google.com/.';
        }
        warn(errorMessage);
    }
}
/* AuthTokenProvider that supplies a constant token. Used by Admin SDK or mockUserToken with emulators. */
class EmulatorTokenProvider {
    constructor(accessToken) {
        this.accessToken = accessToken;
    }
    getToken(forceRefresh) {
        return Promise.resolve({
            accessToken: this.accessToken
        });
    }
    addTokenChangeListener(listener) {
        // Invoke the listener immediately to match the behavior in Firebase Auth
        // (see packages/auth/src/auth.js#L1807)
        listener(this.accessToken);
    }
    removeTokenChangeListener(listener) { }
    notifyForInvalidToken() { }
}
/** A string that is treated as an admin access token by the RTDB emulator. Used by Admin SDK. */
EmulatorTokenProvider.OWNER = 'owner';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PROTOCOL_VERSION = '5';
const VERSION_PARAM = 'v';
const TRANSPORT_SESSION_PARAM = 's';
const REFERER_PARAM = 'r';
const FORGE_REF = 'f';
// Matches console.firebase.google.com, firebase-console-*.corp.google.com and
// firebase.corp.google.com
const FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
const LAST_SESSION_PARAM = 'ls';
const APPLICATION_ID_PARAM = 'p';
const APP_CHECK_TOKEN_PARAM = 'ac';
const WEBSOCKET = 'websocket';
const LONG_POLLING = 'long_polling';

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A class that holds metadata about a Repo object
 */
class RepoInfo {
    /**
     * @param host - Hostname portion of the url for the repo
     * @param secure - Whether or not this repo is accessed over ssl
     * @param namespace - The namespace represented by the repo
     * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).
     * @param nodeAdmin - Whether this instance uses Admin SDK credentials
     * @param persistenceKey - Override the default session persistence storage key
     */
    constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = '', includeNamespaceInQueryParams = false, isUsingEmulator = false) {
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.nodeAdmin = nodeAdmin;
        this.persistenceKey = persistenceKey;
        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
        this.isUsingEmulator = isUsingEmulator;
        this._host = host.toLowerCase();
        this._domain = this._host.substr(this._host.indexOf('.') + 1);
        this.internalHost =
            PersistentStorage.get('host:' + host) || this._host;
    }
    isCacheableHost() {
        return this.internalHost.substr(0, 2) === 's-';
    }
    isCustomHost() {
        return (this._domain !== 'firebaseio.com' &&
            this._domain !== 'firebaseio-demo.com');
    }
    get host() {
        return this._host;
    }
    set host(newHost) {
        if (newHost !== this.internalHost) {
            this.internalHost = newHost;
            if (this.isCacheableHost()) {
                PersistentStorage.set('host:' + this._host, this.internalHost);
            }
        }
    }
    toString() {
        let str = this.toURLString();
        if (this.persistenceKey) {
            str += '<' + this.persistenceKey + '>';
        }
        return str;
    }
    toURLString() {
        const protocol = this.secure ? 'https://' : 'http://';
        const query = this.includeNamespaceInQueryParams
            ? `?ns=${this.namespace}`
            : '';
        return `${protocol}${this.host}/${query}`;
    }
}
function repoInfoNeedsQueryParam(repoInfo) {
    return (repoInfo.host !== repoInfo.internalHost ||
        repoInfo.isCustomHost() ||
        repoInfo.includeNamespaceInQueryParams);
}
/**
 * Returns the websocket URL for this repo
 * @param repoInfo - RepoInfo object
 * @param type - of connection
 * @param params - list
 * @returns The URL for this repo
 */
function repoInfoConnectionURL(repoInfo, type, params) {
    assert(typeof type === 'string', 'typeof type must == string');
    assert(typeof params === 'object', 'typeof params must == object');
    let connURL;
    if (type === WEBSOCKET) {
        connURL =
            (repoInfo.secure ? 'wss://' : 'ws://') + repoInfo.internalHost + '/.ws?';
    }
    else if (type === LONG_POLLING) {
        connURL =
            (repoInfo.secure ? 'https://' : 'http://') +
                repoInfo.internalHost +
                '/.lp?';
    }
    else {
        throw new Error('Unknown connection type: ' + type);
    }
    if (repoInfoNeedsQueryParam(repoInfo)) {
        params['ns'] = repoInfo.namespace;
    }
    const pairs = [];
    each(params, (key, value) => {
        pairs.push(key + '=' + value);
    });
    return connURL + pairs.join('&');
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Tracks a collection of stats.
 */
class StatsCollection {
    constructor() {
        this.counters_ = {};
    }
    incrementCounter(name, amount = 1) {
        if (!contains(this.counters_, name)) {
            this.counters_[name] = 0;
        }
        this.counters_[name] += amount;
    }
    get() {
        return deepCopy(this.counters_);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const collections = {};
const reporters = {};
function statsManagerGetCollection(repoInfo) {
    const hashString = repoInfo.toString();
    if (!collections[hashString]) {
        collections[hashString] = new StatsCollection();
    }
    return collections[hashString];
}
function statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {
    const hashString = repoInfo.toString();
    if (!reporters[hashString]) {
        reporters[hashString] = creatorFunction();
    }
    return reporters[hashString];
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class ensures the packets from the server arrive in order
 * This class takes data from the server and ensures it gets passed into the callbacks in order.
 */
class PacketReceiver {
    /**
     * @param onMessage_
     */
    constructor(onMessage_) {
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
    }
    closeAfter(responseNum, callback) {
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) {
            this.onClose();
            this.onClose = null;
        }
    }
    /**
     * Each message from the server comes with a response number, and an array of data. The responseNumber
     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
     * browsers will respond in the same order as the requests we sent
     */
    handleResponse(requestNum, data) {
        this.pendingResponses[requestNum] = data;
        while (this.pendingResponses[this.currentResponseNum]) {
            const toProcess = this.pendingResponses[this.currentResponseNum];
            delete this.pendingResponses[this.currentResponseNum];
            for (let i = 0; i < toProcess.length; ++i) {
                if (toProcess[i]) {
                    exceptionGuard(() => {
                        this.onMessage_(toProcess[i]);
                    });
                }
            }
            if (this.currentResponseNum === this.closeAfterResponse) {
                if (this.onClose) {
                    this.onClose();
                    this.onClose = null;
                }
                break;
            }
            this.currentResponseNum++;
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// URL query parameters associated with longpolling
const FIREBASE_LONGPOLL_START_PARAM = 'start';
const FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';
const FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';
const FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';
const FIREBASE_LONGPOLL_ID_PARAM = 'id';
const FIREBASE_LONGPOLL_PW_PARAM = 'pw';
const FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';
const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';
const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';
const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';
const FIREBASE_LONGPOLL_DATA_PARAM = 'd';
const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';
//Data size constants.
//TODO: Perf: the maximum length actually differs from browser to browser.
// We should check what browser we're on and set accordingly.
const MAX_URL_DATA_SIZE = 1870;
const SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=
const MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
/**
 * Keepalive period
 * send a fresh request at minimum every 25 seconds. Opera has a maximum request
 * length of 30 seconds that we can't exceed.
 */
const KEEPALIVE_REQUEST_INTERVAL = 25000;
/**
 * How long to wait before aborting a long-polling connection attempt.
 */
const LP_CONNECT_TIMEOUT = 30000;
/**
 * This class manages a single long-polling connection.
 */
class BrowserPollConnection {
    /**
     * @param connId An identifier for this connection, used for logging
     * @param repoInfo The info for the endpoint to send data to.
     * @param applicationId The Firebase App ID for this project.
     * @param appCheckToken The AppCheck token for this client.
     * @param authToken The AuthToken to use for this connection.
     * @param transportSessionId Optional transportSessionid if we are
     * reconnecting for an existing transport session
     * @param lastSessionId Optional lastSessionId if the PersistentConnection has
     * already created a connection previously
     */
    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = logWrapper(connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.urlFn = (params) => {
            // Always add the token if we have one.
            if (this.appCheckToken) {
                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
            }
            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
        };
    }
    /**
     * @param onMessage - Callback when messages arrive
     * @param onDisconnect - Callback with connection lost.
     */
    open(onMessage, onDisconnect) {
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect;
        this.myPacketOrderer = new PacketReceiver(onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(() => {
            this.log_('Timed out trying to connect.');
            // Make sure we clear the host cache
            this.onClosed_();
            this.connectTimeoutTimer_ = null;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, Math.floor(LP_CONNECT_TIMEOUT));
        // Ensure we delay the creation of the iframe until the DOM is loaded.
        executeWhenDOMReady(() => {
            if (this.isClosed_) {
                return;
            }
            //Set up a callback that gets triggered once a connection is set up.
            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args) => {
                const [command, arg1, arg2, arg3, arg4] = args;
                this.incrementIncomingBytes_(args);
                if (!this.scriptTagHolder) {
                    return; // we closed the connection.
                }
                if (this.connectTimeoutTimer_) {
                    clearTimeout(this.connectTimeoutTimer_);
                    this.connectTimeoutTimer_ = null;
                }
                this.everConnected_ = true;
                if (command === FIREBASE_LONGPOLL_START_PARAM) {
                    this.id = arg1;
                    this.password = arg2;
                }
                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
                    // Don't clear the host cache. We got a response from the server, so we know it's reachable
                    if (arg1) {
                        // We aren't expecting any more data (other than what the server's already in the process of sending us
                        // through our already open polls), so don't send any more.
                        this.scriptTagHolder.sendNewPolls = false;
                        // arg1 in this case is the last response number sent by the server. We should try to receive
                        // all of the responses up to this one before closing
                        this.myPacketOrderer.closeAfter(arg1, () => {
                            this.onClosed_();
                        });
                    }
                    else {
                        this.onClosed_();
                    }
                }
                else {
                    throw new Error('Unrecognized command received: ' + command);
                }
            }, (...args) => {
                const [pN, data] = args;
                this.incrementIncomingBytes_(args);
                this.myPacketOrderer.handleResponse(pN, data);
            }, () => {
                this.onClosed_();
            }, this.urlFn);
            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results
            //from cache.
            const urlParams = {};
            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);
            if (this.scriptTagHolder.uniqueCallbackIdentifier) {
                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] =
                    this.scriptTagHolder.uniqueCallbackIdentifier;
            }
            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
            if (this.transportSessionId) {
                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;
            }
            if (this.lastSessionId) {
                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;
            }
            if (this.applicationId) {
                urlParams[APPLICATION_ID_PARAM] = this.applicationId;
            }
            if (this.appCheckToken) {
                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
            }
            if (typeof location !== 'undefined' &&
                location.hostname &&
                FORGE_DOMAIN_RE.test(location.hostname)) {
                urlParams[REFERER_PARAM] = FORGE_REF;
            }
            const connectURL = this.urlFn(urlParams);
            this.log_('Connecting via long-poll to ' + connectURL);
            this.scriptTagHolder.addTag(connectURL, () => {
                /* do nothing */
            });
        });
    }
    /**
     * Call this when a handshake has completed successfully and we want to consider the connection established
     */
    start() {
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
    }
    /**
     * Forces long polling to be considered as a potential transport
     */
    static forceAllow() {
        BrowserPollConnection.forceAllow_ = true;
    }
    /**
     * Forces longpolling to not be considered as a potential transport
     */
    static forceDisallow() {
        BrowserPollConnection.forceDisallow_ = true;
    }
    // Static method, use string literal so it can be accessed in a generic way
    static isAvailable() {
        if (BrowserPollConnection.forceAllow_) {
            return true;
        }
        else {
            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in
            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).
            return (!BrowserPollConnection.forceDisallow_ &&
                typeof document !== 'undefined' &&
                document.createElement != null &&
                !isChromeExtensionContentScript() &&
                !isWindowsStoreApp());
        }
    }
    /**
     * No-op for polling
     */
    markConnectionHealthy() { }
    /**
     * Stops polling and cleans up the iframe
     */
    shutdown_() {
        this.isClosed_ = true;
        if (this.scriptTagHolder) {
            this.scriptTagHolder.close();
            this.scriptTagHolder = null;
        }
        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.
        if (this.myDisconnFrame) {
            document.body.removeChild(this.myDisconnFrame);
            this.myDisconnFrame = null;
        }
        if (this.connectTimeoutTimer_) {
            clearTimeout(this.connectTimeoutTimer_);
            this.connectTimeoutTimer_ = null;
        }
    }
    /**
     * Triggered when this transport is closed
     */
    onClosed_() {
        if (!this.isClosed_) {
            this.log_('Longpoll is closing itself');
            this.shutdown_();
            if (this.onDisconnect_) {
                this.onDisconnect_(this.everConnected_);
                this.onDisconnect_ = null;
            }
        }
    }
    /**
     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
     * that we've left.
     */
    close() {
        if (!this.isClosed_) {
            this.log_('Longpoll is being closed.');
            this.shutdown_();
        }
    }
    /**
     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
     * broken into chunks (since URLs have a small maximum length).
     * @param data - The JSON data to transmit.
     */
    send(data) {
        const dataStr = stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //first, lets get the base64-encoded data
        const base64data = base64Encode(dataStr);
        //We can only fit a certain amount in each URL, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number
        //of segments so that we can reassemble the packet on the server.
        for (let i = 0; i < dataSegs.length; i++) {
            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
            this.curSegmentNum++;
        }
    }
    /**
     * This is how we notify the server that we're leaving.
     * We aren't able to send requests with DHTML on a window close event, but we can
     * trigger XHR requests in some browsers (everything but Opera basically).
     */
    addDisconnectPingFrame(id, pw) {
        this.myDisconnFrame = document.createElement('iframe');
        const urlParams = {};
        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = 'none';
        document.body.appendChild(this.myDisconnFrame);
    }
    /**
     * Used to track the bytes received by this client
     */
    incrementIncomingBytes_(args) {
        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.
        const bytesReceived = stringify(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter('bytes_received', bytesReceived);
    }
}
/*********************************************************************************************
 * A wrapper around an iframe that is used as a long-polling script holder.
 *********************************************************************************************/
class FirebaseIFrameScriptHolder {
    /**
     * @param commandCB - The callback to be called when control commands are recevied from the server.
     * @param onMessageCB - The callback to be triggered when responses arrive from the server.
     * @param onDisconnect - The callback to be triggered when this tag holder is closed
     * @param urlFn - A function that provides the URL of the endpoint to send data to.
     */
    constructor(commandCB, onMessageCB, onDisconnect, urlFn) {
        this.onDisconnect = onDisconnect;
        this.urlFn = urlFn;
        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause
        //problems in some browsers.
        this.outstandingRequests = new Set();
        //A queue of the pending segments waiting for transmission to the server.
        this.pendingSegs = [];
        //A serial number. We use this for two things:
        // 1) A way to ensure the browser doesn't cache responses to polls
        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The
        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute
        //    JSONP code in the order it was added to the iframe.
        this.currentSerial = Math.floor(Math.random() * 100000000);
        // This gets set to false when we're "closing down" the connection (e.g. we're switching transports but there's still
        // incoming data from the server that we're waiting for).
        this.sendNewPolls = true;
        {
            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the
            //iframes where we put the long-polling script tags. We have two callbacks:
            //   1) Command Callback - Triggered for control issues, like starting a connection.
            //   2) Message Callback - Triggered when new data arrives.
            this.uniqueCallbackIdentifier = LUIDGenerator();
            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] =
                onMessageCB;
            //Create an iframe for us to add script tags to.
            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
            // Set the iframe's contents.
            let script = '';
            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient
            // for ie9, but ie8 needs to do it again in the document itself.
            if (this.myIFrame.src &&
                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {
                const currentDomain = document.domain;
                script = '<script>document.domain="' + currentDomain + '";</script>';
            }
            const iframeContents = '<html><body>' + script + '</body></html>';
            try {
                this.myIFrame.doc.open();
                this.myIFrame.doc.write(iframeContents);
                this.myIFrame.doc.close();
            }
            catch (e) {
                log('frame writing exception');
                if (e.stack) {
                    log(e.stack);
                }
                log(e);
            }
        }
    }
    /**
     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
     * actually use.
     */
    static createIFrame_() {
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        // This is necessary in order to initialize the document inside the iframe
        if (document.body) {
            document.body.appendChild(iframe);
            try {
                // If document.domain has been modified in IE, this will throw an error, and we need to set the
                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute
                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.
                const a = iframe.contentWindow.document;
                if (!a) {
                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.
                    log('No IE domain setting required');
                }
            }
            catch (e) {
                const domain = document.domain;
                iframe.src =
                    "javascript:void((function(){document.open();document.domain='" +
                        domain +
                        "';document.close();})())";
            }
        }
        else {
            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this
            // never gets hit.
            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';
        }
        // Get the document of the iframe in a browser-specific way.
        if (iframe.contentDocument) {
            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari
        }
        else if (iframe.contentWindow) {
            iframe.doc = iframe.contentWindow.document; // Internet Explorer
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        else if (iframe.document) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            iframe.doc = iframe.document; //others?
        }
        return iframe;
    }
    /**
     * Cancel all outstanding queries and remove the frame.
     */
    close() {
        //Mark this iframe as dead, so no new requests are sent.
        this.alive = false;
        if (this.myIFrame) {
            //We have to actually remove all of the html inside this iframe before removing it from the
            //window, or IE will continue loading and executing the script tags we've already added, which
            //can lead to some errors being thrown. Setting textContent seems to be the safest way to do this.
            this.myIFrame.doc.body.textContent = '';
            setTimeout(() => {
                if (this.myIFrame !== null) {
                    document.body.removeChild(this.myIFrame);
                    this.myIFrame = null;
                }
            }, Math.floor(0));
        }
        // Protect from being called recursively.
        const onDisconnect = this.onDisconnect;
        if (onDisconnect) {
            this.onDisconnect = null;
            onDisconnect();
        }
    }
    /**
     * Actually start the long-polling session by adding the first script tag(s) to the iframe.
     * @param id - The ID of this connection
     * @param pw - The password for this connection
     */
    startLongPoll(id, pw) {
        this.myID = id;
        this.myPW = pw;
        this.alive = true;
        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.
        while (this.newRequest_()) { }
    }
    /**
     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
     * too many outstanding requests and we are still alive.
     *
     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
     * needed.
     */
    newRequest_() {
        // We keep one outstanding request open all the time to receive data, but if we need to send data
        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically
        // close the old request.
        if (this.alive &&
            this.sendNewPolls &&
            this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
            //construct our url
            this.currentSerial++;
            const urlParams = {};
            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
            let theURL = this.urlFn(urlParams);
            //Now add as much data as we can.
            let curDataString = '';
            let i = 0;
            while (this.pendingSegs.length > 0) {
                //first, lets see if the next segment will fit.
                const nextSeg = this.pendingSegs[0];
                if (nextSeg.d.length +
                    SEG_HEADER_SIZE +
                    curDataString.length <=
                    MAX_URL_DATA_SIZE) {
                    //great, the segment will fit. Lets append it.
                    const theSeg = this.pendingSegs.shift();
                    curDataString =
                        curDataString +
                            '&' +
                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +
                            i +
                            '=' +
                            theSeg.seg +
                            '&' +
                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +
                            i +
                            '=' +
                            theSeg.ts +
                            '&' +
                            FIREBASE_LONGPOLL_DATA_PARAM +
                            i +
                            '=' +
                            theSeg.d;
                    i++;
                }
                else {
                    break;
                }
            }
            theURL = theURL + curDataString;
            this.addLongPollTag_(theURL, this.currentSerial);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Queue a packet for transmission to the server.
     * @param segnum - A sequential id for this packet segment used for reassembly
     * @param totalsegs - The total number of segments in this packet
     * @param data - The data for this segment.
     */
    enqueueSegment(segnum, totalsegs, data) {
        //add this to the queue of segments to send.
        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
        //send the data immediately if there isn't already data being transmitted, unless
        //startLongPoll hasn't been called yet.
        if (this.alive) {
            this.newRequest_();
        }
    }
    /**
     * Add a script tag for a regular long-poll request.
     * @param url - The URL of the script tag.
     * @param serial - The serial number of the request.
     */
    addLongPollTag_(url, serial) {
        //remember that we sent this request.
        this.outstandingRequests.add(serial);
        const doNewRequest = () => {
            this.outstandingRequests.delete(serial);
            this.newRequest_();
        };
        // If this request doesn't return on its own accord (by the server sending us some data), we'll
        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.
        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        const readyStateCB = () => {
            // Request completed.  Cancel the keepalive.
            clearTimeout(keepaliveTimeout);
            // Trigger a new request so we can continue receiving data.
            doNewRequest();
        };
        this.addTag(url, readyStateCB);
    }
    /**
     * Add an arbitrary script tag to the iframe.
     * @param url - The URL for the script tag source.
     * @param loadCB - A callback to be triggered once the script has loaded.
     */
    addTag(url, loadCB) {
        {
            setTimeout(() => {
                try {
                    // if we're already closed, don't add this poll
                    if (!this.sendNewPolls) {
                        return;
                    }
                    const newScript = this.myIFrame.doc.createElement('script');
                    newScript.type = 'text/javascript';
                    newScript.async = true;
                    newScript.src = url;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    newScript.onload = newScript.onreadystatechange =
                        function () {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            const rstate = newScript.readyState;
                            if (!rstate || rstate === 'loaded' || rstate === 'complete') {
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                newScript.onload = newScript.onreadystatechange = null;
                                if (newScript.parentNode) {
                                    newScript.parentNode.removeChild(newScript);
                                }
                                loadCB();
                            }
                        };
                    newScript.onerror = () => {
                        log('Long-poll script failed to load: ' + url);
                        this.sendNewPolls = false;
                        this.close();
                    };
                    this.myIFrame.doc.body.appendChild(newScript);
                }
                catch (e) {
                    // TODO: we should make this error visible somehow
                }
            }, Math.floor(1));
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WEBSOCKET_MAX_FRAME_SIZE = 16384;
const WEBSOCKET_KEEPALIVE_INTERVAL = 45000;
let WebSocketImpl = null;
if (typeof MozWebSocket !== 'undefined') {
    WebSocketImpl = MozWebSocket;
}
else if (typeof WebSocket !== 'undefined') {
    WebSocketImpl = WebSocket;
}
/**
 * Create a new websocket connection with the given callbacks.
 */
class WebSocketConnection {
    /**
     * @param connId identifier for this transport
     * @param repoInfo The info for the websocket endpoint.
     * @param applicationId The Firebase App ID for this project.
     * @param appCheckToken The App Check Token for this client.
     * @param authToken The Auth Token for this client.
     * @param transportSessionId Optional transportSessionId if this is connecting
     * to an existing transport session
     * @param lastSessionId Optional lastSessionId if there was a previous
     * connection
     */
    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = logWrapper(this.connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);
        this.nodeAdmin = repoInfo.nodeAdmin;
    }
    /**
     * @param repoInfo - The info for the websocket endpoint.
     * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param lastSessionId - Optional lastSessionId if there was a previous connection
     * @returns connection url
     */
    static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) {
        const urlParams = {};
        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
        if (typeof location !== 'undefined' &&
            location.hostname &&
            FORGE_DOMAIN_RE.test(location.hostname)) {
            urlParams[REFERER_PARAM] = FORGE_REF;
        }
        if (transportSessionId) {
            urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
        }
        if (lastSessionId) {
            urlParams[LAST_SESSION_PARAM] = lastSessionId;
        }
        if (appCheckToken) {
            urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;
        }
        if (applicationId) {
            urlParams[APPLICATION_ID_PARAM] = applicationId;
        }
        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
    }
    /**
     * @param onMessage - Callback when messages arrive
     * @param onDisconnect - Callback with connection lost.
     */
    open(onMessage, onDisconnect) {
        this.onDisconnect = onDisconnect;
        this.onMessage = onMessage;
        this.log_('Websocket connecting to ' + this.connURL);
        this.everConnected_ = false;
        // Assume failure until proven otherwise.
        PersistentStorage.set('previous_websocket_failure', true);
        try {
            let options;
            if (isNodeSdk()) ;
            this.mySock = new WebSocketImpl(this.connURL, [], options);
        }
        catch (e) {
            this.log_('Error instantiating WebSocket.');
            const error = e.message || e.data;
            if (error) {
                this.log_(error);
            }
            this.onClosed_();
            return;
        }
        this.mySock.onopen = () => {
            this.log_('Websocket connected.');
            this.everConnected_ = true;
        };
        this.mySock.onclose = () => {
            this.log_('Websocket connection was disconnected.');
            this.mySock = null;
            this.onClosed_();
        };
        this.mySock.onmessage = m => {
            this.handleIncomingFrame(m);
        };
        this.mySock.onerror = e => {
            this.log_('WebSocket error.  Closing connection.');
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const error = e.message || e.data;
            if (error) {
                this.log_(error);
            }
            this.onClosed_();
        };
    }
    /**
     * No-op for websockets, we don't need to do anything once the connection is confirmed as open
     */
    start() { }
    static forceDisallow() {
        WebSocketConnection.forceDisallow_ = true;
    }
    static isAvailable() {
        let isOldAndroid = false;
        if (typeof navigator !== 'undefined' && navigator.userAgent) {
            const oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
            const oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
            if (oldAndroidMatch && oldAndroidMatch.length > 1) {
                if (parseFloat(oldAndroidMatch[1]) < 4.4) {
                    isOldAndroid = true;
                }
            }
        }
        return (!isOldAndroid &&
            WebSocketImpl !== null &&
            !WebSocketConnection.forceDisallow_);
    }
    /**
     * Returns true if we previously failed to connect with this transport.
     */
    static previouslyFailed() {
        // If our persistent storage is actually only in-memory storage,
        // we default to assuming that it previously failed to be safe.
        return (PersistentStorage.isInMemoryStorage ||
            PersistentStorage.get('previous_websocket_failure') === true);
    }
    markConnectionHealthy() {
        PersistentStorage.remove('previous_websocket_failure');
    }
    appendFrame_(data) {
        this.frames.push(data);
        if (this.frames.length === this.totalFrames) {
            const fullMess = this.frames.join('');
            this.frames = null;
            const jsonMess = jsonEval(fullMess);
            //handle the message
            this.onMessage(jsonMess);
        }
    }
    /**
     * @param frameCount - The number of frames we are expecting from the server
     */
    handleNewFrameCount_(frameCount) {
        this.totalFrames = frameCount;
        this.frames = [];
    }
    /**
     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
     * @returns Any remaining data to be process, or null if there is none
     */
    extractFrameCount_(data) {
        assert(this.frames === null, 'We already have a frame buffer');
        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced
        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508
        if (data.length <= 6) {
            const frameCount = Number(data);
            if (!isNaN(frameCount)) {
                this.handleNewFrameCount_(frameCount);
                return null;
            }
        }
        this.handleNewFrameCount_(1);
        return data;
    }
    /**
     * Process a websocket frame that has arrived from the server.
     * @param mess - The frame data
     */
    handleIncomingFrame(mess) {
        if (this.mySock === null) {
            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.
        }
        const data = mess['data'];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter('bytes_received', data.length);
        this.resetKeepAlive();
        if (this.frames !== null) {
            // we're buffering
            this.appendFrame_(data);
        }
        else {
            // try to parse out a frame count, otherwise, assume 1 and process it
            const remainingData = this.extractFrameCount_(data);
            if (remainingData !== null) {
                this.appendFrame_(remainingData);
            }
        }
    }
    /**
     * Send a message to the server
     * @param data - The JSON object to transmit
     */
    send(data) {
        this.resetKeepAlive();
        const dataStr = stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //We can only fit a certain amount in each websocket frame, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        //Send the length header
        if (dataSegs.length > 1) {
            this.sendString_(String(dataSegs.length));
        }
        //Send the actual data in segments.
        for (let i = 0; i < dataSegs.length; i++) {
            this.sendString_(dataSegs[i]);
        }
    }
    shutdown_() {
        this.isClosed_ = true;
        if (this.keepaliveTimer) {
            clearInterval(this.keepaliveTimer);
            this.keepaliveTimer = null;
        }
        if (this.mySock) {
            this.mySock.close();
            this.mySock = null;
        }
    }
    onClosed_() {
        if (!this.isClosed_) {
            this.log_('WebSocket is closing itself');
            this.shutdown_();
            // since this is an internal close, trigger the close listener
            if (this.onDisconnect) {
                this.onDisconnect(this.everConnected_);
                this.onDisconnect = null;
            }
        }
    }
    /**
     * External-facing close handler.
     * Close the websocket and kill the connection.
     */
    close() {
        if (!this.isClosed_) {
            this.log_('WebSocket is being closed');
            this.shutdown_();
        }
    }
    /**
     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
     * the last activity.
     */
    resetKeepAlive() {
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(() => {
            //If there has been no websocket activity for a while, send a no-op
            if (this.mySock) {
                this.sendString_('0');
            }
            this.resetKeepAlive();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
    }
    /**
     * Send a string over the websocket.
     *
     * @param str - String to send.
     */
    sendString_(str) {
        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()
        // calls for some unknown reason.  We treat these as an error and disconnect.
        // See https://app.asana.com/0/58926111402292/68021340250410
        try {
            this.mySock.send(str);
        }
        catch (e) {
            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');
            setTimeout(this.onClosed_.bind(this), 0);
        }
    }
}
/**
 * Number of response before we consider the connection "healthy."
 */
WebSocketConnection.responsesRequiredToBeHealthy = 2;
/**
 * Time to wait for the connection te become healthy before giving up.
 */
WebSocketConnection.healthyTimeout = 30000;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Currently simplistic, this class manages what transport a Connection should use at various stages of its
 * lifecycle.
 *
 * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if
 * they are available.
 */
class TransportManager {
    /**
     * @param repoInfo - Metadata around the namespace we're connecting to
     */
    constructor(repoInfo) {
        this.initTransports_(repoInfo);
    }
    static get ALL_TRANSPORTS() {
        return [BrowserPollConnection, WebSocketConnection];
    }
    /**
     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after
     * TransportManager has already set up transports_
     */
    static get IS_TRANSPORT_INITIALIZED() {
        return this.globalTransportInitialized_;
    }
    initTransports_(repoInfo) {
        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection['isAvailable']();
        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();
        if (repoInfo.webSocketOnly) {
            if (!isWebSocketsAvailable) {
                warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
            }
            isSkipPollConnection = true;
        }
        if (isSkipPollConnection) {
            this.transports_ = [WebSocketConnection];
        }
        else {
            const transports = (this.transports_ = []);
            for (const transport of TransportManager.ALL_TRANSPORTS) {
                if (transport && transport['isAvailable']()) {
                    transports.push(transport);
                }
            }
            TransportManager.globalTransportInitialized_ = true;
        }
    }
    /**
     * @returns The constructor for the initial transport to use
     */
    initialTransport() {
        if (this.transports_.length > 0) {
            return this.transports_[0];
        }
        else {
            throw new Error('No transports available');
        }
    }
    /**
     * @returns The constructor for the next transport, or null
     */
    upgradeTransport() {
        if (this.transports_.length > 1) {
            return this.transports_[1];
        }
        else {
            return null;
        }
    }
}
// Keeps track of whether the TransportManager has already chosen a transport to use
TransportManager.globalTransportInitialized_ = false;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Abort upgrade attempt if it takes longer than 60s.
const UPGRADE_TIMEOUT = 60000;
// For some transports (WebSockets), we need to "validate" the transport by exchanging a few requests and responses.
// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.
const DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;
// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)
// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout
// but we've sent/received enough bytes, we don't cancel the connection.
const BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
const BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
const MESSAGE_TYPE = 't';
const MESSAGE_DATA = 'd';
const CONTROL_SHUTDOWN = 's';
const CONTROL_RESET = 'r';
const CONTROL_ERROR = 'e';
const CONTROL_PONG = 'o';
const SWITCH_ACK = 'a';
const END_TRANSMISSION = 'n';
const PING = 'p';
const SERVER_HELLO = 'h';
/**
 * Creates a new real-time connection to the server using whichever method works
 * best in the current browser.
 */
class Connection {
    /**
     * @param id - an id for this connection
     * @param repoInfo_ - the info for the endpoint to connect to
     * @param applicationId_ - the Firebase App ID for this project
     * @param appCheckToken_ - The App Check Token for this device.
     * @param authToken_ - The auth token for this session.
     * @param onMessage_ - the callback to be triggered when a server-push message arrives
     * @param onReady_ - the callback to be triggered when this connection is ready to send messages.
     * @param onDisconnect_ - the callback to be triggered when a connection was lost
     * @param onKill_ - the callback to be triggered when this connection has permanently shut down.
     * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
     */
    constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
        this.id = id;
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.appCheckToken_ = appCheckToken_;
        this.authToken_ = authToken_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0 /* RealtimeState.CONNECTING */;
        this.log_ = logWrapper('c:' + this.id + ':');
        this.transportManager_ = new TransportManager(repoInfo_);
        this.log_('Connection created');
        this.start_();
    }
    /**
     * Starts a connection attempt
     */
    start_() {
        const conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;
        const onMessageReceived = this.connReceiver_(this.conn_);
        const onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        /*
         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.
         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.
         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should
         * still have the context of your originating frame.
         */
        setTimeout(() => {
            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it
            this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);
        }, Math.floor(0));
        const healthyTimeoutMS = conn['healthyTimeout'] || 0;
        if (healthyTimeoutMS > 0) {
            this.healthyTimeout_ = setTimeoutNonBlocking(() => {
                this.healthyTimeout_ = null;
                if (!this.isHealthy_) {
                    if (this.conn_ &&
                        this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
                        this.log_('Connection exceeded healthy timeout but has received ' +
                            this.conn_.bytesReceived +
                            ' bytes.  Marking connection healthy.');
                        this.isHealthy_ = true;
                        this.conn_.markConnectionHealthy();
                    }
                    else if (this.conn_ &&
                        this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
                        this.log_('Connection exceeded healthy timeout but has sent ' +
                            this.conn_.bytesSent +
                            ' bytes.  Leaving connection alive.');
                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to
                        // the server.
                    }
                    else {
                        this.log_('Closing unhealthy connection after timeout.');
                        this.close();
                    }
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
            }, Math.floor(healthyTimeoutMS));
        }
    }
    nextTransportId_() {
        return 'c:' + this.id + ':' + this.connectionCount++;
    }
    disconnReceiver_(conn) {
        return everConnected => {
            if (conn === this.conn_) {
                this.onConnectionLost_(everConnected);
            }
            else if (conn === this.secondaryConn_) {
                this.log_('Secondary connection lost.');
                this.onSecondaryConnectionLost_();
            }
            else {
                this.log_('closing an old connection');
            }
        };
    }
    connReceiver_(conn) {
        return (message) => {
            if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */) {
                if (conn === this.rx_) {
                    this.onPrimaryMessageReceived_(message);
                }
                else if (conn === this.secondaryConn_) {
                    this.onSecondaryMessageReceived_(message);
                }
                else {
                    this.log_('message on old connection');
                }
            }
        };
    }
    /**
     * @param dataMsg - An arbitrary data message to be sent to the server
     */
    sendRequest(dataMsg) {
        // wrap in a data message envelope and send it on
        const msg = { t: 'd', d: dataMsg };
        this.sendData_(msg);
    }
    tryCleanupConnection() {
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);
            this.conn_ = this.secondaryConn_;
            this.secondaryConn_ = null;
            // the server will shutdown the old connection
        }
    }
    onSecondaryControl_(controlData) {
        if (MESSAGE_TYPE in controlData) {
            const cmd = controlData[MESSAGE_TYPE];
            if (cmd === SWITCH_ACK) {
                this.upgradeIfSecondaryHealthy_();
            }
            else if (cmd === CONTROL_RESET) {
                // Most likely the session wasn't valid. Abandon the switch attempt
                this.log_('Got a reset on secondary, closing it');
                this.secondaryConn_.close();
                // If we were already using this connection for something, than we need to fully close
                if (this.tx_ === this.secondaryConn_ ||
                    this.rx_ === this.secondaryConn_) {
                    this.close();
                }
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on secondary.');
                this.secondaryResponsesRequired_--;
                this.upgradeIfSecondaryHealthy_();
            }
        }
    }
    onSecondaryMessageReceived_(parsedData) {
        const layer = requireKey('t', parsedData);
        const data = requireKey('d', parsedData);
        if (layer === 'c') {
            this.onSecondaryControl_(data);
        }
        else if (layer === 'd') {
            // got a data message, but we're still second connection. Need to buffer it up
            this.pendingDataMessages.push(data);
        }
        else {
            throw new Error('Unknown protocol layer: ' + layer);
        }
    }
    upgradeIfSecondaryHealthy_() {
        if (this.secondaryResponsesRequired_ <= 0) {
            this.log_('Secondary connection is healthy.');
            this.isHealthy_ = true;
            this.secondaryConn_.markConnectionHealthy();
            this.proceedWithUpgrade_();
        }
        else {
            // Send a ping to make sure the connection is healthy.
            this.log_('sending ping on secondary.');
            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });
        }
    }
    proceedWithUpgrade_() {
        // tell this connection to consider itself open
        this.secondaryConn_.start();
        // send ack
        this.log_('sending client ack on secondary');
        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });
        // send end packet on primary transport, switch to sending on this one
        // can receive on this one, buffer responses until end received on primary transport
        this.log_('Ending transmission on primary');
        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
    }
    onPrimaryMessageReceived_(parsedData) {
        // Must refer to parsedData properties in quotes, so closure doesn't touch them.
        const layer = requireKey('t', parsedData);
        const data = requireKey('d', parsedData);
        if (layer === 'c') {
            this.onControl_(data);
        }
        else if (layer === 'd') {
            this.onDataMessage_(data);
        }
    }
    onDataMessage_(message) {
        this.onPrimaryResponse_();
        // We don't do anything with data messages, just kick them up a level
        this.onMessage_(message);
    }
    onPrimaryResponse_() {
        if (!this.isHealthy_) {
            this.primaryResponsesRequired_--;
            if (this.primaryResponsesRequired_ <= 0) {
                this.log_('Primary connection is healthy.');
                this.isHealthy_ = true;
                this.conn_.markConnectionHealthy();
            }
        }
    }
    onControl_(controlData) {
        const cmd = requireKey(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) {
            const payload = controlData[MESSAGE_DATA];
            if (cmd === SERVER_HELLO) {
                const handshakePayload = Object.assign({}, payload);
                if (this.repoInfo_.isUsingEmulator) {
                    // Upon connecting, the emulator will pass the hostname that it's aware of, but we prefer the user's set hostname via `connectDatabaseEmulator` over what the emulator passes.
                    handshakePayload.h = this.repoInfo_.host;
                }
                this.onHandshake_(handshakePayload);
            }
            else if (cmd === END_TRANSMISSION) {
                this.log_('recvd end transmission on primary');
                this.rx_ = this.secondaryConn_;
                for (let i = 0; i < this.pendingDataMessages.length; ++i) {
                    this.onDataMessage_(this.pendingDataMessages[i]);
                }
                this.pendingDataMessages = [];
                this.tryCleanupConnection();
            }
            else if (cmd === CONTROL_SHUTDOWN) {
                // This was previously the 'onKill' callback passed to the lower-level connection
                // payload in this case is the reason for the shutdown. Generally a human-readable error
                this.onConnectionShutdown_(payload);
            }
            else if (cmd === CONTROL_RESET) {
                // payload in this case is the host we should contact
                this.onReset_(payload);
            }
            else if (cmd === CONTROL_ERROR) {
                error('Server Error: ' + payload);
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on primary.');
                this.onPrimaryResponse_();
                this.sendPingOnPrimaryIfNecessary_();
            }
            else {
                error('Unknown control packet command: ' + cmd);
            }
        }
    }
    /**
     * @param handshake - The handshake data returned from the server
     */
    onHandshake_(handshake) {
        const timestamp = handshake.ts;
        const version = handshake.v;
        const host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.host = host;
        // if we've already closed the connection, then don't bother trying to progress further
        if (this.state_ === 0 /* RealtimeState.CONNECTING */) {
            this.conn_.start();
            this.onConnectionEstablished_(this.conn_, timestamp);
            if (PROTOCOL_VERSION !== version) {
                warn('Protocol version mismatch detected');
            }
            // TODO: do we want to upgrade? when? maybe a delay?
            this.tryStartUpgrade_();
        }
    }
    tryStartUpgrade_() {
        const conn = this.transportManager_.upgradeTransport();
        if (conn) {
            this.startUpgrade_(conn);
        }
    }
    startUpgrade_(conn) {
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.secondaryResponsesRequired_ =
            conn['responsesRequiredToBeHealthy'] || 0;
        const onMessage = this.connReceiver_(this.secondaryConn_);
        const onDisconnect = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect);
        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.
        setTimeoutNonBlocking(() => {
            if (this.secondaryConn_) {
                this.log_('Timed out trying to upgrade.');
                this.secondaryConn_.close();
            }
        }, Math.floor(UPGRADE_TIMEOUT));
    }
    onReset_(host) {
        this.log_('Reset packet received.  New host: ' + host);
        this.repoInfo_.host = host;
        // TODO: if we're already "connected", we need to trigger a disconnect at the next layer up.
        // We don't currently support resets after the connection has already been established
        if (this.state_ === 1 /* RealtimeState.CONNECTED */) {
            this.close();
        }
        else {
            // Close whatever connections we have open and start again.
            this.closeConnections_();
            this.start_();
        }
    }
    onConnectionEstablished_(conn, timestamp) {
        this.log_('Realtime connection established.');
        this.conn_ = conn;
        this.state_ = 1 /* RealtimeState.CONNECTED */;
        if (this.onReady_) {
            this.onReady_(timestamp, this.sessionId);
            this.onReady_ = null;
        }
        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,
        // send some pings.
        if (this.primaryResponsesRequired_ === 0) {
            this.log_('Primary connection is healthy.');
            this.isHealthy_ = true;
        }
        else {
            setTimeoutNonBlocking(() => {
                this.sendPingOnPrimaryIfNecessary_();
            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        }
    }
    sendPingOnPrimaryIfNecessary_() {
        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.
        if (!this.isHealthy_ && this.state_ === 1 /* RealtimeState.CONNECTED */) {
            this.log_('sending ping on primary.');
            this.sendData_({ t: 'c', d: { t: PING, d: {} } });
        }
    }
    onSecondaryConnectionLost_() {
        const conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) {
            // we are relying on this connection already in some capacity. Therefore, a failure is real
            this.close();
        }
    }
    /**
     * @param everConnected - Whether or not the connection ever reached a server. Used to determine if
     * we should flush the host cache
     */
    onConnectionLost_(everConnected) {
        this.conn_ = null;
        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting
        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.
        if (!everConnected && this.state_ === 0 /* RealtimeState.CONNECTING */) {
            this.log_('Realtime connection failed.');
            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away
            if (this.repoInfo_.isCacheableHost()) {
                PersistentStorage.remove('host:' + this.repoInfo_.host);
                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com
                this.repoInfo_.internalHost = this.repoInfo_.host;
            }
        }
        else if (this.state_ === 1 /* RealtimeState.CONNECTED */) {
            this.log_('Realtime connection lost.');
        }
        this.close();
    }
    onConnectionShutdown_(reason) {
        this.log_('Connection shutdown command received. Shutting down...');
        if (this.onKill_) {
            this.onKill_(reason);
            this.onKill_ = null;
        }
        // We intentionally don't want to fire onDisconnect (kill is a different case),
        // so clear the callback.
        this.onDisconnect_ = null;
        this.close();
    }
    sendData_(data) {
        if (this.state_ !== 1 /* RealtimeState.CONNECTED */) {
            throw 'Connection is not connected';
        }
        else {
            this.tx_.send(data);
        }
    }
    /**
     * Cleans up this connection, calling the appropriate callbacks
     */
    close() {
        if (this.state_ !== 2 /* RealtimeState.DISCONNECTED */) {
            this.log_('Closing realtime connection.');
            this.state_ = 2 /* RealtimeState.DISCONNECTED */;
            this.closeConnections_();
            if (this.onDisconnect_) {
                this.onDisconnect_();
                this.onDisconnect_ = null;
            }
        }
    }
    closeConnections_() {
        this.log_('Shutting down all connections');
        if (this.conn_) {
            this.conn_.close();
            this.conn_ = null;
        }
        if (this.secondaryConn_) {
            this.secondaryConn_.close();
            this.secondaryConn_ = null;
        }
        if (this.healthyTimeout_) {
            clearTimeout(this.healthyTimeout_);
            this.healthyTimeout_ = null;
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Interface defining the set of actions that can be performed against the Firebase server
 * (basically corresponds to our wire protocol).
 *
 * @interface
 */
class ServerActions {
    put(pathString, data, onComplete, hash) { }
    merge(pathString, data, onComplete, hash) { }
    /**
     * Refreshes the auth token for the current connection.
     * @param token - The authentication token
     */
    refreshAuthToken(token) { }
    /**
     * Refreshes the app check token for the current connection.
     * @param token The app check token
     */
    refreshAppCheckToken(token) { }
    onDisconnectPut(pathString, data, onComplete) { }
    onDisconnectMerge(pathString, data, onComplete) { }
    onDisconnectCancel(pathString, onComplete) { }
    reportStats(stats) { }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Base class to be used if you want to emit events. Call the constructor with
 * the set of allowed event names.
 */
class EventEmitter {
    constructor(allowedEvents_) {
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = {};
        assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');
    }
    /**
     * To be called by derived classes to trigger events.
     */
    trigger(eventType, ...varArgs) {
        if (Array.isArray(this.listeners_[eventType])) {
            // Clone the list, since callbacks could add/remove listeners.
            const listeners = [...this.listeners_[eventType]];
            for (let i = 0; i < listeners.length; i++) {
                listeners[i].callback.apply(listeners[i].context, varArgs);
            }
        }
    }
    on(eventType, callback, context) {
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push({ callback, context });
        const eventData = this.getInitialEvent(eventType);
        if (eventData) {
            callback.apply(context, eventData);
        }
    }
    off(eventType, callback, context) {
        this.validateEventType_(eventType);
        const listeners = this.listeners_[eventType] || [];
        for (let i = 0; i < listeners.length; i++) {
            if (listeners[i].callback === callback &&
                (!context || context === listeners[i].context)) {
                listeners.splice(i, 1);
                return;
            }
        }
    }
    validateEventType_(eventType) {
        assert(this.allowedEvents_.find(et => {
            return et === eventType;
        }), 'Unknown event: ' + eventType);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Monitors online state (as reported by window.online/offline events).
 *
 * The expectation is that this could have many false positives (thinks we are online
 * when we're not), but no false negatives.  So we can safely use it to determine when
 * we definitely cannot reach the internet.
 */
class OnlineMonitor extends EventEmitter {
    constructor() {
        super(['online']);
        this.online_ = true;
        // We've had repeated complaints that Cordova apps can get stuck "offline", e.g.
        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810
        // It would seem that the 'online' event does not always fire consistently. So we disable it
        // for Cordova.
        if (typeof window !== 'undefined' &&
            typeof window.addEventListener !== 'undefined' &&
            !isMobileCordova()) {
            window.addEventListener('online', () => {
                if (!this.online_) {
                    this.online_ = true;
                    this.trigger('online', true);
                }
            }, false);
            window.addEventListener('offline', () => {
                if (this.online_) {
                    this.online_ = false;
                    this.trigger('online', false);
                }
            }, false);
        }
    }
    static getInstance() {
        return new OnlineMonitor();
    }
    getInitialEvent(eventType) {
        assert(eventType === 'online', 'Unknown event type: ' + eventType);
        return [this.online_];
    }
    currentlyOnline() {
        return this.online_;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Maximum key depth. */
const MAX_PATH_DEPTH = 32;
/** Maximum number of (UTF8) bytes in a Firebase path. */
const MAX_PATH_LENGTH_BYTES = 768;
/**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */
class Path {
    /**
     * @param pathOrString - Path string to parse, or another path, or the raw
     * tokens array
     */
    constructor(pathOrString, pieceNum) {
        if (pieceNum === void 0) {
            this.pieces_ = pathOrString.split('/');
            // Remove empty pieces.
            let copyTo = 0;
            for (let i = 0; i < this.pieces_.length; i++) {
                if (this.pieces_[i].length > 0) {
                    this.pieces_[copyTo] = this.pieces_[i];
                    copyTo++;
                }
            }
            this.pieces_.length = copyTo;
            this.pieceNum_ = 0;
        }
        else {
            this.pieces_ = pathOrString;
            this.pieceNum_ = pieceNum;
        }
    }
    toString() {
        let pathString = '';
        for (let i = this.pieceNum_; i < this.pieces_.length; i++) {
            if (this.pieces_[i] !== '') {
                pathString += '/' + this.pieces_[i];
            }
        }
        return pathString || '/';
    }
}
function newEmptyPath() {
    return new Path('');
}
function pathGetFront(path) {
    if (path.pieceNum_ >= path.pieces_.length) {
        return null;
    }
    return path.pieces_[path.pieceNum_];
}
/**
 * @returns The number of segments in this path
 */
function pathGetLength(path) {
    return path.pieces_.length - path.pieceNum_;
}
function pathPopFront(path) {
    let pieceNum = path.pieceNum_;
    if (pieceNum < path.pieces_.length) {
        pieceNum++;
    }
    return new Path(path.pieces_, pieceNum);
}
function pathGetBack(path) {
    if (path.pieceNum_ < path.pieces_.length) {
        return path.pieces_[path.pieces_.length - 1];
    }
    return null;
}
function pathToUrlEncodedString(path) {
    let pathString = '';
    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {
        if (path.pieces_[i] !== '') {
            pathString += '/' + encodeURIComponent(String(path.pieces_[i]));
        }
    }
    return pathString || '/';
}
/**
 * Shallow copy of the parts of the path.
 *
 */
function pathSlice(path, begin = 0) {
    return path.pieces_.slice(path.pieceNum_ + begin);
}
function pathParent(path) {
    if (path.pieceNum_ >= path.pieces_.length) {
        return null;
    }
    const pieces = [];
    for (let i = path.pieceNum_; i < path.pieces_.length - 1; i++) {
        pieces.push(path.pieces_[i]);
    }
    return new Path(pieces, 0);
}
function pathChild(path, childPathObj) {
    const pieces = [];
    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {
        pieces.push(path.pieces_[i]);
    }
    if (childPathObj instanceof Path) {
        for (let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
            pieces.push(childPathObj.pieces_[i]);
        }
    }
    else {
        const childPieces = childPathObj.split('/');
        for (let i = 0; i < childPieces.length; i++) {
            if (childPieces[i].length > 0) {
                pieces.push(childPieces[i]);
            }
        }
    }
    return new Path(pieces, 0);
}
/**
 * @returns True if there are no segments in this path
 */
function pathIsEmpty(path) {
    return path.pieceNum_ >= path.pieces_.length;
}
/**
 * @returns The path from outerPath to innerPath
 */
function newRelativePath(outerPath, innerPath) {
    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
    if (outer === null) {
        return innerPath;
    }
    else if (outer === inner) {
        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
    }
    else {
        throw new Error('INTERNAL ERROR: innerPath (' +
            innerPath +
            ') is not within ' +
            'outerPath (' +
            outerPath +
            ')');
    }
}
/**
 * @returns true if paths are the same.
 */
function pathEquals(path, other) {
    if (pathGetLength(path) !== pathGetLength(other)) {
        return false;
    }
    for (let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) {
        if (path.pieces_[i] !== other.pieces_[j]) {
            return false;
        }
    }
    return true;
}
/**
 * @returns True if this path is a parent of (or the same as) other
 */
function pathContains(path, other) {
    let i = path.pieceNum_;
    let j = other.pieceNum_;
    if (pathGetLength(path) > pathGetLength(other)) {
        return false;
    }
    while (i < path.pieces_.length) {
        if (path.pieces_[i] !== other.pieces_[j]) {
            return false;
        }
        ++i;
        ++j;
    }
    return true;
}
/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */
class ValidationPath {
    /**
     * @param path - Initial Path.
     * @param errorPrefix_ - Prefix for any error messages.
     */
    constructor(path, errorPrefix_) {
        this.errorPrefix_ = errorPrefix_;
        this.parts_ = pathSlice(path, 0);
        /** Initialize to number of '/' chars needed in path. */
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (let i = 0; i < this.parts_.length; i++) {
            this.byteLength_ += stringLength(this.parts_[i]);
        }
        validationPathCheckValid(this);
    }
}
function validationPathPush(validationPath, child) {
    // Count the needed '/'
    if (validationPath.parts_.length > 0) {
        validationPath.byteLength_ += 1;
    }
    validationPath.parts_.push(child);
    validationPath.byteLength_ += stringLength(child);
    validationPathCheckValid(validationPath);
}
function validationPathPop(validationPath) {
    const last = validationPath.parts_.pop();
    validationPath.byteLength_ -= stringLength(last);
    // Un-count the previous '/'
    if (validationPath.parts_.length > 0) {
        validationPath.byteLength_ -= 1;
    }
}
function validationPathCheckValid(validationPath) {
    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {
        throw new Error(validationPath.errorPrefix_ +
            'has a key path longer than ' +
            MAX_PATH_LENGTH_BYTES +
            ' bytes (' +
            validationPath.byteLength_ +
            ').');
    }
    if (validationPath.parts_.length > MAX_PATH_DEPTH) {
        throw new Error(validationPath.errorPrefix_ +
            'path specified exceeds the maximum depth that can be written (' +
            MAX_PATH_DEPTH +
            ') or object contains a cycle ' +
            validationPathToErrorString(validationPath));
    }
}
/**
 * String for use in error messages - uses '.' notation for path.
 */
function validationPathToErrorString(validationPath) {
    if (validationPath.parts_.length === 0) {
        return '';
    }
    return "in property '" + validationPath.parts_.join('.') + "'";
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VisibilityMonitor extends EventEmitter {
    constructor() {
        super(['visible']);
        let hidden;
        let visibilityChange;
        if (typeof document !== 'undefined' &&
            typeof document.addEventListener !== 'undefined') {
            if (typeof document['hidden'] !== 'undefined') {
                // Opera 12.10 and Firefox 18 and later support
                visibilityChange = 'visibilitychange';
                hidden = 'hidden';
            }
            else if (typeof document['mozHidden'] !== 'undefined') {
                visibilityChange = 'mozvisibilitychange';
                hidden = 'mozHidden';
            }
            else if (typeof document['msHidden'] !== 'undefined') {
                visibilityChange = 'msvisibilitychange';
                hidden = 'msHidden';
            }
            else if (typeof document['webkitHidden'] !== 'undefined') {
                visibilityChange = 'webkitvisibilitychange';
                hidden = 'webkitHidden';
            }
        }
        // Initially, we always assume we are visible. This ensures that in browsers
        // without page visibility support or in cases where we are never visible
        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay
        // reconnects
        this.visible_ = true;
        if (visibilityChange) {
            document.addEventListener(visibilityChange, () => {
                const visible = !document[hidden];
                if (visible !== this.visible_) {
                    this.visible_ = visible;
                    this.trigger('visible', visible);
                }
            }, false);
        }
    }
    static getInstance() {
        return new VisibilityMonitor();
    }
    getInitialEvent(eventType) {
        assert(eventType === 'visible', 'Unknown event type: ' + eventType);
        return [this.visible_];
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RECONNECT_MIN_DELAY = 1000;
const RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)
const RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)
const RECONNECT_DELAY_MULTIPLIER = 1.3;
const RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.
const SERVER_KILL_INTERRUPT_REASON = 'server_kill';
// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.
const INVALID_TOKEN_THRESHOLD = 3;
/**
 * Firebase connection.  Abstracts wire protocol and handles reconnecting.
 *
 * NOTE: All JSON objects sent to the realtime connection must have property names enclosed
 * in quotes to make sure the closure compiler does not minify them.
 */
class PersistentConnection extends ServerActions {
    /**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param applicationId_ - The Firebase App ID for this project
     * @param onDataUpdate_ - A callback for new data from the server
     */
    constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {
        super();
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.onDataUpdate_ = onDataUpdate_;
        this.onConnectStatus_ = onConnectStatus_;
        this.onServerInfoUpdate_ = onServerInfoUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        this.authOverride_ = authOverride_;
        // Used for diagnostic logging.
        this.id = PersistentConnection.nextPersistentConnectionId_++;
        this.log_ = logWrapper('p:' + this.id + ':');
        this.interruptReasons_ = {};
        this.listens = new Map();
        this.outstandingPuts_ = [];
        this.outstandingGets_ = [];
        this.outstandingPutCount_ = 0;
        this.outstandingGetCount_ = 0;
        this.onDisconnectRequestQueue_ = [];
        this.connected_ = false;
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        this.securityDebugCallback_ = null;
        this.lastSessionId = null;
        this.establishConnectionTimer_ = null;
        this.visible_ = false;
        // Before we get connected, we keep a queue of pending messages to send.
        this.requestCBHash_ = {};
        this.requestNumber_ = 0;
        this.realtime_ = null;
        this.authToken_ = null;
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = false;
        this.invalidAuthTokenCount_ = 0;
        this.invalidAppCheckTokenCount_ = 0;
        this.firstConnection_ = true;
        this.lastConnectionAttemptTime_ = null;
        this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !isNodeSdk()) {
            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');
        }
        VisibilityMonitor.getInstance().on('visible', this.onVisible_, this);
        if (repoInfo_.host.indexOf('fblocal') === -1) {
            OnlineMonitor.getInstance().on('online', this.onOnline_, this);
        }
    }
    sendRequest(action, body, onResponse) {
        const curReqNum = ++this.requestNumber_;
        const msg = { r: curReqNum, a: action, b: body };
        this.log_(stringify(msg));
        assert(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) {
            this.requestCBHash_[curReqNum] = onResponse;
        }
    }
    get(query) {
        this.initConnection_();
        const deferred = new Deferred();
        const request = {
            p: query._path.toString(),
            q: query._queryObject
        };
        const outstandingGet = {
            action: 'g',
            request,
            onComplete: (message) => {
                const payload = message['d'];
                if (message['s'] === 'ok') {
                    deferred.resolve(payload);
                }
                else {
                    deferred.reject(payload);
                }
            }
        };
        this.outstandingGets_.push(outstandingGet);
        this.outstandingGetCount_++;
        const index = this.outstandingGets_.length - 1;
        if (this.connected_) {
            this.sendGet_(index);
        }
        return deferred.promise;
    }
    listen(query, currentHashFn, tag, onComplete) {
        this.initConnection_();
        const queryId = query._queryIdentifier;
        const pathString = query._path.toString();
        this.log_('Listen called for ' + pathString + ' ' + queryId);
        if (!this.listens.has(pathString)) {
            this.listens.set(pathString, new Map());
        }
        assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'listen() called for non-default but complete query');
        assert(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);
        const listenSpec = {
            onComplete,
            hashFn: currentHashFn,
            query,
            tag
        };
        this.listens.get(pathString).set(queryId, listenSpec);
        if (this.connected_) {
            this.sendListen_(listenSpec);
        }
    }
    sendGet_(index) {
        const get = this.outstandingGets_[index];
        this.sendRequest('g', get.request, (message) => {
            delete this.outstandingGets_[index];
            this.outstandingGetCount_--;
            if (this.outstandingGetCount_ === 0) {
                this.outstandingGets_ = [];
            }
            if (get.onComplete) {
                get.onComplete(message);
            }
        });
    }
    sendListen_(listenSpec) {
        const query = listenSpec.query;
        const pathString = query._path.toString();
        const queryId = query._queryIdentifier;
        this.log_('Listen on ' + pathString + ' for ' + queryId);
        const req = { /*path*/ p: pathString };
        const action = 'q';
        // Only bother to send query if it's non-default.
        if (listenSpec.tag) {
            req['q'] = query._queryObject;
            req['t'] = listenSpec.tag;
        }
        req[ /*hash*/'h'] = listenSpec.hashFn();
        this.sendRequest(action, req, (message) => {
            const payload = message[ /*data*/'d'];
            const status = message[ /*status*/'s'];
            // print warnings in any case...
            PersistentConnection.warnOnListenWarnings_(payload, query);
            const currentListenSpec = this.listens.get(pathString) &&
                this.listens.get(pathString).get(queryId);
            // only trigger actions if the listen hasn't been removed and readded
            if (currentListenSpec === listenSpec) {
                this.log_('listen response', message);
                if (status !== 'ok') {
                    this.removeListen_(pathString, queryId);
                }
                if (listenSpec.onComplete) {
                    listenSpec.onComplete(status, payload);
                }
            }
        });
    }
    static warnOnListenWarnings_(payload, query) {
        if (payload && typeof payload === 'object' && contains(payload, 'w')) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const warnings = safeGet(payload, 'w');
            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {
                const indexSpec = '".indexOn": "' + query._queryParams.getIndex().toString() + '"';
                const indexPath = query._path.toString();
                warn(`Using an unspecified index. Your data will be downloaded and ` +
                    `filtered on the client. Consider adding ${indexSpec} at ` +
                    `${indexPath} to your security rules for better performance.`);
            }
        }
    }
    refreshAuthToken(token) {
        this.authToken_ = token;
        this.log_('Auth token refreshed');
        if (this.authToken_) {
            this.tryAuth();
        }
        else {
            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete
            //the credential so we dont become authenticated next time we connect.
            if (this.connected_) {
                this.sendRequest('unauth', {}, () => { });
            }
        }
        this.reduceReconnectDelayIfAdminCredential_(token);
    }
    reduceReconnectDelayIfAdminCredential_(credential) {
        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).
        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.
        const isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || isAdmin(credential)) {
            this.log_('Admin auth credential detected.  Reducing max reconnect time.');
            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        }
    }
    refreshAppCheckToken(token) {
        this.appCheckToken_ = token;
        this.log_('App check token refreshed');
        if (this.appCheckToken_) {
            this.tryAppCheck();
        }
        else {
            //If we're connected we want to let the server know to unauthenticate us.
            //If we're not connected, simply delete the credential so we dont become
            // authenticated next time we connect.
            if (this.connected_) {
                this.sendRequest('unappeck', {}, () => { });
            }
        }
    }
    /**
     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
     * a auth revoked (the connection is closed).
     */
    tryAuth() {
        if (this.connected_ && this.authToken_) {
            const token = this.authToken_;
            const authMethod = isValidFormat(token) ? 'auth' : 'gauth';
            const requestData = { cred: token };
            if (this.authOverride_ === null) {
                requestData['noauth'] = true;
            }
            else if (typeof this.authOverride_ === 'object') {
                requestData['authvar'] = this.authOverride_;
            }
            this.sendRequest(authMethod, requestData, (res) => {
                const status = res[ /*status*/'s'];
                const data = res[ /*data*/'d'] || 'error';
                if (this.authToken_ === token) {
                    if (status === 'ok') {
                        this.invalidAuthTokenCount_ = 0;
                    }
                    else {
                        // Triggers reconnect and force refresh for auth token
                        this.onAuthRevoked_(status, data);
                    }
                }
            });
        }
    }
    /**
     * Attempts to authenticate with the given token. If the authentication
     * attempt fails, it's triggered like the token was revoked (the connection is
     * closed).
     */
    tryAppCheck() {
        if (this.connected_ && this.appCheckToken_) {
            this.sendRequest('appcheck', { 'token': this.appCheckToken_ }, (res) => {
                const status = res[ /*status*/'s'];
                const data = res[ /*data*/'d'] || 'error';
                if (status === 'ok') {
                    this.invalidAppCheckTokenCount_ = 0;
                }
                else {
                    this.onAppCheckRevoked_(status, data);
                }
            });
        }
    }
    /**
     * @inheritDoc
     */
    unlisten(query, tag) {
        const pathString = query._path.toString();
        const queryId = query._queryIdentifier;
        this.log_('Unlisten called for ' + pathString + ' ' + queryId);
        assert(query._queryParams.isDefault() || !query._queryParams.loadsAllData(), 'unlisten() called for non-default but complete query');
        const listen = this.removeListen_(pathString, queryId);
        if (listen && this.connected_) {
            this.sendUnlisten_(pathString, queryId, query._queryObject, tag);
        }
    }
    sendUnlisten_(pathString, queryId, queryObj, tag) {
        this.log_('Unlisten on ' + pathString + ' for ' + queryId);
        const req = { /*path*/ p: pathString };
        const action = 'n';
        // Only bother sending queryId if it's non-default.
        if (tag) {
            req['q'] = queryObj;
            req['t'] = tag;
        }
        this.sendRequest(action, req);
    }
    onDisconnectPut(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
            this.sendOnDisconnect_('o', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString,
                action: 'o',
                data,
                onComplete
            });
        }
    }
    onDisconnectMerge(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
            this.sendOnDisconnect_('om', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString,
                action: 'om',
                data,
                onComplete
            });
        }
    }
    onDisconnectCancel(pathString, onComplete) {
        this.initConnection_();
        if (this.connected_) {
            this.sendOnDisconnect_('oc', pathString, null, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString,
                action: 'oc',
                data: null,
                onComplete
            });
        }
    }
    sendOnDisconnect_(action, pathString, data, onComplete) {
        const request = { /*path*/ p: pathString, /*data*/ d: data };
        this.log_('onDisconnect ' + action, request);
        this.sendRequest(action, request, (response) => {
            if (onComplete) {
                setTimeout(() => {
                    onComplete(response[ /*status*/'s'], response[ /* data */'d']);
                }, Math.floor(0));
            }
        });
    }
    put(pathString, data, onComplete, hash) {
        this.putInternal('p', pathString, data, onComplete, hash);
    }
    merge(pathString, data, onComplete, hash) {
        this.putInternal('m', pathString, data, onComplete, hash);
    }
    putInternal(action, pathString, data, onComplete, hash) {
        this.initConnection_();
        const request = {
            /*path*/ p: pathString,
            /*data*/ d: data
        };
        if (hash !== undefined) {
            request[ /*hash*/'h'] = hash;
        }
        // TODO: Only keep track of the most recent put for a given path?
        this.outstandingPuts_.push({
            action,
            request,
            onComplete
        });
        this.outstandingPutCount_++;
        const index = this.outstandingPuts_.length - 1;
        if (this.connected_) {
            this.sendPut_(index);
        }
        else {
            this.log_('Buffering put: ' + pathString);
        }
    }
    sendPut_(index) {
        const action = this.outstandingPuts_[index].action;
        const request = this.outstandingPuts_[index].request;
        const onComplete = this.outstandingPuts_[index].onComplete;
        this.outstandingPuts_[index].queued = this.connected_;
        this.sendRequest(action, request, (message) => {
            this.log_(action + ' response', message);
            delete this.outstandingPuts_[index];
            this.outstandingPutCount_--;
            // Clean up array occasionally.
            if (this.outstandingPutCount_ === 0) {
                this.outstandingPuts_ = [];
            }
            if (onComplete) {
                onComplete(message[ /*status*/'s'], message[ /* data */'d']);
            }
        });
    }
    reportStats(stats) {
        // If we're not connected, we just drop the stats.
        if (this.connected_) {
            const request = { /*counters*/ c: stats };
            this.log_('reportStats', request);
            this.sendRequest(/*stats*/ 's', request, result => {
                const status = result[ /*status*/'s'];
                if (status !== 'ok') {
                    const errorReason = result[ /* data */'d'];
                    this.log_('reportStats', 'Error sending stats: ' + errorReason);
                }
            });
        }
    }
    onDataMessage_(message) {
        if ('r' in message) {
            // this is a response
            this.log_('from server: ' + stringify(message));
            const reqNum = message['r'];
            const onResponse = this.requestCBHash_[reqNum];
            if (onResponse) {
                delete this.requestCBHash_[reqNum];
                onResponse(message[ /*body*/'b']);
            }
        }
        else if ('error' in message) {
            throw 'A server-side error has occurred: ' + message['error'];
        }
        else if ('a' in message) {
            // a and b are action and body, respectively
            this.onDataPush_(message['a'], message['b']);
        }
    }
    onDataPush_(action, body) {
        this.log_('handleServerMessage', action, body);
        if (action === 'd') {
            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], 
            /*isMerge*/ false, body['t']);
        }
        else if (action === 'm') {
            this.onDataUpdate_(body[ /*path*/'p'], body[ /*data*/'d'], 
            /*isMerge=*/ true, body['t']);
        }
        else if (action === 'c') {
            this.onListenRevoked_(body[ /*path*/'p'], body[ /*query*/'q']);
        }
        else if (action === 'ac') {
            this.onAuthRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);
        }
        else if (action === 'apc') {
            this.onAppCheckRevoked_(body[ /*status code*/'s'], body[ /* explanation */'d']);
        }
        else if (action === 'sd') {
            this.onSecurityDebugPacket_(body);
        }
        else {
            error('Unrecognized action received from server: ' +
                stringify(action) +
                '\nAre you using the latest client?');
        }
    }
    onReady_(timestamp, sessionId) {
        this.log_('connection ready');
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = new Date().getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) {
            this.sendConnectStats_();
        }
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
    }
    scheduleConnect_(timeout) {
        assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) {
            clearTimeout(this.establishConnectionTimer_);
        }
        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating "Security Error" in
        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).
        this.establishConnectionTimer_ = setTimeout(() => {
            this.establishConnectionTimer_ = null;
            this.establishConnection_();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }, Math.floor(timeout));
    }
    initConnection_() {
        if (!this.realtime_ && this.firstConnection_) {
            this.scheduleConnect_(0);
        }
    }
    onVisible_(visible) {
        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.
        if (visible &&
            !this.visible_ &&
            this.reconnectDelay_ === this.maxReconnectDelay_) {
            this.log_('Window became visible.  Reducing delay.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        this.visible_ = visible;
    }
    onOnline_(online) {
        if (online) {
            this.log_('Browser went online.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        else {
            this.log_('Browser went offline.  Killing connection.');
            if (this.realtime_) {
                this.realtime_.close();
            }
        }
    }
    onRealtimeDisconnect_() {
        this.log_('data client disconnected');
        this.connected_ = false;
        this.realtime_ = null;
        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.
        this.cancelSentTransactions_();
        // Clear out the pending requests.
        this.requestCBHash_ = {};
        if (this.shouldReconnect_()) {
            if (!this.visible_) {
                this.log_("Window isn't visible.  Delaying reconnect.");
                this.reconnectDelay_ = this.maxReconnectDelay_;
                this.lastConnectionAttemptTime_ = new Date().getTime();
            }
            else if (this.lastConnectionEstablishedTime_) {
                // If we've been connected long enough, reset reconnect delay to minimum.
                const timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {
                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;
                }
                this.lastConnectionEstablishedTime_ = null;
            }
            const timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
            let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
            reconnectDelay = Math.random() * reconnectDelay;
            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');
            this.scheduleConnect_(reconnectDelay);
            // Adjust reconnect delay for next time.
            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
        }
        this.onConnectStatus_(false);
    }
    async establishConnection_() {
        if (this.shouldReconnect_()) {
            this.log_('Making a connection attempt');
            this.lastConnectionAttemptTime_ = new Date().getTime();
            this.lastConnectionEstablishedTime_ = null;
            const onDataMessage = this.onDataMessage_.bind(this);
            const onReady = this.onReady_.bind(this);
            const onDisconnect = this.onRealtimeDisconnect_.bind(this);
            const connId = this.id + ':' + PersistentConnection.nextConnectionId_++;
            const lastSessionId = this.lastSessionId;
            let canceled = false;
            let connection = null;
            const closeFn = function () {
                if (connection) {
                    connection.close();
                }
                else {
                    canceled = true;
                    onDisconnect();
                }
            };
            const sendRequestFn = function (msg) {
                assert(connection, "sendRequest call when we're not connected not allowed.");
                connection.sendRequest(msg);
            };
            this.realtime_ = {
                close: closeFn,
                sendRequest: sendRequestFn
            };
            const forceRefresh = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = false;
            try {
                // First fetch auth and app check token, and establish connection after
                // fetching the token was successful
                const [authToken, appCheckToken] = await Promise.all([
                    this.authTokenProvider_.getToken(forceRefresh),
                    this.appCheckTokenProvider_.getToken(forceRefresh)
                ]);
                if (!canceled) {
                    log('getToken() completed. Creating connection.');
                    this.authToken_ = authToken && authToken.accessToken;
                    this.appCheckToken_ = appCheckToken && appCheckToken.token;
                    connection = new Connection(connId, this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, onDataMessage, onReady, onDisconnect, 
                    /* onKill= */ reason => {
                        warn(reason + ' (' + this.repoInfo_.toString() + ')');
                        this.interrupt(SERVER_KILL_INTERRUPT_REASON);
                    }, lastSessionId);
                }
                else {
                    log('getToken() completed but was canceled');
                }
            }
            catch (error) {
                this.log_('Failed to get token: ' + error);
                if (!canceled) {
                    if (this.repoInfo_.nodeAdmin) {
                        // This may be a critical error for the Admin Node.js SDK, so log a warning.
                        // But getToken() may also just have temporarily failed, so we still want to
                        // continue retrying.
                        warn(error);
                    }
                    closeFn();
                }
            }
        }
    }
    interrupt(reason) {
        log('Interrupting connection for reason: ' + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
            this.realtime_.close();
        }
        else {
            if (this.establishConnectionTimer_) {
                clearTimeout(this.establishConnectionTimer_);
                this.establishConnectionTimer_ = null;
            }
            if (this.connected_) {
                this.onRealtimeDisconnect_();
            }
        }
    }
    resume(reason) {
        log('Resuming connection for reason: ' + reason);
        delete this.interruptReasons_[reason];
        if (isEmpty(this.interruptReasons_)) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
    }
    handleTimestamp_(timestamp) {
        const delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
    }
    cancelSentTransactions_() {
        for (let i = 0; i < this.outstandingPuts_.length; i++) {
            const put = this.outstandingPuts_[i];
            if (put && /*hash*/ 'h' in put.request && put.queued) {
                if (put.onComplete) {
                    put.onComplete('disconnect');
                }
                delete this.outstandingPuts_[i];
                this.outstandingPutCount_--;
            }
        }
        // Clean up array occasionally.
        if (this.outstandingPutCount_ === 0) {
            this.outstandingPuts_ = [];
        }
    }
    onListenRevoked_(pathString, query) {
        // Remove the listen and manufacture a "permission_denied" error for the failed listen.
        let queryId;
        if (!query) {
            queryId = 'default';
        }
        else {
            queryId = query.map(q => ObjectToUniqueKey(q)).join('$');
        }
        const listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete) {
            listen.onComplete('permission_denied');
        }
    }
    removeListen_(pathString, queryId) {
        const normalizedPathString = new Path(pathString).toString(); // normalize path.
        let listen;
        if (this.listens.has(normalizedPathString)) {
            const map = this.listens.get(normalizedPathString);
            listen = map.get(queryId);
            map.delete(queryId);
            if (map.size === 0) {
                this.listens.delete(normalizedPathString);
            }
        }
        else {
            // all listens for this path has already been removed
            listen = undefined;
        }
        return listen;
    }
    onAuthRevoked_(statusCode, explanation) {
        log('Auth token revoked: ' + statusCode + '/' + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAuthTokenCount_++;
            if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
                // Set a long reconnect delay because recovery is unlikely
                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
                // Notify the auth token provider that the token is invalid, which will log
                // a warning
                this.authTokenProvider_.notifyForInvalidToken();
            }
        }
    }
    onAppCheckRevoked_(statusCode, explanation) {
        log('App check token revoked: ' + statusCode + '/' + explanation);
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = true;
        // Note: We don't close the connection as the developer may not have
        // enforcement enabled. The backend closes connections with enforcements.
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAppCheckTokenCount_++;
            if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
                this.appCheckTokenProvider_.notifyForInvalidToken();
            }
        }
    }
    onSecurityDebugPacket_(body) {
        if (this.securityDebugCallback_) {
            this.securityDebugCallback_(body);
        }
        else {
            if ('msg' in body) {
                console.log('FIREBASE: ' + body['msg'].replace('\n', '\nFIREBASE: '));
            }
        }
    }
    restoreState_() {
        //Re-authenticate ourselves if we have a credential stored.
        this.tryAuth();
        this.tryAppCheck();
        // Puts depend on having received the corresponding data update from the server before they complete, so we must
        // make sure to send listens before puts.
        for (const queries of this.listens.values()) {
            for (const listenSpec of queries.values()) {
                this.sendListen_(listenSpec);
            }
        }
        for (let i = 0; i < this.outstandingPuts_.length; i++) {
            if (this.outstandingPuts_[i]) {
                this.sendPut_(i);
            }
        }
        while (this.onDisconnectRequestQueue_.length) {
            const request = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
        }
        for (let i = 0; i < this.outstandingGets_.length; i++) {
            if (this.outstandingGets_[i]) {
                this.sendGet_(i);
            }
        }
    }
    /**
     * Sends client stats for first connection
     */
    sendConnectStats_() {
        const stats = {};
        let clientName = 'js';
        stats['sdk.' + clientName + '.' + SDK_VERSION.replace(/\./g, '-')] = 1;
        if (isMobileCordova()) {
            stats['framework.cordova'] = 1;
        }
        else if (isReactNative()) {
            stats['framework.reactnative'] = 1;
        }
        this.reportStats(stats);
    }
    shouldReconnect_() {
        const online = OnlineMonitor.getInstance().currentlyOnline();
        return isEmpty(this.interruptReasons_) && online;
    }
}
PersistentConnection.nextPersistentConnectionId_ = 0;
/**
 * Counter for number of connections created. Mainly used for tagging in the logs
 */
PersistentConnection.nextConnectionId_ = 0;

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NamedNode {
    constructor(name, node) {
        this.name = name;
        this.node = node;
    }
    static Wrap(name, node) {
        return new NamedNode(name, node);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Index {
    /**
     * @returns A standalone comparison function for
     * this index
     */
    getCompare() {
        return this.compare.bind(this);
    }
    /**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     *
     * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode
     */
    indexedValueChanged(oldNode, newNode) {
        const oldWrapped = new NamedNode(MIN_NAME, oldNode);
        const newWrapped = new NamedNode(MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
    }
    /**
     * @returns a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */
    minPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let __EMPTY_NODE;
class KeyIndex extends Index {
    static get __EMPTY_NODE() {
        return __EMPTY_NODE;
    }
    static set __EMPTY_NODE(val) {
        __EMPTY_NODE = val;
    }
    compare(a, b) {
        return nameCompare(a.name, b.name);
    }
    isDefinedOn(node) {
        // We could probably return true here (since every node has a key), but it's never called
        // so just leaving unimplemented for now.
        throw assertionError('KeyIndex.isDefinedOn not expected to be called.');
    }
    indexedValueChanged(oldNode, newNode) {
        return false; // The key for a node never changes.
    }
    minPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    }
    maxPost() {
        // TODO: This should really be created once and cached in a static property, but
        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
        return new NamedNode(MAX_NAME, __EMPTY_NODE);
    }
    makePost(indexValue, name) {
        assert(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');
        // We just use empty node, but it'll never be compared, since our comparator only looks at name.
        return new NamedNode(indexValue, __EMPTY_NODE);
    }
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() {
        return '.key';
    }
}
const KEY_INDEX = new KeyIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An iterator over an LLRBNode.
 */
class SortedMapIterator {
    /**
     * @param node - Node to iterate.
     * @param isReverse_ - Whether or not to iterate in reverse
     */
    constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null) {
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        this.nodeStack_ = [];
        let cmp = 1;
        while (!node.isEmpty()) {
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse_) {
                cmp *= -1;
            }
            if (cmp < 0) {
                // This node is less than our start key. ignore it
                if (this.isReverse_) {
                    node = node.left;
                }
                else {
                    node = node.right;
                }
            }
            else if (cmp === 0) {
                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;
                this.nodeStack_.push(node);
                break;
            }
            else {
                // This node is greater than our start key, add it to the stack and move to the next one
                this.nodeStack_.push(node);
                if (this.isReverse_) {
                    node = node.right;
                }
                else {
                    node = node.left;
                }
            }
        }
    }
    getNext() {
        if (this.nodeStack_.length === 0) {
            return null;
        }
        let node = this.nodeStack_.pop();
        let result;
        if (this.resultGenerator_) {
            result = this.resultGenerator_(node.key, node.value);
        }
        else {
            result = { key: node.key, value: node.value };
        }
        if (this.isReverse_) {
            node = node.left;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.right;
            }
        }
        else {
            node = node.right;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.left;
            }
        }
        return result;
    }
    hasNext() {
        return this.nodeStack_.length > 0;
    }
    peek() {
        if (this.nodeStack_.length === 0) {
            return null;
        }
        const node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
            return this.resultGenerator_(node.key, node.value);
        }
        else {
            return { key: node.key, value: node.value };
        }
    }
}
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
class LLRBNode {
    /**
     * @param key - Key associated with this node.
     * @param value - Value associated with this node.
     * @param color - Whether this node is red.
     * @param left - Left child.
     * @param right - Right child.
     */
    constructor(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left =
            left != null ? left : SortedMap.EMPTY_NODE;
        this.right =
            right != null ? right : SortedMap.EMPTY_NODE;
    }
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param key - New key for the node, or null.
     * @param value - New value for the node, or null.
     * @param color - New color for the node, or null.
     * @param left - New left child for the node, or null.
     * @param right - New right child for the node, or null.
     * @returns The node copy.
     */
    copy(key, value, color, left, right) {
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    }
    /**
     * @returns The total number of nodes in the tree.
     */
    count() {
        return this.left.count() + 1 + this.right.count();
    }
    /**
     * @returns True if the tree is empty.
     */
    isEmpty() {
        return false;
    }
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action) {
        return (this.left.inorderTraversal(action) ||
            !!action(this.key, this.value) ||
            this.right.inorderTraversal(action));
    }
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    reverseTraversal(action) {
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
    }
    /**
     * @returns The minimum node in the tree.
     */
    min_() {
        if (this.left.isEmpty()) {
            return this;
        }
        else {
            return this.left.min_();
        }
    }
    /**
     * @returns The maximum key in the tree.
     */
    minKey() {
        return this.min_().key;
    }
    /**
     * @returns The maximum key in the tree.
     */
    maxKey() {
        if (this.right.isEmpty()) {
            return this.key;
        }
        else {
            return this.right.maxKey();
        }
    }
    /**
     * @param key - Key to insert.
     * @param value - Value to insert.
     * @param comparator - Comparator.
     * @returns New tree, with the key/value added.
     */
    insert(key, value, comparator) {
        let n = this;
        const cmp = comparator(key, n.key);
        if (cmp < 0) {
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        }
        else if (cmp === 0) {
            n = n.copy(null, value, null, null, null);
        }
        else {
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp_();
    }
    /**
     * @returns New tree, with the minimum key removed.
     */
    removeMin_() {
        if (this.left.isEmpty()) {
            return SortedMap.EMPTY_NODE;
        }
        let n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_()) {
            n = n.moveRedLeft_();
        }
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
    }
    /**
     * @param key - The key of the item to remove.
     * @param comparator - Comparator.
     * @returns New tree, with the specified item removed.
     */
    remove(key, comparator) {
        let n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) {
            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
                n = n.moveRedLeft_();
            }
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        }
        else {
            if (n.left.isRed_()) {
                n = n.rotateRight_();
            }
            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
                n = n.moveRedRight_();
            }
            if (comparator(key, n.key) === 0) {
                if (n.right.isEmpty()) {
                    return SortedMap.EMPTY_NODE;
                }
                else {
                    smallest = n.right.min_();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
                }
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp_();
    }
    /**
     * @returns Whether this is a RED node.
     */
    isRed_() {
        return this.color;
    }
    /**
     * @returns New tree after performing any needed rotations.
     */
    fixUp_() {
        let n = this;
        if (n.right.isRed_() && !n.left.isRed_()) {
            n = n.rotateLeft_();
        }
        if (n.left.isRed_() && n.left.left.isRed_()) {
            n = n.rotateRight_();
        }
        if (n.left.isRed_() && n.right.isRed_()) {
            n = n.colorFlip_();
        }
        return n;
    }
    /**
     * @returns New tree, after moveRedLeft.
     */
    moveRedLeft_() {
        let n = this.colorFlip_();
        if (n.right.left.isRed_()) {
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
        }
        return n;
    }
    /**
     * @returns New tree, after moveRedRight.
     */
    moveRedRight_() {
        let n = this.colorFlip_();
        if (n.left.left.isRed_()) {
            n = n.rotateRight_();
            n = n.colorFlip_();
        }
        return n;
    }
    /**
     * @returns New tree, after rotateLeft.
     */
    rotateLeft_() {
        const nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    }
    /**
     * @returns New tree, after rotateRight.
     */
    rotateRight_() {
        const nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    }
    /**
     * @returns Newt ree, after colorFlip.
     */
    colorFlip_() {
        const left = this.left.copy(null, null, !this.left.color, null, null);
        const right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    }
    /**
     * For testing.
     *
     * @returns True if all is well.
     */
    checkMaxDepth_() {
        const blackDepth = this.check_();
        return Math.pow(2.0, blackDepth) <= this.count() + 1;
    }
    check_() {
        if (this.isRed_() && this.left.isRed_()) {
            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');
        }
        if (this.right.isRed_()) {
            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');
        }
        const blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
            throw new Error('Black depths differ');
        }
        else {
            return blackDepth + (this.isRed_() ? 0 : 1);
        }
    }
}
LLRBNode.RED = true;
LLRBNode.BLACK = false;
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
class LLRBEmptyNode {
    /**
     * Returns a copy of the current node.
     *
     * @returns The node copy.
     */
    copy(key, value, color, left, right) {
        return this;
    }
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @param comparator - Comparator.
     * @returns New tree, with item added.
     */
    insert(key, value, comparator) {
        return new LLRBNode(key, value, null);
    }
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param key - The key to remove.
     * @param comparator - Comparator.
     * @returns New tree, with item removed.
     */
    remove(key, comparator) {
        return this;
    }
    /**
     * @returns The total number of nodes in the tree.
     */
    count() {
        return 0;
    }
    /**
     * @returns True if the tree is empty.
     */
    isEmpty() {
        return true;
    }
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    inorderTraversal(action) {
        return false;
    }
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param action - Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @returns True if traversal was aborted.
     */
    reverseTraversal(action) {
        return false;
    }
    minKey() {
        return null;
    }
    maxKey() {
        return null;
    }
    check_() {
        return 0;
    }
    /**
     * @returns Whether this node is red.
     */
    isRed_() {
        return false;
    }
}
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
class SortedMap {
    /**
     * @param comparator_ - Key comparator.
     * @param root_ - Optional root node for the map.
     */
    constructor(comparator_, root_ = SortedMap.EMPTY_NODE) {
        this.comparator_ = comparator_;
        this.root_ = root_;
    }
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param key - Key to be added.
     * @param value - Value to be added.
     * @returns New map, with item added.
     */
    insert(key, value) {
        return new SortedMap(this.comparator_, this.root_
            .insert(key, value, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    }
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param key - The key to remove.
     * @returns New map, with item removed.
     */
    remove(key) {
        return new SortedMap(this.comparator_, this.root_
            .remove(key, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    }
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param key - The key to look up.
     * @returns The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    get(key) {
        let cmp;
        let node = this.root_;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                return node.value;
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                node = node.right;
            }
        }
        return null;
    }
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param key - The key to find the predecessor of
     * @returns The predecessor key.
     */
    getPredecessorKey(key) {
        let cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                if (!node.left.isEmpty()) {
                    node = node.left;
                    while (!node.right.isEmpty()) {
                        node = node.right;
                    }
                    return node.key;
                }
                else if (rightParent) {
                    return rightParent.key;
                }
                else {
                    return null; // first item.
                }
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                rightParent = node;
                node = node.right;
            }
        }
        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');
    }
    /**
     * @returns True if the map is empty.
     */
    isEmpty() {
        return this.root_.isEmpty();
    }
    /**
     * @returns The total number of nodes in the map.
     */
    count() {
        return this.root_.count();
    }
    /**
     * @returns The minimum key in the map.
     */
    minKey() {
        return this.root_.minKey();
    }
    /**
     * @returns The maximum key in the map.
     */
    maxKey() {
        return this.root_.maxKey();
    }
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    inorderTraversal(action) {
        return this.root_.inorderTraversal(action);
    }
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param action - Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @returns True if the traversal was aborted.
     */
    reverseTraversal(action) {
        return this.root_.reverseTraversal(action);
    }
    /**
     * Returns an iterator over the SortedMap.
     * @returns The iterator.
     */
    getIterator(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    }
    getIteratorFrom(key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    }
    getReverseIteratorFrom(key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    }
    getReverseIterator(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    }
}
/**
 * Always use the same empty node, to reduce memory.
 */
SortedMap.EMPTY_NODE = new LLRBEmptyNode();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function NAME_ONLY_COMPARATOR(left, right) {
    return nameCompare(left.name, right.name);
}
function NAME_COMPARATOR(left, right) {
    return nameCompare(left, right);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let MAX_NODE$2;
function setMaxNode$1(val) {
    MAX_NODE$2 = val;
}
const priorityHashText = function (priority) {
    if (typeof priority === 'number') {
        return 'number:' + doubleToIEEE754String(priority);
    }
    else {
        return 'string:' + priority;
    }
};
/**
 * Validates that a priority snapshot Node is valid.
 */
const validatePriorityNode = function (priorityNode) {
    if (priorityNode.isLeafNode()) {
        const val = priorityNode.val();
        assert(typeof val === 'string' ||
            typeof val === 'number' ||
            (typeof val === 'object' && contains(val, '.sv')), 'Priority must be a string or number.');
    }
    else {
        assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), 'priority of unexpected type.');
    }
    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.
    assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let __childrenNodeConstructor;
/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */
class LeafNode {
    /**
     * @param value_ - The value to store in this leaf node. The object type is
     * possible in the event of a deferred value
     * @param priorityNode_ - The priority of this node.
     */
    constructor(value_, priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        assert(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        validatePriorityNode(this.priorityNode_);
    }
    static set __childrenNodeConstructor(val) {
        __childrenNodeConstructor = val;
    }
    static get __childrenNodeConstructor() {
        return __childrenNodeConstructor;
    }
    /** @inheritDoc */
    isLeafNode() {
        return true;
    }
    /** @inheritDoc */
    getPriority() {
        return this.priorityNode_;
    }
    /** @inheritDoc */
    updatePriority(newPriorityNode) {
        return new LeafNode(this.value_, newPriorityNode);
    }
    /** @inheritDoc */
    getImmediateChild(childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    }
    /** @inheritDoc */
    getChild(path) {
        if (pathIsEmpty(path)) {
            return this;
        }
        else if (pathGetFront(path) === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    }
    hasChild() {
        return false;
    }
    /** @inheritDoc */
    getPredecessorChildName(childName, childNode) {
        return null;
    }
    /** @inheritDoc */
    updateImmediateChild(childName, newChildNode) {
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else if (newChildNode.isEmpty() && childName !== '.priority') {
            return this;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        }
    }
    /** @inheritDoc */
    updateChild(path, newChildNode) {
        const front = pathGetFront(path);
        if (front === null) {
            return newChildNode;
        }
        else if (newChildNode.isEmpty() && front !== '.priority') {
            return this;
        }
        else {
            assert(front !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');
            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
        }
    }
    /** @inheritDoc */
    isEmpty() {
        return false;
    }
    /** @inheritDoc */
    numChildren() {
        return 0;
    }
    /** @inheritDoc */
    forEachChild(index, action) {
        return false;
    }
    val(exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty()) {
            return {
                '.value': this.getValue(),
                '.priority': this.getPriority().val()
            };
        }
        else {
            return this.getValue();
        }
    }
    /** @inheritDoc */
    hash() {
        if (this.lazyHash_ === null) {
            let toHash = '';
            if (!this.priorityNode_.isEmpty()) {
                toHash +=
                    'priority:' +
                        priorityHashText(this.priorityNode_.val()) +
                        ':';
            }
            const type = typeof this.value_;
            toHash += type + ':';
            if (type === 'number') {
                toHash += doubleToIEEE754String(this.value_);
            }
            else {
                toHash += this.value_;
            }
            this.lazyHash_ = sha1(toHash);
        }
        return this.lazyHash_;
    }
    /**
     * Returns the value of the leaf node.
     * @returns The value of the node.
     */
    getValue() {
        return this.value_;
    }
    compareTo(other) {
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
            return 1;
        }
        else if (other instanceof LeafNode.__childrenNodeConstructor) {
            return -1;
        }
        else {
            assert(other.isLeafNode(), 'Unknown node type');
            return this.compareToLeafNode_(other);
        }
    }
    /**
     * Comparison specifically for two leaf nodes
     */
    compareToLeafNode_(otherLeaf) {
        const otherLeafType = typeof otherLeaf.value_;
        const thisLeafType = typeof this.value_;
        const otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        const thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);
        assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);
        if (otherIndex === thisIndex) {
            // Same type, compare values
            if (thisLeafType === 'object') {
                // Deferred value nodes are all equal, but we should also never get to this point...
                return 0;
            }
            else {
                // Note that this works because true > false, all others are number or string comparisons
                if (this.value_ < otherLeaf.value_) {
                    return -1;
                }
                else if (this.value_ === otherLeaf.value_) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        }
        else {
            return thisIndex - otherIndex;
        }
    }
    withIndex() {
        return this;
    }
    isIndexed() {
        return true;
    }
    equals(other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            const otherLeaf = other;
            return (this.value_ === otherLeaf.value_ &&
                this.priorityNode_.equals(otherLeaf.priorityNode_));
        }
        else {
            return false;
        }
    }
}
/**
 * The sort order for comparing leaf nodes of different types. If two leaf nodes have
 * the same type, the comparison falls back to their value
 */
LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let nodeFromJSON$1;
let MAX_NODE$1;
function setNodeFromJSON(val) {
    nodeFromJSON$1 = val;
}
function setMaxNode(val) {
    MAX_NODE$1 = val;
}
class PriorityIndex extends Index {
    compare(a, b) {
        const aPriority = a.node.getPriority();
        const bPriority = b.node.getPriority();
        const indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    }
    isDefinedOn(node) {
        return !node.getPriority().isEmpty();
    }
    indexedValueChanged(oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
    }
    minPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    }
    maxPost() {
        return new NamedNode(MAX_NAME, new LeafNode('[PRIORITY-POST]', MAX_NODE$1));
    }
    makePost(indexValue, name) {
        const priorityNode = nodeFromJSON$1(indexValue);
        return new NamedNode(name, new LeafNode('[PRIORITY-POST]', priorityNode));
    }
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() {
        return '.priority';
    }
}
const PRIORITY_INDEX = new PriorityIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LOG_2 = Math.log(2);
class Base12Num {
    constructor(length) {
        const logBase2 = (num) => 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        parseInt((Math.log(num) / LOG_2), 10);
        const bitMask = (bits) => parseInt(Array(bits + 1).join('1'), 2);
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        const mask = bitMask(this.count);
        this.bits_ = (length + 1) & mask;
    }
    nextBitIsOne() {
        //noinspection JSBitwiseOperatorUsage
        const result = !(this.bits_ & (0x1 << this.current_));
        this.current_--;
        return result;
    }
}
/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @param childList - Unsorted list of children
 * @param cmp - The comparison method to be used
 * @param keyFn - An optional function to extract K from a node wrapper, if K's
 * type is not NamedNode
 * @param mapSortFn - An optional override for comparator used by the generated sorted map
 */
const buildChildSet = function (childList, cmp, keyFn, mapSortFn) {
    childList.sort(cmp);
    const buildBalancedTree = function (low, high) {
        const length = high - low;
        let namedNode;
        let key;
        if (length === 0) {
            return null;
        }
        else if (length === 1) {
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const middle = parseInt((length / 2), 10) + low;
            const left = buildBalancedTree(low, middle);
            const right = buildBalancedTree(middle + 1, high);
            namedNode = childList[middle];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
        }
    };
    const buildFrom12Array = function (base12) {
        let node = null;
        let root = null;
        let index = childList.length;
        const buildPennant = function (chunkSize, color) {
            const low = index - chunkSize;
            const high = index;
            index -= chunkSize;
            const childTree = buildBalancedTree(low + 1, high);
            const namedNode = childList[low];
            const key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
        };
        const attachPennant = function (pennant) {
            if (node) {
                node.left = pennant;
                node = pennant;
            }
            else {
                root = pennant;
                node = pennant;
            }
        };
        for (let i = 0; i < base12.count; ++i) {
            const isOne = base12.nextBitIsOne();
            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))
            const chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) {
                buildPennant(chunkSize, LLRBNode.BLACK);
            }
            else {
                // current == 2
                buildPennant(chunkSize, LLRBNode.BLACK);
                buildPennant(chunkSize, LLRBNode.RED);
            }
        }
        return root;
    };
    const base12 = new Base12Num(childList.length);
    const root = buildFrom12Array(base12);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new SortedMap(mapSortFn || cmp, root);
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let _defaultIndexMap;
const fallbackObject = {};
class IndexMap {
    constructor(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
    }
    /**
     * The default IndexMap for nodes without a priority
     */
    static get Default() {
        assert(fallbackObject && PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');
        _defaultIndexMap =
            _defaultIndexMap ||
                new IndexMap({ '.priority': fallbackObject }, { '.priority': PRIORITY_INDEX });
        return _defaultIndexMap;
    }
    get(indexKey) {
        const sortedMap = safeGet(this.indexes_, indexKey);
        if (!sortedMap) {
            throw new Error('No index defined for ' + indexKey);
        }
        if (sortedMap instanceof SortedMap) {
            return sortedMap;
        }
        else {
            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
            // regular child map
            return null;
        }
    }
    hasIndex(indexDefinition) {
        return contains(this.indexSet_, indexDefinition.toString());
    }
    addIndex(indexDefinition, existingChildren) {
        assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        const childList = [];
        let sawIndexedValue = false;
        const iter = existingChildren.getIterator(NamedNode.Wrap);
        let next = iter.getNext();
        while (next) {
            sawIndexedValue =
                sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
        }
        let newIndex;
        if (sawIndexedValue) {
            newIndex = buildChildSet(childList, indexDefinition.getCompare());
        }
        else {
            newIndex = fallbackObject;
        }
        const indexName = indexDefinition.toString();
        const newIndexSet = Object.assign({}, this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        const newIndexes = Object.assign({}, this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
    }
    /**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     */
    addToIndexes(namedNode, existingChildren) {
        const newIndexes = map(this.indexes_, (indexedChildren, indexName) => {
            const index = safeGet(this.indexSet_, indexName);
            assert(index, 'Missing index implementation for ' + indexName);
            if (indexedChildren === fallbackObject) {
                // Check to see if we need to index everything
                if (index.isDefinedOn(namedNode.node)) {
                    // We need to build this index
                    const childList = [];
                    const iter = existingChildren.getIterator(NamedNode.Wrap);
                    let next = iter.getNext();
                    while (next) {
                        if (next.name !== namedNode.name) {
                            childList.push(next);
                        }
                        next = iter.getNext();
                    }
                    childList.push(namedNode);
                    return buildChildSet(childList, index.getCompare());
                }
                else {
                    // No change, this remains a fallback
                    return fallbackObject;
                }
            }
            else {
                const existingSnap = existingChildren.get(namedNode.name);
                let newChildren = indexedChildren;
                if (existingSnap) {
                    newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
                }
                return newChildren.insert(namedNode, namedNode.node);
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    }
    /**
     * Create a new IndexMap instance with the given value removed
     */
    removeFromIndexes(namedNode, existingChildren) {
        const newIndexes = map(this.indexes_, (indexedChildren) => {
            if (indexedChildren === fallbackObject) {
                // This is the fallback. Just return it, nothing to do in this case
                return indexedChildren;
            }
            else {
                const existingSnap = existingChildren.get(namedNode.name);
                if (existingSnap) {
                    return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
                }
                else {
                    // No record of this child
                    return indexedChildren;
                }
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// TODO: For memory savings, don't store priorityNode_ if it's empty.
let EMPTY_NODE;
/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 */
class ChildrenNode {
    /**
     * @param children_ - List of children of this node..
     * @param priorityNode_ - The priority of this node (as a snapshot node).
     */
    constructor(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        /**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */
        if (this.priorityNode_) {
            validatePriorityNode(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
            assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');
        }
    }
    static get EMPTY_NODE() {
        return (EMPTY_NODE ||
            (EMPTY_NODE = new ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default)));
    }
    /** @inheritDoc */
    isLeafNode() {
        return false;
    }
    /** @inheritDoc */
    getPriority() {
        return this.priorityNode_ || EMPTY_NODE;
    }
    /** @inheritDoc */
    updatePriority(newPriorityNode) {
        if (this.children_.isEmpty()) {
            // Don't allow priorities on empty nodes
            return this;
        }
        else {
            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        }
    }
    /** @inheritDoc */
    getImmediateChild(childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.getPriority();
        }
        else {
            const child = this.children_.get(childName);
            return child === null ? EMPTY_NODE : child;
        }
    }
    /** @inheritDoc */
    getChild(path) {
        const front = pathGetFront(path);
        if (front === null) {
            return this;
        }
        return this.getImmediateChild(front).getChild(pathPopFront(path));
    }
    /** @inheritDoc */
    hasChild(childName) {
        return this.children_.get(childName) !== null;
    }
    /** @inheritDoc */
    updateImmediateChild(childName, newChildNode) {
        assert(newChildNode, 'We should always be passing snapshot nodes');
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else {
            const namedNode = new NamedNode(childName, newChildNode);
            let newChildren, newIndexMap;
            if (newChildNode.isEmpty()) {
                newChildren = this.children_.remove(childName);
                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
            }
            else {
                newChildren = this.children_.insert(childName, newChildNode);
                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
            }
            const newPriority = newChildren.isEmpty()
                ? EMPTY_NODE
                : this.priorityNode_;
            return new ChildrenNode(newChildren, newPriority, newIndexMap);
        }
    }
    /** @inheritDoc */
    updateChild(path, newChildNode) {
        const front = pathGetFront(path);
        if (front === null) {
            return newChildNode;
        }
        else {
            assert(pathGetFront(path) !== '.priority' || pathGetLength(path) === 1, '.priority must be the last token in a path');
            const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
            return this.updateImmediateChild(front, newImmediateChild);
        }
    }
    /** @inheritDoc */
    isEmpty() {
        return this.children_.isEmpty();
    }
    /** @inheritDoc */
    numChildren() {
        return this.children_.count();
    }
    /** @inheritDoc */
    val(exportFormat) {
        if (this.isEmpty()) {
            return null;
        }
        const obj = {};
        let numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PRIORITY_INDEX, (key, childNode) => {
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {
                maxKey = Math.max(maxKey, Number(key));
            }
            else {
                allIntegerKeys = false;
            }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
            // convert to array.
            const array = [];
            // eslint-disable-next-line guard-for-in
            for (const key in obj) {
                array[key] = obj[key];
            }
            return array;
        }
        else {
            if (exportFormat && !this.getPriority().isEmpty()) {
                obj['.priority'] = this.getPriority().val();
            }
            return obj;
        }
    }
    /** @inheritDoc */
    hash() {
        if (this.lazyHash_ === null) {
            let toHash = '';
            if (!this.getPriority().isEmpty()) {
                toHash +=
                    'priority:' +
                        priorityHashText(this.getPriority().val()) +
                        ':';
            }
            this.forEachChild(PRIORITY_INDEX, (key, childNode) => {
                const childHash = childNode.hash();
                if (childHash !== '') {
                    toHash += ':' + key + ':' + childHash;
                }
            });
            this.lazyHash_ = toHash === '' ? '' : sha1(toHash);
        }
        return this.lazyHash_;
    }
    /** @inheritDoc */
    getPredecessorChildName(childName, childNode, index) {
        const idx = this.resolveIndex_(index);
        if (idx) {
            const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));
            return predecessor ? predecessor.name : null;
        }
        else {
            return this.children_.getPredecessorKey(childName);
        }
    }
    getFirstChildName(indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            const minKey = idx.minKey();
            return minKey && minKey.name;
        }
        else {
            return this.children_.minKey();
        }
    }
    getFirstChild(indexDefinition) {
        const minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
            return new NamedNode(minKey, this.children_.get(minKey));
        }
        else {
            return null;
        }
    }
    /**
     * Given an index, return the key name of the largest value we have, according to that index
     */
    getLastChildName(indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            const maxKey = idx.maxKey();
            return maxKey && maxKey.name;
        }
        else {
            return this.children_.maxKey();
        }
    }
    getLastChild(indexDefinition) {
        const maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
            return new NamedNode(maxKey, this.children_.get(maxKey));
        }
        else {
            return null;
        }
    }
    forEachChild(index, action) {
        const idx = this.resolveIndex_(index);
        if (idx) {
            return idx.inorderTraversal(wrappedNode => {
                return action(wrappedNode.name, wrappedNode.node);
            });
        }
        else {
            return this.children_.inorderTraversal(action);
        }
    }
    getIterator(indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    }
    getIteratorFrom(startPost, indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getIteratorFrom(startPost, key => key);
        }
        else {
            const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
            let next = iterator.peek();
            while (next != null && indexDefinition.compare(next, startPost) < 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    }
    getReverseIterator(indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    }
    getReverseIteratorFrom(endPost, indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getReverseIteratorFrom(endPost, key => {
                return key;
            });
        }
        else {
            const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
            let next = iterator.peek();
            while (next != null && indexDefinition.compare(next, endPost) > 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    }
    compareTo(other) {
        if (this.isEmpty()) {
            if (other.isEmpty()) {
                return 0;
            }
            else {
                return -1;
            }
        }
        else if (other.isLeafNode() || other.isEmpty()) {
            return 1;
        }
        else if (other === MAX_NODE) {
            return -1;
        }
        else {
            // Must be another node with children.
            return 0;
        }
    }
    withIndex(indexDefinition) {
        if (indexDefinition === KEY_INDEX ||
            this.indexMap_.hasIndex(indexDefinition)) {
            return this;
        }
        else {
            const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        }
    }
    isIndexed(index) {
        return index === KEY_INDEX || this.indexMap_.hasIndex(index);
    }
    equals(other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            return false;
        }
        else {
            const otherChildrenNode = other;
            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
                return false;
            }
            else if (this.children_.count() === otherChildrenNode.children_.count()) {
                const thisIter = this.getIterator(PRIORITY_INDEX);
                const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
                let thisCurrent = thisIter.getNext();
                let otherCurrent = otherIter.getNext();
                while (thisCurrent && otherCurrent) {
                    if (thisCurrent.name !== otherCurrent.name ||
                        !thisCurrent.node.equals(otherCurrent.node)) {
                        return false;
                    }
                    thisCurrent = thisIter.getNext();
                    otherCurrent = otherIter.getNext();
                }
                return thisCurrent === null && otherCurrent === null;
            }
            else {
                return false;
            }
        }
    }
    /**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     */
    resolveIndex_(indexDefinition) {
        if (indexDefinition === KEY_INDEX) {
            return null;
        }
        else {
            return this.indexMap_.get(indexDefinition.toString());
        }
    }
}
ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
class MaxNode extends ChildrenNode {
    constructor() {
        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);
    }
    compareTo(other) {
        if (other === this) {
            return 0;
        }
        else {
            return 1;
        }
    }
    equals(other) {
        // Not that we every compare it, but MAX_NODE is only ever equal to itself
        return other === this;
    }
    getPriority() {
        return this;
    }
    getImmediateChild(childName) {
        return ChildrenNode.EMPTY_NODE;
    }
    isEmpty() {
        return false;
    }
}
/**
 * Marker that will sort higher than any other snapshot.
 */
const MAX_NODE = new MaxNode();
Object.defineProperties(NamedNode, {
    MIN: {
        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
    },
    MAX: {
        value: new NamedNode(MAX_NAME, MAX_NODE)
    }
});
/**
 * Reference Extensions
 */
KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode.__childrenNodeConstructor = ChildrenNode;
setMaxNode$1(MAX_NODE);
setMaxNode(MAX_NODE);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const USE_HINZE = true;
/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param json - JSON to create a node for.
 * @param priority - Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 */
function nodeFromJSON(json, priority = null) {
    if (json === null) {
        return ChildrenNode.EMPTY_NODE;
    }
    if (typeof json === 'object' && '.priority' in json) {
        priority = json['.priority'];
    }
    assert(priority === null ||
        typeof priority === 'string' ||
        typeof priority === 'number' ||
        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);
    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {
        json = json['.value'];
    }
    // Valid leaf nodes include non-objects or server-value wrapper objects
    if (typeof json !== 'object' || '.sv' in json) {
        const jsonLeaf = json;
        return new LeafNode(jsonLeaf, nodeFromJSON(priority));
    }
    if (!(json instanceof Array) && USE_HINZE) {
        const children = [];
        let childrenHavePriority = false;
        const hinzeJsonObj = json;
        each(hinzeJsonObj, (key, child) => {
            if (key.substring(0, 1) !== '.') {
                // Ignore metadata nodes
                const childNode = nodeFromJSON(child);
                if (!childNode.isEmpty()) {
                    childrenHavePriority =
                        childrenHavePriority || !childNode.getPriority().isEmpty();
                    children.push(new NamedNode(key, childNode));
                }
            }
        });
        if (children.length === 0) {
            return ChildrenNode.EMPTY_NODE;
        }
        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, namedNode => namedNode.name, NAME_COMPARATOR);
        if (childrenHavePriority) {
            const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());
            return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ '.priority': sortedChildSet }, { '.priority': PRIORITY_INDEX }));
        }
        else {
            return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);
        }
    }
    else {
        let node = ChildrenNode.EMPTY_NODE;
        each(json, (key, childData) => {
            if (contains(json, key)) {
                if (key.substring(0, 1) !== '.') {
                    // ignore metadata nodes.
                    const childNode = nodeFromJSON(childData);
                    if (childNode.isLeafNode() || !childNode.isEmpty()) {
                        node = node.updateImmediateChild(key, childNode);
                    }
                }
            }
        });
        return node.updatePriority(nodeFromJSON(priority));
    }
}
setNodeFromJSON(nodeFromJSON);

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PathIndex extends Index {
    constructor(indexPath_) {
        super();
        this.indexPath_ = indexPath_;
        assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== '.priority', "Can't create PathIndex with empty path or .priority key");
    }
    extractChild(snap) {
        return snap.getChild(this.indexPath_);
    }
    isDefinedOn(node) {
        return !node.getChild(this.indexPath_).isEmpty();
    }
    compare(a, b) {
        const aChild = this.extractChild(a.node);
        const bChild = this.extractChild(b.node);
        const indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    }
    makePost(indexValue, name) {
        const valueNode = nodeFromJSON(indexValue);
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new NamedNode(name, node);
    }
    maxPost() {
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
        return new NamedNode(MAX_NAME, node);
    }
    toString() {
        return pathSlice(this.indexPath_, 0).join('/');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValueIndex extends Index {
    compare(a, b) {
        const indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) {
            return nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    }
    isDefinedOn(node) {
        return true;
    }
    indexedValueChanged(oldNode, newNode) {
        return !oldNode.equals(newNode);
    }
    minPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MIN;
    }
    maxPost() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return NamedNode.MAX;
    }
    makePost(indexValue, name) {
        const valueNode = nodeFromJSON(indexValue);
        return new NamedNode(name, valueNode);
    }
    /**
     * @returns String representation for inclusion in a query spec
     */
    toString() {
        return '.value';
    }
}
const VALUE_INDEX = new ValueIndex();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function changeValue(snapshotNode) {
    return { type: "value" /* ChangeType.VALUE */, snapshotNode };
}
function changeChildAdded(childName, snapshotNode) {
    return { type: "child_added" /* ChangeType.CHILD_ADDED */, snapshotNode, childName };
}
function changeChildRemoved(childName, snapshotNode) {
    return { type: "child_removed" /* ChangeType.CHILD_REMOVED */, snapshotNode, childName };
}
function changeChildChanged(childName, snapshotNode, oldSnap) {
    return {
        type: "child_changed" /* ChangeType.CHILD_CHANGED */,
        snapshotNode,
        childName,
        oldSnap
    };
}
function changeChildMoved(childName, snapshotNode) {
    return { type: "child_moved" /* ChangeType.CHILD_MOVED */, snapshotNode, childName };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 */
class IndexedFilter {
    constructor(index_) {
        this.index_ = index_;
    }
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');
        const oldChild = snap.getImmediateChild(key);
        // Check if anything actually changed.
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.
            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need
            // to avoid treating these cases as "nothing changed."
            if (oldChild.isEmpty() === newChild.isEmpty()) {
                // Nothing changed.
                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
                return snap;
            }
        }
        if (optChangeAccumulator != null) {
            if (newChild.isEmpty()) {
                if (snap.hasChild(key)) {
                    optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));
                }
                else {
                    assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');
                }
            }
            else if (oldChild.isEmpty()) {
                optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));
            }
            else {
                optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));
            }
        }
        if (snap.isLeafNode() && newChild.isEmpty()) {
            return snap;
        }
        else {
            // Make sure the node is indexed
            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        }
    }
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        if (optChangeAccumulator != null) {
            if (!oldSnap.isLeafNode()) {
                oldSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
                    if (!newSnap.hasChild(key)) {
                        optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));
                    }
                });
            }
            if (!newSnap.isLeafNode()) {
                newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
                    if (oldSnap.hasChild(key)) {
                        const oldChild = oldSnap.getImmediateChild(key);
                        if (!oldChild.equals(childNode)) {
                            optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));
                        }
                    }
                    else {
                        optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));
                    }
                });
            }
        }
        return newSnap.withIndex(this.index_);
    }
    updatePriority(oldSnap, newPriority) {
        if (oldSnap.isEmpty()) {
            return ChildrenNode.EMPTY_NODE;
        }
        else {
            return oldSnap.updatePriority(newPriority);
        }
    }
    filtersNodes() {
        return false;
    }
    getIndexedFilter() {
        return this;
    }
    getIndex() {
        return this.index_;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 */
class RangedFilter {
    constructor(params) {
        this.indexedFilter_ = new IndexedFilter(params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = RangedFilter.getStartPost_(params);
        this.endPost_ = RangedFilter.getEndPost_(params);
        this.startIsInclusive_ = !params.startAfterSet_;
        this.endIsInclusive_ = !params.endBeforeSet_;
    }
    getStartPost() {
        return this.startPost_;
    }
    getEndPost() {
        return this.endPost_;
    }
    matches(node) {
        const isWithinStart = this.startIsInclusive_
            ? this.index_.compare(this.getStartPost(), node) <= 0
            : this.index_.compare(this.getStartPost(), node) < 0;
        const isWithinEnd = this.endIsInclusive_
            ? this.index_.compare(node, this.getEndPost()) <= 0
            : this.index_.compare(node, this.getEndPost()) < 0;
        return isWithinStart && isWithinEnd;
    }
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.matches(new NamedNode(key, newChild))) {
            newChild = ChildrenNode.EMPTY_NODE;
        }
        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
    }
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        if (newSnap.isLeafNode()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            newSnap = ChildrenNode.EMPTY_NODE;
        }
        let filtered = newSnap.withIndex(this.index_);
        // Don't support priorities on queries
        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
        const self = this;
        newSnap.forEachChild(PRIORITY_INDEX, (key, childNode) => {
            if (!self.matches(new NamedNode(key, childNode))) {
                filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);
            }
        });
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
    }
    updatePriority(oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    }
    filtersNodes() {
        return true;
    }
    getIndexedFilter() {
        return this.indexedFilter_;
    }
    getIndex() {
        return this.index_;
    }
    static getStartPost_(params) {
        if (params.hasStart()) {
            const startName = params.getIndexStartName();
            return params.getIndex().makePost(params.getIndexStartValue(), startName);
        }
        else {
            return params.getIndex().minPost();
        }
    }
    static getEndPost_(params) {
        if (params.hasEnd()) {
            const endName = params.getIndexEndName();
            return params.getIndex().makePost(params.getIndexEndValue(), endName);
        }
        else {
            return params.getIndex().maxPost();
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 */
class LimitedFilter {
    constructor(params) {
        this.withinDirectionalStart = (node) => this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);
        this.withinDirectionalEnd = (node) => this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);
        this.withinStartPost = (node) => {
            const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);
            return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;
        };
        this.withinEndPost = (node) => {
            const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());
            return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;
        };
        this.rangedFilter_ = new RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
        this.startIsInclusive_ = !params.startAfterSet_;
        this.endIsInclusive_ = !params.endBeforeSet_;
    }
    updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {
            newChild = ChildrenNode.EMPTY_NODE;
        }
        if (snap.getImmediateChild(key).equals(newChild)) {
            // No change
            return snap;
        }
        else if (snap.numChildren() < this.limit_) {
            return this.rangedFilter_
                .getIndexedFilter()
                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        }
        else {
            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        }
    }
    updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        let filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        }
        else {
            if (this.limit_ * 2 < newSnap.numChildren() &&
                newSnap.isIndexed(this.index_)) {
                // Easier to build up a snapshot, since what we're given has more than twice the elements we want
                filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
                // anchor to the startPost, endPost, or last element as appropriate
                let iterator;
                if (this.reverse_) {
                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
                }
                else {
                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
                }
                let count = 0;
                while (iterator.hasNext() && count < this.limit_) {
                    const next = iterator.getNext();
                    if (!this.withinDirectionalStart(next)) {
                        // if we have not reached the start, skip to the next element
                        continue;
                    }
                    else if (!this.withinDirectionalEnd(next)) {
                        // if we have reached the end, stop adding elements
                        break;
                    }
                    else {
                        filtered = filtered.updateImmediateChild(next.name, next.node);
                        count++;
                    }
                }
            }
            else {
                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
                filtered = newSnap.withIndex(this.index_);
                // Don't support priorities on queries
                filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
                let iterator;
                if (this.reverse_) {
                    iterator = filtered.getReverseIterator(this.index_);
                }
                else {
                    iterator = filtered.getIterator(this.index_);
                }
                let count = 0;
                while (iterator.hasNext()) {
                    const next = iterator.getNext();
                    const inRange = count < this.limit_ &&
                        this.withinDirectionalStart(next) &&
                        this.withinDirectionalEnd(next);
                    if (inRange) {
                        count++;
                    }
                    else {
                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
                    }
                }
            }
        }
        return this.rangedFilter_
            .getIndexedFilter()
            .updateFullNode(oldSnap, filtered, optChangeAccumulator);
    }
    updatePriority(oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    }
    filtersNodes() {
        return true;
    }
    getIndexedFilter() {
        return this.rangedFilter_.getIndexedFilter();
    }
    getIndex() {
        return this.index_;
    }
    fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) {
        // TODO: rename all cache stuff etc to general snap terminology
        let cmp;
        if (this.reverse_) {
            const indexCmp = this.index_.getCompare();
            cmp = (a, b) => indexCmp(b, a);
        }
        else {
            cmp = this.index_.getCompare();
        }
        const oldEventCache = snap;
        assert(oldEventCache.numChildren() === this.limit_, '');
        const newChildNamedNode = new NamedNode(childKey, childSnap);
        const windowBoundary = this.reverse_
            ? oldEventCache.getFirstChild(this.index_)
            : oldEventCache.getLastChild(this.index_);
        const inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) {
            const oldChildSnap = oldEventCache.getImmediateChild(childKey);
            let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (nextChild != null &&
                (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {
                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
                // been applied to the limited filter yet. Ignore this next child which will be updated later in
                // the limited filter...
                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
            }
            const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
            const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
                }
                return oldEventCache.updateImmediateChild(childKey, childSnap);
            }
            else {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
                }
                const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
                const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
                if (nextChildInRange) {
                    if (changeAccumulator != null) {
                        changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
                    }
                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
                }
                else {
                    return newEventCache;
                }
            }
        }
        else if (childSnap.isEmpty()) {
            // we're deleting a node, but it was not in the window, so ignore it
            return snap;
        }
        else if (inRange) {
            if (cmp(windowBoundary, newChildNamedNode) >= 0) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
                    changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
                }
                return oldEventCache
                    .updateImmediateChild(childKey, childSnap)
                    .updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
            }
            else {
                return snap;
            }
        }
        else {
            return snap;
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 *
 * @internal
 */
class QueryParams {
    constructor() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.startAfterSet_ = false; // can only be true if startSet_ is true
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.endBeforeSet_ = false; // can only be true if endSet_ is true
        this.limit_ = 0;
        this.viewFrom_ = '';
        this.indexStartValue_ = null;
        this.indexStartName_ = '';
        this.indexEndValue_ = null;
        this.indexEndName_ = '';
        this.index_ = PRIORITY_INDEX;
    }
    hasStart() {
        return this.startSet_;
    }
    /**
     * @returns True if it would return from left.
     */
    isViewFromLeft() {
        if (this.viewFrom_ === '') {
            // limit(), rather than limitToFirst or limitToLast was called.
            // This means that only one of startSet_ and endSet_ is true. Use them
            // to calculate which side of the view to anchor to. If neither is set,
            // anchor to the end.
            return this.startSet_;
        }
        else {
            return this.viewFrom_ === "l" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;
        }
    }
    /**
     * Only valid to call if hasStart() returns true
     */
    getIndexStartValue() {
        assert(this.startSet_, 'Only valid if start has been set');
        return this.indexStartValue_;
    }
    /**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     */
    getIndexStartName() {
        assert(this.startSet_, 'Only valid if start has been set');
        if (this.startNameSet_) {
            return this.indexStartName_;
        }
        else {
            return MIN_NAME;
        }
    }
    hasEnd() {
        return this.endSet_;
    }
    /**
     * Only valid to call if hasEnd() returns true.
     */
    getIndexEndValue() {
        assert(this.endSet_, 'Only valid if end has been set');
        return this.indexEndValue_;
    }
    /**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     */
    getIndexEndName() {
        assert(this.endSet_, 'Only valid if end has been set');
        if (this.endNameSet_) {
            return this.indexEndName_;
        }
        else {
            return MAX_NAME;
        }
    }
    hasLimit() {
        return this.limitSet_;
    }
    /**
     * @returns True if a limit has been set and it has been explicitly anchored
     */
    hasAnchoredLimit() {
        return this.limitSet_ && this.viewFrom_ !== '';
    }
    /**
     * Only valid to call if hasLimit() returns true
     */
    getLimit() {
        assert(this.limitSet_, 'Only valid if limit has been set');
        return this.limit_;
    }
    getIndex() {
        return this.index_;
    }
    loadsAllData() {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
    }
    isDefault() {
        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
    }
    copy() {
        const copy = new QueryParams();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.startAfterSet_ = this.startAfterSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.endBeforeSet_ = this.endBeforeSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
    }
}
function queryParamsGetNodeFilter(queryParams) {
    if (queryParams.loadsAllData()) {
        return new IndexedFilter(queryParams.getIndex());
    }
    else if (queryParams.hasLimit()) {
        return new LimitedFilter(queryParams);
    }
    else {
        return new RangedFilter(queryParams);
    }
}
function queryParamsOrderBy(queryParams, index) {
    const newParams = queryParams.copy();
    newParams.index_ = index;
    return newParams;
}
/**
 * Returns a set of REST query string parameters representing this query.
 *
 * @returns query string parameters
 */
function queryParamsToRestQueryStringParameters(queryParams) {
    const qs = {};
    if (queryParams.isDefault()) {
        return qs;
    }
    let orderBy;
    if (queryParams.index_ === PRIORITY_INDEX) {
        orderBy = "$priority" /* REST_QUERY_CONSTANTS.PRIORITY_INDEX */;
    }
    else if (queryParams.index_ === VALUE_INDEX) {
        orderBy = "$value" /* REST_QUERY_CONSTANTS.VALUE_INDEX */;
    }
    else if (queryParams.index_ === KEY_INDEX) {
        orderBy = "$key" /* REST_QUERY_CONSTANTS.KEY_INDEX */;
    }
    else {
        assert(queryParams.index_ instanceof PathIndex, 'Unrecognized index type!');
        orderBy = queryParams.index_.toString();
    }
    qs["orderBy" /* REST_QUERY_CONSTANTS.ORDER_BY */] = stringify(orderBy);
    if (queryParams.startSet_) {
        const startParam = queryParams.startAfterSet_
            ? "startAfter" /* REST_QUERY_CONSTANTS.START_AFTER */
            : "startAt" /* REST_QUERY_CONSTANTS.START_AT */;
        qs[startParam] = stringify(queryParams.indexStartValue_);
        if (queryParams.startNameSet_) {
            qs[startParam] += ',' + stringify(queryParams.indexStartName_);
        }
    }
    if (queryParams.endSet_) {
        const endParam = queryParams.endBeforeSet_
            ? "endBefore" /* REST_QUERY_CONSTANTS.END_BEFORE */
            : "endAt" /* REST_QUERY_CONSTANTS.END_AT */;
        qs[endParam] = stringify(queryParams.indexEndValue_);
        if (queryParams.endNameSet_) {
            qs[endParam] += ',' + stringify(queryParams.indexEndName_);
        }
    }
    if (queryParams.limitSet_) {
        if (queryParams.isViewFromLeft()) {
            qs["limitToFirst" /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */] = queryParams.limit_;
        }
        else {
            qs["limitToLast" /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */] = queryParams.limit_;
        }
    }
    return qs;
}
function queryParamsGetQueryObject(queryParams) {
    const obj = {};
    if (queryParams.startSet_) {
        obj["sp" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */] =
            queryParams.indexStartValue_;
        if (queryParams.startNameSet_) {
            obj["sn" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */] =
                queryParams.indexStartName_;
        }
        obj["sin" /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */] =
            !queryParams.startAfterSet_;
    }
    if (queryParams.endSet_) {
        obj["ep" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */] = queryParams.indexEndValue_;
        if (queryParams.endNameSet_) {
            obj["en" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */] = queryParams.indexEndName_;
        }
        obj["ein" /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */] =
            !queryParams.endBeforeSet_;
    }
    if (queryParams.limitSet_) {
        obj["l" /* WIRE_PROTOCOL_CONSTANTS.LIMIT */] = queryParams.limit_;
        let viewFrom = queryParams.viewFrom_;
        if (viewFrom === '') {
            if (queryParams.isViewFromLeft()) {
                viewFrom = "l" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT */;
            }
            else {
                viewFrom = "r" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT */;
            }
        }
        obj["vf" /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */] = viewFrom;
    }
    // For now, priority index is the default, so we only specify if it's some other index
    if (queryParams.index_ !== PRIORITY_INDEX) {
        obj["i" /* WIRE_PROTOCOL_CONSTANTS.INDEX */] = queryParams.index_.toString();
    }
    return obj;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */
class ReadonlyRestClient extends ServerActions {
    /**
     * @param repoInfo_ - Data about the namespace we are connecting to
     * @param onDataUpdate_ - A callback for new data from the server
     */
    constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {
        super();
        this.repoInfo_ = repoInfo_;
        this.onDataUpdate_ = onDataUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        /** @private {function(...[*])} */
        this.log_ = logWrapper('p:rest:');
        /**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         */
        this.listens_ = {};
    }
    reportStats(stats) {
        throw new Error('Method not implemented.');
    }
    static getListenId_(query, tag) {
        if (tag !== undefined) {
            return 'tag$' + tag;
        }
        else {
            assert(query._queryParams.isDefault(), "should have a tag if it's not a default query.");
            return query._path.toString();
        }
    }
    /** @inheritDoc */
    listen(query, currentHashFn, tag, onComplete) {
        const pathString = query._path.toString();
        this.log_('Listen called for ' + pathString + ' ' + query._queryIdentifier);
        // Mark this listener so we can tell if it's removed.
        const listenId = ReadonlyRestClient.getListenId_(query, tag);
        const thisListen = {};
        this.listens_[listenId] = thisListen;
        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => {
            let data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);
            }
            if (safeGet(this.listens_, listenId) === thisListen) {
                let status;
                if (!error) {
                    status = 'ok';
                }
                else if (error === 401) {
                    status = 'permission_denied';
                }
                else {
                    status = 'rest_error:' + error;
                }
                onComplete(status, null);
            }
        });
    }
    /** @inheritDoc */
    unlisten(query, tag) {
        const listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
    }
    get(query) {
        const queryStringParameters = queryParamsToRestQueryStringParameters(query._queryParams);
        const pathString = query._path.toString();
        const deferred = new Deferred();
        this.restRequest_(pathString + '.json', queryStringParameters, (error, result) => {
            let data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                this.onDataUpdate_(pathString, data, 
                /*isMerge=*/ false, 
                /*tag=*/ null);
                deferred.resolve(data);
            }
            else {
                deferred.reject(new Error(data));
            }
        });
        return deferred.promise;
    }
    /** @inheritDoc */
    refreshAuthToken(token) {
        // no-op since we just always call getToken.
    }
    /**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     */
    restRequest_(pathString, queryStringParameters = {}, callback) {
        queryStringParameters['format'] = 'export';
        return Promise.all([
            this.authTokenProvider_.getToken(/*forceRefresh=*/ false),
            this.appCheckTokenProvider_.getToken(/*forceRefresh=*/ false)
        ]).then(([authToken, appCheckToken]) => {
            if (authToken && authToken.accessToken) {
                queryStringParameters['auth'] = authToken.accessToken;
            }
            if (appCheckToken && appCheckToken.token) {
                queryStringParameters['ac'] = appCheckToken.token;
            }
            const url = (this.repoInfo_.secure ? 'https://' : 'http://') +
                this.repoInfo_.host +
                pathString +
                '?' +
                'ns=' +
                this.repoInfo_.namespace +
                querystring(queryStringParameters);
            this.log_('Sending REST request for ' + url);
            const xhr = new XMLHttpRequest();
            xhr.onreadystatechange = () => {
                if (callback && xhr.readyState === 4) {
                    this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);
                    let res = null;
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            res = jsonEval(xhr.responseText);
                        }
                        catch (e) {
                            warn('Failed to parse JSON response for ' +
                                url +
                                ': ' +
                                xhr.responseText);
                        }
                        callback(null, res);
                    }
                    else {
                        // 401 and 404 are expected.
                        if (xhr.status !== 401 && xhr.status !== 404) {
                            warn('Got unsuccessful REST response for ' +
                                url +
                                ' Status: ' +
                                xhr.status);
                        }
                        callback(xhr.status);
                    }
                    callback = null;
                }
            };
            xhr.open('GET', url, /*asynchronous=*/ true);
            xhr.send();
        });
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 */
class SnapshotHolder {
    constructor() {
        this.rootNode_ = ChildrenNode.EMPTY_NODE;
    }
    getNode(path) {
        return this.rootNode_.getChild(path);
    }
    updateSnapshot(path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newSparseSnapshotTree() {
    return {
        value: null,
        children: new Map()
    };
}
/**
 * Stores the given node at the specified path. If there is already a node
 * at a shallower path, it merges the new data into that snapshot node.
 *
 * @param path - Path to look up snapshot for.
 * @param data - The new data, or null.
 */
function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {
    if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = data;
        sparseSnapshotTree.children.clear();
    }
    else if (sparseSnapshotTree.value !== null) {
        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
    }
    else {
        const childKey = pathGetFront(path);
        if (!sparseSnapshotTree.children.has(childKey)) {
            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
        }
        const child = sparseSnapshotTree.children.get(childKey);
        path = pathPopFront(path);
        sparseSnapshotTreeRemember(child, path, data);
    }
}
/**
 * Recursively iterates through all of the stored tree and calls the
 * callback on each one.
 *
 * @param prefixPath - Path to look up node for.
 * @param func - The function to invoke for each tree.
 */
function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {
    if (sparseSnapshotTree.value !== null) {
        func(prefixPath, sparseSnapshotTree.value);
    }
    else {
        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree) => {
            const path = new Path(prefixPath.toString() + '/' + key);
            sparseSnapshotTreeForEachTree(tree, path, func);
        });
    }
}
/**
 * Iterates through each immediate child and triggers the callback.
 * Only seems to be used in tests.
 *
 * @param func - The function to invoke for each child.
 */
function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {
    sparseSnapshotTree.children.forEach((tree, key) => {
        func(key, tree);
    });
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ - The collection to "listen" to.
 */
class StatsListener {
    constructor(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
    }
    get() {
        const newStats = this.collection_.get();
        const delta = Object.assign({}, newStats);
        if (this.last_) {
            each(this.last_, (stat, value) => {
                delta[stat] = delta[stat] - value;
            });
        }
        this.last_ = newStats;
        return delta;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
const FIRST_STATS_MIN_TIME = 10 * 1000;
const FIRST_STATS_MAX_TIME = 30 * 1000;
// We'll continue to report stats on average every 5 minutes.
const REPORT_STATS_INTERVAL = 5 * 60 * 1000;
class StatsReporter {
    constructor(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new StatsListener(collection);
        const timeout = FIRST_STATS_MIN_TIME +
            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
    }
    reportStats_() {
        const stats = this.statsListener_.get();
        const reportedStats = {};
        let haveStatsToReport = false;
        each(stats, (stat, value) => {
            if (value > 0 && contains(this.statsToReport_, stat)) {
                reportedStats[stat] = value;
                haveStatsToReport = true;
            }
        });
        if (haveStatsToReport) {
            this.server_.reportStats(reportedStats);
        }
        // queue our next run.
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * @enum
 */
var OperationType;
(function (OperationType) {
    OperationType[OperationType["OVERWRITE"] = 0] = "OVERWRITE";
    OperationType[OperationType["MERGE"] = 1] = "MERGE";
    OperationType[OperationType["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
    OperationType[OperationType["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType || (OperationType = {}));
function newOperationSourceUser() {
    return {
        fromUser: true,
        fromServer: false,
        queryId: null,
        tagged: false
    };
}
function newOperationSourceServer() {
    return {
        fromUser: false,
        fromServer: true,
        queryId: null,
        tagged: false
    };
}
function newOperationSourceServerTaggedQuery(queryId) {
    return {
        fromUser: false,
        fromServer: true,
        queryId,
        tagged: true
    };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AckUserWrite {
    /**
     * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.
     */
    constructor(
    /** @inheritDoc */ path, 
    /** @inheritDoc */ affectedTree, 
    /** @inheritDoc */ revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        /** @inheritDoc */
        this.type = OperationType.ACK_USER_WRITE;
        /** @inheritDoc */
        this.source = newOperationSourceUser();
    }
    operationForChild(childName) {
        if (!pathIsEmpty(this.path)) {
            assert(pathGetFront(this.path) === childName, 'operationForChild called for unrelated child.');
            return new AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);
        }
        else if (this.affectedTree.value != null) {
            assert(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');
            // All child locations are affected as well; just return same operation.
            return this;
        }
        else {
            const childTree = this.affectedTree.subtree(new Path(childName));
            return new AckUserWrite(newEmptyPath(), childTree, this.revert);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ListenComplete {
    constructor(source, path) {
        this.source = source;
        this.path = path;
        /** @inheritDoc */
        this.type = OperationType.LISTEN_COMPLETE;
    }
    operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
            return new ListenComplete(this.source, newEmptyPath());
        }
        else {
            return new ListenComplete(this.source, pathPopFront(this.path));
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Overwrite {
    constructor(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        /** @inheritDoc */
        this.type = OperationType.OVERWRITE;
    }
    operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
            return new Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
        }
        else {
            return new Overwrite(this.source, pathPopFront(this.path), this.snap);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Merge {
    constructor(
    /** @inheritDoc */ source, 
    /** @inheritDoc */ path, 
    /** @inheritDoc */ children) {
        this.source = source;
        this.path = path;
        this.children = children;
        /** @inheritDoc */
        this.type = OperationType.MERGE;
    }
    operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
            const childTree = this.children.subtree(new Path(childName));
            if (childTree.isEmpty()) {
                // This child is unaffected
                return null;
            }
            else if (childTree.value) {
                // We have a snapshot for the child in question.  This becomes an overwrite of the child.
                return new Overwrite(this.source, newEmptyPath(), childTree.value);
            }
            else {
                // This is a merge at a deeper level
                return new Merge(this.source, newEmptyPath(), childTree);
            }
        }
        else {
            assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
            return new Merge(this.source, pathPopFront(this.path), this.children);
        }
    }
    toString() {
        return ('Operation(' +
            this.path +
            ': ' +
            this.source.toString() +
            ' merge: ' +
            this.children.toString() +
            ')');
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */
class CacheNode {
    constructor(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
    }
    /**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     */
    isFullyInitialized() {
        return this.fullyInitialized_;
    }
    /**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     */
    isFiltered() {
        return this.filtered_;
    }
    isCompleteForPath(path) {
        if (pathIsEmpty(path)) {
            return this.isFullyInitialized() && !this.filtered_;
        }
        const childKey = pathGetFront(path);
        return this.isCompleteForChild(childKey);
    }
    isCompleteForChild(key) {
        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));
    }
    getNode() {
        return this.node_;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 */
class EventGenerator {
    constructor(query_) {
        this.query_ = query_;
        this.index_ = this.query_._queryParams.getIndex();
    }
}
/**
 * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
 * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
 *
 * Notes:
 *  - child_moved events will be synthesized at this time for any child_changed events that affect
 *    our index.
 *  - prevName will be calculated based on the index ordering.
 */
function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {
    const events = [];
    const moves = [];
    changes.forEach(change => {
        if (change.type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
            eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
            moves.push(changeChildMoved(change.childName, change.snapshotNode));
        }
    });
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed" /* ChangeType.CHILD_REMOVED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added" /* ChangeType.CHILD_ADDED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved" /* ChangeType.CHILD_MOVED */, moves, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed" /* ChangeType.CHILD_CHANGED */, changes, eventRegistrations, eventCache);
    eventGeneratorGenerateEventsForType(eventGenerator, events, "value" /* ChangeType.VALUE */, changes, eventRegistrations, eventCache);
    return events;
}
/**
 * Given changes of a single change type, generate the corresponding events.
 */
function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {
    const filteredChanges = changes.filter(change => change.type === eventType);
    filteredChanges.sort((a, b) => eventGeneratorCompareChanges(eventGenerator, a, b));
    filteredChanges.forEach(change => {
        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
        registrations.forEach(registration => {
            if (registration.respondsTo(change.type)) {
                events.push(registration.createEvent(materializedChange, eventGenerator.query_));
            }
        });
    });
}
function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {
    if (change.type === 'value' || change.type === 'child_removed') {
        return change;
    }
    else {
        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
        return change;
    }
}
function eventGeneratorCompareChanges(eventGenerator, a, b) {
    if (a.childName == null || b.childName == null) {
        throw assertionError('Should only compare child_ events.');
    }
    const aWrapped = new NamedNode(a.childName, a.snapshotNode);
    const bWrapped = new NamedNode(b.childName, b.snapshotNode);
    return eventGenerator.index_.compare(aWrapped, bWrapped);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newViewCache(eventCache, serverCache) {
    return { eventCache, serverCache };
}
function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {
    return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
}
function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {
    return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
}
function viewCacheGetCompleteEventSnap(viewCache) {
    return viewCache.eventCache.isFullyInitialized()
        ? viewCache.eventCache.getNode()
        : null;
}
function viewCacheGetCompleteServerSnap(viewCache) {
    return viewCache.serverCache.isFullyInitialized()
        ? viewCache.serverCache.getNode()
        : null;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let emptyChildrenSingleton;
/**
 * Singleton empty children collection.
 *
 */
const EmptyChildren = () => {
    if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new SortedMap(stringCompare);
    }
    return emptyChildrenSingleton;
};
/**
 * A tree with immutable elements.
 */
class ImmutableTree {
    constructor(value, children = EmptyChildren()) {
        this.value = value;
        this.children = children;
    }
    static fromObject(obj) {
        let tree = new ImmutableTree(null);
        each(obj, (childPath, childSnap) => {
            tree = tree.set(new Path(childPath), childSnap);
        });
        return tree;
    }
    /**
     * True if the value is empty and there are no children
     */
    isEmpty() {
        return this.value === null && this.children.isEmpty();
    }
    /**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`
     * objects on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param relativePath - The remainder of the path
     * @param predicate - The predicate to satisfy to return a node
     */
    findRootMostMatchingPathAndValue(relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
            return { path: newEmptyPath(), value: this.value };
        }
        else {
            if (pathIsEmpty(relativePath)) {
                return null;
            }
            else {
                const front = pathGetFront(relativePath);
                const child = this.children.get(front);
                if (child !== null) {
                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
                    if (childExistingPathAndValue != null) {
                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
                        return { path: fullPath, value: childExistingPathAndValue.value };
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        }
    }
    /**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     */
    findRootMostValueAndPath(relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, () => true);
    }
    /**
     * @returns The subtree at the given path
     */
    subtree(relativePath) {
        if (pathIsEmpty(relativePath)) {
            return this;
        }
        else {
            const front = pathGetFront(relativePath);
            const childTree = this.children.get(front);
            if (childTree !== null) {
                return childTree.subtree(pathPopFront(relativePath));
            }
            else {
                return new ImmutableTree(null);
            }
        }
    }
    /**
     * Sets a value at the specified path.
     *
     * @param relativePath - Path to set value at.
     * @param toSet - Value to set.
     * @returns Resulting tree.
     */
    set(relativePath, toSet) {
        if (pathIsEmpty(relativePath)) {
            return new ImmutableTree(toSet, this.children);
        }
        else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front) || new ImmutableTree(null);
            const newChild = child.set(pathPopFront(relativePath), toSet);
            const newChildren = this.children.insert(front, newChild);
            return new ImmutableTree(this.value, newChildren);
        }
    }
    /**
     * Removes the value at the specified path.
     *
     * @param relativePath - Path to value to remove.
     * @returns Resulting tree.
     */
    remove(relativePath) {
        if (pathIsEmpty(relativePath)) {
            if (this.children.isEmpty()) {
                return new ImmutableTree(null);
            }
            else {
                return new ImmutableTree(null, this.children);
            }
        }
        else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front);
            if (child) {
                const newChild = child.remove(pathPopFront(relativePath));
                let newChildren;
                if (newChild.isEmpty()) {
                    newChildren = this.children.remove(front);
                }
                else {
                    newChildren = this.children.insert(front, newChild);
                }
                if (this.value === null && newChildren.isEmpty()) {
                    return new ImmutableTree(null);
                }
                else {
                    return new ImmutableTree(this.value, newChildren);
                }
            }
            else {
                return this;
            }
        }
    }
    /**
     * Gets a value from the tree.
     *
     * @param relativePath - Path to get value for.
     * @returns Value at path, or null.
     */
    get(relativePath) {
        if (pathIsEmpty(relativePath)) {
            return this.value;
        }
        else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front);
            if (child) {
                return child.get(pathPopFront(relativePath));
            }
            else {
                return null;
            }
        }
    }
    /**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param relativePath - Path to replace subtree for.
     * @param newTree - New tree.
     * @returns Resulting tree.
     */
    setTree(relativePath, newTree) {
        if (pathIsEmpty(relativePath)) {
            return newTree;
        }
        else {
            const front = pathGetFront(relativePath);
            const child = this.children.get(front) || new ImmutableTree(null);
            const newChild = child.setTree(pathPopFront(relativePath), newTree);
            let newChildren;
            if (newChild.isEmpty()) {
                newChildren = this.children.remove(front);
            }
            else {
                newChildren = this.children.insert(front, newChild);
            }
            return new ImmutableTree(this.value, newChildren);
        }
    }
    /**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     */
    fold(fn) {
        return this.fold_(newEmptyPath(), fn);
    }
    /**
     * Recursive helper for public-facing fold() method
     */
    fold_(pathSoFar, fn) {
        const accum = {};
        this.children.inorderTraversal((childKey, childTree) => {
            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);
        });
        return fn(pathSoFar, this.value, accum);
    }
    /**
     * Find the first matching value on the given path. Return the result of applying f to it.
     */
    findOnPath(path, f) {
        return this.findOnPath_(path, newEmptyPath(), f);
    }
    findOnPath_(pathToFollow, pathSoFar, f) {
        const result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
            return result;
        }
        else {
            if (pathIsEmpty(pathToFollow)) {
                return null;
            }
            else {
                const front = pathGetFront(pathToFollow);
                const nextChild = this.children.get(front);
                if (nextChild) {
                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
                }
                else {
                    return null;
                }
            }
        }
    }
    foreachOnPath(path, f) {
        return this.foreachOnPath_(path, newEmptyPath(), f);
    }
    foreachOnPath_(pathToFollow, currentRelativePath, f) {
        if (pathIsEmpty(pathToFollow)) {
            return this;
        }
        else {
            if (this.value) {
                f(currentRelativePath, this.value);
            }
            const front = pathGetFront(pathToFollow);
            const nextChild = this.children.get(front);
            if (nextChild) {
                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
            }
            else {
                return new ImmutableTree(null);
            }
        }
    }
    /**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param f - A function to be called with the path from the root of the tree to
     * a node, and the value at that node. Called in depth-first order.
     */
    foreach(f) {
        this.foreach_(newEmptyPath(), f);
    }
    foreach_(currentRelativePath, f) {
        this.children.inorderTraversal((childName, childTree) => {
            childTree.foreach_(pathChild(currentRelativePath, childName), f);
        });
        if (this.value) {
            f(currentRelativePath, this.value);
        }
    }
    foreachChild(f) {
        this.children.inorderTraversal((childName, childTree) => {
            if (childTree.value) {
                f(childName, childTree.value);
            }
        });
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 */
class CompoundWrite {
    constructor(writeTree_) {
        this.writeTree_ = writeTree_;
    }
    static empty() {
        return new CompoundWrite(new ImmutableTree(null));
    }
}
function compoundWriteAddWrite(compoundWrite, path, node) {
    if (pathIsEmpty(path)) {
        return new CompoundWrite(new ImmutableTree(node));
    }
    else {
        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) {
            const rootMostPath = rootmost.path;
            let value = rootmost.value;
            const relativePath = newRelativePath(rootMostPath, path);
            value = value.updateChild(relativePath, node);
            return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
        }
        else {
            const subtree = new ImmutableTree(node);
            const newWriteTree = compoundWrite.writeTree_.setTree(path, subtree);
            return new CompoundWrite(newWriteTree);
        }
    }
}
function compoundWriteAddWrites(compoundWrite, path, updates) {
    let newWrite = compoundWrite;
    each(updates, (childKey, node) => {
        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
    });
    return newWrite;
}
/**
 * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
 * location, which must be removed by calling this method with that path.
 *
 * @param compoundWrite - The CompoundWrite to remove.
 * @param path - The path at which a write and all deeper writes should be removed
 * @returns The new CompoundWrite with the removed path
 */
function compoundWriteRemoveWrite(compoundWrite, path) {
    if (pathIsEmpty(path)) {
        return CompoundWrite.empty();
    }
    else {
        const newWriteTree = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
        return new CompoundWrite(newWriteTree);
    }
}
/**
 * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
 * considered "complete".
 *
 * @param compoundWrite - The CompoundWrite to check.
 * @param path - The path to check for
 * @returns Whether there is a complete write at that path
 */
function compoundWriteHasCompleteWrite(compoundWrite, path) {
    return compoundWriteGetCompleteNode(compoundWrite, path) != null;
}
/**
 * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
 * writes from deeper paths, but will return child nodes from a more shallow path.
 *
 * @param compoundWrite - The CompoundWrite to get the node from.
 * @param path - The path to get a complete write
 * @returns The node if complete at that path, or null otherwise.
 */
function compoundWriteGetCompleteNode(compoundWrite, path) {
    const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
    if (rootmost != null) {
        return compoundWrite.writeTree_
            .get(rootmost.path)
            .getChild(newRelativePath(rootmost.path, path));
    }
    else {
        return null;
    }
}
/**
 * Returns all children that are guaranteed to be a complete overwrite.
 *
 * @param compoundWrite - The CompoundWrite to get children from.
 * @returns A list of all complete children.
 */
function compoundWriteGetCompleteChildren(compoundWrite) {
    const children = [];
    const node = compoundWrite.writeTree_.value;
    if (node != null) {
        // If it's a leaf node, it has no children; so nothing to do.
        if (!node.isLeafNode()) {
            node.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
                children.push(new NamedNode(childName, childNode));
            });
        }
    }
    else {
        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree) => {
            if (childTree.value != null) {
                children.push(new NamedNode(childName, childTree.value));
            }
        });
    }
    return children;
}
function compoundWriteChildCompoundWrite(compoundWrite, path) {
    if (pathIsEmpty(path)) {
        return compoundWrite;
    }
    else {
        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
        if (shadowingNode != null) {
            return new CompoundWrite(new ImmutableTree(shadowingNode));
        }
        else {
            return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
        }
    }
}
/**
 * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
 * @returns Whether this CompoundWrite is empty
 */
function compoundWriteIsEmpty(compoundWrite) {
    return compoundWrite.writeTree_.isEmpty();
}
/**
 * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
 * node
 * @param node - The node to apply this CompoundWrite to
 * @returns The node with all writes applied
 */
function compoundWriteApply(compoundWrite, node) {
    return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
}
function applySubtreeWrite(relativePath, writeTree, node) {
    if (writeTree.value != null) {
        // Since there a write is always a leaf, we're done here
        return node.updateChild(relativePath, writeTree.value);
    }
    else {
        let priorityWrite = null;
        writeTree.children.inorderTraversal((childKey, childTree) => {
            if (childKey === '.priority') {
                // Apply priorities at the end so we don't update priorities for either empty nodes or forget
                // to apply priorities to empty nodes that are later filled
                assert(childTree.value !== null, 'Priority writes must always be leaf nodes');
                priorityWrite = childTree.value;
            }
            else {
                node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
            }
        });
        // If there was a priority write, we only apply it if the node is not empty
        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {
            node = node.updateChild(pathChild(relativePath, '.priority'), priorityWrite);
        }
        return node;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
 *
 */
function writeTreeChildWrites(writeTree, path) {
    return newWriteTreeRef(path, writeTree);
}
/**
 * Record a new overwrite from user code.
 *
 * @param visible - This is set to false by some transactions. It should be excluded from event caches
 */
function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {
    assert(writeId > writeTree.lastWriteId, 'Stacking an older write on top of newer ones');
    if (visible === undefined) {
        visible = true;
    }
    writeTree.allWrites.push({
        path,
        snap,
        writeId,
        visible
    });
    if (visible) {
        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
    }
    writeTree.lastWriteId = writeId;
}
function writeTreeGetWrite(writeTree, writeId) {
    for (let i = 0; i < writeTree.allWrites.length; i++) {
        const record = writeTree.allWrites[i];
        if (record.writeId === writeId) {
            return record;
        }
    }
    return null;
}
/**
 * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
 * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
 *
 * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise
 * events as a result).
 */
function writeTreeRemoveWrite(writeTree, writeId) {
    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
    // out of order.
    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
    //assert(validClear, "Either we don't have this write, or it's the first one in the queue");
    const idx = writeTree.allWrites.findIndex(s => {
        return s.writeId === writeId;
    });
    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');
    const writeToRemove = writeTree.allWrites[idx];
    writeTree.allWrites.splice(idx, 1);
    let removedWriteWasVisible = writeToRemove.visible;
    let removedWriteOverlapsWithOtherWrites = false;
    let i = writeTree.allWrites.length - 1;
    while (removedWriteWasVisible && i >= 0) {
        const currentWrite = writeTree.allWrites[i];
        if (currentWrite.visible) {
            if (i >= idx &&
                writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
                // The removed write was completely shadowed by a subsequent write.
                removedWriteWasVisible = false;
            }
            else if (pathContains(writeToRemove.path, currentWrite.path)) {
                // Either we're covering some writes or they're covering part of us (depending on which came first).
                removedWriteOverlapsWithOtherWrites = true;
            }
        }
        i--;
    }
    if (!removedWriteWasVisible) {
        return false;
    }
    else if (removedWriteOverlapsWithOtherWrites) {
        // There's some shadowing going on. Just rebuild the visible writes from scratch.
        writeTreeResetTree_(writeTree);
        return true;
    }
    else {
        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
        if (writeToRemove.snap) {
            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
        }
        else {
            const children = writeToRemove.children;
            each(children, (childName) => {
                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
            });
        }
        return true;
    }
}
function writeTreeRecordContainsPath_(writeRecord, path) {
    if (writeRecord.snap) {
        return pathContains(writeRecord.path, path);
    }
    else {
        for (const childName in writeRecord.children) {
            if (writeRecord.children.hasOwnProperty(childName) &&
                pathContains(pathChild(writeRecord.path, childName), path)) {
                return true;
            }
        }
        return false;
    }
}
/**
 * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
 */
function writeTreeResetTree_(writeTree) {
    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
    if (writeTree.allWrites.length > 0) {
        writeTree.lastWriteId =
            writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
    }
    else {
        writeTree.lastWriteId = -1;
    }
}
/**
 * The default filter used when constructing the tree. Keep everything that's visible.
 */
function writeTreeDefaultFilter_(write) {
    return write.visible;
}
/**
 * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
 * event data at that path.
 */
function writeTreeLayerTree_(writes, filter, treeRoot) {
    let compoundWrite = CompoundWrite.empty();
    for (let i = 0; i < writes.length; ++i) {
        const write = writes[i];
        // Theory, a later set will either:
        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
        if (filter(write)) {
            const writePath = write.path;
            let relativePath;
            if (write.snap) {
                if (pathContains(treeRoot, writePath)) {
                    relativePath = newRelativePath(treeRoot, writePath);
                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);
                }
                else if (pathContains(writePath, treeRoot)) {
                    relativePath = newRelativePath(writePath, treeRoot);
                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));
                }
                else ;
            }
            else if (write.children) {
                if (pathContains(treeRoot, writePath)) {
                    relativePath = newRelativePath(treeRoot, writePath);
                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);
                }
                else if (pathContains(writePath, treeRoot)) {
                    relativePath = newRelativePath(writePath, treeRoot);
                    if (pathIsEmpty(relativePath)) {
                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);
                    }
                    else {
                        const child = safeGet(write.children, pathGetFront(relativePath));
                        if (child) {
                            // There exists a child in this node that matches the root path
                            const deepNode = child.getChild(pathPopFront(relativePath));
                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
                        }
                    }
                }
                else ;
            }
            else {
                throw assertionError('WriteRecord should have .snap or .children');
            }
        }
    }
    return compoundWrite;
}
/**
 * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
 * writes), attempt to calculate a complete snapshot for the given path
 *
 * @param writeIdsToExclude - An optional set to be excluded
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */
function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
    if (!writeIdsToExclude && !includeHiddenWrites) {
        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
        if (shadowingNode != null) {
            return shadowingNode;
        }
        else {
            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
            if (compoundWriteIsEmpty(subMerge)) {
                return completeServerCache;
            }
            else if (completeServerCache == null &&
                !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
                return null;
            }
            else {
                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
                return compoundWriteApply(subMerge, layeredCache);
            }
        }
    }
    else {
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
            return completeServerCache;
        }
        else {
            // If the server cache is null, and we don't have a complete cache, we need to return null
            if (!includeHiddenWrites &&
                completeServerCache == null &&
                !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
                return null;
            }
            else {
                const filter = function (write) {
                    return ((write.visible || includeHiddenWrites) &&
                        (!writeIdsToExclude ||
                            !~writeIdsToExclude.indexOf(write.writeId)) &&
                        (pathContains(write.path, treePath) ||
                            pathContains(treePath, write.path)));
                };
                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
                return compoundWriteApply(mergeAtPath, layeredCache);
            }
        }
    }
}
/**
 * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
 * Used when creating new views, to pre-fill their complete event children snapshot.
 */
function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {
    let completeChildren = ChildrenNode.EMPTY_NODE;
    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
    if (topLevelSet) {
        if (!topLevelSet.isLeafNode()) {
            // we're shadowing everything. Return the children.
            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => {
                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
            });
        }
        return completeChildren;
    }
    else if (completeServerChildren) {
        // Layer any children we have on top of this
        // We know we don't have a top-level set, so just enumerate existing children
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);
            completeChildren = completeChildren.updateImmediateChild(childName, node);
        });
        // Add any complete children we have from the set
        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
    }
    else {
        // We don't have anything to layer on top of. Layer on any children we have
        // Note that we can return an empty snap if we have a defined delete
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {
            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
    }
}
/**
 * Given that the underlying server data has updated, determine what, if anything, needs to be
 * applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events
 *
 * Either existingEventSnap or existingServerSnap must exist
 */
function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
    assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');
    const path = pathChild(treePath, childPath);
    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {
        // At this point we can probably guarantee that we're in case 2, meaning no events
        // May need to check visibility while doing the findRootMostValueAndPath call
        return null;
    }
    else {
        // No complete shadowing. We're either partially shadowing or not shadowing at all.
        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
        if (compoundWriteIsEmpty(childMerge)) {
            // We're not shadowing at all. Case 1
            return existingServerSnap.getChild(childPath);
        }
        else {
            // This could be more efficient if the serverNode + updates doesn't change the eventSnap
            // However this is tricky to find out, since user updates don't necessary change the server
            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
            // adds nodes, but doesn't change any existing writes. It is therefore not enough to
            // only check if the updates change the serverNode.
            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
        }
    }
}
/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */
function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {
    const path = pathChild(treePath, childKey);
    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
    if (shadowingNode != null) {
        return shadowingNode;
    }
    else {
        if (existingServerSnap.isCompleteForChild(childKey)) {
            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
        }
        else {
            return null;
        }
    }
}
/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 */
function writeTreeShadowingWrite(writeTree, path) {
    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
}
/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window.
 */
function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {
    let toIterate;
    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
    if (shadowingNode != null) {
        toIterate = shadowingNode;
    }
    else if (completeServerData != null) {
        toIterate = compoundWriteApply(merge, completeServerData);
    }
    else {
        // no children to iterate on
        return [];
    }
    toIterate = toIterate.withIndex(index);
    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
        const nodes = [];
        const cmp = index.getCompare();
        const iter = reverse
            ? toIterate.getReverseIteratorFrom(startPost, index)
            : toIterate.getIteratorFrom(startPost, index);
        let next = iter.getNext();
        while (next && nodes.length < count) {
            if (cmp(next, startPost) !== 0) {
                nodes.push(next);
            }
            next = iter.getNext();
        }
        return nodes;
    }
    else {
        return [];
    }
}
function newWriteTree() {
    return {
        visibleWrites: CompoundWrite.empty(),
        allWrites: [],
        lastWriteId: -1
    };
}
/**
 * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
 * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
 * can lead to a more expensive calculation.
 *
 * @param writeIdsToExclude - Optional writes to exclude.
 * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false
 */
function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
}
/**
 * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
 * mix of the given server data and write data.
 *
 */
function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {
    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
}
/**
 * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
 * if anything, needs to be applied to the event cache.
 *
 * Possibilities:
 *
 * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
 *
 * 2. Some write is completely shadowing. No events to be raised
 *
 * 3. Is partially shadowed. Events should be raised
 *
 * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
 *
 *
 */
function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {
    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
}
/**
 * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
 * a higher path, this will return the child of that write relative to the write and this path.
 * Returns null if there is no write at this path.
 *
 */
function writeTreeRefShadowingWrite(writeTreeRef, path) {
    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
}
/**
 * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
 * the window, but may now be in the window
 */
function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {
    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);
}
/**
 * Returns a complete child for a given server snap after applying all user writes or null if there is no
 * complete child for this ChildKey.
 */
function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {
    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
}
/**
 * Return a WriteTreeRef for a child.
 */
function writeTreeRefChild(writeTreeRef, childName) {
    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
}
function newWriteTreeRef(path, writeTree) {
    return {
        treePath: path,
        writeTree
    };
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChildChangeAccumulator {
    constructor() {
        this.changeMap = new Map();
    }
    trackChildChange(change) {
        const type = change.type;
        const childKey = change.childName;
        assert(type === "child_added" /* ChangeType.CHILD_ADDED */ ||
            type === "child_changed" /* ChangeType.CHILD_CHANGED */ ||
            type === "child_removed" /* ChangeType.CHILD_REMOVED */, 'Only child changes supported for tracking');
        assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        const oldChange = this.changeMap.get(childKey);
        if (oldChange) {
            const oldType = oldChange.type;
            if (type === "child_added" /* ChangeType.CHILD_ADDED */ &&
                oldType === "child_removed" /* ChangeType.CHILD_REMOVED */) {
                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
            }
            else if (type === "child_removed" /* ChangeType.CHILD_REMOVED */ &&
                oldType === "child_added" /* ChangeType.CHILD_ADDED */) {
                this.changeMap.delete(childKey);
            }
            else if (type === "child_removed" /* ChangeType.CHILD_REMOVED */ &&
                oldType === "child_changed" /* ChangeType.CHILD_CHANGED */) {
                this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
            }
            else if (type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
                oldType === "child_added" /* ChangeType.CHILD_ADDED */) {
                this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
            }
            else if (type === "child_changed" /* ChangeType.CHILD_CHANGED */ &&
                oldType === "child_changed" /* ChangeType.CHILD_CHANGED */) {
                this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
            }
            else {
                throw assertionError('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
            }
        }
        else {
            this.changeMap.set(childKey, change);
        }
    }
    getChanges() {
        return Array.from(this.changeMap.values());
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * An implementation of CompleteChildSource that never returns any additional children
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
class NoCompleteChildSource_ {
    getCompleteChild(childKey) {
        return null;
    }
    getChildAfterChild(index, child, reverse) {
        return null;
    }
}
/**
 * Singleton instance.
 */
const NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 */
class WriteTreeCompleteChildSource {
    constructor(writes_, viewCache_, optCompleteServerCache_ = null) {
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
    }
    getCompleteChild(childKey) {
        const node = this.viewCache_.eventCache;
        if (node.isCompleteForChild(childKey)) {
            return node.getNode().getImmediateChild(childKey);
        }
        else {
            const serverNode = this.optCompleteServerCache_ != null
                ? new CacheNode(this.optCompleteServerCache_, true, false)
                : this.viewCache_.serverCache;
            return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
        }
    }
    getChildAfterChild(index, child, reverse) {
        const completeServerData = this.optCompleteServerCache_ != null
            ? this.optCompleteServerCache_
            : viewCacheGetCompleteServerSnap(this.viewCache_);
        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child, 1, reverse, index);
        if (nodes.length === 0) {
            return null;
        }
        else {
            return nodes[0];
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function newViewProcessor(filter) {
    return { filter };
}
function viewProcessorAssertIndexed(viewProcessor, viewCache) {
    assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Event snap not indexed');
    assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), 'Server snap not indexed');
}
function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
    const accumulator = new ChildChangeAccumulator();
    let newViewCache, filterServerNode;
    if (operation.type === OperationType.OVERWRITE) {
        const overwrite = operation;
        if (overwrite.source.fromUser) {
            newViewCache = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
        }
        else {
            assert(overwrite.source.fromServer, 'Unknown source.');
            // We filter the node if it's a tagged update or the node has been previously filtered  and the
            // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
            // again
            filterServerNode =
                overwrite.source.tagged ||
                    (oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path));
            newViewCache = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
        }
    }
    else if (operation.type === OperationType.MERGE) {
        const merge = operation;
        if (merge.source.fromUser) {
            newViewCache = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
        }
        else {
            assert(merge.source.fromServer, 'Unknown source.');
            // We filter the node if it's a tagged update or the node has been previously filtered
            filterServerNode =
                merge.source.tagged || oldViewCache.serverCache.isFiltered();
            newViewCache = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
        }
    }
    else if (operation.type === OperationType.ACK_USER_WRITE) {
        const ackUserWrite = operation;
        if (!ackUserWrite.revert) {
            newViewCache = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
        }
        else {
            newViewCache = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
        }
    }
    else if (operation.type === OperationType.LISTEN_COMPLETE) {
        newViewCache = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
    }
    else {
        throw assertionError('Unknown operation type: ' + operation.type);
    }
    const changes = accumulator.getChanges();
    viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, changes);
    return { viewCache: newViewCache, changes };
}
function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache, accumulator) {
    const eventSnap = newViewCache.eventCache;
    if (eventSnap.isFullyInitialized()) {
        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
        if (accumulator.length > 0 ||
            !oldViewCache.eventCache.isFullyInitialized() ||
            (isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap)) ||
            !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
            accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache)));
        }
    }
}
function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {
    const oldEventSnap = viewCache.eventCache;
    if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
        // we have a shadowing write, ignore changes
        return viewCache;
    }
    else {
        let newEventCache, serverNode;
        if (pathIsEmpty(changePath)) {
            // TODO: figure out how this plays with "sliding ack windows"
            assert(viewCache.serverCache.isFullyInitialized(), 'If change path is empty, we must have complete server data');
            if (viewCache.serverCache.isFiltered()) {
                // We need to special case this, because we need to only apply writes to complete children, or
                // we might end up raising events for incomplete children. If the server data is filtered deep
                // writes cannot be guaranteed to be complete
                const serverCache = viewCacheGetCompleteServerSnap(viewCache);
                const completeChildren = serverCache instanceof ChildrenNode
                    ? serverCache
                    : ChildrenNode.EMPTY_NODE;
                const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
            }
            else {
                const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
                newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
            }
        }
        else {
            const childKey = pathGetFront(changePath);
            if (childKey === '.priority') {
                assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
                const oldEventNode = oldEventSnap.getNode();
                serverNode = viewCache.serverCache.getNode();
                // we might have overwrites for this priority
                const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
                if (updatedPriority != null) {
                    newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
                }
                else {
                    // priority didn't change, keep old node
                    newEventCache = oldEventSnap.getNode();
                }
            }
            else {
                const childChangePath = pathPopFront(changePath);
                // update child
                let newEventChild;
                if (oldEventSnap.isCompleteForChild(childKey)) {
                    serverNode = viewCache.serverCache.getNode();
                    const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
                    if (eventChildUpdate != null) {
                        newEventChild = oldEventSnap
                            .getNode()
                            .getImmediateChild(childKey)
                            .updateChild(childChangePath, eventChildUpdate);
                    }
                    else {
                        // Nothing changed, just keep the old child
                        newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
                    }
                }
                else {
                    newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
                }
                if (newEventChild != null) {
                    newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
                }
                else {
                    // no complete child available or no change
                    newEventCache = oldEventSnap.getNode();
                }
            }
        }
        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
    }
}
function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
    const oldServerSnap = oldViewCache.serverCache;
    let newServerCache;
    const serverFilter = filterServerNode
        ? viewProcessor.filter
        : viewProcessor.filter.getIndexedFilter();
    if (pathIsEmpty(changePath)) {
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
    }
    else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
        // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
        const newServerNode = oldServerSnap
            .getNode()
            .updateChild(changePath, changedSnap);
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
    }
    else {
        const childKey = pathGetFront(changePath);
        if (!oldServerSnap.isCompleteForPath(changePath) &&
            pathGetLength(changePath) > 1) {
            // We don't update incomplete nodes with updates intended for other listeners
            return oldViewCache;
        }
        const childChangePath = pathPopFront(changePath);
        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);
        const newChildNode = childNode.updateChild(childChangePath, changedSnap);
        if (childKey === '.priority') {
            newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
        }
        else {
            newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
        }
    }
    const newViewCache = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
    const source = new WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);
    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, changePath, writesCache, source, accumulator);
}
function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
    const oldEventSnap = oldViewCache.eventCache;
    let newViewCache, newEventCache;
    const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
    if (pathIsEmpty(changePath)) {
        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
        newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
    }
    else {
        const childKey = pathGetFront(changePath);
        if (childKey === '.priority') {
            newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
            newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
        }
        else {
            const childChangePath = pathPopFront(changePath);
            const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
            let newChild;
            if (pathIsEmpty(childChangePath)) {
                // Child overwrite, we can replace the child
                newChild = changedSnap;
            }
            else {
                const childNode = source.getCompleteChild(childKey);
                if (childNode != null) {
                    if (pathGetBack(childChangePath) === '.priority' &&
                        childNode.getChild(pathParent(childChangePath)).isEmpty()) {
                        // This is a priority update on an empty node. If this node exists on the server, the
                        // server will send down the priority in the update, so ignore for now
                        newChild = childNode;
                    }
                    else {
                        newChild = childNode.updateChild(childChangePath, changedSnap);
                    }
                }
                else {
                    // There is no complete child node available
                    newChild = ChildrenNode.EMPTY_NODE;
                }
            }
            if (!oldChild.equals(newChild)) {
                const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                newViewCache = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
            }
            else {
                newViewCache = oldViewCache;
            }
        }
    }
    return newViewCache;
}
function viewProcessorCacheHasChild(viewCache, childKey) {
    return viewCache.eventCache.isCompleteForChild(childKey);
}
function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
    // HACK: In the case of a limit query, there may be some changes that bump things out of the
    // window leaving room for new items.  It's important we process these changes first, so we
    // iterate the changes twice, first processing any that affect items currently in view.
    // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
    // not the other.
    let curViewCache = viewCache;
    changedChildren.foreach((relativePath, childNode) => {
        const writePath = pathChild(path, relativePath);
        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
    });
    changedChildren.foreach((relativePath, childNode) => {
        const writePath = pathChild(path, relativePath);
        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
            curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
    });
    return curViewCache;
}
function viewProcessorApplyMerge(viewProcessor, node, merge) {
    merge.foreach((relativePath, childNode) => {
        node = node.updateChild(relativePath, childNode);
    });
    return node;
}
function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
    // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
    // wait for the complete data update coming soon.
    if (viewCache.serverCache.getNode().isEmpty() &&
        !viewCache.serverCache.isFullyInitialized()) {
        return viewCache;
    }
    // HACK: In the case of a limit query, there may be some changes that bump things out of the
    // window leaving room for new items.  It's important we process these changes first, so we
    // iterate the changes twice, first processing any that affect items currently in view.
    // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
    // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
    // not the other.
    let curViewCache = viewCache;
    let viewMergeTree;
    if (pathIsEmpty(path)) {
        viewMergeTree = changedChildren;
    }
    else {
        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
    }
    const serverNode = viewCache.serverCache.getNode();
    viewMergeTree.children.inorderTraversal((childKey, childTree) => {
        if (serverNode.hasChild(childKey)) {
            const serverChild = viewCache.serverCache
                .getNode()
                .getImmediateChild(childKey);
            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
    });
    viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {
        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) &&
            childMergeTree.value === null;
        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
            const serverChild = viewCache.serverCache
                .getNode()
                .getImmediateChild(childKey);
            const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
            curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
    });
    return curViewCache;
}
function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
    if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
        return viewCache;
    }
    // Only filter server node if it is currently filtered
    const filterServerNode = viewCache.serverCache.isFiltered();
    // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
    // now that it won't be shadowed.
    const serverCache = viewCache.serverCache;
    if (affectedTree.value != null) {
        // This is an overwrite.
        if ((pathIsEmpty(ackPath) && serverCache.isFullyInitialized()) ||
            serverCache.isCompleteForPath(ackPath)) {
            return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
        }
        else if (pathIsEmpty(ackPath)) {
            // This is a goofy edge case where we are acking data at this location but don't have full data.  We
            // should just re-apply whatever we have in our cache as a merge.
            let changedChildren = new ImmutableTree(null);
            serverCache.getNode().forEachChild(KEY_INDEX, (name, node) => {
                changedChildren = changedChildren.set(new Path(name), node);
            });
            return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
        }
        else {
            return viewCache;
        }
    }
    else {
        // This is a merge.
        let changedChildren = new ImmutableTree(null);
        affectedTree.foreach((mergePath, value) => {
            const serverCachePath = pathChild(ackPath, mergePath);
            if (serverCache.isCompleteForPath(serverCachePath)) {
                changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));
            }
        });
        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
    }
}
function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {
    const oldServerNode = viewCache.serverCache;
    const newViewCache = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
    return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
}
function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {
    let complete;
    if (writeTreeRefShadowingWrite(writesCache, path) != null) {
        return viewCache;
    }
    else {
        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
        const oldEventCache = viewCache.eventCache.getNode();
        let newEventCache;
        if (pathIsEmpty(path) || pathGetFront(path) === '.priority') {
            let newNode;
            if (viewCache.serverCache.isFullyInitialized()) {
                newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
            }
            else {
                const serverChildren = viewCache.serverCache.getNode();
                assert(serverChildren instanceof ChildrenNode, 'serverChildren would be complete if leaf node');
                newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
            }
            newNode = newNode;
            newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
        }
        else {
            const childKey = pathGetFront(path);
            let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
            if (newChild == null &&
                viewCache.serverCache.isCompleteForChild(childKey)) {
                newChild = oldEventCache.getImmediateChild(childKey);
            }
            if (newChild != null) {
                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
            }
            else if (viewCache.eventCache.getNode().hasChild(childKey)) {
                // No complete child available, delete the existing one, if any
                newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
            }
            else {
                newEventCache = oldEventCache;
            }
            if (newEventCache.isEmpty() &&
                viewCache.serverCache.isFullyInitialized()) {
                // We might have reverted all child writes. Maybe the old event was a leaf node
                complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
                if (complete.isLeafNode()) {
                    newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
                }
            }
        }
        complete =
            viewCache.serverCache.isFullyInitialized() ||
                writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 */
class View {
    constructor(query_, initialViewCache) {
        this.query_ = query_;
        this.eventRegistrations_ = [];
        const params = this.query_._queryParams;
        const indexFilter = new IndexedFilter(params.getIndex());
        const filter = queryParamsGetNodeFilter(params);
        this.processor_ = newViewProcessor(filter);
        const initialServerCache = initialViewCache.serverCache;
        const initialEventCache = initialViewCache.eventCache;
        // Don't filter server node with other filter than index, wait for tagged listen
        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        this.viewCache_ = newViewCache(newEventCache, newServerCache);
        this.eventGenerator_ = new EventGenerator(this.query_);
    }
    get query() {
        return this.query_;
    }
}
function viewGetServerCache(view) {
    return view.viewCache_.serverCache.getNode();
}
function viewGetCompleteServerCache(view, path) {
    const cache = viewCacheGetCompleteServerSnap(view.viewCache_);
    if (cache) {
        // If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
        // we need to see if it contains the child we're interested in.
        if (view.query._queryParams.loadsAllData() ||
            (!pathIsEmpty(path) &&
                !cache.getImmediateChild(pathGetFront(path)).isEmpty())) {
            return cache.getChild(path);
        }
    }
    return null;
}
function viewIsEmpty(view) {
    return view.eventRegistrations_.length === 0;
}
function viewAddEventRegistration(view, eventRegistration) {
    view.eventRegistrations_.push(eventRegistration);
}
/**
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns Cancel events, if cancelError was provided.
 */
function viewRemoveEventRegistration(view, eventRegistration, cancelError) {
    const cancelEvents = [];
    if (cancelError) {
        assert(eventRegistration == null, 'A cancel should cancel all event registrations.');
        const path = view.query._path;
        view.eventRegistrations_.forEach(registration => {
            const maybeEvent = registration.createCancelEvent(cancelError, path);
            if (maybeEvent) {
                cancelEvents.push(maybeEvent);
            }
        });
    }
    if (eventRegistration) {
        let remaining = [];
        for (let i = 0; i < view.eventRegistrations_.length; ++i) {
            const existing = view.eventRegistrations_[i];
            if (!existing.matches(eventRegistration)) {
                remaining.push(existing);
            }
            else if (eventRegistration.hasAnyCallback()) {
                // We're removing just this one
                remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
                break;
            }
        }
        view.eventRegistrations_ = remaining;
    }
    else {
        view.eventRegistrations_ = [];
    }
    return cancelEvents;
}
/**
 * Applies the given Operation, updates our cache, and returns the appropriate events.
 */
function viewApplyOperation(view, operation, writesCache, completeServerCache) {
    if (operation.type === OperationType.MERGE &&
        operation.source.queryId !== null) {
        assert(viewCacheGetCompleteServerSnap(view.viewCache_), 'We should always have a full cache before handling merges');
        assert(viewCacheGetCompleteEventSnap(view.viewCache_), 'Missing event cache, even though we have a server cache');
    }
    const oldViewCache = view.viewCache_;
    const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
    viewProcessorAssertIndexed(view.processor_, result.viewCache);
    assert(result.viewCache.serverCache.isFullyInitialized() ||
        !oldViewCache.serverCache.isFullyInitialized(), 'Once a server snap is complete, it should never go back');
    view.viewCache_ = result.viewCache;
    return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
}
function viewGetInitialEvents(view, registration) {
    const eventSnap = view.viewCache_.eventCache;
    const initialChanges = [];
    if (!eventSnap.getNode().isLeafNode()) {
        const eventNode = eventSnap.getNode();
        eventNode.forEachChild(PRIORITY_INDEX, (key, childNode) => {
            initialChanges.push(changeChildAdded(key, childNode));
        });
    }
    if (eventSnap.isFullyInitialized()) {
        initialChanges.push(changeValue(eventSnap.getNode()));
    }
    return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
}
function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {
    const registrations = eventRegistration
        ? [eventRegistration]
        : view.eventRegistrations_;
    return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let referenceConstructor$1;
/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */
class SyncPoint {
    constructor() {
        /**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         */
        this.views = new Map();
    }
}
function syncPointSetReferenceConstructor(val) {
    assert(!referenceConstructor$1, '__referenceConstructor has already been defined');
    referenceConstructor$1 = val;
}
function syncPointGetReferenceConstructor() {
    assert(referenceConstructor$1, 'Reference.ts has not been loaded');
    return referenceConstructor$1;
}
function syncPointIsEmpty(syncPoint) {
    return syncPoint.views.size === 0;
}
function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {
    const queryId = operation.source.queryId;
    if (queryId !== null) {
        const view = syncPoint.views.get(queryId);
        assert(view != null, 'SyncTree gave us an op for an invalid query.');
        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
    }
    else {
        let events = [];
        for (const view of syncPoint.views.values()) {
            events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
        }
        return events;
    }
}
/**
 * Get a view for the specified query.
 *
 * @param query - The query to return a view for
 * @param writesCache
 * @param serverCache
 * @param serverCacheComplete
 * @returns Events to raise.
 */
function syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete) {
    const queryId = query._queryIdentifier;
    const view = syncPoint.views.get(queryId);
    if (!view) {
        // TODO: make writesCache take flag for complete server node
        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
        let eventCacheComplete = false;
        if (eventCache) {
            eventCacheComplete = true;
        }
        else if (serverCache instanceof ChildrenNode) {
            eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
            eventCacheComplete = false;
        }
        else {
            eventCache = ChildrenNode.EMPTY_NODE;
            eventCacheComplete = false;
        }
        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
        return new View(query, viewCache);
    }
    return view;
}
/**
 * Add an event callback for the specified query.
 *
 * @param query
 * @param eventRegistration
 * @param writesCache
 * @param serverCache - Complete server cache, if we have it.
 * @param serverCacheComplete
 * @returns Events to raise.
 */
function syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
    const view = syncPointGetView(syncPoint, query, writesCache, serverCache, serverCacheComplete);
    if (!syncPoint.views.has(query._queryIdentifier)) {
        syncPoint.views.set(query._queryIdentifier, view);
    }
    // This is guaranteed to exist now, we just created anything that was missing
    viewAddEventRegistration(view, eventRegistration);
    return viewGetInitialEvents(view, eventRegistration);
}
/**
 * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
 *
 * If query is the default query, we'll check all views for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
 *
 * @param eventRegistration - If null, remove all callbacks.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @returns removed queries and any cancel events
 */
function syncPointRemoveEventRegistration(syncPoint, query, eventRegistration, cancelError) {
    const queryId = query._queryIdentifier;
    const removed = [];
    let cancelEvents = [];
    const hadCompleteView = syncPointHasCompleteView(syncPoint);
    if (queryId === 'default') {
        // When you do ref.off(...), we search all views for the registration to remove.
        for (const [viewQueryId, view] of syncPoint.views.entries()) {
            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
            if (viewIsEmpty(view)) {
                syncPoint.views.delete(viewQueryId);
                // We'll deal with complete views later.
                if (!view.query._queryParams.loadsAllData()) {
                    removed.push(view.query);
                }
            }
        }
    }
    else {
        // remove the callback from the specific view.
        const view = syncPoint.views.get(queryId);
        if (view) {
            cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
            if (viewIsEmpty(view)) {
                syncPoint.views.delete(queryId);
                // We'll deal with complete views later.
                if (!view.query._queryParams.loadsAllData()) {
                    removed.push(view.query);
                }
            }
        }
    }
    if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {
        // We removed our last complete view.
        removed.push(new (syncPointGetReferenceConstructor())(query._repo, query._path));
    }
    return { removed, events: cancelEvents };
}
function syncPointGetQueryViews(syncPoint) {
    const result = [];
    for (const view of syncPoint.views.values()) {
        if (!view.query._queryParams.loadsAllData()) {
            result.push(view);
        }
    }
    return result;
}
/**
 * @param path - The path to the desired complete snapshot
 * @returns A complete cache, if it exists
 */
function syncPointGetCompleteServerCache(syncPoint, path) {
    let serverCache = null;
    for (const view of syncPoint.views.values()) {
        serverCache = serverCache || viewGetCompleteServerCache(view, path);
    }
    return serverCache;
}
function syncPointViewForQuery(syncPoint, query) {
    const params = query._queryParams;
    if (params.loadsAllData()) {
        return syncPointGetCompleteView(syncPoint);
    }
    else {
        const queryId = query._queryIdentifier;
        return syncPoint.views.get(queryId);
    }
}
function syncPointViewExistsForQuery(syncPoint, query) {
    return syncPointViewForQuery(syncPoint, query) != null;
}
function syncPointHasCompleteView(syncPoint) {
    return syncPointGetCompleteView(syncPoint) != null;
}
function syncPointGetCompleteView(syncPoint) {
    for (const view of syncPoint.views.values()) {
        if (view.query._queryParams.loadsAllData()) {
            return view;
        }
    }
    return null;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let referenceConstructor;
function syncTreeSetReferenceConstructor(val) {
    assert(!referenceConstructor, '__referenceConstructor has already been defined');
    referenceConstructor = val;
}
function syncTreeGetReferenceConstructor() {
    assert(referenceConstructor, 'Reference.ts has not been loaded');
    return referenceConstructor;
}
/**
 * Static tracker for next query tag.
 */
let syncTreeNextQueryTag_ = 1;
/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 */
class SyncTree {
    /**
     * @param listenProvider_ - Used by SyncTree to start / stop listening
     *   to server data.
     */
    constructor(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        /**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         */
        this.syncPointTree_ = new ImmutableTree(null);
        /**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         */
        this.pendingWriteTree_ = newWriteTree();
        this.tagToQueryMap = new Map();
        this.queryToTagMap = new Map();
    }
}
/**
 * Apply the data changes for a user-generated set() or transaction() call.
 *
 * @returns Events to raise.
 */
function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {
    // Record pending write.
    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
    if (!visible) {
        return [];
    }
    else {
        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
    }
}
/**
 * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
 *
 * @param revert - True if the given write failed and needs to be reverted
 * @returns Events to raise.
 */
function syncTreeAckUserWrite(syncTree, writeId, revert = false) {
    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
    if (!needToReevaluate) {
        return [];
    }
    else {
        let affectedTree = new ImmutableTree(null);
        if (write.snap != null) {
            // overwrite
            affectedTree = affectedTree.set(newEmptyPath(), true);
        }
        else {
            each(write.children, (pathString) => {
                affectedTree = affectedTree.set(new Path(pathString), true);
            });
        }
        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));
    }
}
/**
 * Apply new server data for the specified path..
 *
 * @returns Events to raise.
 */
function syncTreeApplyServerOverwrite(syncTree, path, newData) {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
}
/**
 * Apply new server data to be merged in at the specified path.
 *
 * @returns Events to raise.
 */
function syncTreeApplyServerMerge(syncTree, path, changedChildren) {
    const changeTree = ImmutableTree.fromObject(changedChildren);
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
}
/**
 * Apply a listen complete for a query
 *
 * @returns Events to raise.
 */
function syncTreeApplyListenComplete(syncTree, path) {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));
}
/**
 * Apply a listen complete for a tagged query
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // We've already removed the query. No big deal, ignore the update
        return [];
    }
}
/**
 * Remove event callback(s).
 *
 * If query is the default query, we'll check all queries for the specified eventRegistration.
 * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
 *
 * @param eventRegistration - If null, all callbacks are removed.
 * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.
 * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no
 *  deduping needs to take place. This flag allows toggling of that behavior
 * @returns Cancel events, if cancelError was provided.
 */
function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) {
    // Find the syncPoint first. Then deal with whether or not it has matching listeners
    const path = query._path;
    const maybeSyncPoint = syncTree.syncPointTree_.get(path);
    let cancelEvents = [];
    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
    // not loadsAllData().
    if (maybeSyncPoint &&
        (query._queryIdentifier === 'default' ||
            syncPointViewExistsForQuery(maybeSyncPoint, query))) {
        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);
        if (syncPointIsEmpty(maybeSyncPoint)) {
            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);
        }
        const removed = removedAndEvents.removed;
        cancelEvents = removedAndEvents.events;
        if (!skipListenerDedup) {
            /**
             * We may have just removed one of many listeners and can short-circuit this whole process
             * We may also not have removed a default listener, in which case all of the descendant listeners should already be
             * properly set up.
             */
            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
            // queryId === 'default'
            const removingDefault = -1 !==
                removed.findIndex(query => {
                    return query._queryParams.loadsAllData();
                });
            const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint) => syncPointHasCompleteView(parentSyncPoint));
            if (removingDefault && !covered) {
                const subtree = syncTree.syncPointTree_.subtree(path);
                // There are potentially child listeners. Determine what if any listens we need to send before executing the
                // removal
                if (!subtree.isEmpty()) {
                    // We need to fold over our subtree and collect the listeners to send
                    const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
                    // Ok, we've collected all the listens we need. Set them up.
                    for (let i = 0; i < newViews.length; ++i) {
                        const view = newViews[i], newQuery = view.query;
                        const listener = syncTreeCreateListenerForView_(syncTree, view);
                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);
                    }
                }
                // Otherwise there's nothing below us, so nothing we need to start listening on
            }
            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.
            // Also, note that if we have a cancelError, it's already been removed at the provider level.
            if (!covered && removed.length > 0 && !cancelError) {
                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
                // default. Otherwise, we need to iterate through and cancel each individual query
                if (removingDefault) {
                    // We don't tag default listeners
                    const defaultTag = null;
                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);
                }
                else {
                    removed.forEach((queryToRemove) => {
                        const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
                    });
                }
            }
        }
        // Now, clear all of the tags we're tracking for the removed listens
        syncTreeRemoveTags_(syncTree, removed);
    }
    return cancelEvents;
}
/**
 * Apply new server data for the specified tagged query.
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey != null) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // Query must have been removed already
        return [];
    }
}
/**
 * Apply server data to be merged in for the specified tagged query.
 *
 * @returns Events to raise.
 */
function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {
    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
    if (queryKey) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const changeTree = ImmutableTree.fromObject(changedChildren);
        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
    }
    else {
        // We've already removed the query. No big deal, ignore the update
        return [];
    }
}
/**
 * Add an event callback for the specified query.
 *
 * @returns Events to raise.
 */
function syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener = false) {
    const path = query._path;
    let serverCache = null;
    let foundAncestorDefaultView = false;
    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
    // Consider optimizing this once there's a better understanding of what actual behavior will be.
    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {
        const relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(sp, relativePath);
        foundAncestorDefaultView =
            foundAncestorDefaultView || syncPointHasCompleteView(sp);
    });
    let syncPoint = syncTree.syncPointTree_.get(path);
    if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
    }
    else {
        foundAncestorDefaultView =
            foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
        serverCache =
            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    let serverCacheComplete;
    if (serverCache != null) {
        serverCacheComplete = true;
    }
    else {
        serverCacheComplete = false;
        serverCache = ChildrenNode.EMPTY_NODE;
        const subtree = syncTree.syncPointTree_.subtree(path);
        subtree.foreachChild((childName, childSyncPoint) => {
            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
            if (completeCache) {
                serverCache = serverCache.updateImmediateChild(childName, completeCache);
            }
        });
    }
    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);
    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {
        // We need to track a tag for this query
        const queryKey = syncTreeMakeQueryKey_(query);
        assert(!syncTree.queryToTagMap.has(queryKey), 'View does not exist, but we have a tag');
        const tag = syncTreeGetNextQueryTag_();
        syncTree.queryToTagMap.set(queryKey, tag);
        syncTree.tagToQueryMap.set(tag, queryKey);
    }
    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);
    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);
    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {
        const view = syncPointViewForQuery(syncPoint, query);
        events = events.concat(syncTreeSetupListener_(syncTree, query, view));
    }
    return events;
}
/**
 * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a
 * listener above it, we will get a false "null". This shouldn't be a problem because transactions will always
 * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->
 *     <incremented total> as the write is applied locally and then acknowledged at the server.
 *
 * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
 *
 * @param path - The path to the data we want
 * @param writeIdsToExclude - A specific set to be excluded
 */
function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {
    const includeHiddenSets = true;
    const writeTree = syncTree.pendingWriteTree_;
    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint) => {
        const relativePath = newRelativePath(pathSoFar, path);
        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);
        if (serverCache) {
            return serverCache;
        }
    });
    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
}
/**
 * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
 *
 * NOTES:
 * - Descendant SyncPoints will be visited first (since we raise events depth-first).
 *
 * - We call applyOperation() on each SyncPoint passing three things:
 *   1. A version of the Operation that has been made relative to the SyncPoint location.
 *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
 *   3. A snapshot Node with cached server data, if we have it.
 *
 * - We concatenate all of the events returned by each SyncPoint and return the result.
 */
function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {
    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, 
    /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));
}
/**
 * Recursive helper for applyOperationToSyncPoints_
 */
function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {
    if (pathIsEmpty(operation.path)) {
        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
    }
    else {
        const syncPoint = syncPointTree.get(newEmptyPath());
        // If we don't have cached server data, see if we can get it from this SyncPoint.
        if (serverCache == null && syncPoint != null) {
            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
        }
        let events = [];
        const childName = pathGetFront(operation.path);
        const childOperation = operation.operationForChild(childName);
        const childTree = syncPointTree.children.get(childName);
        if (childTree && childOperation) {
            const childServerCache = serverCache
                ? serverCache.getImmediateChild(childName)
                : null;
            const childWritesCache = writeTreeRefChild(writesCache, childName);
            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
        if (syncPoint) {
            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
        }
        return events;
    }
}
/**
 * Recursive helper for applyOperationToSyncPoints_
 */
function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {
    const syncPoint = syncPointTree.get(newEmptyPath());
    // If we don't have cached server data, see if we can get it from this SyncPoint.
    if (serverCache == null && syncPoint != null) {
        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    let events = [];
    syncPointTree.children.inorderTraversal((childName, childTree) => {
        const childServerCache = serverCache
            ? serverCache.getImmediateChild(childName)
            : null;
        const childWritesCache = writeTreeRefChild(writesCache, childName);
        const childOperation = operation.operationForChild(childName);
        if (childOperation) {
            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
    });
    if (syncPoint) {
        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
    }
    return events;
}
function syncTreeCreateListenerForView_(syncTree, view) {
    const query = view.query;
    const tag = syncTreeTagForQuery(syncTree, query);
    return {
        hashFn: () => {
            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
            return cache.hash();
        },
        onComplete: (status) => {
            if (status === 'ok') {
                if (tag) {
                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);
                }
                else {
                    return syncTreeApplyListenComplete(syncTree, query._path);
                }
            }
            else {
                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.
                // Note that this may need to be scoped to just this listener if we change permissions on filtered children
                const error = errorForServerCode(status, query);
                return syncTreeRemoveEventRegistration(syncTree, query, 
                /*eventRegistration*/ null, error);
            }
        }
    };
}
/**
 * Return the tag associated with the given query.
 */
function syncTreeTagForQuery(syncTree, query) {
    const queryKey = syncTreeMakeQueryKey_(query);
    return syncTree.queryToTagMap.get(queryKey);
}
/**
 * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
 */
function syncTreeMakeQueryKey_(query) {
    return query._path.toString() + '$' + query._queryIdentifier;
}
/**
 * Return the query associated with the given tag, if we have one
 */
function syncTreeQueryKeyForTag_(syncTree, tag) {
    return syncTree.tagToQueryMap.get(tag);
}
/**
 * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
 */
function syncTreeParseQueryKey_(queryKey) {
    const splitIndex = queryKey.indexOf('$');
    assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');
    return {
        queryId: queryKey.substr(splitIndex + 1),
        path: new Path(queryKey.substr(0, splitIndex))
    };
}
/**
 * A helper method to apply tagged operations
 */
function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {
    const syncPoint = syncTree.syncPointTree_.get(queryPath);
    assert(syncPoint, "Missing sync point for query tag that we're tracking");
    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
    return syncPointApplyOperation(syncPoint, operation, writesCache, null);
}
/**
 * This collapses multiple unfiltered views into a single view, since we only need a single
 * listener for them.
 */
function syncTreeCollectDistinctViewsForSubTree_(subtree) {
    return subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {
        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);
            return [completeView];
        }
        else {
            // No complete view here, flatten any deeper listens into an array
            let views = [];
            if (maybeChildSyncPoint) {
                views = syncPointGetQueryViews(maybeChildSyncPoint);
            }
            each(childMap, (_key, childViews) => {
                views = views.concat(childViews);
            });
            return views;
        }
    });
}
/**
 * Normalizes a query to a query we send the server for listening
 *
 * @returns The normalized query
 */
function syncTreeQueryForListening_(query) {
    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {
        // We treat queries that load all data as default queries
        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
        // from Query
        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);
    }
    else {
        return query;
    }
}
function syncTreeRemoveTags_(syncTree, queries) {
    for (let j = 0; j < queries.length; ++j) {
        const removedQuery = queries[j];
        if (!removedQuery._queryParams.loadsAllData()) {
            // We should have a tag for this
            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
            syncTree.queryToTagMap.delete(removedQueryKey);
            syncTree.tagToQueryMap.delete(removedQueryTag);
        }
    }
}
/**
 * Static accessor for query tags.
 */
function syncTreeGetNextQueryTag_() {
    return syncTreeNextQueryTag_++;
}
/**
 * For a given new listen, manage the de-duplication of outstanding subscriptions.
 *
 * @returns This method can return events to support synchronous data sources
 */
function syncTreeSetupListener_(syncTree, query, view) {
    const path = query._path;
    const tag = syncTreeTagForQuery(syncTree, query);
    const listener = syncTreeCreateListenerForView_(syncTree, view);
    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);
    const subtree = syncTree.syncPointTree_.subtree(path);
    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
    // may need to shadow other listens as well.
    if (tag) {
        assert(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
    }
    else {
        // Shadow everything at or below this location, this is a default listener.
        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {
            if (!pathIsEmpty(relativePath) &&
                maybeChildSyncPoint &&
                syncPointHasCompleteView(maybeChildSyncPoint)) {
                return [syncPointGetCompleteView(maybeChildSyncPoint).query];
            }
            else {
                // No default listener here, flatten any deeper queries into an array
                let queries = [];
                if (maybeChildSyncPoint) {
                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view => view.query));
                }
                each(childMap, (_key, childQueries) => {
                    queries = queries.concat(childQueries);
                });
                return queries;
            }
        });
        for (let i = 0; i < queriesToStop.length; ++i) {
            const queryToStop = queriesToStop[i];
            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));
        }
    }
    return events;
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ExistingValueProvider {
    constructor(node_) {
        this.node_ = node_;
    }
    getImmediateChild(childName) {
        const child = this.node_.getImmediateChild(childName);
        return new ExistingValueProvider(child);
    }
    node() {
        return this.node_;
    }
}
class DeferredValueProvider {
    constructor(syncTree, path) {
        this.syncTree_ = syncTree;
        this.path_ = path;
    }
    getImmediateChild(childName) {
        const childPath = pathChild(this.path_, childName);
        return new DeferredValueProvider(this.syncTree_, childPath);
    }
    node() {
        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
    }
}
/**
 * Generate placeholders for deferred values.
 */
const generateWithValues = function (values) {
    values = values || {};
    values['timestamp'] = values['timestamp'] || new Date().getTime();
    return values;
};
/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 */
const resolveDeferredLeafValue = function (value, existingVal, serverValues) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    assert('.sv' in value, 'Unexpected leaf node or priority contents');
    if (typeof value['.sv'] === 'string') {
        return resolveScalarDeferredValue(value['.sv'], existingVal, serverValues);
    }
    else if (typeof value['.sv'] === 'object') {
        return resolveComplexDeferredValue(value['.sv'], existingVal);
    }
    else {
        assert(false, 'Unexpected server value: ' + JSON.stringify(value, null, 2));
    }
};
const resolveScalarDeferredValue = function (op, existing, serverValues) {
    switch (op) {
        case 'timestamp':
            return serverValues['timestamp'];
        default:
            assert(false, 'Unexpected server value: ' + op);
    }
};
const resolveComplexDeferredValue = function (op, existing, unused) {
    if (!op.hasOwnProperty('increment')) {
        assert(false, 'Unexpected server value: ' + JSON.stringify(op, null, 2));
    }
    const delta = op['increment'];
    if (typeof delta !== 'number') {
        assert(false, 'Unexpected increment value: ' + delta);
    }
    const existingNode = existing.node();
    assert(existingNode !== null && typeof existingNode !== 'undefined', 'Expected ChildrenNode.EMPTY_NODE for nulls');
    // Incrementing a non-number sets the value to the incremented amount
    if (!existingNode.isLeafNode()) {
        return delta;
    }
    const leaf = existingNode;
    const existingVal = leaf.getValue();
    if (typeof existingVal !== 'number') {
        return delta;
    }
    // No need to do over/underflow arithmetic here because JS only handles floats under the covers
    return existingVal + delta;
};
/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param path - path to which write is relative
 * @param node - new data written at path
 * @param syncTree - current data
 */
const resolveDeferredValueTree = function (path, node, syncTree, serverValues) {
    return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
};
/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 */
const resolveDeferredValueSnapshot = function (node, existing, serverValues) {
    return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
};
function resolveDeferredValue(node, existingVal, serverValues) {
    const rawPri = node.getPriority().val();
    const priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild('.priority'), serverValues);
    let newNode;
    if (node.isLeafNode()) {
        const leafNode = node;
        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
        if (value !== leafNode.getValue() ||
            priority !== leafNode.getPriority().val()) {
            return new LeafNode(value, nodeFromJSON(priority));
        }
        else {
            return node;
        }
    }
    else {
        const childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) {
            newNode = newNode.updatePriority(new LeafNode(priority));
        }
        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
            const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
            if (newChildNode !== childNode) {
                newNode = newNode.updateImmediateChild(childName, newChildNode);
            }
        });
        return newNode;
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */
class Tree {
    /**
     * @param name - Optional name of the node.
     * @param parent - Optional parent node.
     * @param node - Optional node to wrap.
     */
    constructor(name = '', parent = null, node = { children: {}, childCount: 0 }) {
        this.name = name;
        this.parent = parent;
        this.node = node;
    }
}
/**
 * Returns a sub-Tree for the given path.
 *
 * @param pathObj - Path to look up.
 * @returns Tree for path.
 */
function treeSubTree(tree, pathObj) {
    // TODO: Require pathObj to be Path?
    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);
    let child = tree, next = pathGetFront(path);
    while (next !== null) {
        const childNode = safeGet(child.node.children, next) || {
            children: {},
            childCount: 0
        };
        child = new Tree(next, child, childNode);
        path = pathPopFront(path);
        next = pathGetFront(path);
    }
    return child;
}
/**
 * Returns the data associated with this tree node.
 *
 * @returns The data or null if no data exists.
 */
function treeGetValue(tree) {
    return tree.node.value;
}
/**
 * Sets data to this tree node.
 *
 * @param value - Value to set.
 */
function treeSetValue(tree, value) {
    tree.node.value = value;
    treeUpdateParents(tree);
}
/**
 * @returns Whether the tree has any children.
 */
function treeHasChildren(tree) {
    return tree.node.childCount > 0;
}
/**
 * @returns Whethe rthe tree is empty (no value or children).
 */
function treeIsEmpty(tree) {
    return treeGetValue(tree) === undefined && !treeHasChildren(tree);
}
/**
 * Calls action for each child of this tree node.
 *
 * @param action - Action to be called for each child.
 */
function treeForEachChild(tree, action) {
    each(tree.node.children, (child, childTree) => {
        action(new Tree(child, tree, childTree));
    });
}
/**
 * Does a depth-first traversal of this node's descendants, calling action for each one.
 *
 * @param action - Action to be called for each child.
 * @param includeSelf - Whether to call action on this node as well. Defaults to
 *   false.
 * @param childrenFirst - Whether to call action on children before calling it on
 *   parent.
 */
function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {
    if (includeSelf && !childrenFirst) {
        action(tree);
    }
    treeForEachChild(tree, child => {
        treeForEachDescendant(child, action, true, childrenFirst);
    });
    if (includeSelf && childrenFirst) {
        action(tree);
    }
}
/**
 * Calls action on each ancestor node.
 *
 * @param action - Action to be called on each parent; return
 *   true to abort.
 * @param includeSelf - Whether to call action on this node as well.
 * @returns true if the action callback returned true.
 */
function treeForEachAncestor(tree, action, includeSelf) {
    let node = includeSelf ? tree : tree.parent;
    while (node !== null) {
        if (action(node)) {
            return true;
        }
        node = node.parent;
    }
    return false;
}
/**
 * @returns The path of this tree node, as a Path.
 */
function treeGetPath(tree) {
    return new Path(tree.parent === null
        ? tree.name
        : treeGetPath(tree.parent) + '/' + tree.name);
}
/**
 * Adds or removes this child from its parent based on whether it's empty or not.
 */
function treeUpdateParents(tree) {
    if (tree.parent !== null) {
        treeUpdateChild(tree.parent, tree.name, tree);
    }
}
/**
 * Adds or removes the passed child to this tree node, depending on whether it's empty.
 *
 * @param childName - The name of the child to update.
 * @param child - The child to update.
 */
function treeUpdateChild(tree, childName, child) {
    const childEmpty = treeIsEmpty(child);
    const childExists = contains(tree.node.children, childName);
    if (childEmpty && childExists) {
        delete tree.node.children[childName];
        tree.node.childCount--;
        treeUpdateParents(tree);
    }
    else if (!childEmpty && !childExists) {
        tree.node.children[childName] = child.node;
        tree.node.childCount++;
        treeUpdateParents(tree);
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * True for invalid Firebase keys
 */
const INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 */
const INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
/**
 * Maximum number of characters to allow in leaf value
 */
const MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
const isValidKey = function (key) {
    return (typeof key === 'string' && key.length !== 0 && !INVALID_KEY_REGEX_.test(key));
};
const isValidPathString = function (pathString) {
    return (typeof pathString === 'string' &&
        pathString.length !== 0 &&
        !INVALID_PATH_REGEX_.test(pathString));
};
const isValidRootPathString = function (pathString) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    return isValidPathString(pathString);
};
const isValidPriority = function (priority) {
    return (priority === null ||
        typeof priority === 'string' ||
        (typeof priority === 'number' && !isInvalidJSONNumber(priority)) ||
        (priority &&
            typeof priority === 'object' &&
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            contains(priority, '.sv')));
};
/**
 * Pre-validate a datum passed as an argument to Firebase function.
 */
const validateFirebaseDataArg = function (fnName, value, path, optional) {
    if (optional && value === undefined) {
        return;
    }
    validateFirebaseData(errorPrefix(fnName, 'value'), value, path);
};
/**
 * Validate a data object client-side before sending to server.
 */
const validateFirebaseData = function (errorPrefix, data, path_) {
    const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;
    if (data === undefined) {
        throw new Error(errorPrefix + 'contains undefined ' + validationPathToErrorString(path));
    }
    if (typeof data === 'function') {
        throw new Error(errorPrefix +
            'contains a function ' +
            validationPathToErrorString(path) +
            ' with contents = ' +
            data.toString());
    }
    if (isInvalidJSONNumber(data)) {
        throw new Error(errorPrefix +
            'contains ' +
            data.toString() +
            ' ' +
            validationPathToErrorString(path));
    }
    // Check max leaf size, but try to avoid the utf8 conversion if we can.
    if (typeof data === 'string' &&
        data.length > MAX_LEAF_SIZE_ / 3 &&
        stringLength(data) > MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix +
            'contains a string greater than ' +
            MAX_LEAF_SIZE_ +
            ' utf8 bytes ' +
            validationPathToErrorString(path) +
            " ('" +
            data.substring(0, 50) +
            "...')");
    }
    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
    // to save extra walking of large objects.
    if (data && typeof data === 'object') {
        let hasDotValue = false;
        let hasActualChild = false;
        each(data, (key, value) => {
            if (key === '.value') {
                hasDotValue = true;
            }
            else if (key !== '.priority' && key !== '.sv') {
                hasActualChild = true;
                if (!isValidKey(key)) {
                    throw new Error(errorPrefix +
                        ' contains an invalid key (' +
                        key +
                        ') ' +
                        validationPathToErrorString(path) +
                        '.  Keys must be non-empty strings ' +
                        'and can\'t contain ".", "#", "$", "/", "[", or "]"');
                }
            }
            validationPathPush(path, key);
            validateFirebaseData(errorPrefix, value, path);
            validationPathPop(path);
        });
        if (hasDotValue && hasActualChild) {
            throw new Error(errorPrefix +
                ' contains ".value" child ' +
                validationPathToErrorString(path) +
                ' in addition to actual children.');
        }
    }
};
/**
 * @internal
 */
const validatePathString = function (fnName, argumentName, pathString, optional) {
    if (optional && pathString === undefined) {
        return;
    }
    if (!isValidPathString(pathString)) {
        throw new Error(errorPrefix(fnName, argumentName) +
            'was an invalid path = "' +
            pathString +
            '". Paths must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "[", or "]"');
    }
};
const validateRootPathString = function (fnName, argumentName, pathString, optional) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    validatePathString(fnName, argumentName, pathString, optional);
};
/**
 * @internal
 */
const validateWritablePath = function (fnName, path) {
    if (pathGetFront(path) === '.info') {
        throw new Error(fnName + " failed = Can't modify data under /.info/");
    }
};
const validateUrl = function (fnName, parsedUrl) {
    // TODO = Validate server better.
    const pathString = parsedUrl.path.toString();
    if (!(typeof parsedUrl.repoInfo.host === 'string') ||
        parsedUrl.repoInfo.host.length === 0 ||
        (!isValidKey(parsedUrl.repoInfo.namespace) &&
            parsedUrl.repoInfo.host.split(':')[0] !== 'localhost') ||
        (pathString.length !== 0 && !isValidRootPathString(pathString))) {
        throw new Error(errorPrefix(fnName, 'url') +
            'must be a valid firebase URL and ' +
            'the path can\'t contain ".", "#", "$", "[", or "]".');
    }
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 */
class EventQueue {
    constructor() {
        this.eventLists_ = [];
        /**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         */
        this.recursionDepth_ = 0;
    }
}
/**
 * @param eventDataList - The new events to queue.
 */
function eventQueueQueueEvents(eventQueue, eventDataList) {
    // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
    let currList = null;
    for (let i = 0; i < eventDataList.length; i++) {
        const data = eventDataList[i];
        const path = data.getPath();
        if (currList !== null && !pathEquals(path, currList.path)) {
            eventQueue.eventLists_.push(currList);
            currList = null;
        }
        if (currList === null) {
            currList = { events: [], path };
        }
        currList.events.push(data);
    }
    if (currList) {
        eventQueue.eventLists_.push(currList);
    }
}
/**
 * Queues the specified events and synchronously raises all events (including previously queued ones)
 * for the specified path.
 *
 * It is assumed that the new events are all for the specified path.
 *
 * @param path - The path to raise events for.
 * @param eventDataList - The new events to raise.
 */
function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {
    eventQueueQueueEvents(eventQueue, eventDataList);
    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathEquals(eventPath, path));
}
/**
 * Queues the specified events and synchronously raises all events (including previously queued ones) for
 * locations related to the specified change path (i.e. all ancestors and descendants).
 *
 * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
 *
 * @param changedPath - The path to raise events for.
 * @param eventDataList - The events to raise
 */
function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {
    eventQueueQueueEvents(eventQueue, eventDataList);
    eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, eventPath => pathContains(eventPath, changedPath) ||
        pathContains(changedPath, eventPath));
}
function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {
    eventQueue.recursionDepth_++;
    let sentAll = true;
    for (let i = 0; i < eventQueue.eventLists_.length; i++) {
        const eventList = eventQueue.eventLists_[i];
        if (eventList) {
            const eventPath = eventList.path;
            if (predicate(eventPath)) {
                eventListRaise(eventQueue.eventLists_[i]);
                eventQueue.eventLists_[i] = null;
            }
            else {
                sentAll = false;
            }
        }
    }
    if (sentAll) {
        eventQueue.eventLists_ = [];
    }
    eventQueue.recursionDepth_--;
}
/**
 * Iterates through the list and raises each event
 */
function eventListRaise(eventList) {
    for (let i = 0; i < eventList.events.length; i++) {
        const eventData = eventList.events[i];
        if (eventData !== null) {
            eventList.events[i] = null;
            const eventFn = eventData.getEventRunner();
            if (logger) {
                log('event: ' + eventData.toString());
            }
            exceptionGuard(eventFn);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const INTERRUPT_REASON = 'repo_interrupt';
/**
 * If a transaction does not succeed after 25 retries, we abort it. Among other
 * things this ensure that if there's ever a bug causing a mismatch between
 * client / server hashes for some data, we won't retry indefinitely.
 */
const MAX_TRANSACTION_RETRIES = 25;
/**
 * A connection to a single data repository.
 */
class Repo {
    constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {
        this.repoInfo_ = repoInfo_;
        this.forceRestClient_ = forceRestClient_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckProvider_ = appCheckProvider_;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        /** A list of data pieces and paths to be set when this client disconnects. */
        this.onDisconnect_ = newSparseSnapshotTree();
        /** Stores queues of outstanding transactions for Firebase locations. */
        this.transactionQueueTree_ = new Tree();
        // TODO: This should be @private but it's used by test_access.js and internal.js
        this.persistentConnection_ = null;
        // This key is intentionally not updated if RepoInfo is later changed or replaced
        this.key = this.repoInfo_.toURLString();
    }
    /**
     * @returns The URL corresponding to the root of this Firebase.
     */
    toString() {
        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);
    }
}
function repoStart(repo, appId, authOverride) {
    repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
    if (repo.forceRestClient_ || beingCrawled()) {
        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag) => {
            repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, repo.authTokenProvider_, repo.appCheckProvider_);
        // Minor hack: Fire onConnect immediately, since there's no actual connection.
        setTimeout(() => repoOnConnectStatus(repo, /* connectStatus= */ true), 0);
    }
    else {
        // Validate authOverride
        if (typeof authOverride !== 'undefined' && authOverride !== null) {
            if (typeof authOverride !== 'object') {
                throw new Error('Only objects are supported for option databaseAuthVariableOverride');
            }
            try {
                stringify(authOverride);
            }
            catch (e) {
                throw new Error('Invalid authOverride provided: ' + e);
            }
        }
        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag) => {
            repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, (connectStatus) => {
            repoOnConnectStatus(repo, connectStatus);
        }, (updates) => {
            repoOnServerInfoUpdate(repo, updates);
        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
        repo.server_ = repo.persistentConnection_;
    }
    repo.authTokenProvider_.addTokenChangeListener(token => {
        repo.server_.refreshAuthToken(token);
    });
    repo.appCheckProvider_.addTokenChangeListener(result => {
        repo.server_.refreshAppCheckToken(result.token);
    });
    // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
    // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
    repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, () => new StatsReporter(repo.stats_, repo.server_));
    // Used for .info.
    repo.infoData_ = new SnapshotHolder();
    repo.infoSyncTree_ = new SyncTree({
        startListening: (query, tag, currentHashFn, onComplete) => {
            let infoEvents = [];
            const node = repo.infoData_.getNode(query._path);
            // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
            // on initial data...
            if (!node.isEmpty()) {
                infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query._path, node);
                setTimeout(() => {
                    onComplete('ok');
                }, 0);
            }
            return infoEvents;
        },
        stopListening: () => { }
    });
    repoUpdateInfo(repo, 'connected', false);
    repo.serverSyncTree_ = new SyncTree({
        startListening: (query, tag, currentHashFn, onComplete) => {
            repo.server_.listen(query, currentHashFn, tag, (status, data) => {
                const events = onComplete(status, data);
                eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query._path, events);
            });
            // No synchronous events for network-backed sync trees
            return [];
        },
        stopListening: (query, tag) => {
            repo.server_.unlisten(query, tag);
        }
    });
}
/**
 * @returns The time in milliseconds, taking the server offset into account if we have one.
 */
function repoServerTime(repo) {
    const offsetNode = repo.infoData_.getNode(new Path('.info/serverTimeOffset'));
    const offset = offsetNode.val() || 0;
    return new Date().getTime() + offset;
}
/**
 * Generate ServerValues using some variables from the repo object.
 */
function repoGenerateServerValues(repo) {
    return generateWithValues({
        timestamp: repoServerTime(repo)
    });
}
/**
 * Called by realtime when we get new messages from the server.
 */
function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {
    // For testing.
    repo.dataUpdateCount++;
    const path = new Path(pathString);
    data = repo.interceptServerDataCallback_
        ? repo.interceptServerDataCallback_(pathString, data)
        : data;
    let events = [];
    if (tag) {
        if (isMerge) {
            const taggedChildren = map(data, (raw) => nodeFromJSON(raw));
            events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
        }
        else {
            const taggedSnap = nodeFromJSON(data);
            events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
        }
    }
    else if (isMerge) {
        const changedChildren = map(data, (raw) => nodeFromJSON(raw));
        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
    }
    else {
        const snap = nodeFromJSON(data);
        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
    }
    let affectedPath = path;
    if (events.length > 0) {
        // Since we have a listener outstanding for each transaction, receiving any events
        // is a proxy for some change having occurred.
        affectedPath = repoRerunTransactions(repo, path);
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
}
function repoOnConnectStatus(repo, connectStatus) {
    repoUpdateInfo(repo, 'connected', connectStatus);
    if (connectStatus === false) {
        repoRunOnDisconnectEvents(repo);
    }
}
function repoOnServerInfoUpdate(repo, updates) {
    each(updates, (key, value) => {
        repoUpdateInfo(repo, key, value);
    });
}
function repoUpdateInfo(repo, pathString, value) {
    const path = new Path('/.info/' + pathString);
    const newNode = nodeFromJSON(value);
    repo.infoData_.updateSnapshot(path, newNode);
    const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
}
function repoGetNextWriteId(repo) {
    return repo.nextWriteId_++;
}
function repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {
    repoLog(repo, 'set', {
        path: path.toString(),
        value: newVal,
        priority: newPriority
    });
    // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
    // (b) store unresolved paths on JSON parse
    const serverValues = repoGenerateServerValues(repo);
    const newNodeUnresolved = nodeFromJSON(newVal, newPriority);
    const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);
    const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);
    const writeId = repoGetNextWriteId(repo);
    const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);
    eventQueueQueueEvents(repo.eventQueue_, events);
    repo.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), (status, errorReason) => {
        const success = status === 'ok';
        if (!success) {
            warn('set at ' + path + ' failed: ' + status);
        }
        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
    const affectedPath = repoAbortTransactions(repo, path);
    repoRerunTransactions(repo, affectedPath);
    // We queued the events above, so just flush the queue here
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);
}
/**
 * Applies all of the changes stored up in the onDisconnect_ tree.
 */
function repoRunOnDisconnectEvents(repo) {
    repoLog(repo, 'onDisconnectEvents');
    const serverValues = repoGenerateServerValues(repo);
    const resolvedOnDisconnectTree = newSparseSnapshotTree();
    sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node) => {
        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
    });
    let events = [];
    sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap) => {
        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
        const affectedPath = repoAbortTransactions(repo, path);
        repoRerunTransactions(repo, affectedPath);
    });
    repo.onDisconnect_ = newSparseSnapshotTree();
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
}
function repoAddEventCallbackForQuery(repo, query, eventRegistration) {
    let events;
    if (pathGetFront(query._path) === '.info') {
        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query, eventRegistration);
    }
    else {
        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query, eventRegistration);
    }
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
}
function repoRemoveEventCallbackForQuery(repo, query, eventRegistration) {
    // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
    // a little bit by handling the return values anyways.
    let events;
    if (pathGetFront(query._path) === '.info') {
        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query, eventRegistration);
    }
    else {
        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query, eventRegistration);
    }
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query._path, events);
}
function repoInterrupt(repo) {
    if (repo.persistentConnection_) {
        repo.persistentConnection_.interrupt(INTERRUPT_REASON);
    }
}
function repoLog(repo, ...varArgs) {
    let prefix = '';
    if (repo.persistentConnection_) {
        prefix = repo.persistentConnection_.id + ':';
    }
    log(prefix, ...varArgs);
}
function repoCallOnCompleteCallback(repo, callback, status, errorReason) {
    if (callback) {
        exceptionGuard(() => {
            if (status === 'ok') {
                callback(null);
            }
            else {
                const code = (status || 'error').toUpperCase();
                let message = code;
                if (errorReason) {
                    message += ': ' + errorReason;
                }
                const error = new Error(message);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                error.code = code;
                callback(error);
            }
        });
    }
}
/**
 * @param excludeSets - A specific set to exclude
 */
function repoGetLatestState(repo, path, excludeSets) {
    return (syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) ||
        ChildrenNode.EMPTY_NODE);
}
/**
 * Sends any already-run transactions that aren't waiting for outstanding
 * transactions to complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively
 * with a particular transactionQueueTree node to recurse through the tree.
 *
 * @param node - transactionQueueTree node to start at.
 */
function repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {
    // Before recursing, make sure any completed transactions are removed.
    if (!node) {
        repoPruneCompletedTransactionsBelowNode(repo, node);
    }
    if (treeGetValue(node)) {
        const queue = repoBuildTransactionQueue(repo, node);
        assert(queue.length > 0, 'Sending zero length transaction queue');
        const allRun = queue.every((transaction) => transaction.status === 0 /* TransactionStatus.RUN */);
        // If they're all run (and not sent), we can send them.  Else, we must wait.
        if (allRun) {
            repoSendTransactionQueue(repo, treeGetPath(node), queue);
        }
    }
    else if (treeHasChildren(node)) {
        treeForEachChild(node, childNode => {
            repoSendReadyTransactions(repo, childNode);
        });
    }
}
/**
 * Given a list of run transactions, send them to the server and then handle
 * the result (success or failure).
 *
 * @param path - The location of the queue.
 * @param queue - Queue of transactions under the specified location.
 */
function repoSendTransactionQueue(repo, path, queue) {
    // Mark transactions as sent and increment retry count!
    const setsToIgnore = queue.map(txn => {
        return txn.currentWriteId;
    });
    const latestState = repoGetLatestState(repo, path, setsToIgnore);
    let snapToSend = latestState;
    const latestHash = latestState.hash();
    for (let i = 0; i < queue.length; i++) {
        const txn = queue[i];
        assert(txn.status === 0 /* TransactionStatus.RUN */, 'tryToSendTransactionQueue_: items in queue should all be run.');
        txn.status = 1 /* TransactionStatus.SENT */;
        txn.retryCount++;
        const relativePath = newRelativePath(path, txn.path);
        // If we've gotten to this point, the output snapshot must be defined.
        snapToSend = snapToSend.updateChild(relativePath /** @type {!Node} */, txn.currentOutputSnapshotRaw);
    }
    const dataToSend = snapToSend.val(true);
    const pathToSend = path;
    // Send the put.
    repo.server_.put(pathToSend.toString(), dataToSend, (status) => {
        repoLog(repo, 'transaction put response', {
            path: pathToSend.toString(),
            status
        });
        let events = [];
        if (status === 'ok') {
            // Queue up the callbacks and fire them after cleaning up all of our
            // transaction state, since the callback could trigger more
            // transactions or sets.
            const callbacks = [];
            for (let i = 0; i < queue.length; i++) {
                queue[i].status = 2 /* TransactionStatus.COMPLETED */;
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));
                if (queue[i].onComplete) {
                    // We never unset the output snapshot, and given that this
                    // transaction is complete, it should be set
                    callbacks.push(() => queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));
                }
                queue[i].unwatcher();
            }
            // Now remove the completed transactions.
            repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
            // There may be pending transactions that we can now send.
            repoSendReadyTransactions(repo, repo.transactionQueueTree_);
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
            // Finally, trigger onComplete callbacks.
            for (let i = 0; i < callbacks.length; i++) {
                exceptionGuard(callbacks[i]);
            }
        }
        else {
            // transactions are no longer sent.  Update their status appropriately.
            if (status === 'datastale') {
                for (let i = 0; i < queue.length; i++) {
                    if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) {
                        queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;
                    }
                    else {
                        queue[i].status = 0 /* TransactionStatus.RUN */;
                    }
                }
            }
            else {
                warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);
                for (let i = 0; i < queue.length; i++) {
                    queue[i].status = 4 /* TransactionStatus.NEEDS_ABORT */;
                    queue[i].abortReason = status;
                }
            }
            repoRerunTransactions(repo, path);
        }
    }, latestHash);
}
/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions. This
 * is the path at which events need to be raised for.
 *
 * @param changedPath - The path in mergedData that changed.
 * @returns The rootmost path that was affected by rerunning transactions.
 */
function repoRerunTransactions(repo, changedPath) {
    const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
    const path = treeGetPath(rootMostTransactionNode);
    const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);
    repoRerunTransactionQueue(repo, queue, path);
    return path;
}
/**
 * Does all the work of rerunning transactions (as well as cleans up aborted
 * transactions and whatnot).
 *
 * @param queue - The queue of transactions to run.
 * @param path - The path the queue is for.
 */
function repoRerunTransactionQueue(repo, queue, path) {
    if (queue.length === 0) {
        return; // Nothing to do!
    }
    // Queue up the callbacks and fire them after cleaning up all of our
    // transaction state, since the callback could trigger more transactions or
    // sets.
    const callbacks = [];
    let events = [];
    // Ignore all of the sets we're going to re-run.
    const txnsToRerun = queue.filter(q => {
        return q.status === 0 /* TransactionStatus.RUN */;
    });
    const setsToIgnore = txnsToRerun.map(q => {
        return q.currentWriteId;
    });
    for (let i = 0; i < queue.length; i++) {
        const transaction = queue[i];
        const relativePath = newRelativePath(path, transaction.path);
        let abortTransaction = false, abortReason;
        assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');
        if (transaction.status === 4 /* TransactionStatus.NEEDS_ABORT */) {
            abortTransaction = true;
            abortReason = transaction.abortReason;
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        }
        else if (transaction.status === 0 /* TransactionStatus.RUN */) {
            if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
                abortTransaction = true;
                abortReason = 'maxretry';
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
            }
            else {
                // This code reruns a transaction
                const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
                transaction.currentInputSnapshot = currentNode;
                const newData = queue[i].update(currentNode.val());
                if (newData !== undefined) {
                    validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);
                    let newDataNode = nodeFromJSON(newData);
                    const hasExplicitPriority = typeof newData === 'object' &&
                        newData != null &&
                        contains(newData, '.priority');
                    if (!hasExplicitPriority) {
                        // Keep the old priority if there wasn't a priority explicitly specified.
                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());
                    }
                    const oldWriteId = transaction.currentWriteId;
                    const serverValues = repoGenerateServerValues(repo);
                    const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
                    transaction.currentOutputSnapshotRaw = newDataNode;
                    transaction.currentOutputSnapshotResolved = newNodeResolved;
                    transaction.currentWriteId = repoGetNextWriteId(repo);
                    // Mutates setsToIgnore in place
                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
                    events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
                }
                else {
                    abortTransaction = true;
                    abortReason = 'nodata';
                    events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
                }
            }
        }
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        events = [];
        if (abortTransaction) {
            // Abort.
            queue[i].status = 2 /* TransactionStatus.COMPLETED */;
            // Removing a listener can trigger pruning which can muck with
            // mergedData/visibleData (as it prunes data). So defer the unwatcher
            // until we're done.
            (function (unwatcher) {
                setTimeout(unwatcher, Math.floor(0));
            })(queue[i].unwatcher);
            if (queue[i].onComplete) {
                if (abortReason === 'nodata') {
                    callbacks.push(() => queue[i].onComplete(null, false, queue[i].currentInputSnapshot));
                }
                else {
                    callbacks.push(() => queue[i].onComplete(new Error(abortReason), false, null));
                }
            }
        }
    }
    // Clean up completed transactions.
    repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
    // Now fire callbacks, now that we're in a good, known state.
    for (let i = 0; i < callbacks.length; i++) {
        exceptionGuard(callbacks[i]);
    }
    // Try to send the transaction result to the server.
    repoSendReadyTransactions(repo, repo.transactionQueueTree_);
}
/**
 * Returns the rootmost ancestor node of the specified path that has a pending
 * transaction on it, or just returns the node for the given path if there are
 * no pending transactions on any ancestor.
 *
 * @param path - The location to start at.
 * @returns The rootmost node with a transaction.
 */
function repoGetAncestorTransactionNode(repo, path) {
    let front;
    // Start at the root and walk deeper into the tree towards path until we
    // find a node with pending transactions.
    let transactionNode = repo.transactionQueueTree_;
    front = pathGetFront(path);
    while (front !== null && treeGetValue(transactionNode) === undefined) {
        transactionNode = treeSubTree(transactionNode, front);
        path = pathPopFront(path);
        front = pathGetFront(path);
    }
    return transactionNode;
}
/**
 * Builds the queue of all transactions at or below the specified
 * transactionNode.
 *
 * @param transactionNode
 * @returns The generated queue.
 */
function repoBuildTransactionQueue(repo, transactionNode) {
    // Walk any child transaction queues and aggregate them into a single queue.
    const transactionQueue = [];
    repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
    // Sort them by the order the transactions were created.
    transactionQueue.sort((a, b) => a.order - b.order);
    return transactionQueue;
}
function repoAggregateTransactionQueuesForNode(repo, node, queue) {
    const nodeQueue = treeGetValue(node);
    if (nodeQueue) {
        for (let i = 0; i < nodeQueue.length; i++) {
            queue.push(nodeQueue[i]);
        }
    }
    treeForEachChild(node, child => {
        repoAggregateTransactionQueuesForNode(repo, child, queue);
    });
}
/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 */
function repoPruneCompletedTransactionsBelowNode(repo, node) {
    const queue = treeGetValue(node);
    if (queue) {
        let to = 0;
        for (let from = 0; from < queue.length; from++) {
            if (queue[from].status !== 2 /* TransactionStatus.COMPLETED */) {
                queue[to] = queue[from];
                to++;
            }
        }
        queue.length = to;
        treeSetValue(node, queue.length > 0 ? queue : undefined);
    }
    treeForEachChild(node, childNode => {
        repoPruneCompletedTransactionsBelowNode(repo, childNode);
    });
}
/**
 * Aborts all transactions on ancestors or descendants of the specified path.
 * Called when doing a set() or update() since we consider them incompatible
 * with transactions.
 *
 * @param path - Path for which we want to abort related transactions.
 */
function repoAbortTransactions(repo, path) {
    const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
    const transactionNode = treeSubTree(repo.transactionQueueTree_, path);
    treeForEachAncestor(transactionNode, (node) => {
        repoAbortTransactionsOnNode(repo, node);
    });
    repoAbortTransactionsOnNode(repo, transactionNode);
    treeForEachDescendant(transactionNode, (node) => {
        repoAbortTransactionsOnNode(repo, node);
    });
    return affectedPath;
}
/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param node - Node to abort transactions for.
 */
function repoAbortTransactionsOnNode(repo, node) {
    const queue = treeGetValue(node);
    if (queue) {
        // Queue up the callbacks and fire them after cleaning up all of our
        // transaction state, since the callback could trigger more transactions
        // or sets.
        const callbacks = [];
        // Go through queue.  Any already-sent transactions must be marked for
        // abort, while the unsent ones can be immediately aborted and removed.
        let events = [];
        let lastSent = -1;
        for (let i = 0; i < queue.length; i++) {
            if (queue[i].status === 3 /* TransactionStatus.SENT_NEEDS_ABORT */) ;
            else if (queue[i].status === 1 /* TransactionStatus.SENT */) {
                assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');
                lastSent = i;
                // Mark transaction for abort when it comes back.
                queue[i].status = 3 /* TransactionStatus.SENT_NEEDS_ABORT */;
                queue[i].abortReason = 'set';
            }
            else {
                assert(queue[i].status === 0 /* TransactionStatus.RUN */, 'Unexpected transaction status in abort');
                // We can abort it immediately.
                queue[i].unwatcher();
                events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));
                if (queue[i].onComplete) {
                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, null));
                }
            }
        }
        if (lastSent === -1) {
            // We're not waiting for any sent transactions.  We can clear the queue.
            treeSetValue(node, undefined);
        }
        else {
            // Remove the transactions we aborted.
            queue.length = lastSent + 1;
        }
        // Now fire the callbacks.
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
        for (let i = 0; i < callbacks.length; i++) {
            exceptionGuard(callbacks[i]);
        }
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function decodePath(pathString) {
    let pathStringDecoded = '';
    const pieces = pathString.split('/');
    for (let i = 0; i < pieces.length; i++) {
        if (pieces[i].length > 0) {
            let piece = pieces[i];
            try {
                piece = decodeURIComponent(piece.replace(/\+/g, ' '));
            }
            catch (e) { }
            pathStringDecoded += '/' + piece;
        }
    }
    return pathStringDecoded;
}
/**
 * @returns key value hash
 */
function decodeQuery(queryString) {
    const results = {};
    if (queryString.charAt(0) === '?') {
        queryString = queryString.substring(1);
    }
    for (const segment of queryString.split('&')) {
        if (segment.length === 0) {
            continue;
        }
        const kv = segment.split('=');
        if (kv.length === 2) {
            results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
        }
        else {
            warn(`Invalid query segment '${segment}' in query '${queryString}'`);
        }
    }
    return results;
}
const parseRepoInfo = function (dataURL, nodeAdmin) {
    const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
    if (parsedUrl.domain === 'firebase.com') {
        fatal(parsedUrl.host +
            ' is no longer supported. ' +
            'Please use <YOUR FIREBASE>.firebaseio.com instead');
    }
    // Catch common error of uninitialized namespace value.
    if ((!namespace || namespace === 'undefined') &&
        parsedUrl.domain !== 'localhost') {
        fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');
    }
    if (!parsedUrl.secure) {
        warnIfPageIsSecure();
    }
    const webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';
    return {
        repoInfo: new RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly, nodeAdmin, 
        /*persistenceKey=*/ '', 
        /*includeNamespaceInQueryParams=*/ namespace !== parsedUrl.subdomain),
        path: new Path(parsedUrl.pathString)
    };
};
const parseDatabaseURL = function (dataURL) {
    // Default to empty strings in the event of a malformed string.
    let host = '', domain = '', subdomain = '', pathString = '', namespace = '';
    // Always default to SSL, unless otherwise specified.
    let secure = true, scheme = 'https', port = 443;
    // Don't do any validation here. The caller is responsible for validating the result of parsing.
    if (typeof dataURL === 'string') {
        // Parse scheme.
        let colonInd = dataURL.indexOf('//');
        if (colonInd >= 0) {
            scheme = dataURL.substring(0, colonInd - 1);
            dataURL = dataURL.substring(colonInd + 2);
        }
        // Parse host, path, and query string.
        let slashInd = dataURL.indexOf('/');
        if (slashInd === -1) {
            slashInd = dataURL.length;
        }
        let questionMarkInd = dataURL.indexOf('?');
        if (questionMarkInd === -1) {
            questionMarkInd = dataURL.length;
        }
        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
        if (slashInd < questionMarkInd) {
            // For pathString, questionMarkInd will always come after slashInd
            pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
        }
        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
        // If we have a port, use scheme for determining if it's secure.
        colonInd = host.indexOf(':');
        if (colonInd >= 0) {
            secure = scheme === 'https' || scheme === 'wss';
            port = parseInt(host.substring(colonInd + 1), 10);
        }
        else {
            colonInd = host.length;
        }
        const hostWithoutPort = host.slice(0, colonInd);
        if (hostWithoutPort.toLowerCase() === 'localhost') {
            domain = 'localhost';
        }
        else if (hostWithoutPort.split('.').length <= 2) {
            domain = hostWithoutPort;
        }
        else {
            // Interpret the subdomain of a 3 or more component URL as the namespace name.
            const dotInd = host.indexOf('.');
            subdomain = host.substring(0, dotInd).toLowerCase();
            domain = host.substring(dotInd + 1);
            // Normalize namespaces to lowercase to share storage / connection.
            namespace = subdomain;
        }
        // Always treat the value of the `ns` as the namespace name if it is present.
        if ('ns' in queryParams) {
            namespace = queryParams['ns'];
        }
    }
    return {
        host,
        port,
        domain,
        subdomain,
        secure,
        scheme,
        pathString,
        namespace
    };
};

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Modeled after base64 web-safe chars, but ordered by ASCII.
const PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
/**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */
const nextPushId = (function () {
    // Timestamp of last push, used to prevent local collisions if you push twice
    // in one ms.
    let lastPushTime = 0;
    // We generate 72-bits of randomness which get turned into 12 characters and
    // appended to the timestamp to prevent collisions with other clients. We
    // store the last characters we generated because in the event of a collision,
    // we'll use those same characters except "incremented" by one.
    const lastRandChars = [];
    return function (now) {
        const duplicateTime = now === lastPushTime;
        lastPushTime = now;
        let i;
        const timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) {
            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
            // NOTE: Can't use << here because javascript will convert to int and lose
            // the upper bits.
            now = Math.floor(now / 64);
        }
        assert(now === 0, 'Cannot push at time == 0');
        let id = timeStampChars.join('');
        if (!duplicateTime) {
            for (i = 0; i < 12; i++) {
                lastRandChars[i] = Math.floor(Math.random() * 64);
            }
        }
        else {
            // If the timestamp hasn't changed since last push, use the same random
            // number, except incremented by 1.
            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
                lastRandChars[i] = 0;
            }
            lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
            id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        assert(id.length === 20, 'nextPushId: Length should be 20.');
        return id;
    };
})();

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Encapsulates the data needed to raise an event
 */
class DataEvent {
    /**
     * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed
     * @param eventRegistration - The function to call to with the event data. User provided
     * @param snapshot - The data backing the event
     * @param prevName - Optional, the name of the previous child for child_* events.
     */
    constructor(eventType, eventRegistration, snapshot, prevName) {
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
    }
    getPath() {
        const ref = this.snapshot.ref;
        if (this.eventType === 'value') {
            return ref._path;
        }
        else {
            return ref.parent._path;
        }
    }
    getEventType() {
        return this.eventType;
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
    }
    toString() {
        return (this.getPath().toString() +
            ':' +
            this.eventType +
            ':' +
            stringify(this.snapshot.exportVal()));
    }
}
class CancelEvent {
    constructor(eventRegistration, error, path) {
        this.eventRegistration = eventRegistration;
        this.error = error;
        this.path = path;
    }
    getPath() {
        return this.path;
    }
    getEventType() {
        return 'cancel';
    }
    getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
    }
    toString() {
        return this.path.toString() + ':cancel';
    }
}

/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * A wrapper class that converts events from the database@exp SDK to the legacy
 * Database SDK. Events are not converted directly as event registration relies
 * on reference comparison of the original user callback (see `matches()`) and
 * relies on equality of the legacy SDK's `context` object.
 */
class CallbackContext {
    constructor(snapshotCallback, cancelCallback) {
        this.snapshotCallback = snapshotCallback;
        this.cancelCallback = cancelCallback;
    }
    onValue(expDataSnapshot, previousChildName) {
        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);
    }
    onCancel(error) {
        assert(this.hasCancelCallback, 'Raising a cancel event on a listener with no cancel callback');
        return this.cancelCallback.call(null, error);
    }
    get hasCancelCallback() {
        return !!this.cancelCallback;
    }
    matches(other) {
        return (this.snapshotCallback === other.snapshotCallback ||
            (this.snapshotCallback.userCallback !== undefined &&
                this.snapshotCallback.userCallback ===
                    other.snapshotCallback.userCallback &&
                this.snapshotCallback.context === other.snapshotCallback.context));
    }
}

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @internal
 */
class QueryImpl {
    /**
     * @hideconstructor
     */
    constructor(_repo, _path, _queryParams, _orderByCalled) {
        this._repo = _repo;
        this._path = _path;
        this._queryParams = _queryParams;
        this._orderByCalled = _orderByCalled;
    }
    get key() {
        if (pathIsEmpty(this._path)) {
            return null;
        }
        else {
            return pathGetBack(this._path);
        }
    }
    get ref() {
        return new ReferenceImpl(this._repo, this._path);
    }
    get _queryIdentifier() {
        const obj = queryParamsGetQueryObject(this._queryParams);
        const id = ObjectToUniqueKey(obj);
        return id === '{}' ? 'default' : id;
    }
    /**
     * An object representation of the query parameters used by this Query.
     */
    get _queryObject() {
        return queryParamsGetQueryObject(this._queryParams);
    }
    isEqual(other) {
        other = getModularInstance(other);
        if (!(other instanceof QueryImpl)) {
            return false;
        }
        const sameRepo = this._repo === other._repo;
        const samePath = pathEquals(this._path, other._path);
        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
        return sameRepo && samePath && sameQueryIdentifier;
    }
    toJSON() {
        return this.toString();
    }
    toString() {
        return this._repo.toString() + pathToUrlEncodedString(this._path);
    }
}
/**
 * Validates that no other order by call has been made
 */
function validateNoPreviousOrderByCall(query, fnName) {
    if (query._orderByCalled === true) {
        throw new Error(fnName + ": You can't combine multiple orderBy calls.");
    }
}
/**
 * Validates start/end values for queries.
 */
function validateQueryEndpoints(params) {
    let startNode = null;
    let endNode = null;
    if (params.hasStart()) {
        startNode = params.getIndexStartValue();
    }
    if (params.hasEnd()) {
        endNode = params.getIndexEndValue();
    }
    if (params.getIndex() === KEY_INDEX) {
        const tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +
            'startAt(), endAt(), or equalTo().';
        const wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), startAfter(), ' +
            'endAt(), endBefore(), or equalTo() must be a string.';
        if (params.hasStart()) {
            const startName = params.getIndexStartName();
            if (startName !== MIN_NAME) {
                throw new Error(tooManyArgsError);
            }
            else if (typeof startNode !== 'string') {
                throw new Error(wrongArgTypeError);
            }
        }
        if (params.hasEnd()) {
            const endName = params.getIndexEndName();
            if (endName !== MAX_NAME) {
                throw new Error(tooManyArgsError);
            }
            else if (typeof endNode !== 'string') {
                throw new Error(wrongArgTypeError);
            }
        }
    }
    else if (params.getIndex() === PRIORITY_INDEX) {
        if ((startNode != null && !isValidPriority(startNode)) ||
            (endNode != null && !isValidPriority(endNode))) {
            throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +
                'startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value ' +
                '(null, a number, or a string).');
        }
    }
    else {
        assert(params.getIndex() instanceof PathIndex ||
            params.getIndex() === VALUE_INDEX, 'unknown index type.');
        if ((startNode != null && typeof startNode === 'object') ||
            (endNode != null && typeof endNode === 'object')) {
            throw new Error('Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or ' +
                'equalTo() cannot be an object.');
        }
    }
}
/**
 * @internal
 */
class ReferenceImpl extends QueryImpl {
    /** @hideconstructor */
    constructor(repo, path) {
        super(repo, path, new QueryParams(), false);
    }
    get parent() {
        const parentPath = pathParent(this._path);
        return parentPath === null
            ? null
            : new ReferenceImpl(this._repo, parentPath);
    }
    get root() {
        let ref = this;
        while (ref.parent !== null) {
            ref = ref.parent;
        }
        return ref;
    }
}
/**
 * A `DataSnapshot` contains data from a Database location.
 *
 * Any time you read data from the Database, you receive the data as a
 * `DataSnapshot`. A `DataSnapshot` is passed to the event callbacks you attach
 * with `on()` or `once()`. You can extract the contents of the snapshot as a
 * JavaScript object by calling the `val()` method. Alternatively, you can
 * traverse into the snapshot by calling `child()` to return child snapshots
 * (which you could then call `val()` on).
 *
 * A `DataSnapshot` is an efficiently generated, immutable copy of the data at
 * a Database location. It cannot be modified and will never change (to modify
 * data, you always call the `set()` method on a `Reference` directly).
 */
class DataSnapshot {
    /**
     * @param _node - A SnapshotNode to wrap.
     * @param ref - The location this snapshot came from.
     * @param _index - The iteration order for this snapshot
     * @hideconstructor
     */
    constructor(_node, 
    /**
     * The location of this DataSnapshot.
     */
    ref, _index) {
        this._node = _node;
        this.ref = ref;
        this._index = _index;
    }
    /**
     * Gets the priority value of the data in this `DataSnapshot`.
     *
     * Applications need not use priority but can order collections by
     * ordinary properties (see
     * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}
     * ).
     */
    get priority() {
        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
        return this._node.getPriority().val();
    }
    /**
     * The key (last part of the path) of the location of this `DataSnapshot`.
     *
     * The last token in a Database location is considered its key. For example,
     * "ada" is the key for the /users/ada/ node. Accessing the key on any
     * `DataSnapshot` will return the key for the location that generated it.
     * However, accessing the key on the root URL of a Database will return
     * `null`.
     */
    get key() {
        return this.ref.key;
    }
    /** Returns the number of child properties of this `DataSnapshot`. */
    get size() {
        return this._node.numChildren();
    }
    /**
     * Gets another `DataSnapshot` for the location at the specified relative path.
     *
     * Passing a relative path to the `child()` method of a DataSnapshot returns
     * another `DataSnapshot` for the location at the specified relative path. The
     * relative path can either be a simple child name (for example, "ada") or a
     * deeper, slash-separated path (for example, "ada/name/first"). If the child
     * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`
     * whose value is `null`) is returned.
     *
     * @param path - A relative path to the location of child data.
     */
    child(path) {
        const childPath = new Path(path);
        const childRef = child(this.ref, path);
        return new DataSnapshot(this._node.getChild(childPath), childRef, PRIORITY_INDEX);
    }
    /**
     * Returns true if this `DataSnapshot` contains any data. It is slightly more
     * efficient than using `snapshot.val() !== null`.
     */
    exists() {
        return !this._node.isEmpty();
    }
    /**
     * Exports the entire contents of the DataSnapshot as a JavaScript object.
     *
     * The `exportVal()` method is similar to `val()`, except priority information
     * is included (if available), making it suitable for backing up your data.
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    exportVal() {
        return this._node.val(true);
    }
    /**
     * Enumerates the top-level children in the `DataSnapshot`.
     *
     * Because of the way JavaScript objects work, the ordering of data in the
     * JavaScript object returned by `val()` is not guaranteed to match the
     * ordering on the server nor the ordering of `onChildAdded()` events. That is
     * where `forEach()` comes in handy. It guarantees the children of a
     * `DataSnapshot` will be iterated in their query order.
     *
     * If no explicit `orderBy*()` method is used, results are returned
     * ordered by key (unless priorities are used, in which case, results are
     * returned by priority).
     *
     * @param action - A function that will be called for each child DataSnapshot.
     * The callback can return true to cancel further enumeration.
     * @returns true if enumeration was canceled due to your callback returning
     * true.
     */
    forEach(action) {
        if (this._node.isLeafNode()) {
            return false;
        }
        const childrenNode = this._node;
        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
        return !!childrenNode.forEachChild(this._index, (key, node) => {
            return action(new DataSnapshot(node, child(this.ref, key), PRIORITY_INDEX));
        });
    }
    /**
     * Returns true if the specified child path has (non-null) data.
     *
     * @param path - A relative path to the location of a potential child.
     * @returns `true` if data exists at the specified child path; else
     *  `false`.
     */
    hasChild(path) {
        const childPath = new Path(path);
        return !this._node.getChild(childPath).isEmpty();
    }
    /**
     * Returns whether or not the `DataSnapshot` has any non-`null` child
     * properties.
     *
     * You can use `hasChildren()` to determine if a `DataSnapshot` has any
     * children. If it does, you can enumerate them using `forEach()`. If it
     * doesn't, then either this snapshot contains a primitive value (which can be
     * retrieved with `val()`) or it is empty (in which case, `val()` will return
     * `null`).
     *
     * @returns true if this snapshot has any children; else false.
     */
    hasChildren() {
        if (this._node.isLeafNode()) {
            return false;
        }
        else {
            return !this._node.isEmpty();
        }
    }
    /**
     * Returns a JSON-serializable representation of this object.
     */
    toJSON() {
        return this.exportVal();
    }
    /**
     * Extracts a JavaScript value from a `DataSnapshot`.
     *
     * Depending on the data in a `DataSnapshot`, the `val()` method may return a
     * scalar type (string, number, or boolean), an array, or an object. It may
     * also return null, indicating that the `DataSnapshot` is empty (contains no
     * data).
     *
     * @returns The DataSnapshot's contents as a JavaScript value (Object,
     *   Array, string, number, boolean, or `null`).
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    val() {
        return this._node.val();
    }
}
/**
 *
 * Returns a `Reference` representing the location in the Database
 * corresponding to the provided path. If no path is provided, the `Reference`
 * will point to the root of the Database.
 *
 * @param db - The database instance to obtain a reference for.
 * @param path - Optional path representing the location the returned
 *   `Reference` will point. If not provided, the returned `Reference` will
 *   point to the root of the Database.
 * @returns If a path is provided, a `Reference`
 *   pointing to the provided path. Otherwise, a `Reference` pointing to the
 *   root of the Database.
 */
function ref(db, path) {
    db = getModularInstance(db);
    db._checkNotDeleted('ref');
    return path !== undefined ? child(db._root, path) : db._root;
}
/**
 * Gets a `Reference` for the location at the specified relative path.
 *
 * The relative path can either be a simple child name (for example, "ada") or
 * a deeper slash-separated path (for example, "ada/name/first").
 *
 * @param parent - The parent location.
 * @param path - A relative path from this location to the desired child
 *   location.
 * @returns The specified child location.
 */
function child(parent, path) {
    parent = getModularInstance(parent);
    if (pathGetFront(parent._path) === null) {
        validateRootPathString('child', 'path', path, false);
    }
    else {
        validatePathString('child', 'path', path, false);
    }
    return new ReferenceImpl(parent._repo, pathChild(parent._path, path));
}
/**
 * Generates a new child location using a unique key and returns its
 * `Reference`.
 *
 * This is the most common pattern for adding data to a collection of items.
 *
 * If you provide a value to `push()`, the value is written to the
 * generated location. If you don't pass a value, nothing is written to the
 * database and the child remains empty (but you can use the `Reference`
 * elsewhere).
 *
 * The unique keys generated by `push()` are ordered by the current time, so the
 * resulting list of items is chronologically sorted. The keys are also
 * designed to be unguessable (they contain 72 random bits of entropy).
 *
 * See {@link https://firebase.google.com/docs/database/web/lists-of-data#append_to_a_list_of_data | Append to a list of data}.
 * See {@link https://firebase.googleblog.com/2015/02/the-2120-ways-to-ensure-unique_68.html | The 2^120 Ways to Ensure Unique Identifiers}.
 *
 * @param parent - The parent location.
 * @param value - Optional value to be written at the generated location.
 * @returns Combined `Promise` and `Reference`; resolves when write is complete,
 * but can be used immediately as the `Reference` to the child location.
 */
function push(parent, value) {
    parent = getModularInstance(parent);
    validateWritablePath('push', parent._path);
    validateFirebaseDataArg('push', value, parent._path, true);
    const now = repoServerTime(parent._repo);
    const name = nextPushId(now);
    // push() returns a ThennableReference whose promise is fulfilled with a
    // regular Reference. We use child() to create handles to two different
    // references. The first is turned into a ThennableReference below by adding
    // then() and catch() methods and is used as the return value of push(). The
    // second remains a regular Reference and is used as the fulfilled value of
    // the first ThennableReference.
    const thennablePushRef = child(parent, name);
    const pushRef = child(parent, name);
    let promise;
    if (value != null) {
        promise = set(pushRef, value).then(() => pushRef);
    }
    else {
        promise = Promise.resolve(pushRef);
    }
    thennablePushRef.then = promise.then.bind(promise);
    thennablePushRef.catch = promise.then.bind(promise, undefined);
    return thennablePushRef;
}
/**
 * Writes data to this Database location.
 *
 * This will overwrite any data at this location and all child locations.
 *
 * The effect of the write will be visible immediately, and the corresponding
 * events ("value", "child_added", etc.) will be triggered. Synchronization of
 * the data to the Firebase servers will also be started, and the returned
 * Promise will resolve when complete. If provided, the `onComplete` callback
 * will be called asynchronously after synchronization has finished.
 *
 * Passing `null` for the new value is equivalent to calling `remove()`; namely,
 * all data at this location and all child locations will be deleted.
 *
 * `set()` will remove any priority stored at this location, so if priority is
 * meant to be preserved, you need to use `setWithPriority()` instead.
 *
 * Note that modifying data with `set()` will cancel any pending transactions
 * at that location, so extreme care should be taken if mixing `set()` and
 * `transaction()` to modify the same data.
 *
 * A single `set()` will generate a single "value" event at the location where
 * the `set()` was performed.
 *
 * @param ref - The location to write to.
 * @param value - The value to be written (string, number, boolean, object,
 *   array, or null).
 * @returns Resolves when write to server is complete.
 */
function set(ref, value) {
    ref = getModularInstance(ref);
    validateWritablePath('set', ref._path);
    validateFirebaseDataArg('set', value, ref._path, false);
    const deferred = new Deferred();
    repoSetWithPriority(ref._repo, ref._path, value, 
    /*priority=*/ null, deferred.wrapCallback(() => { }));
    return deferred.promise;
}
/**
 * Represents registration for 'value' events.
 */
class ValueEventRegistration {
    constructor(callbackContext) {
        this.callbackContext = callbackContext;
    }
    respondsTo(eventType) {
        return eventType === 'value';
    }
    createEvent(change, query) {
        const index = query._queryParams.getIndex();
        return new DataEvent('value', this, new DataSnapshot(change.snapshotNode, new ReferenceImpl(query._repo, query._path), index));
    }
    getEventRunner(eventData) {
        if (eventData.getEventType() === 'cancel') {
            return () => this.callbackContext.onCancel(eventData.error);
        }
        else {
            return () => this.callbackContext.onValue(eventData.snapshot, null);
        }
    }
    createCancelEvent(error, path) {
        if (this.callbackContext.hasCancelCallback) {
            return new CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    }
    matches(other) {
        if (!(other instanceof ValueEventRegistration)) {
            return false;
        }
        else if (!other.callbackContext || !this.callbackContext) {
            // If no callback specified, we consider it to match any callback.
            return true;
        }
        else {
            return other.callbackContext.matches(this.callbackContext);
        }
    }
    hasAnyCallback() {
        return this.callbackContext !== null;
    }
}
/**
 * Represents the registration of a child_x event.
 */
class ChildEventRegistration {
    constructor(eventType, callbackContext) {
        this.eventType = eventType;
        this.callbackContext = callbackContext;
    }
    respondsTo(eventType) {
        let eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;
        eventToCheck =
            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;
        return this.eventType === eventToCheck;
    }
    createCancelEvent(error, path) {
        if (this.callbackContext.hasCancelCallback) {
            return new CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    }
    createEvent(change, query) {
        assert(change.childName != null, 'Child events should have a childName.');
        const childRef = child(new ReferenceImpl(query._repo, query._path), change.childName);
        const index = query._queryParams.getIndex();
        return new DataEvent(change.type, this, new DataSnapshot(change.snapshotNode, childRef, index), change.prevName);
    }
    getEventRunner(eventData) {
        if (eventData.getEventType() === 'cancel') {
            return () => this.callbackContext.onCancel(eventData.error);
        }
        else {
            return () => this.callbackContext.onValue(eventData.snapshot, eventData.prevName);
        }
    }
    matches(other) {
        if (other instanceof ChildEventRegistration) {
            return (this.eventType === other.eventType &&
                (!this.callbackContext ||
                    !other.callbackContext ||
                    this.callbackContext.matches(other.callbackContext)));
        }
        return false;
    }
    hasAnyCallback() {
        return !!this.callbackContext;
    }
}
function addEventListener(query, eventType, callback, cancelCallbackOrListenOptions, options) {
    let cancelCallback;
    if (typeof cancelCallbackOrListenOptions === 'object') {
        cancelCallback = undefined;
        options = cancelCallbackOrListenOptions;
    }
    if (typeof cancelCallbackOrListenOptions === 'function') {
        cancelCallback = cancelCallbackOrListenOptions;
    }
    if (options && options.onlyOnce) {
        const userCallback = callback;
        const onceCallback = (dataSnapshot, previousChildName) => {
            repoRemoveEventCallbackForQuery(query._repo, query, container);
            userCallback(dataSnapshot, previousChildName);
        };
        onceCallback.userCallback = callback.userCallback;
        onceCallback.context = callback.context;
        callback = onceCallback;
    }
    const callbackContext = new CallbackContext(callback, cancelCallback || undefined);
    const container = eventType === 'value'
        ? new ValueEventRegistration(callbackContext)
        : new ChildEventRegistration(eventType, callbackContext);
    repoAddEventCallbackForQuery(query._repo, query, container);
    return () => repoRemoveEventCallbackForQuery(query._repo, query, container);
}
function onValue(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'value', callback, cancelCallbackOrListenOptions, options);
}
function onChildAdded(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_added', callback, cancelCallbackOrListenOptions, options);
}
function onChildChanged(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_changed', callback, cancelCallbackOrListenOptions, options);
}
function onChildMoved(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_moved', callback, cancelCallbackOrListenOptions, options);
}
function onChildRemoved(query, callback, cancelCallbackOrListenOptions, options) {
    return addEventListener(query, 'child_removed', callback, cancelCallbackOrListenOptions, options);
}
/**
 * A `QueryConstraint` is used to narrow the set of documents returned by a
 * Database query. `QueryConstraint`s are created by invoking {@link endAt},
 * {@link endBefore}, {@link startAt}, {@link startAfter}, {@link
 * limitToFirst}, {@link limitToLast}, {@link orderByChild},
 * {@link orderByChild}, {@link orderByKey} , {@link orderByPriority} ,
 * {@link orderByValue}  or {@link equalTo} and
 * can then be passed to {@link query} to create a new query instance that
 * also contains this `QueryConstraint`.
 */
class QueryConstraint {
}
class QueryOrderByChildConstraint extends QueryConstraint {
    constructor(_path) {
        super();
        this._path = _path;
    }
    _apply(query) {
        validateNoPreviousOrderByCall(query, 'orderByChild');
        const parsedPath = new Path(this._path);
        if (pathIsEmpty(parsedPath)) {
            throw new Error('orderByChild: cannot pass in empty path. Use orderByValue() instead.');
        }
        const index = new PathIndex(parsedPath);
        const newParams = queryParamsOrderBy(query._queryParams, index);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    }
}
/**
 * Creates a new `QueryConstraint` that orders by the specified child key.
 *
 * Queries can only order by one key at a time. Calling `orderByChild()`
 * multiple times on the same query is an error.
 *
 * Firebase queries allow you to order your data by any child key on the fly.
 * However, if you know in advance what your indexes will be, you can define
 * them via the .indexOn rule in your Security Rules for better performance. See
 * the{@link https://firebase.google.com/docs/database/security/indexing-data}
 * rule for more information.
 *
 * You can read more about `orderByChild()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 *
 * @param path - The path to order by.
 */
function orderByChild(path) {
    if (path === '$key') {
        throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
    }
    else if (path === '$priority') {
        throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
    }
    else if (path === '$value') {
        throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
    }
    validatePathString('orderByChild', 'path', path, false);
    return new QueryOrderByChildConstraint(path);
}
class QueryOrderByKeyConstraint extends QueryConstraint {
    _apply(query) {
        validateNoPreviousOrderByCall(query, 'orderByKey');
        const newParams = queryParamsOrderBy(query._queryParams, KEY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    }
}
/**
 * Creates a new `QueryConstraint` that orders by the key.
 *
 * Sorts the results of a query by their (ascending) key values.
 *
 * You can read more about `orderByKey()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */
function orderByKey() {
    return new QueryOrderByKeyConstraint();
}
class QueryOrderByValueConstraint extends QueryConstraint {
    _apply(query) {
        validateNoPreviousOrderByCall(query, 'orderByValue');
        const newParams = queryParamsOrderBy(query._queryParams, VALUE_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(query._repo, query._path, newParams, 
        /*orderByCalled=*/ true);
    }
}
/**
 * Creates a new `QueryConstraint` that orders by value.
 *
 * If the children of a query are all scalar values (string, number, or
 * boolean), you can order the results by their (ascending) values.
 *
 * You can read more about `orderByValue()` in
 * {@link https://firebase.google.com/docs/database/web/lists-of-data#sort_data | Sort data}.
 */
function orderByValue() {
    return new QueryOrderByValueConstraint();
}
/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */
syncPointSetReferenceConstructor(ReferenceImpl);
syncTreeSetReferenceConstructor(ReferenceImpl);

/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This variable is also defined in the firebase Node.js Admin SDK. Before
 * modifying this definition, consult the definition in:
 *
 * https://github.com/firebase/firebase-admin-node
 *
 * and make sure the two are consistent.
 */
const FIREBASE_DATABASE_EMULATOR_HOST_VAR = 'FIREBASE_DATABASE_EMULATOR_HOST';
/**
 * Creates and caches `Repo` instances.
 */
const repos = {};
/**
 * If true, any new `Repo` will be created to use `ReadonlyRestClient` (for testing purposes).
 */
let useRestClient = false;
/**
 * Update an existing `Repo` in place to point to a new host/port.
 */
function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {
    repo.repoInfo_ = new RepoInfo(`${host}:${port}`, 
    /* secure= */ false, repo.repoInfo_.namespace, repo.repoInfo_.webSocketOnly, repo.repoInfo_.nodeAdmin, repo.repoInfo_.persistenceKey, repo.repoInfo_.includeNamespaceInQueryParams, 
    /*isUsingEmulator=*/ true);
    if (tokenProvider) {
        repo.authTokenProvider_ = tokenProvider;
    }
}
/**
 * This function should only ever be called to CREATE a new database instance.
 * @internal
 */
function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {
    let dbUrl = url || app.options.databaseURL;
    if (dbUrl === undefined) {
        if (!app.options.projectId) {
            fatal("Can't determine Firebase Database URL. Be sure to include " +
                ' a Project ID when calling firebase.initializeApp().');
        }
        log('Using default host for project ', app.options.projectId);
        dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;
    }
    let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
    let repoInfo = parsedUrl.repoInfo;
    let isEmulator;
    let dbEmulatorHost = undefined;
    if (typeof process !== 'undefined' && process.env) {
        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
    }
    if (dbEmulatorHost) {
        isEmulator = true;
        dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;
        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
        repoInfo = parsedUrl.repoInfo;
    }
    else {
        isEmulator = !parsedUrl.repoInfo.secure;
    }
    const authTokenProvider = nodeAdmin && isEmulator
        ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)
        : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);
    validateUrl('Invalid Firebase Database URL', parsedUrl);
    if (!pathIsEmpty(parsedUrl.path)) {
        fatal('Database URL must point to the root of a Firebase Database ' +
            '(not including a child path).');
    }
    const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));
    return new Database(repo, app);
}
/**
 * Remove the repo and make sure it is disconnected.
 *
 */
function repoManagerDeleteRepo(repo, appName) {
    const appRepos = repos[appName];
    // This should never happen...
    if (!appRepos || appRepos[repo.key] !== repo) {
        fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);
    }
    repoInterrupt(repo);
    delete appRepos[repo.key];
}
/**
 * Ensures a repo doesn't already exist and then creates one using the
 * provided app.
 *
 * @param repoInfo - The metadata about the Repo
 * @returns The Repo object for the specified server / repoName.
 */
function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {
    let appRepos = repos[app.name];
    if (!appRepos) {
        appRepos = {};
        repos[app.name] = appRepos;
    }
    let repo = appRepos[repoInfo.toURLString()];
    if (repo) {
        fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');
    }
    repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
    appRepos[repoInfo.toURLString()] = repo;
    return repo;
}
/**
 * Class representing a Firebase Realtime Database.
 */
class Database {
    /** @hideconstructor */
    constructor(_repoInternal, 
    /** The {@link @firebase/app#FirebaseApp} associated with this Realtime Database instance. */
    app) {
        this._repoInternal = _repoInternal;
        this.app = app;
        /** Represents a `Database` instance. */
        this['type'] = 'database';
        /** Track if the instance has been used (root or repo accessed) */
        this._instanceStarted = false;
    }
    get _repo() {
        if (!this._instanceStarted) {
            repoStart(this._repoInternal, this.app.options.appId, this.app.options['databaseAuthVariableOverride']);
            this._instanceStarted = true;
        }
        return this._repoInternal;
    }
    get _root() {
        if (!this._rootInternal) {
            this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
        }
        return this._rootInternal;
    }
    _delete() {
        if (this._rootInternal !== null) {
            repoManagerDeleteRepo(this._repo, this.app.name);
            this._repoInternal = null;
            this._rootInternal = null;
        }
        return Promise.resolve();
    }
    _checkNotDeleted(apiName) {
        if (this._rootInternal === null) {
            fatal('Cannot call ' + apiName + ' on a deleted database.');
        }
    }
}
/**
 * Returns the instance of the Realtime Database SDK that is associated
 * with the provided {@link @firebase/app#FirebaseApp}. Initializes a new instance with
 * with default settings if no instance exists or if the existing instance uses
 * a custom database URL.
 *
 * @param app - The {@link @firebase/app#FirebaseApp} instance that the returned Realtime
 * Database instance is associated with.
 * @param url - The URL of the Realtime Database instance to connect to. If not
 * provided, the SDK connects to the default instance of the Firebase App.
 * @returns The `Database` instance of the provided app.
 */
function getDatabase(app = getApp(), url) {
    const db = _getProvider(app, 'database').getImmediate({
        identifier: url
    });
    if (!db._instanceStarted) {
        const emulator = getDefaultEmulatorHostnameAndPort('database');
        if (emulator) {
            connectDatabaseEmulator(db, ...emulator);
        }
    }
    return db;
}
/**
 * Modify the provided instance to communicate with the Realtime Database
 * emulator.
 *
 * <p>Note: This method must be called before performing any other operation.
 *
 * @param db - The instance to modify.
 * @param host - The emulator host (ex: localhost)
 * @param port - The emulator port (ex: 8080)
 * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules
 */
function connectDatabaseEmulator(db, host, port, options = {}) {
    db = getModularInstance(db);
    db._checkNotDeleted('useEmulator');
    if (db._instanceStarted) {
        fatal('Cannot call useEmulator() after instance has already been initialized.');
    }
    const repo = db._repoInternal;
    let tokenProvider = undefined;
    if (repo.repoInfo_.nodeAdmin) {
        if (options.mockUserToken) {
            fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');
        }
        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);
    }
    else if (options.mockUserToken) {
        const token = typeof options.mockUserToken === 'string'
            ? options.mockUserToken
            : createMockUserToken(options.mockUserToken, db.app.options.projectId);
        tokenProvider = new EmulatorTokenProvider(token);
    }
    // Modify the repo to apply emulator settings
    repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);
}

/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerDatabase(variant) {
    setSDKVersion(SDK_VERSION$1);
    _registerComponent(new Component('database', (container, { instanceIdentifier: url }) => {
        const app = container.getProvider('app').getImmediate();
        const authProvider = container.getProvider('auth-internal');
        const appCheckProvider = container.getProvider('app-check-internal');
        return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url);
    }, "PUBLIC" /* ComponentType.PUBLIC */).setMultipleInstances(true));
    registerVersion(name, version, variant);
    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation
    registerVersion(name, version, 'esm2017');
}
// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {
    this.sendRequest('q', { p: pathString }, onComplete);
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
PersistentConnection.prototype.echo = function (data, onEcho) {
    this.sendRequest('echo', { d: data }, onEcho);
};

/**
 * Firebase Realtime Database
 *
 * @packageDocumentation
 */
registerDatabase();

const _database = {};
_database.getDatabase = wrapper("getDatabase", getDatabase);
_database.onValue = wrapper("onValue", onValue);
_database.ref = wrapper("ref", ref);
_database.DataSnapshot = DataSnapshot;
_database.push = wrapper("push", push);
_database.onChildAdded = wrapper("onChildAdded", onChildAdded);
_database.onChildChanged = wrapper("onChildChanged", onChildChanged);
_database.onChildRemoved = wrapper("onChildRemoved", onChildRemoved);
_database.onChildMoved = wrapper("onChildMoved", onChildMoved);
_database.orderByChild = wrapper("orderByChild", orderByChild);
_database.orderByKey = wrapper("orderByKey", orderByKey);
_database.orderByValue = wrapper("orderByValue", orderByValue);
const database$1 = _database;

const app = app$1;
const database = database$1;

export { app, database };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyIuLi9qcy9oZWxwZXIudHMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vQGZpcmViYXNlK3V0aWxAMS45LjMvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvaW5kZXguZXNtMjAxNy5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZmlyZWJhc2UrY29tcG9uZW50QDAuNi40L25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvY29tcG9uZW50L2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vQGZpcmViYXNlK2xvZ2dlckAwLjQuMC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2xvZ2dlci9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lkYkA3LjAuMS9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL3dyYXAtaWRiLXZhbHVlLmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lkYkA3LjAuMS9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BmaXJlYmFzZSthcHBAMC45Ljgvbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcyIsIi4uL25vZGVfbW9kdWxlcy8ucG5wbS9maXJlYmFzZUA5LjIwLjAvbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5lc20uanMiLCIuLi9qcy9hcHAudHMiLCIuLi9ub2RlX21vZHVsZXMvLnBucG0vQGZpcmViYXNlK2RhdGFiYXNlQDAuMTQuNC9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvaW5kZXguZXNtMjAxNy5qcyIsIi4uL2pzL2RhdGFiYXNlLnRzIiwiLi4vanMvYnVuZGxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiB3cmFwcGVyPEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+LCBSZXR1cm4+KG5hbWU6IFN0cmluZywgY2FsbGJhY2s6ICguLi5hcmdzOiBBcmdzKSA9PiBSZXR1cm4pIHtcblx0cmV0dXJuICguLi5hcmdzOiBBcmdzKSA9PiB7XG5cdFx0Y29uc29sZS5pbmZvKGBmaXJlYmFzZS1qcy1zeXM6IENhbGxpbmcgJyR7bmFtZX0nIHdpdGggYXJnczpgLCBhcmdzKVxuXHRcdGNvbnN0IHJldHVybmVkID0gY2FsbGJhY2soLi4uYXJncylcblx0XHRpZiAocmV0dXJuZWQpIHtcblx0XHRcdGNvbnNvbGUuaW5mbyhgZmlyZWJhc2UtanMtc3lzOiAnJHtuYW1lfScgcmV0dXJuZWQ6YCwgcmV0dXJuZWQpXG5cdFx0fVxuXHRcdHJldHVybiByZXR1cm5lZFxuXHR9XG59IiwiLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEBmaWxlb3ZlcnZpZXcgRmlyZWJhc2UgY29uc3RhbnRzLiAgU29tZSBvZiB0aGVzZSAoQGRlZmluZXMpIGNhbiBiZSBvdmVycmlkZGVuIGF0IGNvbXBpbGUtdGltZS5cclxuICovXHJcbmNvbnN0IENPTlNUQU5UUyA9IHtcclxuICAgIC8qKlxyXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBjbGllbnQgTm9kZS5qcyBTREsuXHJcbiAgICAgKi9cclxuICAgIE5PREVfQ0xJRU5UOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIHRoZSBBZG1pbiBOb2RlLmpzIFNESy5cclxuICAgICAqL1xyXG4gICAgTk9ERV9BRE1JTjogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIEZpcmViYXNlIFNESyBWZXJzaW9uXHJcbiAgICAgKi9cclxuICAgIFNES19WRVJTSU9OOiAnJHtKU0NPUkVfVkVSU0lPTn0nXHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHByb3ZpZGVkIGFzc2VydGlvbiBpcyBmYWxzeVxyXG4gKi9cclxuY29uc3QgYXNzZXJ0ID0gZnVuY3Rpb24gKGFzc2VydGlvbiwgbWVzc2FnZSkge1xyXG4gICAgaWYgKCFhc3NlcnRpb24pIHtcclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgYW4gRXJyb3Igb2JqZWN0IHN1aXRhYmxlIGZvciB0aHJvd2luZy5cclxuICovXHJcbmNvbnN0IGFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgIHJldHVybiBuZXcgRXJyb3IoJ0ZpcmViYXNlIERhdGFiYXNlICgnICtcclxuICAgICAgICBDT05TVEFOVFMuU0RLX1ZFUlNJT04gK1xyXG4gICAgICAgICcpIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6ICcgK1xyXG4gICAgICAgIG1lc3NhZ2UpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSQxID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcclxuICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgbGV0IHAgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiA2KSB8IDE5MjtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiZcclxuICAgICAgICAgICAgaSArIDEgPCBzdHIubGVuZ3RoICYmXHJcbiAgICAgICAgICAgIChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZjMDApID09PSAweGRjMDApIHtcclxuICAgICAgICAgICAgLy8gU3Vycm9nYXRlIFBhaXJcclxuICAgICAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHgwM2ZmKTtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDEyKSB8IDIyNDtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuLyoqXHJcbiAqIFR1cm5zIGFuIGFycmF5IG9mIG51bWJlcnMgaW50byB0aGUgc3RyaW5nIGdpdmVuIGJ5IHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxyXG4gKiBjaGFyYWN0ZXJzIHRvIHdoaWNoIHRoZSBudW1iZXJzIGNvcnJlc3BvbmQuXHJcbiAqIEBwYXJhbSBieXRlcyBBcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyBjaGFyYWN0ZXJzLlxyXG4gKiBAcmV0dXJuIFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXHJcbiAqL1xyXG5jb25zdCBieXRlQXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlcykge1xyXG4gICAgLy8gVE9ETyh1c2VyKTogVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMgaWYvd2hlbiBhdmFpbGFibGVcclxuICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgbGV0IHBvcyA9IDAsIGMgPSAwO1xyXG4gICAgd2hpbGUgKHBvcyA8IGJ5dGVzLmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGMxID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYzEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjMSA+IDE5MSAmJiBjMSA8IDIyNCkge1xyXG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgb3V0W2MrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYzEgJiAzMSkgPDwgNikgfCAoYzIgJiA2MykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjMSA+IDIzOSAmJiBjMSA8IDM2NSkge1xyXG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxyXG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIGNvbnN0IGM0ID0gYnl0ZXNbcG9zKytdO1xyXG4gICAgICAgICAgICBjb25zdCB1ID0gKCgoYzEgJiA3KSA8PCAxOCkgfCAoKGMyICYgNjMpIDw8IDEyKSB8ICgoYzMgJiA2MykgPDwgNikgfCAoYzQgJiA2MykpIC1cclxuICAgICAgICAgICAgICAgIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGQ4MDAgKyAodSA+PiAxMCkpO1xyXG4gICAgICAgICAgICBvdXRbYysrXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhkYzAwICsgKHUgJiAxMDIzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjMiA9IGJ5dGVzW3BvcysrXTtcclxuICAgICAgICAgICAgY29uc3QgYzMgPSBieXRlc1twb3MrK107XHJcbiAgICAgICAgICAgIG91dFtjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMxICYgMTUpIDw8IDEyKSB8ICgoYzIgJiA2MykgPDwgNikgfCAoYzMgJiA2MykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvdXQuam9pbignJyk7XHJcbn07XHJcbi8vIFdlIGRlZmluZSBpdCBhcyBhbiBvYmplY3QgbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY2xhc3MgYmVjYXVzZSBhIGNsYXNzIGNvbXBpbGVkIGRvd24gdG8gZXM1IGNhbid0XHJcbi8vIGJlIHRyZWVzaGFrZWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNjkxXHJcbi8vIFN0YXRpYyBsb29rdXAgbWFwcywgbGF6aWx5IHBvcHVsYXRlZCBieSBpbml0XygpXHJcbmNvbnN0IGJhc2U2NCA9IHtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBieXRlcyB0byBjaGFyYWN0ZXJzLlxyXG4gICAgICovXHJcbiAgICBieXRlVG9DaGFyTWFwXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBjaGFyVG9CeXRlTWFwXzogbnVsbCxcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyBieXRlcyB0byB3ZWJzYWZlIGNoYXJhY3RlcnMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBieXRlVG9DaGFyTWFwV2ViU2FmZV86IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgd2Vic2FmZSBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY2hhclRvQnl0ZU1hcFdlYlNhZmVfOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldCwgc2hhcmVkIGJldHdlZW5cclxuICAgICAqIEVOQ09ERURfVkFMUyBhbmQgRU5DT0RFRF9WQUxTX1dFQlNBRkVcclxuICAgICAqL1xyXG4gICAgRU5DT0RFRF9WQUxTX0JBU0U6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgZGVmYXVsdCBhbHBoYWJldC4gVmFsdWUgNjQgKD0pIGlzIHNwZWNpYWw7IGl0IG1lYW5zIFwibm90aGluZy5cIlxyXG4gICAgICovXHJcbiAgICBnZXQgRU5DT0RFRF9WQUxTKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLkVOQ09ERURfVkFMU19CQVNFICsgJysvPSc7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBPdXIgd2Vic2FmZSBhbHBoYWJldC5cclxuICAgICAqL1xyXG4gICAgZ2V0IEVOQ09ERURfVkFMU19XRUJTQUZFKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLkVOQ09ERURfVkFMU19CQVNFICsgJy1fLic7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyB0aGUgYXRvYiBhbmQgYnRvYSBmdW5jdGlvbnMuIFRoaXMgZXh0ZW5zaW9uXHJcbiAgICAgKiBzdGFydGVkIGF0IE1vemlsbGEgYnV0IGlzIG5vdyBpbXBsZW1lbnRlZCBieSBtYW55IGJyb3dzZXJzLiBXZSB1c2UgdGhlXHJcbiAgICAgKiBBU1NVTUVfKiB2YXJpYWJsZXMgdG8gYXZvaWQgcHVsbGluZyBpbiB0aGUgZnVsbCB1c2VyYWdlbnQgZGV0ZWN0aW9uIGxpYnJhcnlcclxuICAgICAqIGJ1dCBzdGlsbCBhbGxvd2luZyB0aGUgc3RhbmRhcmQgcGVyLWJyb3dzZXIgY29tcGlsYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgSEFTX05BVElWRV9TVVBQT1JUOiB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJyxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWVuY29kZSBhbiBhcnJheSBvZiBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgQW4gYXJyYXkgb2YgYnl0ZXMgKG51bWJlcnMgd2l0aFxyXG4gICAgICogICAgIHZhbHVlIGluIFswLCAyNTVdKSB0byBlbmNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBCb29sZWFuIGluZGljYXRpbmcgd2Ugc2hvdWxkIHVzZSB0aGVcclxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cclxuICAgICAqIEByZXR1cm4gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICAgICAqL1xyXG4gICAgZW5jb2RlQnl0ZUFycmF5KGlucHV0LCB3ZWJTYWZlKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW5jb2RlQnl0ZUFycmF5IHRha2VzIGFuIGFycmF5IGFzIGEgcGFyYW1ldGVyJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdF8oKTtcclxuICAgICAgICBjb25zdCBieXRlVG9DaGFyTWFwID0gd2ViU2FmZVxyXG4gICAgICAgICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfXHJcbiAgICAgICAgICAgIDogdGhpcy5ieXRlVG9DaGFyTWFwXztcclxuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gaW5wdXRbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMiA9IGhhdmVCeXRlMiA/IGlucHV0W2kgKyAxXSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMyA9IGkgKyAyIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGlucHV0W2kgKyAyXSA6IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gYnl0ZTEgPj4gMjtcclxuICAgICAgICAgICAgY29uc3Qgb3V0Qnl0ZTIgPSAoKGJ5dGUxICYgMHgwMykgPDwgNCkgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgICAgIGxldCBvdXRCeXRlMyA9ICgoYnl0ZTIgJiAweDBmKSA8PCAyKSB8IChieXRlMyA+PiA2KTtcclxuICAgICAgICAgICAgbGV0IG91dEJ5dGU0ID0gYnl0ZTMgJiAweDNmO1xyXG4gICAgICAgICAgICBpZiAoIWhhdmVCeXRlMykge1xyXG4gICAgICAgICAgICAgICAgb3V0Qnl0ZTQgPSA2NDtcclxuICAgICAgICAgICAgICAgIGlmICghaGF2ZUJ5dGUyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0Qnl0ZTMgPSA2NDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChieXRlVG9DaGFyTWFwW291dEJ5dGUxXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMl0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTNdLCBieXRlVG9DaGFyTWFwW291dEJ5dGU0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnB1dCBBIHN0cmluZyB0byBlbmNvZGUuXHJcbiAgICAgKiBAcGFyYW0gd2ViU2FmZSBJZiB0cnVlLCB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBlbmNvZGVTdHJpbmcoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxyXG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcclxuICAgICAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJ0b2EoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVCeXRlQXJyYXkoc3RyaW5nVG9CeXRlQXJyYXkkMShpbnB1dCksIHdlYlNhZmUpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5wdXQgdG8gZGVjb2RlLlxyXG4gICAgICogQHBhcmFtIHdlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZVxyXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxyXG4gICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBkZWNvZGVTdHJpbmcoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgTW96aWxsYSBicm93c2VycyB0aGF0IGltcGxlbWVudFxyXG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcclxuICAgICAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIXdlYlNhZmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGF0b2IoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnl0ZUFycmF5VG9TdHJpbmcodGhpcy5kZWNvZGVTdHJpbmdUb0J5dGVBcnJheShpbnB1dCwgd2ViU2FmZSkpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBJbiBiYXNlLTY0IGRlY29kaW5nLCBncm91cHMgb2YgZm91ciBjaGFyYWN0ZXJzIGFyZSBjb252ZXJ0ZWQgaW50byB0aHJlZVxyXG4gICAgICogYnl0ZXMuICBJZiB0aGUgZW5jb2RlciBkaWQgbm90IGFwcGx5IHBhZGRpbmcsIHRoZSBpbnB1dCBsZW5ndGggbWF5IG5vdFxyXG4gICAgICogYmUgYSBtdWx0aXBsZSBvZiA0LlxyXG4gICAgICpcclxuICAgICAqIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgZ3JvdXAgd2lsbCBoYXZlIGZld2VyIHRoYW4gNCBjaGFyYWN0ZXJzLCBhbmRcclxuICAgICAqIHBhZGRpbmcgd2lsbCBiZSBpbmZlcnJlZC4gIElmIHRoZSBncm91cCBoYXMgb25lIG9yIHR3byBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzXHJcbiAgICAgKiB0byBvbmUgYnl0ZS4gIElmIHRoZSBncm91cCBoYXMgdGhyZWUgY2hhcmFjdGVycywgaXQgZGVjb2RlcyB0byB0d28gYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlucHV0IElucHV0IHRvIGRlY29kZS5cclxuICAgICAqIEBwYXJhbSB3ZWJTYWZlIFRydWUgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgd2ViLXNhZmUgYWxwaGFiZXQuXHJcbiAgICAgKiBAcmV0dXJuIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgZGVjb2RlZCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgZGVjb2RlU3RyaW5nVG9CeXRlQXJyYXkoaW5wdXQsIHdlYlNhZmUpIHtcclxuICAgICAgICB0aGlzLmluaXRfKCk7XHJcbiAgICAgICAgY29uc3QgY2hhclRvQnl0ZU1hcCA9IHdlYlNhZmVcclxuICAgICAgICAgICAgPyB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1xyXG4gICAgICAgICAgICA6IHRoaXMuY2hhclRvQnl0ZU1hcF87XHJcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUxID0gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSsrKV07XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlMiA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGUyID0gaGF2ZUJ5dGUyID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogMDtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBjb25zdCBoYXZlQnl0ZTMgPSBpIDwgaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlMyA9IGhhdmVCeXRlMyA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGU0ID0gaGF2ZUJ5dGU0ID8gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSldIDogNjQ7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgaWYgKGJ5dGUxID09IG51bGwgfHwgYnl0ZTIgPT0gbnVsbCB8fCBieXRlMyA9PSBudWxsIHx8IGJ5dGU0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUxID0gKGJ5dGUxIDw8IDIpIHwgKGJ5dGUyID4+IDQpO1xyXG4gICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMSk7XHJcbiAgICAgICAgICAgIGlmIChieXRlMyAhPT0gNjQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUyID0gKChieXRlMiA8PCA0KSAmIDB4ZjApIHwgKGJ5dGUzID4+IDIpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ5dGU0ICE9PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dEJ5dGUzID0gKChieXRlMyA8PCA2KSAmIDB4YzApIHwgYnl0ZTQ7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gob3V0Qnl0ZTMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBMYXp5IHN0YXRpYyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbi4gQ2FsbGVkIGJlZm9yZVxyXG4gICAgICogYWNjZXNzaW5nIGFueSBvZiB0aGUgc3RhdGljIG1hcCB2YXJpYWJsZXMuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBpbml0XygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYnl0ZVRvQ2hhck1hcF8pIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwXyA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfID0ge307XHJcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5FTkNPREVEX1ZBTFMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcF9baV0gPSB0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldID0gdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXV0gPSBpO1xyXG4gICAgICAgICAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSB0aGlzLkVOQ09ERURfVkFMU19CQVNFLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcF9bdGhpcy5FTkNPREVEX1ZBTFNfV0VCU0FGRS5jaGFyQXQoaSldID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEFuIGVycm9yIGVuY291bnRlcmVkIHdoaWxlIGRlY29kaW5nIGJhc2U2NCBzdHJpbmcuXHJcbiAqL1xyXG5jbGFzcyBEZWNvZGVCYXNlNjRTdHJpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0RlY29kZUJhc2U2NFN0cmluZ0Vycm9yJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nXHJcbiAqL1xyXG5jb25zdCBiYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBjb25zdCB1dGY4Qnl0ZXMgPSBzdHJpbmdUb0J5dGVBcnJheSQxKHN0cik7XHJcbiAgICByZXR1cm4gYmFzZTY0LmVuY29kZUJ5dGVBcnJheSh1dGY4Qnl0ZXMsIHRydWUpO1xyXG59O1xyXG4vKipcclxuICogVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nICh3aXRob3V0IFwiLlwiIHBhZGRpbmcgaW4gdGhlIGVuZCkuXHJcbiAqIGUuZy4gVXNlZCBpbiBKU09OIFdlYiBUb2tlbiAoSldUKSBwYXJ0cy5cclxuICovXHJcbmNvbnN0IGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgLy8gVXNlIGJhc2U2NHVybCBlbmNvZGluZyBhbmQgcmVtb3ZlIHBhZGRpbmcgaW4gdGhlIGVuZCAoZG90IGNoYXJhY3RlcnMpLlxyXG4gICAgcmV0dXJuIGJhc2U2NEVuY29kZShzdHIpLnJlcGxhY2UoL1xcLi9nLCAnJyk7XHJcbn07XHJcbi8qKlxyXG4gKiBVUkwtc2FmZSBiYXNlNjQgZGVjb2RpbmdcclxuICpcclxuICogTk9URTogRE8gTk9UIHVzZSB0aGUgZ2xvYmFsIGF0b2IoKSBmdW5jdGlvbiAtIGl0IGRvZXMgTk9UIHN1cHBvcnQgdGhlXHJcbiAqIGJhc2U2NFVybCB2YXJpYW50IGVuY29kaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3RyIFRvIGJlIGRlY29kZWRcclxuICogQHJldHVybiBEZWNvZGVkIHJlc3VsdCwgaWYgcG9zc2libGVcclxuICovXHJcbmNvbnN0IGJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGJhc2U2NC5kZWNvZGVTdHJpbmcoc3RyLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignYmFzZTY0RGVjb2RlIGZhaWxlZDogJywgZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIERvIGEgZGVlcC1jb3B5IG9mIGJhc2ljIEphdmFTY3JpcHQgT2JqZWN0cyBvciBBcnJheXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGRlZXBFeHRlbmQodW5kZWZpbmVkLCB2YWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAqIENvcHkgcHJvcGVydGllcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgKHJlY3Vyc2l2ZWx5IGFsbG93cyBleHRlbnNpb25cclxuICogb2YgT2JqZWN0cyBhbmQgQXJyYXlzKS4gIFNjYWxhciB2YWx1ZXMgaW4gdGhlIHRhcmdldCBhcmUgb3Zlci13cml0dGVuLlxyXG4gKiBJZiB0YXJnZXQgaXMgdW5kZWZpbmVkLCBhbiBvYmplY3Qgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUgd2lsbCBiZSBjcmVhdGVkXHJcbiAqIChhbmQgcmV0dXJuZWQpLlxyXG4gKlxyXG4gKiBXZSByZWN1cnNpdmVseSBjb3B5IGFsbCBjaGlsZCBwcm9wZXJ0aWVzIG9mIHBsYWluIE9iamVjdHMgaW4gdGhlIHNvdXJjZS0gc29cclxuICogdGhhdCBuYW1lc3BhY2UtIGxpa2UgZGljdGlvbmFyaWVzIGFyZSBtZXJnZWQuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCB0aGUgdGFyZ2V0IGNhbiBiZSBhIGZ1bmN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwcm9wZXJ0aWVzIGluXHJcbiAqIHRoZSBzb3VyY2UgT2JqZWN0IGFyZSBjb3BpZWQgb250byBpdCBhcyBzdGF0aWMgcHJvcGVydGllcyBvZiB0aGUgRnVuY3Rpb24uXHJcbiAqXHJcbiAqIE5vdGU6IHdlIGRvbid0IG1lcmdlIF9fcHJvdG9fXyB0byBwcmV2ZW50IHByb3RvdHlwZSBwb2xsdXRpb25cclxuICovXHJcbmZ1bmN0aW9uIGRlZXBFeHRlbmQodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgc3dpdGNoIChzb3VyY2UuY29uc3RydWN0b3IpIHtcclxuICAgICAgICBjYXNlIERhdGU6XHJcbiAgICAgICAgICAgIC8vIFRyZWF0IERhdGVzIGxpa2Ugc2NhbGFyczsgaWYgdGhlIHRhcmdldCBkYXRlIG9iamVjdCBoYWQgYW55IGNoaWxkXHJcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgLSB0aGV5IHdpbGwgYmUgbG9zdCFcclxuICAgICAgICAgICAgY29uc3QgZGF0ZVZhbHVlID0gc291cmNlO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZVZhbHVlLmdldFRpbWUoKSk7XHJcbiAgICAgICAgY2FzZSBPYmplY3Q6XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBBcnJheTpcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgIHRhcmdldCA9IFtdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAvLyBOb3QgYSBwbGFpbiBPYmplY3QgLSB0cmVhdCBpdCBhcyBhIHNjYWxhci5cclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzb3VyY2UpIHtcclxuICAgICAgICAvLyB1c2UgaXNWYWxpZEtleSB0byBndWFyZCBhZ2FpbnN0IHByb3RvdHlwZSBwb2xsdXRpb24uIFNlZSBodHRwczovL3NueWsuaW8vdnVsbi9TTllLLUpTLUxPREFTSC00NTAyMDJcclxuICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCAhaXNWYWxpZEtleShwcm9wKSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIGlzVmFsaWRLZXkoa2V5KSB7XHJcbiAgICByZXR1cm4ga2V5ICE9PSAnX19wcm90b19fJztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUG9seWZpbGwgZm9yIGBnbG9iYWxUaGlzYCBvYmplY3QuXHJcbiAqIEByZXR1cm5zIHRoZSBgZ2xvYmFsVGhpc2Agb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnQuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEdsb2JhbCgpIHtcclxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBvYmplY3QuJyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIyIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdHNGcm9tR2xvYmFsID0gKCkgPT4gZ2V0R2xvYmFsKCkuX19GSVJFQkFTRV9ERUZBVUxUU19fO1xyXG4vKipcclxuICogQXR0ZW1wdCB0byByZWFkIGRlZmF1bHRzIGZyb20gYSBKU09OIHN0cmluZyBwcm92aWRlZCB0b1xyXG4gKiBwcm9jZXNzKC4pZW52KC4pX19GSVJFQkFTRV9ERUZBVUxUU19fIG9yIGEgSlNPTiBmaWxlIHdob3NlIHBhdGggaXMgaW5cclxuICogcHJvY2VzcyguKWVudiguKV9fRklSRUJBU0VfREVGQVVMVFNfUEFUSF9fXHJcbiAqIFRoZSBkb3RzIGFyZSBpbiBwYXJlbnMgYmVjYXVzZSBjZXJ0YWluIGNvbXBpbGVycyAoVml0ZT8pIGNhbm5vdFxyXG4gKiBoYW5kbGUgc2VlaW5nIHRoYXQgdmFyaWFibGUgaW4gY29tbWVudHMuXHJcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL2lzc3Vlcy82ODM4XHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21FbnZWYXJpYWJsZSA9ICgpID0+IHtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHByb2Nlc3MuZW52ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGRlZmF1bHRzSnNvblN0cmluZyA9IHByb2Nlc3MuZW52Ll9fRklSRUJBU0VfREVGQVVMVFNfXztcclxuICAgIGlmIChkZWZhdWx0c0pzb25TdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWZhdWx0c0pzb25TdHJpbmcpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBnZXREZWZhdWx0c0Zyb21Db29raWUgPSAoKSA9PiB7XHJcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBtYXRjaDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2goL19fRklSRUJBU0VfREVGQVVMVFNfXz0oW147XSspLyk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIFNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQW5ndWxhciBVbml2ZXJzYWwgU1NSIGhhdmUgYVxyXG4gICAgICAgIC8vIGBkb2N1bWVudGAgb2JqZWN0IGJ1dCBlcnJvciBvbiBhY2Nlc3NpbmcgYGRvY3VtZW50LmNvb2tpZWAuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVjb2RlZCA9IG1hdGNoICYmIGJhc2U2NERlY29kZShtYXRjaFsxXSk7XHJcbiAgICByZXR1cm4gZGVjb2RlZCAmJiBKU09OLnBhcnNlKGRlY29kZWQpO1xyXG59O1xyXG4vKipcclxuICogR2V0IHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LiBJdCBjaGVja3MgaW4gb3JkZXI6XHJcbiAqICgxKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgYXMgYSBwcm9wZXJ0eSBvZiBgZ2xvYmFsVGhpc2BcclxuICogKDIpIGlmIHN1Y2ggYW4gb2JqZWN0IHdhcyBwcm92aWRlZCBvbiBhIHNoZWxsIGVudmlyb25tZW50IHZhcmlhYmxlXHJcbiAqICgzKSBpZiBzdWNoIGFuIG9iamVjdCBleGlzdHMgaW4gYSBjb29raWVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdHMgPSAoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAoZ2V0RGVmYXVsdHNGcm9tR2xvYmFsKCkgfHxcclxuICAgICAgICAgICAgZ2V0RGVmYXVsdHNGcm9tRW52VmFyaWFibGUoKSB8fFxyXG4gICAgICAgICAgICBnZXREZWZhdWx0c0Zyb21Db29raWUoKSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhdGNoLWFsbCBmb3IgYmVpbmcgdW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlXHJcbiAgICAgICAgICogdG8gYW55IGVudmlyb25tZW50IGNhc2Ugd2UgaGF2ZSBub3QgYWNjb3VudGVkIGZvci4gTG9nIHRvXHJcbiAgICAgICAgICogaW5mbyBpbnN0ZWFkIG9mIHN3YWxsb3dpbmcgc28gd2UgY2FuIGZpbmQgdGhlc2UgdW5rbm93biBjYXNlc1xyXG4gICAgICAgICAqIGFuZCBhZGQgcGF0aHMgZm9yIHRoZW0gaWYgbmVlZGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbnNvbGUuaW5mbyhgVW5hYmxlIHRvIGdldCBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gZHVlIHRvOiAke2V9YCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBlbXVsYXRvciBob3N0IHN0b3JlZCBpbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdFxyXG4gKiBmb3IgdGhlIGdpdmVuIHByb2R1Y3QuXHJcbiAqIEByZXR1cm5zIGEgVVJMIGhvc3QgZm9ybWF0dGVkIGxpa2UgYDEyNy4wLjAuMTo5OTk5YCBvciBgWzo6MV06NDAwMGAgaWYgYXZhaWxhYmxlXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IGdldERlZmF1bHRFbXVsYXRvckhvc3QgPSAocHJvZHVjdE5hbWUpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbXVsYXRvckhvc3RzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbcHJvZHVjdE5hbWVdOyB9O1xyXG4vKipcclxuICogUmV0dXJucyBlbXVsYXRvciBob3N0bmFtZSBhbmQgcG9ydCBzdG9yZWQgaW4gdGhlIF9fRklSRUJBU0VfREVGQVVMVFNfXyBvYmplY3RcclxuICogZm9yIHRoZSBnaXZlbiBwcm9kdWN0LlxyXG4gKiBAcmV0dXJucyBhIHBhaXIgb2YgaG9zdG5hbWUgYW5kIHBvcnQgbGlrZSBgW1wiOjoxXCIsIDQwMDBdYCBpZiBhdmFpbGFibGVcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0ID0gKHByb2R1Y3ROYW1lKSA9PiB7XHJcbiAgICBjb25zdCBob3N0ID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdChwcm9kdWN0TmFtZSk7XHJcbiAgICBpZiAoIWhvc3QpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VwYXJhdG9ySW5kZXggPSBob3N0Lmxhc3RJbmRleE9mKCc6Jyk7IC8vIEZpbmRpbmcgdGhlIGxhc3Qgc2luY2UgSVB2NiBhZGRyIGFsc28gaGFzIGNvbG9ucy5cclxuICAgIGlmIChzZXBhcmF0b3JJbmRleCA8PSAwIHx8IHNlcGFyYXRvckluZGV4ICsgMSA9PT0gaG9zdC5sZW5ndGgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaG9zdCAke2hvc3R9IHdpdGggbm8gc2VwYXJhdGUgaG9zdG5hbWUgYW5kIHBvcnQhYCk7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXHJcbiAgICBjb25zdCBwb3J0ID0gcGFyc2VJbnQoaG9zdC5zdWJzdHJpbmcoc2VwYXJhdG9ySW5kZXggKyAxKSwgMTApO1xyXG4gICAgaWYgKGhvc3RbMF0gPT09ICdbJykge1xyXG4gICAgICAgIC8vIEJyYWNrZXQtcXVvdGVkIGBbaXB2NmFkZHJdOnBvcnRgID0+IHJldHVybiBcImlwdjZhZGRyXCIgKHdpdGhvdXQgYnJhY2tldHMpLlxyXG4gICAgICAgIHJldHVybiBbaG9zdC5zdWJzdHJpbmcoMSwgc2VwYXJhdG9ySW5kZXggLSAxKSwgcG9ydF07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW2hvc3Quc3Vic3RyaW5nKDAsIHNlcGFyYXRvckluZGV4KSwgcG9ydF07XHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZXR1cm5zIEZpcmViYXNlIGFwcCBjb25maWcgc3RvcmVkIGluIHRoZSBfX0ZJUkVCQVNFX0RFRkFVTFRTX18gb2JqZWN0LlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5jb25zdCBnZXREZWZhdWx0QXBwQ29uZmlnID0gKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBnZXREZWZhdWx0cygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlnOyB9O1xyXG4vKipcclxuICogUmV0dXJucyBhbiBleHBlcmltZW50YWwgc2V0dGluZyBvbiB0aGUgX19GSVJFQkFTRV9ERUZBVUxUU19fIG9iamVjdCAocHJvcGVydGllc1xyXG4gKiBwcmVmaXhlZCBieSBcIl9cIilcclxuICogQHB1YmxpY1xyXG4gKi9cclxuY29uc3QgZ2V0RXhwZXJpbWVudGFsU2V0dGluZyA9IChuYW1lKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGdldERlZmF1bHRzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtgXyR7bmFtZX1gXTsgfTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgRGVmZXJyZWQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yZWplY3QgPSAoKSA9PiB7IH07XHJcbiAgICAgICAgdGhpcy5yZXNvbHZlID0gKCkgPT4geyB9O1xyXG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE91ciBBUEkgaW50ZXJuYWxzIGFyZSBub3QgcHJvbWlzZWlmaWVkIGFuZCBjYW5ub3QgYmVjYXVzZSBvdXIgY2FsbGJhY2sgQVBJcyBoYXZlIHN1YnRsZSBleHBlY3RhdGlvbnMgYXJvdW5kXHJcbiAgICAgKiBpbnZva2luZyBwcm9taXNlcyBpbmxpbmUsIHdoaWNoIFByb21pc2VzIGFyZSBmb3JiaWRkZW4gdG8gZG8uIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgbm9kZS1zdHlsZSBjYWxsYmFja1xyXG4gICAgICogYW5kIHJldHVybnMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHdoaWNoIHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIERlZmVycmVkJ3MgcHJvbWlzZS5cclxuICAgICAqL1xyXG4gICAgd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIChlcnJvciwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0dGFjaGluZyBub29wIGhhbmRsZXIganVzdCBpbiBjYXNlIGRldmVsb3BlciB3YXNuJ3QgZXhwZWN0aW5nXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9taXNlLmNhdGNoKCgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBTb21lIG9mIG91ciBjYWxsYmFja3MgZG9uJ3QgZXhwZWN0IGEgdmFsdWUgYW5kIG91ciBvd24gdGVzdHNcclxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVNb2NrVXNlclRva2VuKHRva2VuLCBwcm9qZWN0SWQpIHtcclxuICAgIGlmICh0b2tlbi51aWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBcInVpZFwiIGZpZWxkIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYnkgbW9ja1VzZXJUb2tlbi4gUGxlYXNlIHVzZSBcInN1YlwiIGluc3RlYWQgZm9yIEZpcmViYXNlIEF1dGggVXNlciBJRC4nKTtcclxuICAgIH1cclxuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSBcIm5vbmVcIiBhcyB0aGUgYWxnb3JpdGhtLlxyXG4gICAgY29uc3QgaGVhZGVyID0ge1xyXG4gICAgICAgIGFsZzogJ25vbmUnLFxyXG4gICAgICAgIHR5cGU6ICdKV1QnXHJcbiAgICB9O1xyXG4gICAgY29uc3QgcHJvamVjdCA9IHByb2plY3RJZCB8fCAnZGVtby1wcm9qZWN0JztcclxuICAgIGNvbnN0IGlhdCA9IHRva2VuLmlhdCB8fCAwO1xyXG4gICAgY29uc3Qgc3ViID0gdG9rZW4uc3ViIHx8IHRva2VuLnVzZXJfaWQ7XHJcbiAgICBpZiAoIXN1Yikge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1vY2tVc2VyVG9rZW4gbXVzdCBjb250YWluICdzdWInIG9yICd1c2VyX2lkJyBmaWVsZCFcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7IFxyXG4gICAgICAgIC8vIFNldCBhbGwgcmVxdWlyZWQgZmllbGRzIHRvIGRlY2VudCBkZWZhdWx0c1xyXG4gICAgICAgIGlzczogYGh0dHBzOi8vc2VjdXJldG9rZW4uZ29vZ2xlLmNvbS8ke3Byb2plY3R9YCwgYXVkOiBwcm9qZWN0LCBpYXQsIGV4cDogaWF0ICsgMzYwMCwgYXV0aF90aW1lOiBpYXQsIHN1YiwgdXNlcl9pZDogc3ViLCBmaXJlYmFzZToge1xyXG4gICAgICAgICAgICBzaWduX2luX3Byb3ZpZGVyOiAnY3VzdG9tJyxcclxuICAgICAgICAgICAgaWRlbnRpdGllczoge31cclxuICAgICAgICB9IH0sIHRva2VuKTtcclxuICAgIC8vIFVuc2VjdXJlZCBKV1RzIHVzZSB0aGUgZW1wdHkgc3RyaW5nIGFzIGEgc2lnbmF0dXJlLlxyXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gJyc7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KGhlYWRlcikpLFxyXG4gICAgICAgIGJhc2U2NHVybEVuY29kZVdpdGhvdXRQYWRkaW5nKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKSxcclxuICAgICAgICBzaWduYXR1cmVcclxuICAgIF0uam9pbignLicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXHJcbiAqIEByZXR1cm4gdXNlciBhZ2VudCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGdldFVBKCkge1xyXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgdHlwZW9mIG5hdmlnYXRvclsndXNlckFnZW50J10gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsndXNlckFnZW50J107XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBDb3Jkb3ZhIC8gUGhvbmVHYXAgLyBJb25pYyBmcmFtZXdvcmtzIG9uIGEgbW9iaWxlIGRldmljZS5cclxuICpcclxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXBcclxuICogaW4gdGhlIFJpcHBsZSBlbXVsYXRvcikgbm9yIENvcmRvdmEgYG9uRGV2aWNlUmVhZHlgLCB3aGljaCB3b3VsZCBub3JtYWxseVxyXG4gKiB3YWl0IGZvciBhIGNhbGxiYWNrLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNNb2JpbGVDb3Jkb3ZhKCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgU2V0dGluZyB1cCBhbiBicm9hZGx5IGFwcGxpY2FibGUgaW5kZXggc2lnbmF0dXJlIGZvciBXaW5kb3dcclxuICAgICAgICAvLyBqdXN0IHRvIGRlYWwgd2l0aCB0aGlzIGNhc2Ugd291bGQgcHJvYmFibHkgYmUgYSBiYWQgaWRlYS5cclxuICAgICAgICAhISh3aW5kb3dbJ2NvcmRvdmEnXSB8fCB3aW5kb3dbJ3Bob25lZ2FwJ10gfHwgd2luZG93WydQaG9uZUdhcCddKSAmJlxyXG4gICAgICAgIC9pb3N8aXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGJsYWNrYmVycnl8aWVtb2JpbGUvaS50ZXN0KGdldFVBKCkpKTtcclxufVxyXG4vKipcclxuICogRGV0ZWN0IE5vZGUuanMuXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBOb2RlLmpzIGVudmlyb25tZW50IGlzIGRldGVjdGVkIG9yIHNwZWNpZmllZC5cclxuICovXHJcbi8vIE5vZGUgZGV0ZWN0aW9uIGxvZ2ljIGZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9pbGlha2FuL2RldGVjdC1ub2RlL1xyXG5mdW5jdGlvbiBpc05vZGUoKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBjb25zdCBmb3JjZUVudmlyb25tZW50ID0gKF9hID0gZ2V0RGVmYXVsdHMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvcmNlRW52aXJvbm1lbnQ7XHJcbiAgICBpZiAoZm9yY2VFbnZpcm9ubWVudCA9PT0gJ25vZGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmb3JjZUVudmlyb25tZW50ID09PSAnYnJvd3NlcicpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXRlY3QgQnJvd3NlciBFbnZpcm9ubWVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGY7XHJcbn1cclxuZnVuY3Rpb24gaXNCcm93c2VyRXh0ZW5zaW9uKCkge1xyXG4gICAgY29uc3QgcnVudGltZSA9IHR5cGVvZiBjaHJvbWUgPT09ICdvYmplY3QnXHJcbiAgICAgICAgPyBjaHJvbWUucnVudGltZVxyXG4gICAgICAgIDogdHlwZW9mIGJyb3dzZXIgPT09ICdvYmplY3QnXHJcbiAgICAgICAgICAgID8gYnJvd3Nlci5ydW50aW1lXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBydW50aW1lID09PSAnb2JqZWN0JyAmJiBydW50aW1lLmlkICE9PSB1bmRlZmluZWQ7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCBSZWFjdCBOYXRpdmUuXHJcbiAqXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cclxuICovXHJcbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBuYXZpZ2F0b3IgPT09ICdvYmplY3QnICYmIG5hdmlnYXRvclsncHJvZHVjdCddID09PSAnUmVhY3ROYXRpdmUnKTtcclxufVxyXG4vKiogRGV0ZWN0cyBFbGVjdHJvbiBhcHBzLiAqL1xyXG5mdW5jdGlvbiBpc0VsZWN0cm9uKCkge1xyXG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignRWxlY3Ryb24vJykgPj0gMDtcclxufVxyXG4vKiogRGV0ZWN0cyBJbnRlcm5ldCBFeHBsb3Jlci4gKi9cclxuZnVuY3Rpb24gaXNJRSgpIHtcclxuICAgIGNvbnN0IHVhID0gZ2V0VUEoKTtcclxuICAgIHJldHVybiB1YS5pbmRleE9mKCdNU0lFICcpID49IDAgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSA+PSAwO1xyXG59XHJcbi8qKiBEZXRlY3RzIFVuaXZlcnNhbCBXaW5kb3dzIFBsYXRmb3JtIGFwcHMuICovXHJcbmZ1bmN0aW9uIGlzVVdQKCkge1xyXG4gICAgcmV0dXJuIGdldFVBKCkuaW5kZXhPZignTVNBcHBIb3N0LycpID49IDA7XHJcbn1cclxuLyoqXHJcbiAqIERldGVjdCB3aGV0aGVyIHRoZSBjdXJyZW50IFNESyBidWlsZCBpcyB0aGUgTm9kZSB2ZXJzaW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaXQncyB0aGUgTm9kZSBTREsgYnVpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc05vZGVTZGsoKSB7XHJcbiAgICByZXR1cm4gQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IENPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xyXG59XHJcbi8qKiBSZXR1cm5zIHRydWUgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gU2FmYXJpLiAqL1xyXG5mdW5jdGlvbiBpc1NhZmFyaSgpIHtcclxuICAgIHJldHVybiAoIWlzTm9kZSgpICYmXHJcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnU2FmYXJpJykgJiZcclxuICAgICAgICAhbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnQ2hyb21lJykpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSBjdXJyZW50IGJyb3dzZXIvc2VydmljZSB3b3JrZXIgY29udGV4dFxyXG4gKi9cclxuZnVuY3Rpb24gaXNJbmRleGVkREJBdmFpbGFibGUoKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5kZXhlZERCID09PSAnb2JqZWN0JztcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB2YWxpZGF0ZXMgYnJvd3Nlci9zdyBjb250ZXh0IGZvciBpbmRleGVkREIgYnkgb3BlbmluZyBhIGR1bW15IGluZGV4ZWREQiBkYXRhYmFzZSBhbmQgcmVqZWN0XHJcbiAqIGlmIGVycm9ycyBvY2N1ciBkdXJpbmcgdGhlIGRhdGFiYXNlIG9wZW4gb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBAdGhyb3dzIGV4Y2VwdGlvbiBpZiBjdXJyZW50IGJyb3dzZXIvc3cgY29udGV4dCBjYW4ndCBydW4gaWRiLm9wZW4gKGV4OiBTYWZhcmkgaWZyYW1lLCBGaXJlZm94XHJcbiAqIHByaXZhdGUgYnJvd3NpbmcpXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBsZXQgcHJlRXhpc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBEQl9DSEVDS19OQU1FID0gJ3ZhbGlkYXRlLWJyb3dzZXItY29udGV4dC1mb3ItaW5kZXhlZGRiLWFuYWx5dGljcy1tb2R1bGUnO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gc2VsZi5pbmRleGVkREIub3BlbihEQl9DSEVDS19OQU1FKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlc3VsdC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGRhdGFiYXNlIG9ubHkgd2hlbiBpdCBkb2Vzbid0IHByZS1leGlzdFxyXG4gICAgICAgICAgICAgICAgaWYgKCFwcmVFeGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuaW5kZXhlZERCLmRlbGV0ZURhdGFiYXNlKERCX0NIRUNLX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwcmVFeGlzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoKChfYSA9IHJlcXVlc3QuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnJyk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBjaGVja3Mgd2hldGhlciBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiBjb29raWUgaXMgZW5hYmxlZCB3aXRoaW4gY3VycmVudCBicm93c2VyXHJcbiAqL1xyXG5mdW5jdGlvbiBhcmVDb29raWVzRW5hYmxlZCgpIHtcclxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yLmNvb2tpZUVuYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBTdGFuZGFyZGl6ZWQgRmlyZWJhc2UgRXJyb3IuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKlxyXG4gKiAgIC8vIFR5cGVzY3JpcHQgc3RyaW5nIGxpdGVyYWxzIGZvciB0eXBlLXNhZmUgY29kZXNcclxuICogICB0eXBlIEVyciA9XHJcbiAqICAgICAndW5rbm93bicgfFxyXG4gKiAgICAgJ29iamVjdC1ub3QtZm91bmQnXHJcbiAqICAgICA7XHJcbiAqXHJcbiAqICAgLy8gQ2xvc3VyZSBlbnVtIGZvciB0eXBlLXNhZmUgZXJyb3IgY29kZXNcclxuICogICAvLyBhdC1lbnVtIHtzdHJpbmd9XHJcbiAqICAgdmFyIEVyciA9IHtcclxuICogICAgIFVOS05PV046ICd1bmtub3duJyxcclxuICogICAgIE9CSkVDVF9OT1RfRk9VTkQ6ICdvYmplY3Qtbm90LWZvdW5kJyxcclxuICogICB9XHJcbiAqXHJcbiAqICAgbGV0IGVycm9yczogTWFwPEVyciwgc3RyaW5nPiA9IHtcclxuICogICAgICdnZW5lcmljLWVycm9yJzogXCJVbmtub3duIGVycm9yXCIsXHJcbiAqICAgICAnZmlsZS1ub3QtZm91bmQnOiBcIkNvdWxkIG5vdCBmaW5kIGZpbGU6IHskZmlsZX1cIixcclxuICogICB9O1xyXG4gKlxyXG4gKiAgIC8vIFR5cGUtc2FmZSBmdW5jdGlvbiAtIG11c3QgcGFzcyBhIHZhbGlkIGVycm9yIGNvZGUgYXMgcGFyYW0uXHJcbiAqICAgbGV0IGVycm9yID0gbmV3IEVycm9yRmFjdG9yeTxFcnI+KCdzZXJ2aWNlJywgJ1NlcnZpY2UnLCBlcnJvcnMpO1xyXG4gKlxyXG4gKiAgIC4uLlxyXG4gKiAgIHRocm93IGVycm9yLmNyZWF0ZShFcnIuR0VORVJJQyk7XHJcbiAqICAgLi4uXHJcbiAqICAgdGhyb3cgZXJyb3IuY3JlYXRlKEVyci5GSUxFX05PVF9GT1VORCwgeydmaWxlJzogZmlsZU5hbWV9KTtcclxuICogICAuLi5cclxuICogICAvLyBTZXJ2aWNlOiBDb3VsZCBub3QgZmlsZSBmaWxlOiBmb28udHh0IChzZXJ2aWNlL2ZpbGUtbm90LWZvdW5kKS5cclxuICpcclxuICogICBjYXRjaCAoZSkge1xyXG4gKiAgICAgYXNzZXJ0KGUubWVzc2FnZSA9PT0gXCJDb3VsZCBub3QgZmluZCBmaWxlOiBmb28udHh0LlwiKTtcclxuICogICAgIGlmICgoZSBhcyBGaXJlYmFzZUVycm9yKT8uY29kZSA9PT0gJ3NlcnZpY2UvZmlsZS1ub3QtZm91bmQnKSB7XHJcbiAqICAgICAgIGNvbnNvbGUubG9nKFwiQ291bGQgbm90IHJlYWQgZmlsZTogXCIgKyBlWydmaWxlJ10pO1xyXG4gKiAgICAgfVxyXG4gKiAgIH1cclxuICovXHJcbmNvbnN0IEVSUk9SX05BTUUgPSAnRmlyZWJhc2VFcnJvcic7XHJcbi8vIEJhc2VkIG9uIGNvZGUgZnJvbTpcclxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRXJyb3IjQ3VzdG9tX0Vycm9yX1R5cGVzXHJcbmNsYXNzIEZpcmViYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBUaGUgZXJyb3IgY29kZSBmb3IgdGhpcyBlcnJvci4gKi9cclxuICAgIGNvZGUsIG1lc3NhZ2UsIFxyXG4gICAgLyoqIEN1c3RvbSBkYXRhIGZvciB0aGlzIGVycm9yLiAqL1xyXG4gICAgY3VzdG9tRGF0YSkge1xyXG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgdGhpcy5jdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcclxuICAgICAgICAvKiogVGhlIGN1c3RvbSBuYW1lIGZvciBhbGwgRmlyZWJhc2VFcnJvcnMuICovXHJcbiAgICAgICAgdGhpcy5uYW1lID0gRVJST1JfTkFNRTtcclxuICAgICAgICAvLyBGaXggRm9yIEVTNVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZpcmViYXNlRXJyb3IucHJvdG90eXBlKTtcclxuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93bi5cclxuICAgICAgICAvLyBPbmx5IGF2YWlsYWJsZSBvbiBWOC5cclxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXJyb3JGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBFcnJvckZhY3Rvcnkge1xyXG4gICAgY29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIGVycm9ycykge1xyXG4gICAgICAgIHRoaXMuc2VydmljZSA9IHNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xyXG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlKGNvZGUsIC4uLmRhdGEpIHtcclxuICAgICAgICBjb25zdCBjdXN0b21EYXRhID0gZGF0YVswXSB8fCB7fTtcclxuICAgICAgICBjb25zdCBmdWxsQ29kZSA9IGAke3RoaXMuc2VydmljZX0vJHtjb2RlfWA7XHJcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLmVycm9yc1tjb2RlXTtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGVtcGxhdGUgPyByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGN1c3RvbURhdGEpIDogJ0Vycm9yJztcclxuICAgICAgICAvLyBTZXJ2aWNlIE5hbWU6IEVycm9yIG1lc3NhZ2UgKHNlcnZpY2UvY29kZSkuXHJcbiAgICAgICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgJHt0aGlzLnNlcnZpY2VOYW1lfTogJHttZXNzYWdlfSAoJHtmdWxsQ29kZX0pLmA7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRmlyZWJhc2VFcnJvcihmdWxsQ29kZSwgZnVsbE1lc3NhZ2UsIGN1c3RvbURhdGEpO1xyXG4gICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBsYWNlVGVtcGxhdGUodGVtcGxhdGUsIGRhdGEpIHtcclxuICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKFBBVFRFUk4sIChfLCBrZXkpID0+IHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGFba2V5XTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiBgPCR7a2V5fT8+YDtcclxuICAgIH0pO1xyXG59XHJcbmNvbnN0IFBBVFRFUk4gPSAvXFx7XFwkKFtefV0rKX0vZztcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEV2YWx1YXRlcyBhIEpTT04gc3RyaW5nIGludG8gYSBqYXZhc2NyaXB0IG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBjb250YWluaW5nIEpTT04uXHJcbiAqIEByZXR1cm4geyp9IFRoZSBqYXZhc2NyaXB0IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBKU09OLlxyXG4gKi9cclxuZnVuY3Rpb24ganNvbkV2YWwoc3RyKSB7XHJcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50aW5nIGEgamF2YXNjcmlwdCBvYmplY3QuXHJcbiAqIEBwYXJhbSB7Kn0gZGF0YSBKYXZhc2NyaXB0IG9iamVjdCB0byBiZSBzdHJpbmdpZmllZC5cclxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiBjb250ZW50cyBvZiB0aGUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5KGRhdGEpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGludG8gY29uc3RpdHVlbnQgcGFydHMuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gd2l0aCBpbnZhbGlkIC8gaW5jb21wbGV0ZSBjbGFpbXMgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXHJcbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXHJcbiAqL1xyXG5jb25zdCBkZWNvZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGxldCBoZWFkZXIgPSB7fSwgY2xhaW1zID0ge30sIGRhdGEgPSB7fSwgc2lnbmF0dXJlID0gJyc7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcclxuICAgICAgICBoZWFkZXIgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMF0pIHx8ICcnKTtcclxuICAgICAgICBjbGFpbXMgPSBqc29uRXZhbChiYXNlNjREZWNvZGUocGFydHNbMV0pIHx8ICcnKTtcclxuICAgICAgICBzaWduYXR1cmUgPSBwYXJ0c1syXTtcclxuICAgICAgICBkYXRhID0gY2xhaW1zWydkJ10gfHwge307XHJcbiAgICAgICAgZGVsZXRlIGNsYWltc1snZCddO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFkZXIsXHJcbiAgICAgICAgY2xhaW1zLFxyXG4gICAgICAgIGRhdGEsXHJcbiAgICAgICAgc2lnbmF0dXJlXHJcbiAgICB9O1xyXG59O1xyXG4vKipcclxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyB0aW1lLWJhc2VkIGNsYWltcy4gV2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcclxuICogdG9rZW4gaXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvdyBhdXRob3JpemVkIGJ5IHRoZSAnbmJmJyAobm90LWJlZm9yZSkgYW5kICdpYXQnIChpc3N1ZWQtYXQpIGNsYWltcy5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNWYWxpZFRpbWVzdGFtcCA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgY29uc3QgY2xhaW1zID0gZGVjb2RlKHRva2VuKS5jbGFpbXM7XHJcbiAgICBjb25zdCBub3cgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XHJcbiAgICBsZXQgdmFsaWRTaW5jZSA9IDAsIHZhbGlkVW50aWwgPSAwO1xyXG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnbmJmJykpIHtcclxuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snbmJmJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcclxuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snaWF0J107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2V4cCcpKSB7XHJcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcclxuICAgICAgICAgICAgdmFsaWRVbnRpbCA9IHZhbGlkU2luY2UgKyA4NjQwMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKCEhbm93ICYmXHJcbiAgICAgICAgISF2YWxpZFNpbmNlICYmXHJcbiAgICAgICAgISF2YWxpZFVudGlsICYmXHJcbiAgICAgICAgbm93ID49IHZhbGlkU2luY2UgJiZcclxuICAgICAgICBub3cgPD0gdmFsaWRVbnRpbCk7XHJcbn07XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIHJldHVybnMgaXRzIGlzc3VlZCBhdCB0aW1lIGlmIHZhbGlkLCBudWxsIG90aGVyd2lzZS5cclxuICpcclxuICogTm90ZXM6XHJcbiAqIC0gTWF5IHJldHVybiBudWxsIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxyXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxyXG4gKi9cclxuY29uc3QgaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICBjb25zdCBjbGFpbXMgPSBkZWNvZGUodG9rZW4pLmNsYWltcztcclxuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuLyoqXHJcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgY2hlY2tzIHRoZSB2YWxpZGl0eSBvZiBpdHMgZm9ybWF0LiBFeHBlY3RzIGEgdmFsaWQgaXNzdWVkLWF0IHRpbWUuXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzVmFsaWRGb3JtYXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGUodG9rZW4pLCBjbGFpbXMgPSBkZWNvZGVkLmNsYWltcztcclxuICAgIHJldHVybiAhIWNsYWltcyAmJiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpO1xyXG59O1xyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gcGVlciBpbnRvIGFuIGF1dGggdG9rZW4gYW5kIGRldGVybWluZSBpZiBpdCdzIGFuIGFkbWluIGF1dGggdG9rZW4gYnkgbG9va2luZyBhdCB0aGUgY2xhaW1zIHBvcnRpb24uXHJcbiAqXHJcbiAqIE5vdGVzOlxyXG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cclxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cclxuICovXHJcbmNvbnN0IGlzQWRtaW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICAgIGNvbnN0IGNsYWltcyA9IGRlY29kZSh0b2tlbikuY2xhaW1zO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltc1snYWRtaW4nXSA9PT0gdHJ1ZTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29udGFpbnMob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG59XHJcbmZ1bmN0aW9uIHNhZmVHZXQob2JqLCBrZXkpIHtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG1hcChvYmosIGZuLCBjb250ZXh0T2JqKSB7XHJcbiAgICBjb25zdCByZXMgPSB7fTtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHJlc1trZXldID0gZm4uY2FsbChjb250ZXh0T2JqLCBvYmpba2V5XSwga2V5LCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuLyoqXHJcbiAqIERlZXAgZXF1YWwgdHdvIG9iamVjdHMuIFN1cHBvcnQgQXJyYXlzIGFuZCBPYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcclxuICAgIGZvciAoY29uc3QgayBvZiBhS2V5cykge1xyXG4gICAgICAgIGlmICghYktleXMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhUHJvcCA9IGFba107XHJcbiAgICAgICAgY29uc3QgYlByb3AgPSBiW2tdO1xyXG4gICAgICAgIGlmIChpc09iamVjdChhUHJvcCkgJiYgaXNPYmplY3QoYlByb3ApKSB7XHJcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFsKGFQcm9wLCBiUHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhUHJvcCAhPT0gYlByb3ApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgayBvZiBiS2V5cykge1xyXG4gICAgICAgIGlmICghYUtleXMuaW5jbHVkZXMoaykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzT2JqZWN0KHRoaW5nKSB7XHJcbiAgICByZXR1cm4gdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nID09PSAnb2JqZWN0JztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogUmVqZWN0cyBpZiB0aGUgZ2l2ZW4gcHJvbWlzZSBkb2Vzbid0IHJlc29sdmUgaW4gdGltZUluTVMgbWlsbGlzZWNvbmRzLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHByb21pc2VXaXRoVGltZW91dChwcm9taXNlLCB0aW1lSW5NUyA9IDIwMDApIHtcclxuICAgIGNvbnN0IGRlZmVycmVkUHJvbWlzZSA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgc2V0VGltZW91dCgoKSA9PiBkZWZlcnJlZFByb21pc2UucmVqZWN0KCd0aW1lb3V0IScpLCB0aW1lSW5NUyk7XHJcbiAgICBwcm9taXNlLnRoZW4oZGVmZXJyZWRQcm9taXNlLnJlc29sdmUsIGRlZmVycmVkUHJvbWlzZS5yZWplY3QpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkUHJvbWlzZS5wcm9taXNlO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVlcnlzdHJpbmctZm9ybWF0dGVkIHN0cmluZyAoZS5nLiAmYXJnPXZhbCZhcmcyPXZhbDIpIGZyb20gYVxyXG4gKiBwYXJhbXMgb2JqZWN0IChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxyXG4gKiBOb3RlOiBZb3UgbXVzdCBwcmVwZW5kIGl0IHdpdGggPyB3aGVuIGFkZGluZyBpdCB0byBhIFVSTC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5c3RyaW5nUGFyYW1zKSB7XHJcbiAgICBjb25zdCBwYXJhbXMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHF1ZXJ5c3RyaW5nUGFyYW1zKSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGFycmF5VmFsID0+IHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFyYW1zLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyYW1zLmxlbmd0aCA/ICcmJyArIHBhcmFtcy5qb2luKCcmJykgOiAnJztcclxufVxyXG4vKipcclxuICogRGVjb2RlcyBhIHF1ZXJ5c3RyaW5nIChlLmcuID9hcmc9dmFsJmFyZzI9dmFsMikgaW50byBhIHBhcmFtcyBvYmplY3RcclxuICogKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeXN0cmluZ0RlY29kZShxdWVyeXN0cmluZykge1xyXG4gICAgY29uc3Qgb2JqID0ge307XHJcbiAgICBjb25zdCB0b2tlbnMgPSBxdWVyeXN0cmluZy5yZXBsYWNlKC9eXFw/LywgJycpLnNwbGl0KCcmJyk7XHJcbiAgICB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiB7XHJcbiAgICAgICAgaWYgKHRva2VuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHRva2VuLnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQoa2V5KV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG4vKipcclxuICogRXh0cmFjdCB0aGUgcXVlcnkgc3RyaW5nIHBhcnQgb2YgYSBVUkwsIGluY2x1ZGluZyB0aGUgbGVhZGluZyBxdWVzdGlvbiBtYXJrIChpZiBwcmVzZW50KS5cclxuICovXHJcbmZ1bmN0aW9uIGV4dHJhY3RRdWVyeXN0cmluZyh1cmwpIHtcclxuICAgIGNvbnN0IHF1ZXJ5U3RhcnQgPSB1cmwuaW5kZXhPZignPycpO1xyXG4gICAgaWYgKCFxdWVyeVN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZnJhZ21lbnRTdGFydCA9IHVybC5pbmRleE9mKCcjJywgcXVlcnlTdGFydCk7XHJcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZyhxdWVyeVN0YXJ0LCBmcmFnbWVudFN0YXJ0ID4gMCA/IGZyYWdtZW50U3RhcnQgOiB1bmRlZmluZWQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAZmlsZW92ZXJ2aWV3IFNIQS0xIGNyeXB0b2dyYXBoaWMgaGFzaC5cclxuICogVmFyaWFibGUgbmFtZXMgZm9sbG93IHRoZSBub3RhdGlvbiBpbiBGSVBTIFBVQiAxODAtMzpcclxuICogaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC0zL2ZpcHMxODAtM19maW5hbC5wZGYuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKiAgIHZhciBzaGExID0gbmV3IHNoYTEoKTtcclxuICogICBzaGExLnVwZGF0ZShieXRlcyk7XHJcbiAqICAgdmFyIGhhc2ggPSBzaGExLmRpZ2VzdCgpO1xyXG4gKlxyXG4gKiBQZXJmb3JtYW5jZTpcclxuICogICBDaHJvbWUgMjM6ICAgfjQwMCBNYml0L3NcclxuICogICBGaXJlZm94IDE2OiAgfjI1MCBNYml0L3NcclxuICpcclxuICovXHJcbi8qKlxyXG4gKiBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2ggY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIFRoZSBwcm9wZXJ0aWVzIGRlY2xhcmVkIGhlcmUgYXJlIGRpc2N1c3NlZCBpbiB0aGUgYWJvdmUgYWxnb3JpdGhtIGRvY3VtZW50LlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQGZpbmFsXHJcbiAqIEBzdHJ1Y3RcclxuICovXHJcbmNsYXNzIFNoYTEge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYS1lIGluIHRoZSBjb21wcmVzc19cclxuICAgICAgICAgKiBmdW5jdGlvbi5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hhaW5fID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBidWZmZXIgaG9sZGluZyB0aGUgcGFydGlhbGx5IGNvbXB1dGVkIGhhc2ggcmVzdWx0LlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5idWZfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJyYXkgb2YgODAgYnl0ZXMsIGVhY2ggYSBwYXJ0IG9mIHRoZSBtZXNzYWdlIHRvIGJlIGhhc2hlZC4gIFJlZmVycmVkIHRvXHJcbiAgICAgICAgICogYXMgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgaW4gdGhlIGRvY3MuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLldfID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGFpbnMgZGF0YSBuZWVkZWQgdG8gcGFkIG1lc3NhZ2VzIGxlc3MgdGhhbiA2NCBieXRlcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFkXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b3RhbF8gPSAwO1xyXG4gICAgICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gODtcclxuICAgICAgICB0aGlzLnBhZF9bMF0gPSAxMjg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFkX1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzBdID0gMHg2NzQ1MjMwMTtcclxuICAgICAgICB0aGlzLmNoYWluX1sxXSA9IDB4ZWZjZGFiODk7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAweDk4YmFkY2ZlO1xyXG4gICAgICAgIHRoaXMuY2hhaW5fWzNdID0gMHgxMDMyNTQ3NjtcclxuICAgICAgICB0aGlzLmNoYWluX1s0XSA9IDB4YzNkMmUxZjA7XHJcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xyXG4gICAgICAgIHRoaXMudG90YWxfID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJuYWwgY29tcHJlc3MgaGVscGVyIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIHRoZSBibG9jayBpbiB0aGUgYnVmZmVyLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29tcHJlc3NfKGJ1Ziwgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKCFvZmZzZXQpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgVyA9IHRoaXMuV187XHJcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcclxuICAgICAgICBpZiAodHlwZW9mIGJ1ZiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgYnVnIHRoYXQgdHVybnMgdGhlIHBvc3QtaW5jcmVtZW50ICsrIG9wZXJhdG9yIGludG8gcHJlLWluY3JlbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIEpJVCBjb21waWxhdGlvbi4gIFdlIGhhdmUgY29kZSB0aGF0IGRlcGVuZHMgaGVhdmlseSBvbiBTSEEtMSBmb3JcclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXHJcbiAgICAgICAgICAgICAgICAvLyBvZiBwb3N0LWluY3JlbWVudCArKyBpbiB3aGljaCB0aGUgcmVzdWx0IHZhbHVlIGlzIHVzZWQuICBXZSBjYW4gcmV2ZXJ0XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoYW5nZSBvbmNlIHRoZSBTYWZhcmkgYnVnXHJcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXHJcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGNsaWVudHMgaGF2ZSBiZWVuIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgICAgICBXW2ldID1cclxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCkgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1Zi5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDgpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob2Zmc2V0ICsgMyk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBXW2ldID1cclxuICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldF0gPDwgMjQpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvZmZzZXQgKyAxXSA8PCAxNikgfFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29mZnNldCArIDJdIDw8IDgpIHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW29mZnNldCArIDNdO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXhwYW5kIHRvIDgwIHdvcmRzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcclxuICAgICAgICAgICAgV1tpXSA9ICgodCA8PCAxKSB8ICh0ID4+PiAzMSkpICYgMHhmZmZmZmZmZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNoYWluX1swXTtcclxuICAgICAgICBsZXQgYiA9IHRoaXMuY2hhaW5fWzFdO1xyXG4gICAgICAgIGxldCBjID0gdGhpcy5jaGFpbl9bMl07XHJcbiAgICAgICAgbGV0IGQgPSB0aGlzLmNoYWluX1szXTtcclxuICAgICAgICBsZXQgZSA9IHRoaXMuY2hhaW5fWzRdO1xyXG4gICAgICAgIGxldCBmLCBrO1xyXG4gICAgICAgIC8vIFRPRE8odXNlcik6IFRyeSB0byB1bnJvbGwgdGhpcyBsb29wIHRvIHNwZWVkIHVwIHRoZSBjb21wdXRhdGlvbi5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPCA0MCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBkIF4gKGIgJiAoYyBeIGQpKTtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHg1YTgyNzk5OTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGYgPSBiIF4gYyBeIGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NmVkOWViYTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDYwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoZCAmIChiIHwgYykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDhmMWJiY2RjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcclxuICAgICAgICAgICAgICAgICAgICBrID0gMHhjYTYyYzFkNjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB0ID0gKCgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZiArIGUgKyBrICsgV1tpXSkgJiAweGZmZmZmZmZmO1xyXG4gICAgICAgICAgICBlID0gZDtcclxuICAgICAgICAgICAgZCA9IGM7XHJcbiAgICAgICAgICAgIGMgPSAoKGIgPDwgMzApIHwgKGIgPj4+IDIpKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgICAgIGIgPSBhO1xyXG4gICAgICAgICAgICBhID0gdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMV0gPSAodGhpcy5jaGFpbl9bMV0gKyBiKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAodGhpcy5jaGFpbl9bMl0gKyBjKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICAgICAgdGhpcy5jaGFpbl9bNF0gPSAodGhpcy5jaGFpbl9bNF0gKyBlKSAmIDB4ZmZmZmZmZmY7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoYnl0ZXMsIGxlbmd0aCkge1xyXG4gICAgICAgIC8vIFRPRE8oam9obmxlbnopOiB0aWdodGVuIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgYW5kIHJlbW92ZSB0aGlzIGNoZWNrXHJcbiAgICAgICAgaWYgKGJ5dGVzID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW5ndGhNaW51c0Jsb2NrID0gbGVuZ3RoIC0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIC8vIFVzaW5nIGxvY2FsIGluc3RlYWQgb2YgbWVtYmVyIHZhcmlhYmxlcyBnaXZlcyB+NSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LlxyXG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuYnVmXztcclxuICAgICAgICBsZXQgaW5idWYgPSB0aGlzLmluYnVmXztcclxuICAgICAgICAvLyBUaGUgb3V0ZXIgd2hpbGUgbG9vcCBzaG91bGQgZXhlY3V0ZSBhdCBtb3N0IHR3aWNlLlxyXG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgaGF2ZSBubyBkYXRhIGluIHRoZSBibG9jayB0byB0b3AgdXAsIHdlIGNhbiBkaXJlY3RseSBwcm9jZXNzIHRoZVxyXG4gICAgICAgICAgICAvLyBpbnB1dCBidWZmZXIgKGFzc3VtaW5nIGl0IGNvbnRhaW5zIHN1ZmZpY2llbnQgZGF0YSkuIFRoaXMgZ2l2ZXMgfjI1JVxyXG4gICAgICAgICAgICAvLyBzcGVlZHVwIG9uIENocm9tZSAyMyBhbmQgfjE1JSBzcGVlZHVwIG9uIEZpcmVmb3ggMTYsIGJ1dCByZXF1aXJlcyB0aGF0XHJcbiAgICAgICAgICAgIC8vIHRoZSBkYXRhIGlzIHByb3ZpZGVkIGluIGxhcmdlIGNodW5rcyAob3IgaW4gbXVsdGlwbGVzIG9mIDY0IGJ5dGVzKS5cclxuICAgICAgICAgICAgaWYgKGluYnVmID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8PSBsZW5ndGhNaW51c0Jsb2NrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzc18oYnl0ZXMsIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gdGhpcy5ibG9ja1NpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmW2luYnVmXSA9IGJ5dGVzLmNoYXJDb2RlQXQobik7XHJcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcclxuICAgICAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG4gPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXNbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcclxuICAgICAgICAgICAgICAgICAgICArK247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09PSB0aGlzLmJsb2NrU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIG91dGVyIGxvb3Agc28gd2UgdXNlIHRoZSBmdWxsLWJsb2NrIG9wdGltaXphdGlvbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5idWZfID0gaW5idWY7XHJcbiAgICAgICAgdGhpcy50b3RhbF8gKz0gbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqIEBvdmVycmlkZSAqL1xyXG4gICAgZGlnZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xyXG4gICAgICAgIGxldCB0b3RhbEJpdHMgPSB0aGlzLnRvdGFsXyAqIDg7XHJcbiAgICAgICAgLy8gQWRkIHBhZCAweDgwIDB4MDAqLlxyXG4gICAgICAgIGlmICh0aGlzLmluYnVmXyA8IDU2KSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgNTYgLSB0aGlzLmluYnVmXyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnBhZF8sIHRoaXMuYmxvY2tTaXplIC0gKHRoaXMuaW5idWZfIC0gNTYpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWRkICMgYml0cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5ibG9ja1NpemUgLSAxOyBpID49IDU2OyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5idWZfW2ldID0gdG90YWxCaXRzICYgMjU1O1xyXG4gICAgICAgICAgICB0b3RhbEJpdHMgLz0gMjU2OyAvLyBEb24ndCB1c2UgYml0LXNoaWZ0aW5nIGhlcmUhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcHJlc3NfKHRoaXMuYnVmXyk7XHJcbiAgICAgICAgbGV0IG4gPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcclxuICAgICAgICAgICAgICAgIGRpZ2VzdFtuXSA9ICh0aGlzLmNoYWluX1tpXSA+PiBqKSAmIDI1NTtcclxuICAgICAgICAgICAgICAgICsrbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlnZXN0O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBIZWxwZXIgdG8gbWFrZSBhIFN1YnNjcmliZSBmdW5jdGlvbiAoanVzdCBsaWtlIFByb21pc2UgaGVscHMgbWFrZSBhXHJcbiAqIFRoZW5hYmxlKS5cclxuICpcclxuICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXHJcbiAqICAgICBhcyBhIHByb3h5LlxyXG4gKiBAcGFyYW0gb25Ob09ic2VydmVycyBDYWxsYmFjayB3aGVuIGNvdW50IG9mIE9ic2VydmVycyBnb2VzIHRvIHplcm8uXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVTdWJzY3JpYmUoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpIHtcclxuICAgIGNvbnN0IHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xyXG4gICAgcmV0dXJuIHByb3h5LnN1YnNjcmliZS5iaW5kKHByb3h5KTtcclxufVxyXG4vKipcclxuICogSW1wbGVtZW50IGZhbi1vdXQgZm9yIGFueSBudW1iZXIgb2YgT2JzZXJ2ZXJzIGF0dGFjaGVkIHZpYSBhIHN1YnNjcmliZVxyXG4gKiBmdW5jdGlvbi5cclxuICovXHJcbmNsYXNzIE9ic2VydmVyUHJveHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXhlY3V0b3IgRnVuY3Rpb24gd2hpY2ggY2FuIG1ha2UgY2FsbHMgdG8gYSBzaW5nbGUgT2JzZXJ2ZXJcclxuICAgICAqICAgICBhcyBhIHByb3h5LlxyXG4gICAgICogQHBhcmFtIG9uTm9PYnNlcnZlcnMgQ2FsbGJhY2sgd2hlbiBjb3VudCBvZiBPYnNlcnZlcnMgZ29lcyB0byB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihleGVjdXRvciwgb25Ob09ic2VydmVycykge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgPSAwO1xyXG4gICAgICAgIC8vIE1pY3JvLXRhc2sgc2NoZWR1bGluZyBieSBjYWxsaW5nIHRhc2sudGhlbigpLlxyXG4gICAgICAgIHRoaXMudGFzayA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuZmluYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gb25Ob09ic2VydmVycztcclxuICAgICAgICAvLyBDYWxsIHRoZSBleGVjdXRvciBhc3luY2hyb25vdXNseSBzbyBzdWJzY3JpYmVycyB0aGF0IGFyZSBjYWxsZWRcclxuICAgICAgICAvLyBzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBjcmVhdGlvbiBvZiB0aGUgc3Vic2NyaWJlIGZ1bmN0aW9uXHJcbiAgICAgICAgLy8gY2FuIHN0aWxsIHJlY2VpdmUgdGhlIHZlcnkgZmlyc3QgdmFsdWUgZ2VuZXJhdGVkIGluIHRoZSBleGVjdXRvci5cclxuICAgICAgICB0aGlzLnRhc2tcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBleGVjdXRvcih0aGlzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBuZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcigob2JzZXJ2ZXIpID0+IHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2xvc2UoZXJyb3IpO1xyXG4gICAgfVxyXG4gICAgY29tcGxldGUoKSB7XHJcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoKG9ic2VydmVyKSA9PiB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgYW4gT2JzZXJ2ZXIgdG8gdGhlIGZhbi1vdXQgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiAtIFdlIHJlcXVpcmUgdGhhdCBubyBldmVudCBpcyBzZW50IHRvIGEgc3Vic2NyaWJlciBzeWNocm9ub3VzbHkgdG8gdGhlaXJcclxuICAgICAqICAgY2FsbCB0byBzdWJzY3JpYmUoKS5cclxuICAgICAqL1xyXG4gICAgc3Vic2NyaWJlKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcclxuICAgICAgICBsZXQgb2JzZXJ2ZXI7XHJcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgZXJyb3IgPT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBjb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBPYnNlcnZlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXNzZW1ibGUgYW4gT2JzZXJ2ZXIgb2JqZWN0IHdoZW4gcGFzc2VkIGFzIGNhbGxiYWNrIGZ1bmN0aW9ucy5cclxuICAgICAgICBpZiAoaW1wbGVtZW50c0FueU1ldGhvZHMobmV4dE9yT2JzZXJ2ZXIsIFtcclxuICAgICAgICAgICAgJ25leHQnLFxyXG4gICAgICAgICAgICAnZXJyb3InLFxyXG4gICAgICAgICAgICAnY29tcGxldGUnXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyID0ge1xyXG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dE9yT2JzZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICBlcnJvcixcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5uZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCA9IG5vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvYnNlcnZlci5lcnJvciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yID0gbm9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9ic2VydmVyLmNvbXBsZXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUgPSBub29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB1bnN1YiA9IHRoaXMudW5zdWJzY3JpYmVPbmUuYmluZCh0aGlzLCB0aGlzLm9ic2VydmVycy5sZW5ndGgpO1xyXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc3Vic2NyaWJlIHRvIGEgdGVybWluYXRlZCBPYnNlcnZhYmxlIC0gd2VcclxuICAgICAgICAvLyBqdXN0IHJlc3BvbmQgdG8gdGhlIE9ic2VydmVyIHdpdGggdGhlIGZpbmFsIGVycm9yIG9yIGNvbXBsZXRlXHJcbiAgICAgICAgLy8gZXZlbnQuXHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICAgICAgdGhpcy50YXNrLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5hbEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKHRoaXMuZmluYWxFcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgcmV0dXJuIHVuc3ViO1xyXG4gICAgfVxyXG4gICAgLy8gVW5zdWJzY3JpYmUgaXMgc3luY2hyb25vdXMgLSB3ZSBndWFyYW50ZWUgdGhhdCBubyBldmVudHMgYXJlIHNlbnQgdG9cclxuICAgIC8vIGFueSB1bnN1YnNjcmliZWQgT2JzZXJ2ZXIuXHJcbiAgICB1bnN1YnNjcmliZU9uZShpKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJzID09PSB1bmRlZmluZWQgfHwgdGhpcy5vYnNlcnZlcnNbaV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm9ic2VydmVyc1tpXTtcclxuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgLT0gMTtcclxuICAgICAgICBpZiAodGhpcy5vYnNlcnZlckNvdW50ID09PSAwICYmIHRoaXMub25Ob09ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JFYWNoT2JzZXJ2ZXIoZm4pIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgLy8gQWxyZWFkeSBjbG9zZWQgYnkgcHJldmlvdXMgZXZlbnQuLi4uanVzdCBlYXQgdGhlIGFkZGl0aW9uYWwgdmFsdWVzLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNpbmNlIHNlbmRPbmUgY2FsbHMgYXN5bmNocm9ub3VzbHkgLSB0aGVyZSBpcyBubyBjaGFuY2UgdGhhdFxyXG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uZShpLCBmbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2FsbCB0aGUgT2JzZXJ2ZXIgdmlhIG9uZSBvZiBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uLiBXZSBhcmUgY2FyZWZ1bCB0b1xyXG4gICAgLy8gY29uZmlybSB0aGF0IHRoZSBvYnNlcnZlIGhhcyBub3QgYmVlbiB1bnN1YnNjcmliZWQgc2luY2UgdGhpcyBhc3luY2hyb25vdXNcclxuICAgIC8vIGZ1bmN0aW9uIGhhZCBiZWVuIHF1ZXVlZC5cclxuICAgIHNlbmRPbmUoaSwgZm4pIHtcclxuICAgICAgICAvLyBFeGVjdXRlIHRoZSBjYWxsYmFjayBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXNcclxuICAgICAgICB0aGlzLnRhc2sudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMub2JzZXJ2ZXJzW2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm4odGhpcy5vYnNlcnZlcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXhjZXB0aW9ucyByYWlzZWQgaW4gT2JzZXJ2ZXJzIG9yIG1pc3NpbmcgbWV0aG9kcyBvZiBhblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ic2VydmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciB0byBjb25zb2xlLiBiLzMxNDA0ODA2XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjbG9zZShlcnIpIHtcclxuICAgICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpbmFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJveHkgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIGdhcmJhZ2UgY29sbGVjdCByZWZlcmVuY2VzXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xyXG4gICAgICAgIHRoaXMudGFzay50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKiogVHVybiBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIG9uZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICovXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXHJcbmZ1bmN0aW9uIGFzeW5jKGZuLCBvbkVycm9yKSB7XHJcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBQcm9taXNlLnJlc29sdmUodHJ1ZSlcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBmbiguLi5hcmdzKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbXBsZW1lbnRzQW55TWV0aG9kcyhvYmosIG1ldGhvZHMpIHtcclxuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSB7XHJcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBub29wKCkge1xyXG4gICAgLy8gZG8gbm90aGluZ1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBDaGVjayB0byBtYWtlIHN1cmUgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIGZvciBhIHB1YmxpYyBmdW5jdGlvbi5cclxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSBtaW5Db3VudCBUaGUgbWluaW11bSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxyXG4gKiBAcGFyYW0gbWF4Q291bnQgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50IHRvIGFsbG93IGZvciB0aGUgZnVuY3Rpb24gY2FsbFxyXG4gKiBAcGFyYW0gYXJnQ291bnQgVGhlIGFjdHVhbCBudW1iZXIgb2YgYXJndW1lbnRzIHByb3ZpZGVkLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVBcmdDb3VudCA9IGZ1bmN0aW9uIChmbk5hbWUsIG1pbkNvdW50LCBtYXhDb3VudCwgYXJnQ291bnQpIHtcclxuICAgIGxldCBhcmdFcnJvcjtcclxuICAgIGlmIChhcmdDb3VudCA8IG1pbkNvdW50KSB7XHJcbiAgICAgICAgYXJnRXJyb3IgPSAnYXQgbGVhc3QgJyArIG1pbkNvdW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYXJnQ291bnQgPiBtYXhDb3VudCkge1xyXG4gICAgICAgIGFyZ0Vycm9yID0gbWF4Q291bnQgPT09IDAgPyAnbm9uZScgOiAnbm8gbW9yZSB0aGFuICcgKyBtYXhDb3VudDtcclxuICAgIH1cclxuICAgIGlmIChhcmdFcnJvcikge1xyXG4gICAgICAgIGNvbnN0IGVycm9yID0gZm5OYW1lICtcclxuICAgICAgICAgICAgJyBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCAnICtcclxuICAgICAgICAgICAgYXJnQ291bnQgK1xyXG4gICAgICAgICAgICAoYXJnQ291bnQgPT09IDEgPyAnIGFyZ3VtZW50LicgOiAnIGFyZ3VtZW50cy4nKSArXHJcbiAgICAgICAgICAgICcgRXhwZWN0cyAnICtcclxuICAgICAgICAgICAgYXJnRXJyb3IgK1xyXG4gICAgICAgICAgICAnLic7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyB0byBwcmVmaXggYW4gZXJyb3IgbWVzc2FnZSBhYm91dCBmYWlsZWQgYXJndW1lbnQgdmFsaWRhdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXHJcbiAqIEBwYXJhbSBhcmdOYW1lIFRoZSBuYW1lIG9mIHRoZSBhcmd1bWVudFxyXG4gKiBAcmV0dXJuIFRoZSBwcmVmaXggdG8gYWRkIHRvIHRoZSBlcnJvciB0aHJvd24gZm9yIHZhbGlkYXRpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBlcnJvclByZWZpeChmbk5hbWUsIGFyZ05hbWUpIHtcclxuICAgIHJldHVybiBgJHtmbk5hbWV9IGZhaWxlZDogJHthcmdOYW1lfSBhcmd1bWVudCBgO1xyXG59XHJcbi8qKlxyXG4gKiBAcGFyYW0gZm5OYW1lXHJcbiAqIEBwYXJhbSBhcmd1bWVudE51bWJlclxyXG4gKiBAcGFyYW0gbmFtZXNwYWNlXHJcbiAqIEBwYXJhbSBvcHRpb25hbFxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOYW1lc3BhY2UoZm5OYW1lLCBuYW1lc3BhY2UsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vVE9ETzogSSBzaG91bGQgZG8gbW9yZSB2YWxpZGF0aW9uIGhlcmUuIFdlIG9ubHkgYWxsb3cgY2VydGFpbiBjaGFycyBpbiBuYW1lc3BhY2VzLlxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICduYW1lc3BhY2UnKSArICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgbmFtZXNwYWNlLicpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FsbGJhY2soZm5OYW1lLCBhcmd1bWVudE5hbWUsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xyXG5jYWxsYmFjaywgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiAhY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROYW1lLCBjb250ZXh0LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmICFjb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArICdtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQ29kZSBvcmlnaW5hbGx5IGNhbWUgZnJvbSBnb29nLmNyeXB0LnN0cmluZ1RvVXRmOEJ5dGVBcnJheSwgYnV0IGZvciBzb21lIHJlYXNvbiB0aGV5XHJcbi8vIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgJ1xcclxcbicgd2l0aCAnXFxuJywgYW5kIHRoZXkgZGlkbid0IGhhbmRsZSBzdXJyb2dhdGUgcGFpcnMsXHJcbi8vIHNvIGl0J3MgYmVlbiBtb2RpZmllZC5cclxuLy8gTm90ZSB0aGF0IG5vdCBhbGwgVW5pY29kZSBjaGFyYWN0ZXJzIGFwcGVhciBhcyBzaW5nbGUgY2hhcmFjdGVycyBpbiBKYXZhU2NyaXB0IHN0cmluZ3MuXHJcbi8vIGZyb21DaGFyQ29kZSByZXR1cm5zIHRoZSBVVEYtMTYgZW5jb2Rpbmcgb2YgYSBjaGFyYWN0ZXIgLSBzbyBzb21lIFVuaWNvZGUgY2hhcmFjdGVyc1xyXG4vLyB1c2UgMiBjaGFyYWN0ZXJzIGluIEphdmFzY3JpcHQuICBBbGwgNC1ieXRlIFVURi04IGNoYXJhY3RlcnMgYmVnaW4gd2l0aCBhIGZpcnN0XHJcbi8vIGNoYXJhY3RlciBpbiB0aGUgcmFuZ2UgMHhEODAwIC0gMHhEQkZGICh0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc28tY2FsbGVkIHN1cnJvZ2F0ZVxyXG4vLyBwYWlyKS5cclxuLy8gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xNS4xLjNcclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqL1xyXG5jb25zdCBzdHJpbmdUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IG91dCA9IFtdO1xyXG4gICAgbGV0IHAgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIC8vIElzIHRoaXMgdGhlIGxlYWQgc3Vycm9nYXRlIGluIGEgc3Vycm9nYXRlIHBhaXI/XHJcbiAgICAgICAgaWYgKGMgPj0gMHhkODAwICYmIGMgPD0gMHhkYmZmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBjIC0gMHhkODAwOyAvLyB0aGUgaGlnaCAxMCBiaXRzLlxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIGFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xyXG4gICAgICAgICAgICBjb25zdCBsb3cgPSBzdHIuY2hhckNvZGVBdChpKSAtIDB4ZGMwMDsgLy8gdGhlIGxvdyAxMCBiaXRzLlxyXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArIChoaWdoIDw8IDEwKSArIGxvdztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjIDwgNjU1MzYpIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xyXG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcclxuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufTtcclxuLyoqXHJcbiAqIENhbGN1bGF0ZSBsZW5ndGggd2l0aG91dCBhY3R1YWxseSBjb252ZXJ0aW5nOyB1c2VmdWwgZm9yIGRvaW5nIGNoZWFwZXIgdmFsaWRhdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqL1xyXG5jb25zdCBzdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICBsZXQgcCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOCkge1xyXG4gICAgICAgICAgICBwKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIHAgKz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcclxuICAgICAgICAgICAgLy8gTGVhZCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci4gIFRoZSBwYWlyIHRvZ2V0aGVyIHdpbGwgdGFrZSA0IGJ5dGVzIHRvIHJlcHJlc2VudC5cclxuICAgICAgICAgICAgcCArPSA0O1xyXG4gICAgICAgICAgICBpKys7IC8vIHNraXAgdHJhaWwgc3Vycm9nYXRlLlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcCArPSAzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBwO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29waWVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcclxuICogR2VuZXJhdGVzIGEgbmV3IHV1aWQuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IHV1aWR2NCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGMgPT4ge1xyXG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDAsIHYgPSBjID09PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xyXG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcclxuICAgIH0pO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgdG8gZXhwb25lbnRpYWxseSBpbmNyZWFzZS5cclxuICovXHJcbmNvbnN0IERFRkFVTFRfSU5URVJWQUxfTUlMTElTID0gMTAwMDtcclxuLyoqXHJcbiAqIFRoZSBmYWN0b3IgdG8gYmFja29mZiBieS5cclxuICogU2hvdWxkIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAxLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9CQUNLT0ZGX0ZBQ1RPUiA9IDI7XHJcbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBtaWxsaXNlY29uZHMgdG8gaW5jcmVhc2UgdG8uXHJcbiAqXHJcbiAqIDxwPlZpc2libGUgZm9yIHRlc3RpbmdcclxuICovXHJcbmNvbnN0IE1BWF9WQUxVRV9NSUxMSVMgPSA0ICogNjAgKiA2MCAqIDEwMDA7IC8vIEZvdXIgaG91cnMsIGxpa2UgaU9TIGFuZCBBbmRyb2lkLlxyXG4vKipcclxuICogVGhlIHBlcmNlbnRhZ2Ugb2YgYmFja29mZiB0aW1lIHRvIHJhbmRvbWl6ZSBieS5cclxuICogU2VlXHJcbiAqIGh0dHA6Ly9nby9zYWZlLWNsaWVudC1iZWhhdmlvciNzdGVwLTEtZGV0ZXJtaW5lLXRoZS1hcHByb3ByaWF0ZS1yZXRyeS1pbnRlcnZhbC10by1oYW5kbGUtc3Bpa2UtdHJhZmZpY1xyXG4gKiBmb3IgY29udGV4dC5cclxuICpcclxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZ1xyXG4gKi9cclxuY29uc3QgUkFORE9NX0ZBQ1RPUiA9IDAuNTtcclxuLyoqXHJcbiAqIEJhc2VkIG9uIHRoZSBiYWNrb2ZmIG1ldGhvZCBmcm9tXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2V4cG9uZW50aWFsYmFja29mZi5qcy5cclxuICogRXh0cmFjdGVkIGhlcmUgc28gd2UgZG9uJ3QgbmVlZCB0byBwYXNzIG1ldGFkYXRhIGFuZCBhIHN0YXRlZnVsIEV4cG9uZW50aWFsQmFja29mZiBvYmplY3QgYXJvdW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlQmFja29mZk1pbGxpcyhiYWNrb2ZmQ291bnQsIGludGVydmFsTWlsbGlzID0gREVGQVVMVF9JTlRFUlZBTF9NSUxMSVMsIGJhY2tvZmZGYWN0b3IgPSBERUZBVUxUX0JBQ0tPRkZfRkFDVE9SKSB7XHJcbiAgICAvLyBDYWxjdWxhdGVzIGFuIGV4cG9uZW50aWFsbHkgaW5jcmVhc2luZyB2YWx1ZS5cclxuICAgIC8vIERldmlhdGlvbjogY2FsY3VsYXRlcyB2YWx1ZSBmcm9tIGNvdW50IGFuZCBhIGNvbnN0YW50IGludGVydmFsLCBzbyB3ZSBvbmx5IG5lZWQgdG8gc2F2ZSB2YWx1ZVxyXG4gICAgLy8gYW5kIGNvdW50IHRvIHJlc3RvcmUgc3RhdGUuXHJcbiAgICBjb25zdCBjdXJyQmFzZVZhbHVlID0gaW50ZXJ2YWxNaWxsaXMgKiBNYXRoLnBvdyhiYWNrb2ZmRmFjdG9yLCBiYWNrb2ZmQ291bnQpO1xyXG4gICAgLy8gQSByYW5kb20gXCJmdXp6XCIgdG8gYXZvaWQgd2F2ZXMgb2YgcmV0cmllcy5cclxuICAgIC8vIERldmlhdGlvbjogcmFuZG9tRmFjdG9yIGlzIHJlcXVpcmVkLlxyXG4gICAgY29uc3QgcmFuZG9tV2FpdCA9IE1hdGgucm91bmQoXHJcbiAgICAvLyBBIGZyYWN0aW9uIG9mIHRoZSBiYWNrb2ZmIHZhbHVlIHRvIGFkZC9zdWJ0cmFjdC5cclxuICAgIC8vIERldmlhdGlvbjogY2hhbmdlcyBtdWx0aXBsaWNhdGlvbiBvcmRlciB0byBpbXByb3ZlIHJlYWRhYmlsaXR5LlxyXG4gICAgUkFORE9NX0ZBQ1RPUiAqXHJcbiAgICAgICAgY3VyckJhc2VWYWx1ZSAqXHJcbiAgICAgICAgLy8gQSByYW5kb20gZmxvYXQgKHJvdW5kZWQgdG8gaW50IGJ5IE1hdGgucm91bmQgYWJvdmUpIGluIHRoZSByYW5nZSBbLTEsIDFdLiBEZXRlcm1pbmVzXHJcbiAgICAgICAgLy8gaWYgd2UgYWRkIG9yIHN1YnRyYWN0LlxyXG4gICAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqXHJcbiAgICAgICAgMik7XHJcbiAgICAvLyBMaW1pdHMgYmFja29mZiB0byBtYXggdG8gYXZvaWQgZWZmZWN0aXZlbHkgcGVybWFuZW50IGJhY2tvZmYuXHJcbiAgICByZXR1cm4gTWF0aC5taW4oTUFYX1ZBTFVFX01JTExJUywgY3VyckJhc2VWYWx1ZSArIHJhbmRvbVdhaXQpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlIEVuZ2xpc2ggb3JkaW5hbCBsZXR0ZXJzIGFmdGVyIGEgbnVtYmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRpbmFsKGkpIHtcclxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGkpKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2l9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBpICsgaW5kaWNhdG9yKGkpO1xyXG59XHJcbmZ1bmN0aW9uIGluZGljYXRvcihpKSB7XHJcbiAgICBpID0gTWF0aC5hYnMoaSk7XHJcbiAgICBjb25zdCBjZW50ID0gaSAlIDEwMDtcclxuICAgIGlmIChjZW50ID49IDEwICYmIGNlbnQgPD0gMjApIHtcclxuICAgICAgICByZXR1cm4gJ3RoJztcclxuICAgIH1cclxuICAgIGNvbnN0IGRlYyA9IGkgJSAxMDtcclxuICAgIGlmIChkZWMgPT09IDEpIHtcclxuICAgICAgICByZXR1cm4gJ3N0JztcclxuICAgIH1cclxuICAgIGlmIChkZWMgPT09IDIpIHtcclxuICAgICAgICByZXR1cm4gJ25kJztcclxuICAgIH1cclxuICAgIGlmIChkZWMgPT09IDMpIHtcclxuICAgICAgICByZXR1cm4gJ3JkJztcclxuICAgIH1cclxuICAgIHJldHVybiAndGgnO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldE1vZHVsYXJJbnN0YW5jZShzZXJ2aWNlKSB7XHJcbiAgICBpZiAoc2VydmljZSAmJiBzZXJ2aWNlLl9kZWxlZ2F0ZSkge1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlLl9kZWxlZ2F0ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzZXJ2aWNlO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENPTlNUQU5UUywgRGVjb2RlQmFzZTY0U3RyaW5nRXJyb3IsIERlZmVycmVkLCBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IsIE1BWF9WQUxVRV9NSUxMSVMsIFJBTkRPTV9GQUNUT1IsIFNoYTEsIGFyZUNvb2tpZXNFbmFibGVkLCBhc3NlcnQsIGFzc2VydGlvbkVycm9yLCBhc3luYywgYmFzZTY0LCBiYXNlNjREZWNvZGUsIGJhc2U2NEVuY29kZSwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMsIGNvbnRhaW5zLCBjcmVhdGVNb2NrVXNlclRva2VuLCBjcmVhdGVTdWJzY3JpYmUsIGRlY29kZSwgZGVlcENvcHksIGRlZXBFcXVhbCwgZGVlcEV4dGVuZCwgZXJyb3JQcmVmaXgsIGV4dHJhY3RRdWVyeXN0cmluZywgZ2V0RGVmYXVsdEFwcENvbmZpZywgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdCwgZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0LCBnZXREZWZhdWx0cywgZ2V0RXhwZXJpbWVudGFsU2V0dGluZywgZ2V0R2xvYmFsLCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldFVBLCBpc0FkbWluLCBpc0Jyb3dzZXIsIGlzQnJvd3NlckV4dGVuc2lvbiwgaXNFbGVjdHJvbiwgaXNFbXB0eSwgaXNJRSwgaXNJbmRleGVkREJBdmFpbGFibGUsIGlzTW9iaWxlQ29yZG92YSwgaXNOb2RlLCBpc05vZGVTZGssIGlzUmVhY3ROYXRpdmUsIGlzU2FmYXJpLCBpc1VXUCwgaXNWYWxpZEZvcm1hdCwgaXNWYWxpZFRpbWVzdGFtcCwgaXNzdWVkQXRUaW1lLCBqc29uRXZhbCwgbWFwLCBvcmRpbmFsLCBwcm9taXNlV2l0aFRpbWVvdXQsIHF1ZXJ5c3RyaW5nLCBxdWVyeXN0cmluZ0RlY29kZSwgc2FmZUdldCwgc3RyaW5nTGVuZ3RoLCBzdHJpbmdUb0J5dGVBcnJheSwgc3RyaW5naWZ5LCB1dWlkdjQsIHZhbGlkYXRlQXJnQ291bnQsIHZhbGlkYXRlQ2FsbGJhY2ssIHZhbGlkYXRlQ29udGV4dE9iamVjdCwgdmFsaWRhdGVJbmRleGVkREJPcGVuYWJsZSwgdmFsaWRhdGVOYW1lc3BhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iLCJpbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcblxuLyoqXHJcbiAqIENvbXBvbmVudCBmb3Igc2VydmljZSBuYW1lIFQsIGUuZy4gYGF1dGhgLCBgYXV0aC1pbnRlcm5hbGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcHVibGljIHNlcnZpY2UgbmFtZSwgZS5nLiBhcHAsIGF1dGgsIGZpcmVzdG9yZSwgZGF0YWJhc2VcclxuICAgICAqIEBwYXJhbSBpbnN0YW5jZUZhY3RvcnkgU2VydmljZSBmYWN0b3J5IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgcHVibGljIGludGVyZmFjZVxyXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGUgc2VydmljZSBwcm92aWRlZCBieSB0aGUgY29tcG9uZW50IGlzIHB1YmxpYyBvciBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGluc3RhbmNlRmFjdG9yeSwgdHlwZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZUZhY3RvcnkgPSBpbnN0YW5jZUZhY3Rvcnk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyB0byBiZSBhZGRlZCB0byB0aGUgc2VydmljZSBuYW1lc3BhY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBcIkxBWllcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5MQVpZICovO1xyXG4gICAgICAgIHRoaXMub25JbnN0YW5jZUNyZWF0ZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFudGlhdGlvbk1vZGUobW9kZSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFudGlhdGlvbk1vZGUgPSBtb2RlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0TXVsdGlwbGVJbnN0YW5jZXMobXVsdGlwbGVJbnN0YW5jZXMpIHtcclxuICAgICAgICB0aGlzLm11bHRpcGxlSW5zdGFuY2VzID0gbXVsdGlwbGVJbnN0YW5jZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRTZXJ2aWNlUHJvcHMocHJvcHMpIHtcclxuICAgICAgICB0aGlzLnNlcnZpY2VQcm9wcyA9IHByb3BzO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0SW5zdGFuY2VDcmVhdGVkQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLm9uSW5zdGFuY2VDcmVhdGVkID0gY2FsbGJhY2s7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREVGQVVMVF9FTlRSWV9OQU1FID0gJ1tERUZBVUxUXSc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBQcm92aWRlciBmb3IgaW5zdGFuY2UgZm9yIHNlcnZpY2UgbmFtZSBULCBlLmcuICdhdXRoJywgJ2F1dGgtaW50ZXJuYWwnXHJcbiAqIE5hbWVTZXJ2aWNlTWFwcGluZ1tUXSBpcyBhbiBhbGlhcyBmb3IgdGhlIHR5cGUgb2YgdGhlIGluc3RhbmNlXHJcbiAqL1xyXG5jbGFzcyBQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VzT3B0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm9uSW5pdENhbGxiYWNrcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQSBwcm92aWRlciBjYW4gcHJvdmlkZSBtdWxpdHBsZSBpbnN0YW5jZXMgb2YgYSBzZXJ2aWNlXHJcbiAgICAgKiBpZiB0aGlzLmNvbXBvbmVudC5tdWx0aXBsZUluc3RhbmNlcyBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBnZXQoaWRlbnRpZmllcikge1xyXG4gICAgICAgIC8vIGlmIG11bHRpcGxlSW5zdGFuY2VzIGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSB0aGUgZGVmYXVsdCBuYW1lXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuaGFzKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc0RlZmVycmVkLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZGVmZXJyZWQpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRBdXRvSW5pdGlhbGl6ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBzZXJ2aWNlIGlmIGl0IGNhbiBiZSBhdXRvLWluaXRpYWxpemVkXHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVkSWRlbnRpZmllclxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgZ2V0KCksIGl0IHNob3VsZCBub3QgY2F1c2VcclxuICAgICAgICAgICAgICAgICAgICAvLyBhIGZhdGFsIGVycm9yLiBXZSBqdXN0IHJldHVybiB0aGUgdW5yZXNvbHZlZCBwcm9taXNlIGluIHRoaXMgY2FzZS5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICBnZXRJbW1lZGlhdGUob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyBpZiBtdWx0aXBsZUluc3RhbmNlcyBpcyBub3Qgc3VwcG9ydGVkLCB1c2UgdGhlIGRlZmF1bHQgbmFtZVxyXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRJZGVudGlmaWVyID0gdGhpcy5ub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlkZW50aWZpZXIpO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9wdGlvbmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE9ySW5pdGlhbGl6ZVNlcnZpY2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXJcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluIGNhc2UgYSBjb21wb25lbnQgaXMgbm90IGluaXRpYWxpemVkIGFuZCBzaG91bGQvY2FuIG5vdCBiZSBhdXRvLWluaXRpYWxpemVkIGF0IHRoZSBtb21lbnQsIHJldHVybiBudWxsIGlmIHRoZSBvcHRpb25hbCBmbGFnIGlzIHNldCwgb3IgdGhyb3dcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBTZXJ2aWNlICR7dGhpcy5uYW1lfSBpcyBub3QgYXZhaWxhYmxlYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgc2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmIChjb21wb25lbnQubmFtZSAhPT0gdGhpcy5uYW1lKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBNaXNtYXRjaGluZyBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gZm9yIFByb3ZpZGVyICR7dGhpcy5uYW1lfS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgZm9yICR7dGhpcy5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIC8vIHJldHVybiBlYXJseSB3aXRob3V0IGF0dGVtcHRpbmcgdG8gaW5pdGlhbGl6ZSB0aGUgY29tcG9uZW50IGlmIHRoZSBjb21wb25lbnQgcmVxdWlyZXMgZXhwbGljaXQgaW5pdGlhbGl6YXRpb24gKGNhbGxpbmcgYFByb3ZpZGVyLmluaXRpYWxpemUoKWApXHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF1dG9Jbml0aWFsaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgc2VydmljZSBpcyBlYWdlciwgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZVxyXG4gICAgICAgIGlmIChpc0NvbXBvbmVudEVhZ2VyKGNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7IGluc3RhbmNlSWRlbnRpZmllcjogREVGQVVMVF9FTlRSWV9OQU1FIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpbnN0YW5jZSBmYWN0b3J5IGZvciBhbiBlYWdlciBDb21wb25lbnQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBkdXJpbmcgdGhlIGVhZ2VyXHJcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZSBhIGZhdGFsIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgd2UgbmVlZCB0byBtYWtlIGl0IGNvbmZpZ3VyYWJsZSwgYmVjYXVzZSBzb21lIGNvbXBvbmVudCBtYXkgd2FudCB0byBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvciBpbiB0aGlzIGNhc2U/XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIHNlcnZpY2UgaW5zdGFuY2VzIGZvciB0aGUgcGVuZGluZyBwcm9taXNlcyBhbmQgcmVzb2x2ZSB0aGVtXHJcbiAgICAgICAgLy8gTk9URTogaWYgdGhpcy5tdWx0aXBsZUluc3RhbmNlcyBpcyBmYWxzZSwgb25seSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB3aWxsIGJlIGNyZWF0ZWRcclxuICAgICAgICAvLyBhbmQgYWxsIHByb21pc2VzIHdpdGggcmVzb2x2ZSB3aXRoIGl0IHJlZ2FyZGxlc3Mgb2YgdGhlIGlkZW50aWZpZXIuXHJcbiAgICAgICAgZm9yIChjb25zdCBbaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZURlZmVycmVkXSBvZiB0aGlzLmluc3RhbmNlc0RlZmVycmVkLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBgZ2V0T3JJbml0aWFsaXplU2VydmljZSgpYCBzaG91bGQgYWx3YXlzIHJldHVybiBhIHZhbGlkIGluc3RhbmNlIHNpbmNlIGEgY29tcG9uZW50IGlzIGd1YXJhbnRlZWQuIHVzZSAhIHRvIG1ha2UgdHlwZXNjcmlwdCBoYXBweS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRPckluaXRpYWxpemVTZXJ2aWNlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUlkZW50aWZpZXI6IG5vcm1hbGl6ZWRJZGVudGlmaWVyXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGluc3RhbmNlIGZhY3RvcnkgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgaXQgc2hvdWxkIG5vdCBjYXVzZVxyXG4gICAgICAgICAgICAgICAgLy8gYSBmYXRhbCBlcnJvci4gV2UganVzdCBsZWF2ZSB0aGUgcHJvbWlzZSB1bnJlc29sdmVkLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJJbnN0YW5jZShpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNEZWZlcnJlZC5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZXNPcHRpb25zLmRlbGV0ZShpZGVudGlmaWVyKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlcy5kZWxldGUoaWRlbnRpZmllcik7XHJcbiAgICB9XHJcbiAgICAvLyBhcHAuZGVsZXRlKCkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIG9uIGV2ZXJ5IHByb3ZpZGVyIHRvIGRlbGV0ZSB0aGUgc2VydmljZXNcclxuICAgIC8vIFRPRE86IHNob3VsZCB3ZSBtYXJrIHRoZSBwcm92aWRlciBhcyBkZWxldGVkP1xyXG4gICAgYXN5bmMgZGVsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gQXJyYXkuZnJvbSh0aGlzLmluc3RhbmNlcy52YWx1ZXMoKSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdJTlRFUk5BTCcgaW4gc2VydmljZSkgLy8gbGVnYWN5IHNlcnZpY2VzXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgLm1hcChzZXJ2aWNlID0+IHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCkpLFxyXG4gICAgICAgICAgICAuLi5zZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihzZXJ2aWNlID0+ICdfZGVsZXRlJyBpbiBzZXJ2aWNlKSAvLyBtb2R1bGFyaXplZCBzZXJ2aWNlc1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIC5tYXAoc2VydmljZSA9PiBzZXJ2aWNlLl9kZWxldGUoKSlcclxuICAgICAgICBdKTtcclxuICAgIH1cclxuICAgIGlzQ29tcG9uZW50U2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudCAhPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaXNJbml0aWFsaXplZChpZGVudGlmaWVyID0gREVGQVVMVF9FTlRSWV9OQU1FKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VzLmhhcyhpZGVudGlmaWVyKTtcclxuICAgIH1cclxuICAgIGdldE9wdGlvbnMoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlc09wdGlvbnMuZ2V0KGlkZW50aWZpZXIpIHx8IHt9O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShvcHRzID0ge30pIHtcclxuICAgICAgICBjb25zdCB7IG9wdGlvbnMgPSB7fSB9ID0gb3B0cztcclxuICAgICAgICBjb25zdCBub3JtYWxpemVkSWRlbnRpZmllciA9IHRoaXMubm9ybWFsaXplSW5zdGFuY2VJZGVudGlmaWVyKG9wdHMuaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAodGhpcy5pc0luaXRpYWxpemVkKG5vcm1hbGl6ZWRJZGVudGlmaWVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgJHt0aGlzLm5hbWV9KCR7bm9ybWFsaXplZElkZW50aWZpZXJ9KSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBvbmVudFNldCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb21wb25lbnQgJHt0aGlzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuZ2V0T3JJbml0aWFsaXplU2VydmljZSh7XHJcbiAgICAgICAgICAgIGluc3RhbmNlSWRlbnRpZmllcjogbm9ybWFsaXplZElkZW50aWZpZXIsXHJcbiAgICAgICAgICAgIG9wdGlvbnNcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2Ugd2FpdGluZyBmb3IgdGhlIHNlcnZpY2UgaW5zdGFuY2VcclxuICAgICAgICBmb3IgKGNvbnN0IFtpbnN0YW5jZUlkZW50aWZpZXIsIGluc3RhbmNlRGVmZXJyZWRdIG9mIHRoaXMuaW5zdGFuY2VzRGVmZXJyZWQuZW50cmllcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpbnN0YW5jZUlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZElkZW50aWZpZXIgPT09IG5vcm1hbGl6ZWREZWZlcnJlZElkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlRGVmZXJyZWQucmVzb2x2ZShpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgaW52b2tlZCAgYWZ0ZXIgdGhlIHByb3ZpZGVyIGhhcyBiZWVuIGluaXRpYWxpemVkIGJ5IGNhbGxpbmcgcHJvdmlkZXIuaW5pdGlhbGl6ZSgpLlxyXG4gICAgICogVGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgU1lOQ0hST05PVVNMWSwgc28gaXQgc2hvdWxkIG5vdCBleGVjdXRlIGFueSBsb25ncnVubmluZyB0YXNrcyBpbiBvcmRlciB0byBub3QgYmxvY2sgdGhlIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGlkZW50aWZpZXIgQW4gb3B0aW9uYWwgaW5zdGFuY2UgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0byB1bnJlZ2lzdGVyIHRoZSBjYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBvbkluaXQoY2FsbGJhY2ssIGlkZW50aWZpZXIpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZElkZW50aWZpZXIgPSB0aGlzLm5vcm1hbGl6ZUluc3RhbmNlSWRlbnRpZmllcihpZGVudGlmaWVyKTtcclxuICAgICAgICBjb25zdCBleGlzdGluZ0NhbGxiYWNrcyA9IChfYSA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChub3JtYWxpemVkSWRlbnRpZmllcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBTZXQoKTtcclxuICAgICAgICBleGlzdGluZ0NhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xyXG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzLnNldChub3JtYWxpemVkSWRlbnRpZmllciwgZXhpc3RpbmdDYWxsYmFja3MpO1xyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlcy5nZXQobm9ybWFsaXplZElkZW50aWZpZXIpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKGV4aXN0aW5nSW5zdGFuY2UsIG5vcm1hbGl6ZWRJZGVudGlmaWVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgZXhpc3RpbmdDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2Ugb25Jbml0IGNhbGxiYWNrcyBzeW5jaHJvbm91c2x5XHJcbiAgICAgKiBAcGFyYW0gaW5zdGFuY2UgdGhlIHNlcnZpY2UgaW5zdGFuY2VgXHJcbiAgICAgKi9cclxuICAgIGludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaWRlbnRpZmllcikge1xyXG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMub25Jbml0Q2FsbGJhY2tzLmdldChpZGVudGlmaWVyKTtcclxuICAgICAgICBpZiAoIWNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpbnN0YW5jZSwgaWRlbnRpZmllcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluaXQgY2FsbGJhY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE9ySW5pdGlhbGl6ZVNlcnZpY2UoeyBpbnN0YW5jZUlkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSB9KSB7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXMuZ2V0KGluc3RhbmNlSWRlbnRpZmllcik7XHJcbiAgICAgICAgaWYgKCFpbnN0YW5jZSAmJiB0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuY29tcG9uZW50Lmluc3RhbmNlRmFjdG9yeSh0aGlzLmNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VJZGVudGlmaWVyOiBub3JtYWxpemVJZGVudGlmaWVyRm9yRmFjdG9yeShpbnN0YW5jZUlkZW50aWZpZXIpLFxyXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlc09wdGlvbnMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbnZva2Ugb25Jbml0IGxpc3RlbmVycy5cclxuICAgICAgICAgICAgICogTm90ZSB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCBpcyBkaWZmZXJlbnQsIHdoaWNoIGlzIHVzZWQgYnkgdGhlIGNvbXBvbmVudCBjcmVhdG9yLFxyXG4gICAgICAgICAgICAgKiB3aGlsZSBvbkluaXQgbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGJ5IGNvbnN1bWVycyBvZiB0aGUgcHJvdmlkZXIuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLmludm9rZU9uSW5pdENhbGxiYWNrcyhpbnN0YW5jZSwgaW5zdGFuY2VJZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIE9yZGVyIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICAgKiBvbkluc3RhbmNlQ3JlYXRlZCgpIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgdGhpcy5pbnN0YW5jZXMuc2V0KGluc3RhbmNlSWRlbnRpZmllciwgaW5zdGFuY2UpOyB3aGljaFxyXG4gICAgICAgICAgICAgKiBtYWtlcyBgaXNJbml0aWFsaXplZCgpYCByZXR1cm4gdHJ1ZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5vbkluc3RhbmNlQ3JlYXRlZCh0aGlzLmNvbnRhaW5lciwgaW5zdGFuY2VJZGVudGlmaWVyLCBpbnN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgZXJyb3JzIGluIHRoZSBvbkluc3RhbmNlQ3JlYXRlZENhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVJbnN0YW5jZUlkZW50aWZpZXIoaWRlbnRpZmllciA9IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQubXVsdGlwbGVJbnN0YW5jZXMgPyBpZGVudGlmaWVyIDogREVGQVVMVF9FTlRSWV9OQU1FO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7IC8vIGFzc3VtZSBtdWx0aXBsZSBpbnN0YW5jZXMgYXJlIHN1cHBvcnRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBwcm92aWRlZC5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG91bGRBdXRvSW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICByZXR1cm4gKCEhdGhpcy5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgIT09IFwiRVhQTElDSVRcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FWFBMSUNJVCAqLyk7XHJcbiAgICB9XHJcbn1cclxuLy8gdW5kZWZpbmVkIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHNlcnZpY2UgZmFjdG9yeSBmb3IgdGhlIGRlZmF1bHQgaW5zdGFuY2VcclxuZnVuY3Rpb24gbm9ybWFsaXplSWRlbnRpZmllckZvckZhY3RvcnkoaWRlbnRpZmllcikge1xyXG4gICAgcmV0dXJuIGlkZW50aWZpZXIgPT09IERFRkFVTFRfRU5UUllfTkFNRSA/IHVuZGVmaW5lZCA6IGlkZW50aWZpZXI7XHJcbn1cclxuZnVuY3Rpb24gaXNDb21wb25lbnRFYWdlcihjb21wb25lbnQpIHtcclxuICAgIHJldHVybiBjb21wb25lbnQuaW5zdGFudGlhdGlvbk1vZGUgPT09IFwiRUFHRVJcIiAvKiBJbnN0YW50aWF0aW9uTW9kZS5FQUdFUiAqLztcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ29tcG9uZW50Q29udGFpbmVyIHRoYXQgcHJvdmlkZXMgUHJvdmlkZXJzIGZvciBzZXJ2aWNlIG5hbWUgVCwgZS5nLiBgYXV0aGAsIGBhdXRoLWludGVybmFsYFxyXG4gKi9cclxuY2xhc3MgQ29tcG9uZW50Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMucHJvdmlkZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgYmVpbmcgYWRkZWRcclxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgV2hlbiBhIGNvbXBvbmVudCB3aXRoIHRoZSBzYW1lIG5hbWUgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLFxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIHRydWU6IG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggdGhlIG5ldyBjb21wb25lbnQgYW5kIGNyZWF0ZSBhIG5ld1xyXG4gICAgICogcHJvdmlkZXIgd2l0aCB0aGUgbmV3IGNvbXBvbmVudC4gSXQgY2FuIGJlIHVzZWZ1bCBpbiB0ZXN0cyB3aGVyZSB5b3Ugd2FudCB0byB1c2UgZGlmZmVyZW50IG1vY2tzXHJcbiAgICAgKiBmb3IgZGlmZmVyZW50IHRlc3RzLlxyXG4gICAgICogaWYgb3ZlcndyaXRlIGlzIGZhbHNlOiB0aHJvdyBhbiBleGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyLmlzQ29tcG9uZW50U2V0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkIHdpdGggJHt0aGlzLm5hbWV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3ZpZGVyLnNldENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkT3JPdmVyd3JpdGVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKGNvbXBvbmVudC5uYW1lKTtcclxuICAgICAgICBpZiAocHJvdmlkZXIuaXNDb21wb25lbnRTZXQoKSkge1xyXG4gICAgICAgICAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHByb3ZpZGVyIGZyb20gdGhlIGNvbnRhaW5lciwgc28gd2UgY2FuIHJlZ2lzdGVyIHRoZSBuZXcgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXJzLmRlbGV0ZShjb21wb25lbnQubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGdldFByb3ZpZGVyIHByb3ZpZGVzIGEgdHlwZSBzYWZlIGludGVyZmFjZSB3aGVyZSBpdCBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIGZpZWxkIG5hbWVcclxuICAgICAqIHByZXNlbnQgaW4gTmFtZVNlcnZpY2VNYXBwaW5nIGludGVyZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBGaXJlYmFzZSBTREtzIHByb3ZpZGluZyBzZXJ2aWNlcyBzaG91bGQgZXh0ZW5kIE5hbWVTZXJ2aWNlTWFwcGluZyBpbnRlcmZhY2UgdG8gcmVnaXN0ZXJcclxuICAgICAqIHRoZW1zZWx2ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldFByb3ZpZGVyKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcnMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVycy5nZXQobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNyZWF0ZSBhIFByb3ZpZGVyIGZvciBhIHNlcnZpY2UgdGhhdCBoYXNuJ3QgcmVnaXN0ZXJlZCB3aXRoIEZpcmViYXNlXHJcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIobmFtZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KG5hbWUsIHByb3ZpZGVyKTtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXRQcm92aWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyLCBQcm92aWRlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiIsIi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNvbnRhaW5lciBmb3IgYWxsIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2VzXHJcbiAqL1xyXG5jb25zdCBpbnN0YW5jZXMgPSBbXTtcclxuLyoqXHJcbiAqIFRoZSBKUyBTREsgc3VwcG9ydHMgNSBsb2cgbGV2ZWxzIGFuZCBhbHNvIGFsbG93cyBhIHVzZXIgdGhlIGFiaWxpdHkgdG9cclxuICogc2lsZW5jZSB0aGUgbG9ncyBhbHRvZ2V0aGVyLlxyXG4gKlxyXG4gKiBUaGUgb3JkZXIgaXMgYSBmb2xsb3dzOlxyXG4gKiBERUJVRyA8IFZFUkJPU0UgPCBJTkZPIDwgV0FSTiA8IEVSUk9SXHJcbiAqXHJcbiAqIEFsbCBvZiB0aGUgbG9nIHR5cGVzIGFib3ZlIHRoZSBjdXJyZW50IGxvZyBsZXZlbCB3aWxsIGJlIGNhcHR1cmVkIChpLmUuIGlmXHJcbiAqIHlvdSBzZXQgdGhlIGxvZyBsZXZlbCB0byBgSU5GT2AsIGVycm9ycyB3aWxsIHN0aWxsIGJlIGxvZ2dlZCwgYnV0IGBERUJVR2AgYW5kXHJcbiAqIGBWRVJCT1NFYCBsb2dzIHdpbGwgbm90KVxyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlZFUkJPU0VcIl0gPSAxXSA9IFwiVkVSQk9TRVwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJJTkZPXCJdID0gMl0gPSBcIklORk9cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiV0FSTlwiXSA9IDNdID0gXCJXQVJOXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIlNJTEVOVFwiXSA9IDVdID0gXCJTSUxFTlRcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuY29uc3QgbGV2ZWxTdHJpbmdUb0VudW0gPSB7XHJcbiAgICAnZGVidWcnOiBMb2dMZXZlbC5ERUJVRyxcclxuICAgICd2ZXJib3NlJzogTG9nTGV2ZWwuVkVSQk9TRSxcclxuICAgICdpbmZvJzogTG9nTGV2ZWwuSU5GTyxcclxuICAgICd3YXJuJzogTG9nTGV2ZWwuV0FSTixcclxuICAgICdlcnJvcic6IExvZ0xldmVsLkVSUk9SLFxyXG4gICAgJ3NpbGVudCc6IExvZ0xldmVsLlNJTEVOVFxyXG59O1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9nIGxldmVsXHJcbiAqL1xyXG5jb25zdCBkZWZhdWx0TG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPO1xyXG4vKipcclxuICogQnkgZGVmYXVsdCwgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBkaXNwbGF5ZWQgaW4gdGhlIGRldmVsb3BlciBjb25zb2xlIChpblxyXG4gKiBjaHJvbWUpLiBUbyBhdm9pZCBmb3JjaW5nIHVzZXJzIHRvIGhhdmUgdG8gb3B0LWluIHRvIHRoZXNlIGxvZ3MgdHdpY2VcclxuICogKGkuZS4gb25jZSBmb3IgZmlyZWJhc2UsIGFuZCBvbmNlIGluIHRoZSBjb25zb2xlKSwgd2UgYXJlIHNlbmRpbmcgYERFQlVHYFxyXG4gKiBsb2dzIHRvIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgQ29uc29sZU1ldGhvZCA9IHtcclxuICAgIFtMb2dMZXZlbC5ERUJVR106ICdsb2cnLFxyXG4gICAgW0xvZ0xldmVsLlZFUkJPU0VdOiAnbG9nJyxcclxuICAgIFtMb2dMZXZlbC5JTkZPXTogJ2luZm8nLFxyXG4gICAgW0xvZ0xldmVsLldBUk5dOiAnd2FybicsXHJcbiAgICBbTG9nTGV2ZWwuRVJST1JdOiAnZXJyb3InXHJcbn07XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBsb2cgaGFuZGxlciB3aWxsIGZvcndhcmQgREVCVUcsIFZFUkJPU0UsIElORk8sIFdBUk4sIGFuZCBFUlJPUlxyXG4gKiBtZXNzYWdlcyBvbiB0byB0aGVpciBjb3JyZXNwb25kaW5nIGNvbnNvbGUgY291bnRlcnBhcnRzIChpZiB0aGUgbG9nIG1ldGhvZFxyXG4gKiBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgbG9nIGxldmVsKVxyXG4gKi9cclxuY29uc3QgZGVmYXVsdExvZ0hhbmRsZXIgPSAoaW5zdGFuY2UsIGxvZ1R5cGUsIC4uLmFyZ3MpID0+IHtcclxuICAgIGlmIChsb2dUeXBlIDwgaW5zdGFuY2UubG9nTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XHJcbiAgICBjb25zdCBtZXRob2QgPSBDb25zb2xlTWV0aG9kW2xvZ1R5cGVdO1xyXG4gICAgaWYgKG1ldGhvZCkge1xyXG4gICAgICAgIGNvbnNvbGVbbWV0aG9kXShgWyR7bm93fV0gICR7aW5zdGFuY2UubmFtZX06YCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBsb2cgYSBtZXNzYWdlIHdpdGggYW4gaW52YWxpZCBsb2dUeXBlICh2YWx1ZTogJHtsb2dUeXBlfSlgKTtcclxuICAgIH1cclxufTtcclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZXMgeW91IGFuIGluc3RhbmNlIG9mIGEgTG9nZ2VyIHRvIGNhcHR1cmUgbWVzc2FnZXMgYWNjb3JkaW5nIHRvXHJcbiAgICAgKiBGaXJlYmFzZSdzIGxvZ2dpbmcgc2NoZW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIHRoYXQgdGhlIGxvZ3Mgd2lsbCBiZSBhc3NvY2lhdGVkIHdpdGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxvZyBsZXZlbCBvZiB0aGUgZ2l2ZW4gTG9nZ2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtYWluIChpbnRlcm5hbCkgbG9nIGhhbmRsZXIgZm9yIHRoZSBMb2dnZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogQ2FuIGJlIHNldCB0byBhIG5ldyBmdW5jdGlvbiBpbiBpbnRlcm5hbCBwYWNrYWdlIGNvZGUgYnV0IG5vdCBieSB1c2VyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSBkZWZhdWx0TG9nSGFuZGxlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3B0aW9uYWwsIGFkZGl0aW9uYWwsIHVzZXItZGVmaW5lZCBsb2cgaGFuZGxlciBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FwdHVyZSB0aGUgY3VycmVudCBpbnN0YW5jZSBmb3IgbGF0ZXIgdXNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaW5zdGFuY2VzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9nTGV2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIGlmICghKHZhbCBpbiBMb2dMZXZlbCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCB2YWx1ZSBcIiR7dmFsfVwiIGFzc2lnbmVkIHRvIFxcYGxvZ0xldmVsXFxgYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLy8gV29ya2Fyb3VuZCBmb3Igc2V0dGVyL2dldHRlciBoYXZpbmcgdG8gYmUgdGhlIHNhbWUgdHlwZS5cclxuICAgIHNldExvZ0xldmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX2xvZ0xldmVsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyBsZXZlbFN0cmluZ1RvRW51bVt2YWxdIDogdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9nSGFuZGxlcih2YWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdWYWx1ZSBhc3NpZ25lZCB0byBgbG9nSGFuZGxlcmAgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgdXNlckxvZ0hhbmRsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZXJMb2dIYW5kbGVyO1xyXG4gICAgfVxyXG4gICAgc2V0IHVzZXJMb2dIYW5kbGVyKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnVuY3Rpb25zIGJlbG93IGFyZSBhbGwgYmFzZWQgb24gdGhlIGBjb25zb2xlYCBpbnRlcmZhY2VcclxuICAgICAqL1xyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkRFQlVHLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGxvZyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIgJiZcclxuICAgICAgICAgICAgdGhpcy5fdXNlckxvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuVkVSQk9TRSwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fbG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5WRVJCT1NFLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLklORk8sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2xvZ0hhbmRsZXIodGhpcywgTG9nTGV2ZWwuSU5GTywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl91c2VyTG9nSGFuZGxlciAmJiB0aGlzLl91c2VyTG9nSGFuZGxlcih0aGlzLCBMb2dMZXZlbC5XQVJOLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLldBUk4sIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX3VzZXJMb2dIYW5kbGVyICYmIHRoaXMuX3VzZXJMb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9sb2dIYW5kbGVyKHRoaXMsIExvZ0xldmVsLkVSUk9SLCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xyXG4gICAgaW5zdGFuY2VzLmZvckVhY2goaW5zdCA9PiB7XHJcbiAgICAgICAgaW5zdC5zZXRMb2dMZXZlbChsZXZlbCk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcclxuICAgICAgICBsZXQgY3VzdG9tTG9nTGV2ZWwgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubGV2ZWwpIHtcclxuICAgICAgICAgICAgY3VzdG9tTG9nTGV2ZWwgPSBsZXZlbFN0cmluZ1RvRW51bVtvcHRpb25zLmxldmVsXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxvZ0NhbGxiYWNrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlLnVzZXJMb2dIYW5kbGVyID0gKGluc3RhbmNlLCBsZXZlbCwgLi4uYXJncykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3NcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGFyZyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZy50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJnLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFyZyA9PiBhcmcpXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZXZlbCA+PSAoY3VzdG9tTG9nTGV2ZWwgIT09IG51bGwgJiYgY3VzdG9tTG9nTGV2ZWwgIT09IHZvaWQgMCA/IGN1c3RvbUxvZ0xldmVsIDogaW5zdGFuY2UubG9nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXZlbDogTG9nTGV2ZWxbbGV2ZWxdLnRvTG93ZXJDYXNlKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGluc3RhbmNlLm5hbWVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IHsgTG9nTGV2ZWwsIExvZ2dlciwgc2V0TG9nTGV2ZWwsIHNldFVzZXJMb2dIYW5kbGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIiwiY29uc3QgaW5zdGFuY2VPZkFueSA9IChvYmplY3QsIGNvbnN0cnVjdG9ycykgPT4gY29uc3RydWN0b3JzLnNvbWUoKGMpID0+IG9iamVjdCBpbnN0YW5jZW9mIGMpO1xuXG5sZXQgaWRiUHJveHlhYmxlVHlwZXM7XG5sZXQgY3Vyc29yQWR2YW5jZU1ldGhvZHM7XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldElkYlByb3h5YWJsZVR5cGVzKCkge1xuICAgIHJldHVybiAoaWRiUHJveHlhYmxlVHlwZXMgfHxcbiAgICAgICAgKGlkYlByb3h5YWJsZVR5cGVzID0gW1xuICAgICAgICAgICAgSURCRGF0YWJhc2UsXG4gICAgICAgICAgICBJREJPYmplY3RTdG9yZSxcbiAgICAgICAgICAgIElEQkluZGV4LFxuICAgICAgICAgICAgSURCQ3Vyc29yLFxuICAgICAgICAgICAgSURCVHJhbnNhY3Rpb24sXG4gICAgICAgIF0pKTtcbn1cbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIChjdXJzb3JBZHZhbmNlTWV0aG9kcyB8fFxuICAgICAgICAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgPSBbXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmFkdmFuY2UsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZVByaW1hcnlLZXksXG4gICAgICAgIF0pKTtcbn1cbmNvbnN0IGN1cnNvclJlcXVlc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgdHJhbnNhY3Rpb25Eb25lTWFwID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHRyYW5zYWN0aW9uU3RvcmVOYW1lc01hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gcHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXAocmVxdWVzdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gICAgcHJvbWlzZVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgLy8gU2luY2UgY3Vyc29yaW5nIHJldXNlcyB0aGUgSURCUmVxdWVzdCAoKnNpZ2gqKSwgd2UgY2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbFxuICAgICAgICAvLyAoc2VlIHdyYXBGdW5jdGlvbikuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQkN1cnNvcikge1xuICAgICAgICAgICAgY3Vyc29yUmVxdWVzdE1hcC5zZXQodmFsdWUsIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhdGNoaW5nIHRvIGF2b2lkIFwiVW5jYXVnaHQgUHJvbWlzZSBleGNlcHRpb25zXCJcbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAvLyBUaGlzIG1hcHBpbmcgZXhpc3RzIGluIHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBidXQgZG9lc24ndCBkb2Vzbid0IGV4aXN0IGluIHRyYW5zZm9ybUNhY2hlLiBUaGlzXG4gICAgLy8gaXMgYmVjYXVzZSB3ZSBjcmVhdGUgbWFueSBwcm9taXNlcyBmcm9tIGEgc2luZ2xlIElEQlJlcXVlc3QuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm9taXNlLCByZXF1ZXN0KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGNhY2hlRG9uZVByb21pc2VGb3JUcmFuc2FjdGlvbih0eCkge1xuICAgIC8vIEVhcmx5IGJhaWwgaWYgd2UndmUgYWxyZWFkeSBjcmVhdGVkIGEgZG9uZSBwcm9taXNlIGZvciB0aGlzIHRyYW5zYWN0aW9uLlxuICAgIGlmICh0cmFuc2FjdGlvbkRvbmVNYXAuaGFzKHR4KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRvbmUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVubGlzdGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29tcGxldGUnLCBjb21wbGV0ZSk7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHR4LmVycm9yIHx8IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0RXJyb3InLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gQ2FjaGUgaXQgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICB0cmFuc2FjdGlvbkRvbmVNYXAuc2V0KHR4LCBkb25lKTtcbn1cbmxldCBpZGJQcm94eVRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgdHJhbnNhY3Rpb24uZG9uZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnZG9uZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uRG9uZU1hcC5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIFBvbHlmaWxsIGZvciBvYmplY3RTdG9yZU5hbWVzIGJlY2F1c2Ugb2YgRWRnZS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnb2JqZWN0U3RvcmVOYW1lcycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0Lm9iamVjdFN0b3JlTmFtZXMgfHwgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSB0eC5zdG9yZSByZXR1cm4gdGhlIG9ubHkgc3RvcmUgaW4gdGhlIHRyYW5zYWN0aW9uLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG1hbnkuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3N0b3JlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzFdXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogcmVjZWl2ZXIub2JqZWN0U3RvcmUocmVjZWl2ZXIub2JqZWN0U3RvcmVOYW1lc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRWxzZSB0cmFuc2Zvcm0gd2hhdGV2ZXIgd2UgZ2V0IGJhY2suXG4gICAgICAgIHJldHVybiB3cmFwKHRhcmdldFtwcm9wXSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBoYXModGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBJREJUcmFuc2FjdGlvbiAmJlxuICAgICAgICAgICAgKHByb3AgPT09ICdkb25lJyB8fCBwcm9wID09PSAnc3RvcmUnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0O1xuICAgIH0sXG59O1xuZnVuY3Rpb24gcmVwbGFjZVRyYXBzKGNhbGxiYWNrKSB7XG4gICAgaWRiUHJveHlUcmFwcyA9IGNhbGxiYWNrKGlkYlByb3h5VHJhcHMpO1xufVxuZnVuY3Rpb24gd3JhcEZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAvLyBEdWUgdG8gZXhwZWN0ZWQgb2JqZWN0IGVxdWFsaXR5ICh3aGljaCBpcyBlbmZvcmNlZCBieSB0aGUgY2FjaGluZyBpbiBgd3JhcGApLCB3ZVxuICAgIC8vIG9ubHkgY3JlYXRlIG9uZSBuZXcgZnVuYyBwZXIgZnVuYy5cbiAgICAvLyBFZGdlIGRvZXNuJ3Qgc3VwcG9ydCBvYmplY3RTdG9yZU5hbWVzIChib29vKSwgc28gd2UgcG9seWZpbGwgaXQgaGVyZS5cbiAgICBpZiAoZnVuYyA9PT0gSURCRGF0YWJhc2UucHJvdG90eXBlLnRyYW5zYWN0aW9uICYmXG4gICAgICAgICEoJ29iamVjdFN0b3JlTmFtZXMnIGluIElEQlRyYW5zYWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdG9yZU5hbWVzLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IGZ1bmMuY2FsbCh1bndyYXAodGhpcyksIHN0b3JlTmFtZXMsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25TdG9yZU5hbWVzTWFwLnNldCh0eCwgc3RvcmVOYW1lcy5zb3J0ID8gc3RvcmVOYW1lcy5zb3J0KCkgOiBbc3RvcmVOYW1lc10pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAodHgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDdXJzb3IgbWV0aG9kcyBhcmUgc3BlY2lhbCwgYXMgdGhlIGJlaGF2aW91ciBpcyBhIGxpdHRsZSBtb3JlIGRpZmZlcmVudCB0byBzdGFuZGFyZCBJREIuIEluXG4gICAgLy8gSURCLCB5b3UgYWR2YW5jZSB0aGUgY3Vyc29yIGFuZCB3YWl0IGZvciBhIG5ldyAnc3VjY2Vzcycgb24gdGhlIElEQlJlcXVlc3QgdGhhdCBnYXZlIHlvdSB0aGVcbiAgICAvLyBjdXJzb3IuIEl0J3Mga2luZGEgbGlrZSBhIHByb21pc2UgdGhhdCBjYW4gcmVzb2x2ZSB3aXRoIG1hbnkgdmFsdWVzLiBUaGF0IGRvZXNuJ3QgbWFrZSBzZW5zZVxuICAgIC8vIHdpdGggcmVhbCBwcm9taXNlcywgc28gZWFjaCBhZHZhbmNlIG1ldGhvZHMgcmV0dXJucyBhIG5ldyBwcm9taXNlIGZvciB0aGUgY3Vyc29yIG9iamVjdCwgb3JcbiAgICAvLyB1bmRlZmluZWQgaWYgdGhlIGVuZCBvZiB0aGUgY3Vyc29yIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgaWYgKGdldEN1cnNvckFkdmFuY2VNZXRob2RzKCkuaW5jbHVkZXMoZnVuYykpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBDYWxsaW5nIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm94eSBhcyAndGhpcycgY2F1c2VzIElMTEVHQUwgSU5WT0NBVElPTiwgc28gd2UgdXNlXG4gICAgICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICAgICAgZnVuYy5hcHBseSh1bndyYXAodGhpcyksIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXAoY3Vyc29yUmVxdWVzdE1hcC5nZXQodGhpcykpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbih2YWx1ZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcbiAgICAvLyB3aGljaCBpcyBsYXRlciByZXR1cm5lZCBmb3IgdHJhbnNhY3Rpb24uZG9uZSAoc2VlIGlkYk9iamVjdEhhbmRsZXIpLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKVxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIGlmIChpbnN0YW5jZU9mQW55KHZhbHVlLCBnZXRJZGJQcm94eWFibGVUeXBlcygpKSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgaWRiUHJveHlUcmFwcyk7XG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgLy8gV2Ugc29tZXRpbWVzIGdlbmVyYXRlIG11bHRpcGxlIHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdCAoZWcgd2hlbiBjdXJzb3JpbmcpLCBiZWNhdXNlXG4gICAgLy8gSURCIGlzIHdlaXJkIGFuZCBhIHNpbmdsZSBJREJSZXF1ZXN0IGNhbiB5aWVsZCBtYW55IHJlc3BvbnNlcywgc28gdGhlc2UgY2FuJ3QgYmUgY2FjaGVkLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHZhbHVlKTtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHRyYW5zZm9ybWVkIHRoaXMgdmFsdWUgYmVmb3JlLCByZXVzZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cbiAgICBpZiAodHJhbnNmb3JtQ2FjaGUuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcbiAgICAvLyBOb3QgYWxsIHR5cGVzIGFyZSB0cmFuc2Zvcm1lZC5cbiAgICAvLyBUaGVzZSBtYXkgYmUgcHJpbWl0aXZlIHR5cGVzLCBzbyB0aGV5IGNhbid0IGJlIFdlYWtNYXAga2V5cy5cbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRyYW5zZm9ybUNhY2hlLnNldCh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KG5ld1ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG5cbmV4cG9ydCB7IHJldmVyc2VUcmFuc2Zvcm1DYWNoZSBhcyBhLCBpbnN0YW5jZU9mQW55IGFzIGksIHJlcGxhY2VUcmFwcyBhcyByLCB1bndyYXAgYXMgdSwgd3JhcCBhcyB3IH07XG4iLCJpbXBvcnQgeyB3IGFzIHdyYXAsIHIgYXMgcmVwbGFjZVRyYXBzIH0gZnJvbSAnLi93cmFwLWlkYi12YWx1ZS5qcyc7XG5leHBvcnQgeyB1IGFzIHVud3JhcCwgdyBhcyB3cmFwIH0gZnJvbSAnLi93cmFwLWlkYi12YWx1ZS5qcyc7XG5cbi8qKlxuICogT3BlbiBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICogQHBhcmFtIHZlcnNpb24gU2NoZW1hIHZlcnNpb24uXG4gKiBAcGFyYW0gY2FsbGJhY2tzIEFkZGl0aW9uYWwgY2FsbGJhY2tzLlxuICovXG5mdW5jdGlvbiBvcGVuREIobmFtZSwgdmVyc2lvbiwgeyBibG9ja2VkLCB1cGdyYWRlLCBibG9ja2luZywgdGVybWluYXRlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSwgdmVyc2lvbik7XG4gICAgY29uc3Qgb3BlblByb21pc2UgPSB3cmFwKHJlcXVlc3QpO1xuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigndXBncmFkZW5lZWRlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdXBncmFkZSh3cmFwKHJlcXVlc3QucmVzdWx0KSwgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgd3JhcChyZXF1ZXN0LnRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmxvY2tlZClcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKCkgPT4gYmxvY2tlZCgpKTtcbiAgICBvcGVuUHJvbWlzZVxuICAgICAgICAudGhlbigoZGIpID0+IHtcbiAgICAgICAgaWYgKHRlcm1pbmF0ZWQpXG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICgpID0+IHRlcm1pbmF0ZWQoKSk7XG4gICAgICAgIGlmIChibG9ja2luZylcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ3ZlcnNpb25jaGFuZ2UnLCAoKSA9PiBibG9ja2luZygpKTtcbiAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4geyB9KTtcbiAgICByZXR1cm4gb3BlblByb21pc2U7XG59XG4vKipcbiAqIERlbGV0ZSBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICovXG5mdW5jdGlvbiBkZWxldGVEQihuYW1lLCB7IGJsb2NrZWQgfSA9IHt9KSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKTtcbiAgICBpZiAoYmxvY2tlZClcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKCkgPT4gYmxvY2tlZCgpKTtcbiAgICByZXR1cm4gd3JhcChyZXF1ZXN0KS50aGVuKCgpID0+IHVuZGVmaW5lZCk7XG59XG5cbmNvbnN0IHJlYWRNZXRob2RzID0gWydnZXQnLCAnZ2V0S2V5JywgJ2dldEFsbCcsICdnZXRBbGxLZXlzJywgJ2NvdW50J107XG5jb25zdCB3cml0ZU1ldGhvZHMgPSBbJ3B1dCcsICdhZGQnLCAnZGVsZXRlJywgJ2NsZWFyJ107XG5jb25zdCBjYWNoZWRNZXRob2RzID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkge1xuICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIElEQkRhdGFiYXNlICYmXG4gICAgICAgICEocHJvcCBpbiB0YXJnZXQpICYmXG4gICAgICAgIHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FjaGVkTWV0aG9kcy5nZXQocHJvcCkpXG4gICAgICAgIHJldHVybiBjYWNoZWRNZXRob2RzLmdldChwcm9wKTtcbiAgICBjb25zdCB0YXJnZXRGdW5jTmFtZSA9IHByb3AucmVwbGFjZSgvRnJvbUluZGV4JC8sICcnKTtcbiAgICBjb25zdCB1c2VJbmRleCA9IHByb3AgIT09IHRhcmdldEZ1bmNOYW1lO1xuICAgIGNvbnN0IGlzV3JpdGUgPSB3cml0ZU1ldGhvZHMuaW5jbHVkZXModGFyZ2V0RnVuY05hbWUpO1xuICAgIGlmIChcbiAgICAvLyBCYWlsIGlmIHRoZSB0YXJnZXQgZG9lc24ndCBleGlzdCBvbiB0aGUgdGFyZ2V0LiBFZywgZ2V0QWxsIGlzbid0IGluIEVkZ2UuXG4gICAgISh0YXJnZXRGdW5jTmFtZSBpbiAodXNlSW5kZXggPyBJREJJbmRleCA6IElEQk9iamVjdFN0b3JlKS5wcm90b3R5cGUpIHx8XG4gICAgICAgICEoaXNXcml0ZSB8fCByZWFkTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gYXN5bmMgZnVuY3Rpb24gKHN0b3JlTmFtZSwgLi4uYXJncykge1xuICAgICAgICAvLyBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiB1bmRlZmluZWQgZ3ppcHBzIGJldHRlciwgYnV0IGZhaWxzIGluIEVkZ2UgOihcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLnRyYW5zYWN0aW9uKHN0b3JlTmFtZSwgaXNXcml0ZSA/ICdyZWFkd3JpdGUnIDogJ3JlYWRvbmx5Jyk7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0eC5zdG9yZTtcbiAgICAgICAgaWYgKHVzZUluZGV4KVxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmluZGV4KGFyZ3Muc2hpZnQoKSk7XG4gICAgICAgIC8vIE11c3QgcmVqZWN0IGlmIG9wIHJlamVjdHMuXG4gICAgICAgIC8vIElmIGl0J3MgYSB3cml0ZSBvcGVyYXRpb24sIG11c3QgcmVqZWN0IGlmIHR4LmRvbmUgcmVqZWN0cy5cbiAgICAgICAgLy8gTXVzdCByZWplY3Qgd2l0aCBvcCByZWplY3Rpb24gZmlyc3QuXG4gICAgICAgIC8vIE11c3QgcmVzb2x2ZSB3aXRoIG9wIHZhbHVlLlxuICAgICAgICAvLyBNdXN0IGhhbmRsZSBib3RoIHByb21pc2VzIChubyB1bmhhbmRsZWQgcmVqZWN0aW9ucylcbiAgICAgICAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0YXJnZXRbdGFyZ2V0RnVuY05hbWVdKC4uLmFyZ3MpLFxuICAgICAgICAgICAgaXNXcml0ZSAmJiB0eC5kb25lLFxuICAgICAgICBdKSlbMF07XG4gICAgfTtcbiAgICBjYWNoZWRNZXRob2RzLnNldChwcm9wLCBtZXRob2QpO1xuICAgIHJldHVybiBtZXRob2Q7XG59XG5yZXBsYWNlVHJhcHMoKG9sZFRyYXBzKSA9PiAoe1xuICAgIC4uLm9sZFRyYXBzLFxuICAgIGdldDogKHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpID0+IGdldE1ldGhvZCh0YXJnZXQsIHByb3ApIHx8IG9sZFRyYXBzLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSxcbiAgICBoYXM6ICh0YXJnZXQsIHByb3ApID0+ICEhZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuaGFzKHRhcmdldCwgcHJvcCksXG59KSk7XG5cbmV4cG9ydCB7IGRlbGV0ZURCLCBvcGVuREIgfTtcbiIsImltcG9ydCB7IENvbXBvbmVudCwgQ29tcG9uZW50Q29udGFpbmVyIH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBMb2dnZXIsIHNldFVzZXJMb2dIYW5kbGVyLCBzZXRMb2dMZXZlbCBhcyBzZXRMb2dMZXZlbCQxIH0gZnJvbSAnQGZpcmViYXNlL2xvZ2dlcic7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIGdldERlZmF1bHRBcHBDb25maWcsIGRlZXBFcXVhbCwgRmlyZWJhc2VFcnJvciwgYmFzZTY0dXJsRW5jb2RlV2l0aG91dFBhZGRpbmcsIGlzSW5kZXhlZERCQXZhaWxhYmxlLCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuZXhwb3J0IHsgRmlyZWJhc2VFcnJvciB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBsYXRmb3JtTG9nZ2VyU2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICAvLyBJbiBpbml0aWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGJ5IGluc3RhbGxhdGlvbnMgb25cclxuICAgIC8vIGF1dGggdG9rZW4gcmVmcmVzaCwgYW5kIGluc3RhbGxhdGlvbnMgd2lsbCBzZW5kIHRoaXMgc3RyaW5nLlxyXG4gICAgZ2V0UGxhdGZvcm1JbmZvU3RyaW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IHRoaXMuY29udGFpbmVyLmdldFByb3ZpZGVycygpO1xyXG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBwcm92aWRlcnMgYW5kIGdldCBsaWJyYXJ5L3ZlcnNpb24gcGFpcnMgZnJvbSBhbnkgdGhhdCBhcmVcclxuICAgICAgICAvLyB2ZXJzaW9uIGNvbXBvbmVudHMuXHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyc1xyXG4gICAgICAgICAgICAubWFwKHByb3ZpZGVyID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzVmVyc2lvblNlcnZpY2VQcm92aWRlcihwcm92aWRlcikpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzZXJ2aWNlLmxpYnJhcnl9LyR7c2VydmljZS52ZXJzaW9ufWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5maWx0ZXIobG9nU3RyaW5nID0+IGxvZ1N0cmluZylcclxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHByb3ZpZGVyIGNoZWNrIGlmIHRoaXMgcHJvdmlkZXIgcHJvdmlkZXMgYSBWZXJzaW9uU2VydmljZVxyXG4gKlxyXG4gKiBOT1RFOiBVc2luZyBQcm92aWRlcjwnYXBwLXZlcnNpb24nPiBpcyBhIGhhY2sgdG8gaW5kaWNhdGUgdGhhdCB0aGUgcHJvdmlkZXJcclxuICogcHJvdmlkZXMgVmVyc2lvblNlcnZpY2UuIFRoZSBwcm92aWRlciBpcyBub3QgbmVjZXNzYXJpbHkgYSAnYXBwLXZlcnNpb24nXHJcbiAqIHByb3ZpZGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNWZXJzaW9uU2VydmljZVByb3ZpZGVyKHByb3ZpZGVyKSB7XHJcbiAgICBjb25zdCBjb21wb25lbnQgPSBwcm92aWRlci5nZXRDb21wb25lbnQoKTtcclxuICAgIHJldHVybiAoY29tcG9uZW50ID09PSBudWxsIHx8IGNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9uZW50LnR5cGUpID09PSBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi87XHJcbn1cblxuY29uc3QgbmFtZSRvID0gXCJAZmlyZWJhc2UvYXBwXCI7XG5jb25zdCB2ZXJzaW9uJDEgPSBcIjAuOS44XCI7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ0BmaXJlYmFzZS9hcHAnKTtcblxuY29uc3QgbmFtZSRuID0gXCJAZmlyZWJhc2UvYXBwLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJG0gPSBcIkBmaXJlYmFzZS9hbmFseXRpY3MtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkbCA9IFwiQGZpcmViYXNlL2FuYWx5dGljc1wiO1xuXG5jb25zdCBuYW1lJGsgPSBcIkBmaXJlYmFzZS9hcHAtY2hlY2stY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkaiA9IFwiQGZpcmViYXNlL2FwcC1jaGVja1wiO1xuXG5jb25zdCBuYW1lJGkgPSBcIkBmaXJlYmFzZS9hdXRoXCI7XG5cbmNvbnN0IG5hbWUkaCA9IFwiQGZpcmViYXNlL2F1dGgtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkZyA9IFwiQGZpcmViYXNlL2RhdGFiYXNlXCI7XG5cbmNvbnN0IG5hbWUkZiA9IFwiQGZpcmViYXNlL2RhdGFiYXNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGUgPSBcIkBmaXJlYmFzZS9mdW5jdGlvbnNcIjtcblxuY29uc3QgbmFtZSRkID0gXCJAZmlyZWJhc2UvZnVuY3Rpb25zLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJGMgPSBcIkBmaXJlYmFzZS9pbnN0YWxsYXRpb25zXCI7XG5cbmNvbnN0IG5hbWUkYiA9IFwiQGZpcmViYXNlL2luc3RhbGxhdGlvbnMtY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkYSA9IFwiQGZpcmViYXNlL21lc3NhZ2luZ1wiO1xuXG5jb25zdCBuYW1lJDkgPSBcIkBmaXJlYmFzZS9tZXNzYWdpbmctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkOCA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlXCI7XG5cbmNvbnN0IG5hbWUkNyA9IFwiQGZpcmViYXNlL3BlcmZvcm1hbmNlLWNvbXBhdFwiO1xuXG5jb25zdCBuYW1lJDYgPSBcIkBmaXJlYmFzZS9yZW1vdGUtY29uZmlnXCI7XG5cbmNvbnN0IG5hbWUkNSA9IFwiQGZpcmViYXNlL3JlbW90ZS1jb25maWctY29tcGF0XCI7XG5cbmNvbnN0IG5hbWUkNCA9IFwiQGZpcmViYXNlL3N0b3JhZ2VcIjtcblxuY29uc3QgbmFtZSQzID0gXCJAZmlyZWJhc2Uvc3RvcmFnZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSQyID0gXCJAZmlyZWJhc2UvZmlyZXN0b3JlXCI7XG5cbmNvbnN0IG5hbWUkMSA9IFwiQGZpcmViYXNlL2ZpcmVzdG9yZS1jb21wYXRcIjtcblxuY29uc3QgbmFtZSA9IFwiZmlyZWJhc2VcIjtcbmNvbnN0IHZlcnNpb24gPSBcIjkuMjAuMFwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgYXBwIG5hbWVcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcclxuY29uc3QgUExBVEZPUk1fTE9HX1NUUklORyA9IHtcclxuICAgIFtuYW1lJG9dOiAnZmlyZS1jb3JlJyxcclxuICAgIFtuYW1lJG5dOiAnZmlyZS1jb3JlLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRsXTogJ2ZpcmUtYW5hbHl0aWNzJyxcclxuICAgIFtuYW1lJG1dOiAnZmlyZS1hbmFseXRpY3MtY29tcGF0JyxcclxuICAgIFtuYW1lJGpdOiAnZmlyZS1hcHAtY2hlY2snLFxyXG4gICAgW25hbWUka106ICdmaXJlLWFwcC1jaGVjay1jb21wYXQnLFxyXG4gICAgW25hbWUkaV06ICdmaXJlLWF1dGgnLFxyXG4gICAgW25hbWUkaF06ICdmaXJlLWF1dGgtY29tcGF0JyxcclxuICAgIFtuYW1lJGddOiAnZmlyZS1ydGRiJyxcclxuICAgIFtuYW1lJGZdOiAnZmlyZS1ydGRiLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRlXTogJ2ZpcmUtZm4nLFxyXG4gICAgW25hbWUkZF06ICdmaXJlLWZuLWNvbXBhdCcsXHJcbiAgICBbbmFtZSRjXTogJ2ZpcmUtaWlkJyxcclxuICAgIFtuYW1lJGJdOiAnZmlyZS1paWQtY29tcGF0JyxcclxuICAgIFtuYW1lJGFdOiAnZmlyZS1mY20nLFxyXG4gICAgW25hbWUkOV06ICdmaXJlLWZjbS1jb21wYXQnLFxyXG4gICAgW25hbWUkOF06ICdmaXJlLXBlcmYnLFxyXG4gICAgW25hbWUkN106ICdmaXJlLXBlcmYtY29tcGF0JyxcclxuICAgIFtuYW1lJDZdOiAnZmlyZS1yYycsXHJcbiAgICBbbmFtZSQ1XTogJ2ZpcmUtcmMtY29tcGF0JyxcclxuICAgIFtuYW1lJDRdOiAnZmlyZS1nY3MnLFxyXG4gICAgW25hbWUkM106ICdmaXJlLWdjcy1jb21wYXQnLFxyXG4gICAgW25hbWUkMl06ICdmaXJlLWZzdCcsXHJcbiAgICBbbmFtZSQxXTogJ2ZpcmUtZnN0LWNvbXBhdCcsXHJcbiAgICAnZmlyZS1qcyc6ICdmaXJlLWpzJyxcclxuICAgIFtuYW1lXTogJ2ZpcmUtanMtYWxsJ1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBfYXBwcyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVyZWQgY29tcG9uZW50cy5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5jb25zdCBfY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcclxuLyoqXHJcbiAqIEBwYXJhbSBjb21wb25lbnQgLSB0aGUgY29tcG9uZW50IGJlaW5nIGFkZGVkIHRvIHRoaXMgYXBwJ3MgY29udGFpbmVyXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBhcHAuY29udGFpbmVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBsb2dnZXIuZGVidWcoYENvbXBvbmVudCAke2NvbXBvbmVudC5uYW1lfSBmYWlsZWQgdG8gcmVnaXN0ZXIgd2l0aCBGaXJlYmFzZUFwcCAke2FwcC5uYW1lfWAsIGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChhcHAsIGNvbXBvbmVudCkge1xyXG4gICAgYXBwLmNvbnRhaW5lci5hZGRPck92ZXJ3cml0ZUNvbXBvbmVudChjb21wb25lbnQpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG9uZW50IC0gdGhlIGNvbXBvbmVudCB0byByZWdpc3RlclxyXG4gKiBAcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY29tcG9uZW50IGlzIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX3JlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgY29uc3QgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5uYW1lO1xyXG4gICAgaWYgKF9jb21wb25lbnRzLmhhcyhjb21wb25lbnROYW1lKSkge1xyXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlcmUgd2VyZSBtdWx0aXBsZSBhdHRlbXB0cyB0byByZWdpc3RlciBjb21wb25lbnQgJHtjb21wb25lbnROYW1lfS5gKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBfY29tcG9uZW50cy5zZXQoY29tcG9uZW50TmFtZSwgY29tcG9uZW50KTtcclxuICAgIC8vIGFkZCB0aGUgY29tcG9uZW50IHRvIGV4aXN0aW5nIGFwcCBpbnN0YW5jZXNcclxuICAgIGZvciAoY29uc3QgYXBwIG9mIF9hcHBzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgX2FkZENvbXBvbmVudChhcHAsIGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGFwcCAtIEZpcmViYXNlQXBwIGluc3RhbmNlXHJcbiAqIEBwYXJhbSBuYW1lIC0gc2VydmljZSBuYW1lXHJcbiAqXHJcbiAqIEByZXR1cm5zIHRoZSBwcm92aWRlciBmb3IgdGhlIHNlcnZpY2Ugd2l0aCB0aGUgbWF0Y2hpbmcgbmFtZVxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpIHtcclxuICAgIGNvbnN0IGhlYXJ0YmVhdENvbnRyb2xsZXIgPSBhcHAuY29udGFpbmVyXHJcbiAgICAgICAgLmdldFByb3ZpZGVyKCdoZWFydGJlYXQnKVxyXG4gICAgICAgIC5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgIGlmIChoZWFydGJlYXRDb250cm9sbGVyKSB7XHJcbiAgICAgICAgdm9pZCBoZWFydGJlYXRDb250cm9sbGVyLnRyaWdnZXJIZWFydGJlYXQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcHAuY29udGFpbmVyLmdldFByb3ZpZGVyKG5hbWUpO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gYXBwIC0gRmlyZWJhc2VBcHAgaW5zdGFuY2VcclxuICogQHBhcmFtIG5hbWUgLSBzZXJ2aWNlIG5hbWVcclxuICogQHBhcmFtIGluc3RhbmNlSWRlbnRpZmllciAtIHNlcnZpY2UgaW5zdGFuY2UgaWRlbnRpZmllciBpbiBjYXNlIHRoZSBzZXJ2aWNlIHN1cHBvcnRzIG11bHRpcGxlIGluc3RhbmNlc1xyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UoYXBwLCBuYW1lLCBpbnN0YW5jZUlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgIF9nZXRQcm92aWRlcihhcHAsIG5hbWUpLmNsZWFySW5zdGFuY2UoaW5zdGFuY2VJZGVudGlmaWVyKTtcclxufVxyXG4vKipcclxuICogVGVzdCBvbmx5XHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gX2NsZWFyQ29tcG9uZW50cygpIHtcclxuICAgIF9jb21wb25lbnRzLmNsZWFyKCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgRVJST1JTID0ge1xyXG4gICAgW1wibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovXTogXCJObyBGaXJlYmFzZSBBcHAgJ3skYXBwTmFtZX0nIGhhcyBiZWVuIGNyZWF0ZWQgLSBcIiArXHJcbiAgICAgICAgJ2NhbGwgRmlyZWJhc2UgQXBwLmluaXRpYWxpemVBcHAoKScsXHJcbiAgICBbXCJiYWQtYXBwLW5hbWVcIiAvKiBBcHBFcnJvci5CQURfQVBQX05BTUUgKi9dOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JGFwcE5hbWV9XCIsXHJcbiAgICBbXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqL106IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JGFwcE5hbWV9JyBhbHJlYWR5IGV4aXN0cyB3aXRoIGRpZmZlcmVudCBvcHRpb25zIG9yIGNvbmZpZ1wiLFxyXG4gICAgW1wiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqL106IFwiRmlyZWJhc2UgQXBwIG5hbWVkICd7JGFwcE5hbWV9JyBhbHJlYWR5IGRlbGV0ZWRcIixcclxuICAgIFtcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovXTogJ05lZWQgdG8gcHJvdmlkZSBvcHRpb25zLCB3aGVuIG5vdCBiZWluZyBkZXBsb3llZCB0byBob3N0aW5nIHZpYSBzb3VyY2UuJyxcclxuICAgIFtcImludmFsaWQtYXBwLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9BUFBfQVJHVU1FTlQgKi9dOiAnZmlyZWJhc2UueyRhcHBOYW1lfSgpIHRha2VzIGVpdGhlciBubyBhcmd1bWVudCBvciBhICcgK1xyXG4gICAgICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJyxcclxuICAgIFtcImludmFsaWQtbG9nLWFyZ3VtZW50XCIgLyogQXBwRXJyb3IuSU5WQUxJRF9MT0dfQVJHVU1FTlQgKi9dOiAnRmlyc3QgYXJndW1lbnQgdG8gYG9uTG9nYCBtdXN0IGJlIG51bGwgb3IgYSBmdW5jdGlvbi4nLFxyXG4gICAgW1wiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqL106ICdFcnJvciB0aHJvd24gd2hlbiBvcGVuaW5nIEluZGV4ZWREQi4gT3JpZ2luYWwgZXJyb3I6IHskb3JpZ2luYWxFcnJvck1lc3NhZ2V9LicsXHJcbiAgICBbXCJpZGItZ2V0XCIgLyogQXBwRXJyb3IuSURCX0dFVCAqL106ICdFcnJvciB0aHJvd24gd2hlbiByZWFkaW5nIGZyb20gSW5kZXhlZERCLiBPcmlnaW5hbCBlcnJvcjogeyRvcmlnaW5hbEVycm9yTWVzc2FnZX0uJyxcclxuICAgIFtcImlkYi1zZXRcIiAvKiBBcHBFcnJvci5JREJfV1JJVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gd3JpdGluZyB0byBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nLFxyXG4gICAgW1wiaWRiLWRlbGV0ZVwiIC8qIEFwcEVycm9yLklEQl9ERUxFVEUgKi9dOiAnRXJyb3IgdGhyb3duIHdoZW4gZGVsZXRpbmcgZnJvbSBJbmRleGVkREIuIE9yaWdpbmFsIGVycm9yOiB7JG9yaWdpbmFsRXJyb3JNZXNzYWdlfS4nXHJcbn07XHJcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBFUlJPUlMpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUFwcEltcGwge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gY29uZmlnLm5hbWU7XHJcbiAgICAgICAgdGhpcy5fYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkID1cclxuICAgICAgICAgICAgY29uZmlnLmF1dG9tYXRpY0RhdGFDb2xsZWN0aW9uRW5hYmxlZDtcclxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FwcCcsICgpID0+IHRoaXMsIFwiUFVCTElDXCIgLyogQ29tcG9uZW50VHlwZS5QVUJMSUMgKi8pKTtcclxuICAgIH1cclxuICAgIGdldCBhdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQoKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkKHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICB0aGlzLl9hdXRvbWF0aWNEYXRhQ29sbGVjdGlvbkVuYWJsZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgb3B0aW9ucygpIHtcclxuICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBnZXQgY29uZmlnKCkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVsZXRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNEZWxldGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGlzRGVsZXRlZCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9pc0RlbGV0ZWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXHJcbiAgICAgKiB1c2UgYmVmb3JlIHBlcmZvcm1pbmcgQVBJIGFjdGlvbnMgb24gdGhlIEFwcC5cclxuICAgICAqL1xyXG4gICAgY2hlY2tEZXN0cm95ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEZWxldGVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYXBwLWRlbGV0ZWRcIiAvKiBBcHBFcnJvci5BUFBfREVMRVRFRCAqLywgeyBhcHBOYW1lOiB0aGlzLl9uYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGN1cnJlbnQgU0RLIHZlcnNpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmNvbnN0IFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxuZnVuY3Rpb24gaW5pdGlhbGl6ZUFwcChfb3B0aW9ucywgcmF3Q29uZmlnID0ge30pIHtcclxuICAgIGxldCBvcHRpb25zID0gX29wdGlvbnM7XHJcbiAgICBpZiAodHlwZW9mIHJhd0NvbmZpZyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcmF3Q29uZmlnO1xyXG4gICAgICAgIHJhd0NvbmZpZyA9IHsgbmFtZSB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IG5hbWU6IERFRkFVTFRfRU5UUllfTkFNRSwgYXV0b21hdGljRGF0YUNvbGxlY3Rpb25FbmFibGVkOiBmYWxzZSB9LCByYXdDb25maWcpO1xyXG4gICAgY29uc3QgbmFtZSA9IGNvbmZpZy5uYW1lO1xyXG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCAhbmFtZSkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYmFkLWFwcC1uYW1lXCIgLyogQXBwRXJyb3IuQkFEX0FQUF9OQU1FICovLCB7XHJcbiAgICAgICAgICAgIGFwcE5hbWU6IFN0cmluZyhuYW1lKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IGdldERlZmF1bHRBcHBDb25maWcoKSk7XHJcbiAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLW9wdGlvbnNcIiAvKiBBcHBFcnJvci5OT19PUFRJT05TICovKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGV4aXN0aW5nQXBwID0gX2FwcHMuZ2V0KG5hbWUpO1xyXG4gICAgaWYgKGV4aXN0aW5nQXBwKSB7XHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBleGlzdGluZyBhcHAgaWYgb3B0aW9ucyBhbmQgY29uZmlnIGRlZXAgZXF1YWwgdGhlIG9uZXMgaW4gdGhlIGV4aXN0aW5nIGFwcC5cclxuICAgICAgICBpZiAoZGVlcEVxdWFsKG9wdGlvbnMsIGV4aXN0aW5nQXBwLm9wdGlvbnMpICYmXHJcbiAgICAgICAgICAgIGRlZXBFcXVhbChjb25maWcsIGV4aXN0aW5nQXBwLmNvbmZpZykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQXBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJkdXBsaWNhdGUtYXBwXCIgLyogQXBwRXJyb3IuRFVQTElDQVRFX0FQUCAqLywgeyBhcHBOYW1lOiBuYW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb21wb25lbnRDb250YWluZXIobmFtZSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBfY29tcG9uZW50cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnRhaW5lci5hZGRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld0FwcCA9IG5ldyBGaXJlYmFzZUFwcEltcGwob3B0aW9ucywgY29uZmlnLCBjb250YWluZXIpO1xyXG4gICAgX2FwcHMuc2V0KG5hbWUsIG5ld0FwcCk7XHJcbiAgICByZXR1cm4gbmV3QXBwO1xyXG59XHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgYSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXHJcbiAqXHJcbiAqIFdoZW4gY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCB0aGUgZGVmYXVsdCBhcHAgaXMgcmV0dXJuZWQuIFdoZW4gYW4gYXBwIG5hbWVcclxuICogaXMgcHJvdmlkZWQsIHRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGF0IG5hbWUgaXMgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlIGFwcCBiZWluZyByZXRyaWV2ZWQgaGFzIG5vdCB5ZXQgYmVlblxyXG4gKiBpbml0aWFsaXplZC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBSZXR1cm4gdGhlIGRlZmF1bHQgYXBwXHJcbiAqIGNvbnN0IGFwcCA9IGdldEFwcCgpO1xyXG4gKiBgYGBcclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgamF2YXNjcmlwdFxyXG4gKiAvLyBSZXR1cm4gYSBuYW1lZCBhcHBcclxuICogY29uc3Qgb3RoZXJBcHAgPSBnZXRBcHAoXCJvdGhlckFwcFwiKTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgYXBwIHRvIHJldHVybi4gSWYgbm8gbmFtZSBpc1xyXG4gKiAgIHByb3ZpZGVkLCB0aGUgZGVmYXVsdCBpcyBgXCJbREVGQVVMVF1cImAuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBhcHAgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgYXBwIG5hbWUuXHJcbiAqICAgSWYgbm8gYXBwIG5hbWUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGFwcCBpcyByZXR1cm5lZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QXBwKG5hbWUgPSBERUZBVUxUX0VOVFJZX05BTUUpIHtcclxuICAgIGNvbnN0IGFwcCA9IF9hcHBzLmdldChuYW1lKTtcclxuICAgIGlmICghYXBwICYmIG5hbWUgPT09IERFRkFVTFRfRU5UUllfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiBpbml0aWFsaXplQXBwKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWFwcCkge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBwXCIgLyogQXBwRXJyb3IuTk9fQVBQICovLCB7IGFwcE5hbWU6IG5hbWUgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXBwO1xyXG59XHJcbi8qKlxyXG4gKiBBIChyZWFkLW9ubHkpIGFycmF5IG9mIGFsbCBpbml0aWFsaXplZCBhcHBzLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcHBzKCkge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oX2FwcHMudmFsdWVzKCkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZW5kZXJzIHRoaXMgYXBwIHVudXNhYmxlIGFuZCBmcmVlcyB0aGUgcmVzb3VyY2VzIG9mIGFsbCBhc3NvY2lhdGVkXHJcbiAqIHNlcnZpY2VzLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGBqYXZhc2NyaXB0XHJcbiAqIGRlbGV0ZUFwcChhcHApXHJcbiAqICAgLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAqICAgICBjb25zb2xlLmxvZyhcIkFwcCBkZWxldGVkIHN1Y2Nlc3NmdWxseVwiKTtcclxuICogICB9KVxyXG4gKiAgIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xyXG4gKiAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZWxldGluZyBhcHA6XCIsIGVycm9yKTtcclxuICogICB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUFwcChhcHApIHtcclxuICAgIGNvbnN0IG5hbWUgPSBhcHAubmFtZTtcclxuICAgIGlmIChfYXBwcy5oYXMobmFtZSkpIHtcclxuICAgICAgICBfYXBwcy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoYXBwLmNvbnRhaW5lclxyXG4gICAgICAgICAgICAuZ2V0UHJvdmlkZXJzKClcclxuICAgICAgICAgICAgLm1hcChwcm92aWRlciA9PiBwcm92aWRlci5kZWxldGUoKSkpO1xyXG4gICAgICAgIGFwcC5pc0RlbGV0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBsaWJyYXJ5J3MgbmFtZSBhbmQgdmVyc2lvbiBmb3IgcGxhdGZvcm0gbG9nZ2luZyBwdXJwb3Nlcy5cclxuICogQHBhcmFtIGxpYnJhcnkgLSBOYW1lIG9mIDFwIG9yIDNwIGxpYnJhcnkgKGUuZy4gZmlyZXN0b3JlLCBhbmd1bGFyZmlyZSlcclxuICogQHBhcmFtIHZlcnNpb24gLSBDdXJyZW50IHZlcnNpb24gb2YgdGhhdCBsaWJyYXJ5LlxyXG4gKiBAcGFyYW0gdmFyaWFudCAtIEJ1bmRsZSB2YXJpYW50LCBlLmcuLCBub2RlLCBybiwgZXRjLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3RlclZlcnNpb24obGlicmFyeUtleU9yTmFtZSwgdmVyc2lvbiwgdmFyaWFudCkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgLy8gVE9ETzogV2UgY2FuIHVzZSB0aGlzIGNoZWNrIHRvIHdoaXRlbGlzdCBzdHJpbmdzIHdoZW4vaWYgd2Ugc2V0IHVwXHJcbiAgICAvLyBhIGdvb2Qgd2hpdGVsaXN0IHN5c3RlbS5cclxuICAgIGxldCBsaWJyYXJ5ID0gKF9hID0gUExBVEZPUk1fTE9HX1NUUklOR1tsaWJyYXJ5S2V5T3JOYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbGlicmFyeUtleU9yTmFtZTtcclxuICAgIGlmICh2YXJpYW50KSB7XHJcbiAgICAgICAgbGlicmFyeSArPSBgLSR7dmFyaWFudH1gO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGlicmFyeU1pc21hdGNoID0gbGlicmFyeS5tYXRjaCgvXFxzfFxcLy8pO1xyXG4gICAgY29uc3QgdmVyc2lvbk1pc21hdGNoID0gdmVyc2lvbi5tYXRjaCgvXFxzfFxcLy8pO1xyXG4gICAgaWYgKGxpYnJhcnlNaXNtYXRjaCB8fCB2ZXJzaW9uTWlzbWF0Y2gpIHtcclxuICAgICAgICBjb25zdCB3YXJuaW5nID0gW1xyXG4gICAgICAgICAgICBgVW5hYmxlIHRvIHJlZ2lzdGVyIGxpYnJhcnkgXCIke2xpYnJhcnl9XCIgd2l0aCB2ZXJzaW9uIFwiJHt2ZXJzaW9ufVwiOmBcclxuICAgICAgICBdO1xyXG4gICAgICAgIGlmIChsaWJyYXJ5TWlzbWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybmluZy5wdXNoKGBsaWJyYXJ5IG5hbWUgXCIke2xpYnJhcnl9XCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzICh3aGl0ZXNwYWNlIG9yIFwiL1wiKWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGlicmFyeU1pc21hdGNoICYmIHZlcnNpb25NaXNtYXRjaCkge1xyXG4gICAgICAgICAgICB3YXJuaW5nLnB1c2goJ2FuZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmVyc2lvbk1pc21hdGNoKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcucHVzaChgdmVyc2lvbiBuYW1lIFwiJHt2ZXJzaW9ufVwiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyAod2hpdGVzcGFjZSBvciBcIi9cIilgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZy5qb2luKCcgJykpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KGAke2xpYnJhcnl9LXZlcnNpb25gLCAoKSA9PiAoeyBsaWJyYXJ5LCB2ZXJzaW9uIH0pLCBcIlZFUlNJT05cIiAvKiBDb21wb25lbnRUeXBlLlZFUlNJT04gKi8pKTtcclxufVxyXG4vKipcclxuICogU2V0cyBsb2cgaGFuZGxlciBmb3IgYWxsIEZpcmViYXNlIFNES3MuXHJcbiAqIEBwYXJhbSBsb2dDYWxsYmFjayAtIEFuIG9wdGlvbmFsIGN1c3RvbSBsb2cgaGFuZGxlciB0aGF0IGV4ZWN1dGVzIHVzZXIgY29kZSB3aGVuZXZlclxyXG4gKiB0aGUgRmlyZWJhc2UgU0RLIG1ha2VzIGEgbG9nZ2luZyBjYWxsLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBvbkxvZyhsb2dDYWxsYmFjaywgb3B0aW9ucykge1xyXG4gICAgaWYgKGxvZ0NhbGxiYWNrICE9PSBudWxsICYmIHR5cGVvZiBsb2dDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1sb2ctYXJndW1lbnRcIiAvKiBBcHBFcnJvci5JTlZBTElEX0xPR19BUkdVTUVOVCAqLyk7XHJcbiAgICB9XHJcbiAgICBzZXRVc2VyTG9nSGFuZGxlcihsb2dDYWxsYmFjaywgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIFNldHMgbG9nIGxldmVsIGZvciBhbGwgRmlyZWJhc2UgU0RLcy5cclxuICpcclxuICogQWxsIG9mIHRoZSBsb2cgdHlwZXMgYWJvdmUgdGhlIGN1cnJlbnQgbG9nIGxldmVsIGFyZSBjYXB0dXJlZCAoaS5lLiBpZlxyXG4gKiB5b3Ugc2V0IHRoZSBsb2cgbGV2ZWwgdG8gYGluZm9gLCBlcnJvcnMgYXJlIGxvZ2dlZCwgYnV0IGBkZWJ1Z2AgYW5kXHJcbiAqIGB2ZXJib3NlYCBsb2dzIGFyZSBub3QpLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xyXG4gICAgc2V0TG9nTGV2ZWwkMShsb2dMZXZlbCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgREJfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtZGF0YWJhc2UnO1xyXG5jb25zdCBEQl9WRVJTSU9OID0gMTtcclxuY29uc3QgU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1oZWFydGJlYXQtc3RvcmUnO1xyXG5sZXQgZGJQcm9taXNlID0gbnVsbDtcclxuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCkge1xyXG4gICAgaWYgKCFkYlByb21pc2UpIHtcclxuICAgICAgICBkYlByb21pc2UgPSBvcGVuREIoREJfTkFNRSwgREJfVkVSU0lPTiwge1xyXG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHVzZSAnYnJlYWsnIGluIHRoaXMgc3dpdGNoIHN0YXRlbWVudCwgdGhlIGZhbGwtdGhyb3VnaFxyXG4gICAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgaXMgd2hhdCB3ZSB3YW50LCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSB2ZXJzaW9ucyBiZXR3ZWVuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhvc2UgdmVyc2lvbnMgdG8gcnVuLCBub3Qgb25seSB0aGUgbGFzdCBvbmUuXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKFNUT1JFX05BTUUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLW9wZW5cIiAvKiBBcHBFcnJvci5JREJfT1BFTiAqLywge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvck1lc3NhZ2U6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYlByb21pc2U7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcmVhZEhlYXJ0YmVhdHNGcm9tSW5kZXhlZERCKGFwcCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xyXG4gICAgICAgIHJldHVybiBkYlxyXG4gICAgICAgICAgICAudHJhbnNhY3Rpb24oU1RPUkVfTkFNRSlcclxuICAgICAgICAgICAgLm9iamVjdFN0b3JlKFNUT1JFX05BTUUpXHJcbiAgICAgICAgICAgIC5nZXQoY29tcHV0ZUtleShhcHApKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGUubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpZGJHZXRFcnJvciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaWRiLWdldFwiIC8qIEFwcEVycm9yLklEQl9HRVQgKi8sIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3JNZXNzYWdlOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oaWRiR2V0RXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIHdyaXRlSGVhcnRiZWF0c1RvSW5kZXhlZERCKGFwcCwgaGVhcnRiZWF0T2JqZWN0KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XHJcbiAgICAgICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihTVE9SRV9OQU1FLCAncmVhZHdyaXRlJyk7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0U3RvcmUgPSB0eC5vYmplY3RTdG9yZShTVE9SRV9OQU1FKTtcclxuICAgICAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQoaGVhcnRiZWF0T2JqZWN0LCBjb21wdXRlS2V5KGFwcCkpO1xyXG4gICAgICAgIHJldHVybiB0eC5kb25lO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEZpcmViYXNlRXJyb3IpIHtcclxuICAgICAgICAgICAgbG9nZ2VyLndhcm4oZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkdldEVycm9yID0gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJpZGItc2V0XCIgLyogQXBwRXJyb3IuSURCX1dSSVRFICovLCB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yTWVzc2FnZTogZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2VcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGlkYkdldEVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjb21wdXRlS2V5KGFwcCkge1xyXG4gICAgcmV0dXJuIGAke2FwcC5uYW1lfSEke2FwcC5vcHRpb25zLmFwcElkfWA7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgTUFYX0hFQURFUl9CWVRFUyA9IDEwMjQ7XHJcbi8vIDMwIGRheXNcclxuY29uc3QgU1RPUkVEX0hFQVJUQkVBVF9SRVRFTlRJT05fTUFYX01JTExJUyA9IDMwICogMjQgKiA2MCAqIDYwICogMTAwMDtcclxuY2xhc3MgSGVhcnRiZWF0U2VydmljZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW4tbWVtb3J5IGNhY2hlIGZvciBoZWFydGJlYXRzLCB1c2VkIGJ5IGdldEhlYXJ0YmVhdHNIZWFkZXIoKSB0byBnZW5lcmF0ZVxyXG4gICAgICAgICAqIHRoZSBoZWFkZXIgc3RyaW5nLlxyXG4gICAgICAgICAqIFN0b3JlcyBvbmUgcmVjb3JkIHBlciBkYXRlLiBUaGlzIHdpbGwgYmUgY29uc29saWRhdGVkIGludG8gdGhlIHN0YW5kYXJkXHJcbiAgICAgICAgICogZm9ybWF0IG9mIG9uZSByZWNvcmQgcGVyIHVzZXIgYWdlbnQgc3RyaW5nIGJlZm9yZSBiZWluZyBzZW50IGFzIGEgaGVhZGVyLlxyXG4gICAgICAgICAqIFBvcHVsYXRlZCBmcm9tIGluZGV4ZWREQiB3aGVuIHRoZSBjb250cm9sbGVyIGlzIGluc3RhbnRpYXRlZCBhbmQgc2hvdWxkXHJcbiAgICAgICAgICogYmUga2VwdCBpbiBzeW5jIHdpdGggaW5kZXhlZERCLlxyXG4gICAgICAgICAqIExlYXZlIHB1YmxpYyBmb3IgZWFzaWVyIHRlc3RpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gbnVsbDtcclxuICAgICAgICBjb25zdCBhcHAgPSB0aGlzLmNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcmFnZSA9IG5ldyBIZWFydGJlYXRTdG9yYWdlSW1wbChhcHApO1xyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZVByb21pc2UgPSB0aGlzLl9zdG9yYWdlLnJlYWQoKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSA9IHJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHRvIHJlcG9ydCBhIGhlYXJ0YmVhdC4gVGhlIGZ1bmN0aW9uIHdpbGwgZ2VuZXJhdGVcclxuICAgICAqIGEgSGVhcnRiZWF0c0J5VXNlckFnZW50IG9iamVjdCwgdXBkYXRlIGhlYXJ0YmVhdHNDYWNoZSwgYW5kIHBlcnNpc3QgaXRcclxuICAgICAqIHRvIEluZGV4ZWREQi5cclxuICAgICAqIE5vdGUgdGhhdCB3ZSBvbmx5IHN0b3JlIG9uZSBoZWFydGJlYXQgcGVyIGRheS4gU28gaWYgYSBoZWFydGJlYXQgZm9yIHRvZGF5IGlzXHJcbiAgICAgKiBhbHJlYWR5IGxvZ2dlZCwgc3Vic2VxdWVudCBjYWxscyB0byB0aGlzIGZ1bmN0aW9uIGluIHRoZSBzYW1lIGRheSB3aWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgKi9cclxuICAgIGFzeW5jIHRyaWdnZXJIZWFydGJlYXQoKSB7XHJcbiAgICAgICAgY29uc3QgcGxhdGZvcm1Mb2dnZXIgPSB0aGlzLmNvbnRhaW5lclxyXG4gICAgICAgICAgICAuZ2V0UHJvdmlkZXIoJ3BsYXRmb3JtLWxvZ2dlcicpXHJcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBcIkZpcmViYXNlIHVzZXIgYWdlbnRcIiBzdHJpbmcgZnJvbSB0aGUgcGxhdGZvcm0gbG9nZ2VyXHJcbiAgICAgICAgLy8gc2VydmljZSwgbm90IHRoZSBicm93c2VyIHVzZXIgYWdlbnQuXHJcbiAgICAgICAgY29uc3QgYWdlbnQgPSBwbGF0Zm9ybUxvZ2dlci5nZXRQbGF0Zm9ybUluZm9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBkYXRlID0gZ2V0VVRDRGF0ZVN0cmluZygpO1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlID0gYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRG8gbm90IHN0b3JlIGEgaGVhcnRiZWF0IGlmIG9uZSBpcyBhbHJlYWR5IHN0b3JlZCBmb3IgdGhpcyBkYXlcclxuICAgICAgICAvLyBvciBpZiBhIGhlYWRlciBoYXMgYWxyZWFkeSBiZWVuIHNlbnQgdG9kYXkuXHJcbiAgICAgICAgaWYgKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPT09IGRhdGUgfHxcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMuc29tZShzaW5nbGVEYXRlSGVhcnRiZWF0ID0+IHNpbmdsZURhdGVIZWFydGJlYXQuZGF0ZSA9PT0gZGF0ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgZGF0ZS4gQ3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMucHVzaCh7IGRhdGUsIGFnZW50IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgZW50cmllcyBvbGRlciB0aGFuIDMwIGRheXMuXHJcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMgPSB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cy5maWx0ZXIoc2luZ2xlRGF0ZUhlYXJ0YmVhdCA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhiVGltZXN0YW1wID0gbmV3IERhdGUoc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKS52YWx1ZU9mKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBub3cgLSBoYlRpbWVzdGFtcCA8PSBTVE9SRURfSEVBUlRCRUFUX1JFVEVOVElPTl9NQVhfTUlMTElTO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLm92ZXJ3cml0ZSh0aGlzLl9oZWFydGJlYXRzQ2FjaGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHdoaWNoIGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgaGVhcnRiZWF0LXNwZWNpZmljIGhlYWRlciBkaXJlY3RseS5cclxuICAgICAqIEl0IGFsc28gY2xlYXJzIGFsbCBoZWFydGJlYXRzIGZyb20gbWVtb3J5IGFzIHdlbGwgYXMgaW4gSW5kZXhlZERCLlxyXG4gICAgICpcclxuICAgICAqIE5PVEU6IENvbnN1bWluZyBwcm9kdWN0IFNES3Mgc2hvdWxkIG5vdCBzZW5kIHRoZSBoZWFkZXIgaWYgdGhpcyBtZXRob2RcclxuICAgICAqIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBhc3luYyBnZXRIZWFydGJlYXRzSGVhZGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5faGVhcnRiZWF0c0NhY2hlUHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgaXQncyBzdGlsbCBudWxsIG9yIHRoZSBhcnJheSBpcyBlbXB0eSwgdGhlcmUgaXMgbm8gZGF0YSB0byBzZW5kLlxyXG4gICAgICAgIGlmICh0aGlzLl9oZWFydGJlYXRzQ2FjaGUgPT09IG51bGwgfHxcclxuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0c0NhY2hlLmhlYXJ0YmVhdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0ZSA9IGdldFVUQ0RhdGVTdHJpbmcoKTtcclxuICAgICAgICAvLyBFeHRyYWN0IGFzIG1hbnkgaGVhcnRiZWF0cyBmcm9tIHRoZSBjYWNoZSBhcyB3aWxsIGZpdCB1bmRlciB0aGUgc2l6ZSBsaW1pdC5cclxuICAgICAgICBjb25zdCB7IGhlYXJ0YmVhdHNUb1NlbmQsIHVuc2VudEVudHJpZXMgfSA9IGV4dHJhY3RIZWFydGJlYXRzRm9ySGVhZGVyKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJTdHJpbmcgPSBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhKU09OLnN0cmluZ2lmeSh7IHZlcnNpb246IDIsIGhlYXJ0YmVhdHM6IGhlYXJ0YmVhdHNUb1NlbmQgfSkpO1xyXG4gICAgICAgIC8vIFN0b3JlIGxhc3Qgc2VudCBkYXRlIHRvIHByZXZlbnQgYW5vdGhlciBiZWluZyBsb2dnZWQvc2VudCBmb3IgdGhlIHNhbWUgZGF5LlxyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5sYXN0U2VudEhlYXJ0YmVhdERhdGUgPSBkYXRlO1xyXG4gICAgICAgIGlmICh1bnNlbnRFbnRyaWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gU3RvcmUgYW55IHVuc2VudCBlbnRyaWVzIGlmIHRoZXkgZXhpc3QuXHJcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdHNDYWNoZS5oZWFydGJlYXRzID0gdW5zZW50RW50cmllcztcclxuICAgICAgICAgICAgLy8gVGhpcyBzZWVtcyBtb3JlIGxpa2VseSB0aGFuIGVtcHR5aW5nIHRoZSBhcnJheSAoYmVsb3cpIHRvIGxlYWQgdG8gc29tZSBvZGQgc3RhdGVcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhlIGNhY2hlIGlzbid0IGVtcHR5IGFuZCB0aGlzIHdpbGwgYmUgY2FsbGVkIGFnYWluIG9uIHRoZSBuZXh0IHJlcXVlc3QsXHJcbiAgICAgICAgICAgIC8vIGFuZCBpcyBwcm9iYWJseSBzYWZlc3QgaWYgd2UgYXdhaXQgaXQuXHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3N0b3JhZ2Uub3ZlcndyaXRlKHRoaXMuX2hlYXJ0YmVhdHNDYWNoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFydGJlYXRzQ2FjaGUuaGVhcnRiZWF0cyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcywgdG8gcmVkdWNlIGxhdGVuY3kuXHJcbiAgICAgICAgICAgIHZvaWQgdGhpcy5fc3RvcmFnZS5vdmVyd3JpdGUodGhpcy5faGVhcnRiZWF0c0NhY2hlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWRlclN0cmluZztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRVVENEYXRlU3RyaW5nKCkge1xyXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xyXG4gICAgLy8gUmV0dXJucyBkYXRlIGZvcm1hdCAnWVlZWS1NTS1ERCdcclxuICAgIHJldHVybiB0b2RheS50b0lTT1N0cmluZygpLnN1YnN0cmluZygwLCAxMCk7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdEhlYXJ0YmVhdHNGb3JIZWFkZXIoaGVhcnRiZWF0c0NhY2hlLCBtYXhTaXplID0gTUFYX0hFQURFUl9CWVRFUykge1xyXG4gICAgLy8gSGVhcnRiZWF0cyBncm91cGVkIGJ5IHVzZXIgYWdlbnQgaW4gdGhlIHN0YW5kYXJkIGZvcm1hdCB0byBiZSBzZW50IGluXHJcbiAgICAvLyB0aGUgaGVhZGVyLlxyXG4gICAgY29uc3QgaGVhcnRiZWF0c1RvU2VuZCA9IFtdO1xyXG4gICAgLy8gU2luZ2xlIGRhdGUgZm9ybWF0IGhlYXJ0YmVhdHMgdGhhdCBhcmUgbm90IHNlbnQuXHJcbiAgICBsZXQgdW5zZW50RW50cmllcyA9IGhlYXJ0YmVhdHNDYWNoZS5zbGljZSgpO1xyXG4gICAgZm9yIChjb25zdCBzaW5nbGVEYXRlSGVhcnRiZWF0IG9mIGhlYXJ0YmVhdHNDYWNoZSkge1xyXG4gICAgICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIGVudHJ5IHdpdGggdGhlIHNhbWUgdXNlciBhZ2VudC5cclxuICAgICAgICBjb25zdCBoZWFydGJlYXRFbnRyeSA9IGhlYXJ0YmVhdHNUb1NlbmQuZmluZChoYiA9PiBoYi5hZ2VudCA9PT0gc2luZ2xlRGF0ZUhlYXJ0YmVhdC5hZ2VudCk7XHJcbiAgICAgICAgaWYgKCFoZWFydGJlYXRFbnRyeSkge1xyXG4gICAgICAgICAgICAvLyBJZiBubyBlbnRyeSBmb3IgdGhpcyB1c2VyIGFnZW50IGV4aXN0cywgY3JlYXRlIG9uZS5cclxuICAgICAgICAgICAgaGVhcnRiZWF0c1RvU2VuZC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGFnZW50OiBzaW5nbGVEYXRlSGVhcnRiZWF0LmFnZW50LFxyXG4gICAgICAgICAgICAgICAgZGF0ZXM6IFtzaW5nbGVEYXRlSGVhcnRiZWF0LmRhdGVdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoY291bnRCeXRlcyhoZWFydGJlYXRzVG9TZW5kKSA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBoZWFkZXIgd291bGQgZXhjZWVkIG1heCBzaXplLCByZW1vdmUgdGhlIGFkZGVkIGhlYXJ0YmVhdFxyXG4gICAgICAgICAgICAgICAgLy8gZW50cnkgYW5kIHN0b3AgYWRkaW5nIHRvIHRoZSBoZWFkZXIuXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzVG9TZW5kLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGhlYXJ0YmVhdEVudHJ5LmRhdGVzLnB1c2goc2luZ2xlRGF0ZUhlYXJ0YmVhdC5kYXRlKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGhlYWRlciB3b3VsZCBleGNlZWQgbWF4IHNpemUsIHJlbW92ZSB0aGUgYWRkZWQgZGF0ZVxyXG4gICAgICAgICAgICAvLyBhbmQgc3RvcCBhZGRpbmcgdG8gdGhlIGhlYWRlci5cclxuICAgICAgICAgICAgaWYgKGNvdW50Qnl0ZXMoaGVhcnRiZWF0c1RvU2VuZCkgPiBtYXhTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRFbnRyeS5kYXRlcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvcCB1bnNlbnQgZW50cnkgZnJvbSBxdWV1ZS4gKFNraXBwZWQgaWYgYWRkaW5nIHRoZSBlbnRyeSBleGNlZWRlZFxyXG4gICAgICAgIC8vIHF1b3RhIGFuZCB0aGUgbG9vcCBicmVha3MgZWFybHkuKVxyXG4gICAgICAgIHVuc2VudEVudHJpZXMgPSB1bnNlbnRFbnRyaWVzLnNsaWNlKDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoZWFydGJlYXRzVG9TZW5kLFxyXG4gICAgICAgIHVuc2VudEVudHJpZXNcclxuICAgIH07XHJcbn1cclxuY2xhc3MgSGVhcnRiZWF0U3RvcmFnZUltcGwge1xyXG4gICAgY29uc3RydWN0b3IoYXBwKSB7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5fY2FuVXNlSW5kZXhlZERCUHJvbWlzZSA9IHRoaXMucnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgcnVuSW5kZXhlZERCRW52aXJvbm1lbnRDaGVjaygpIHtcclxuICAgICAgICBpZiAoIWlzSW5kZXhlZERCQXZhaWxhYmxlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGFsbCBoZWFydGJlYXRzLlxyXG4gICAgICovXHJcbiAgICBhc3luYyByZWFkKCkge1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgaGVhcnRiZWF0czogW10gfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkYkhlYXJ0YmVhdE9iamVjdCA9IGF3YWl0IHJlYWRIZWFydGJlYXRzRnJvbUluZGV4ZWREQih0aGlzLmFwcCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpZGJIZWFydGJlYXRPYmplY3QgfHwgeyBoZWFydGJlYXRzOiBbXSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG92ZXJ3cml0ZSB0aGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBoZWFydGJlYXRzXHJcbiAgICBhc3luYyBvdmVyd3JpdGUoaGVhcnRiZWF0c09iamVjdCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBjYW5Vc2VJbmRleGVkREIgPSBhd2FpdCB0aGlzLl9jYW5Vc2VJbmRleGVkREJQcm9taXNlO1xyXG4gICAgICAgIGlmICghY2FuVXNlSW5kZXhlZERCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdCA9IGF3YWl0IHRoaXMucmVhZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVIZWFydGJlYXRzVG9JbmRleGVkREIodGhpcy5hcHAsIHtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50SGVhcnRiZWF0RGF0ZTogKF9hID0gaGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4aXN0aW5nSGVhcnRiZWF0c09iamVjdC5sYXN0U2VudEhlYXJ0YmVhdERhdGUsXHJcbiAgICAgICAgICAgICAgICBoZWFydGJlYXRzOiBoZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gYWRkIGhlYXJ0YmVhdHNcclxuICAgIGFzeW5jIGFkZChoZWFydGJlYXRzT2JqZWN0KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IGNhblVzZUluZGV4ZWREQiA9IGF3YWl0IHRoaXMuX2NhblVzZUluZGV4ZWREQlByb21pc2U7XHJcbiAgICAgICAgaWYgKCFjYW5Vc2VJbmRleGVkREIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0ID0gYXdhaXQgdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZUhlYXJ0YmVhdHNUb0luZGV4ZWREQih0aGlzLmFwcCwge1xyXG4gICAgICAgICAgICAgICAgbGFzdFNlbnRIZWFydGJlYXREYXRlOiAoX2EgPSBoZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhpc3RpbmdIZWFydGJlYXRzT2JqZWN0Lmxhc3RTZW50SGVhcnRiZWF0RGF0ZSxcclxuICAgICAgICAgICAgICAgIGhlYXJ0YmVhdHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0hlYXJ0YmVhdHNPYmplY3QuaGVhcnRiZWF0cyxcclxuICAgICAgICAgICAgICAgICAgICAuLi5oZWFydGJlYXRzT2JqZWN0LmhlYXJ0YmVhdHNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgYnl0ZXMgb2YgYSBIZWFydGJlYXRzQnlVc2VyQWdlbnQgYXJyYXkgYWZ0ZXIgYmVpbmcgd3JhcHBlZFxyXG4gKiBpbiBhIHBsYXRmb3JtIGxvZ2dpbmcgaGVhZGVyIEpTT04gb2JqZWN0LCBzdHJpbmdpZmllZCwgYW5kIGNvbnZlcnRlZFxyXG4gKiB0byBiYXNlIDY0LlxyXG4gKi9cclxuZnVuY3Rpb24gY291bnRCeXRlcyhoZWFydGJlYXRzQ2FjaGUpIHtcclxuICAgIC8vIGJhc2U2NCBoYXMgYSByZXN0cmljdGVkIHNldCBvZiBjaGFyYWN0ZXJzLCBhbGwgb2Ygd2hpY2ggc2hvdWxkIGJlIDEgYnl0ZS5cclxuICAgIHJldHVybiBiYXNlNjR1cmxFbmNvZGVXaXRob3V0UGFkZGluZyhcclxuICAgIC8vIGhlYXJ0YmVhdHNDYWNoZSB3cmFwcGVyIHByb3BlcnRpZXNcclxuICAgIEpTT04uc3RyaW5naWZ5KHsgdmVyc2lvbjogMiwgaGVhcnRiZWF0czogaGVhcnRiZWF0c0NhY2hlIH0pKS5sZW5ndGg7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJDb3JlQ29tcG9uZW50cyh2YXJpYW50KSB7XHJcbiAgICBfcmVnaXN0ZXJDb21wb25lbnQobmV3IENvbXBvbmVudCgncGxhdGZvcm0tbG9nZ2VyJywgY29udGFpbmVyID0+IG5ldyBQbGF0Zm9ybUxvZ2dlclNlcnZpY2VJbXBsKGNvbnRhaW5lciksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2hlYXJ0YmVhdCcsIGNvbnRhaW5lciA9PiBuZXcgSGVhcnRiZWF0U2VydmljZUltcGwoY29udGFpbmVyKSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XHJcbiAgICAvLyBSZWdpc3RlciBgYXBwYCBwYWNrYWdlLlxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUkbywgdmVyc2lvbiQxLCB2YXJpYW50KTtcclxuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTUsIGVzbTIwMTcsIGNqczUsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSRvLCB2ZXJzaW9uJDEsICdlc20yMDE3Jyk7XHJcbiAgICAvLyBSZWdpc3RlciBwbGF0Zm9ybSBTREsgaWRlbnRpZmllciAobm8gdmVyc2lvbikuXHJcbiAgICByZWdpc3RlclZlcnNpb24oJ2ZpcmUtanMnLCAnJyk7XHJcbn1cblxuLyoqXHJcbiAqIEZpcmViYXNlIEFwcFxyXG4gKlxyXG4gKiBAcmVtYXJrcyBUaGlzIHBhY2thZ2UgY29vcmRpbmF0ZXMgdGhlIGNvbW11bmljYXRpb24gYmV0d2VlbiB0aGUgZGlmZmVyZW50IEZpcmViYXNlIGNvbXBvbmVudHNcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3RlckNvcmVDb21wb25lbnRzKCcnKTtcblxuZXhwb3J0IHsgU0RLX1ZFUlNJT04sIERFRkFVTFRfRU5UUllfTkFNRSBhcyBfREVGQVVMVF9FTlRSWV9OQU1FLCBfYWRkQ29tcG9uZW50LCBfYWRkT3JPdmVyd3JpdGVDb21wb25lbnQsIF9hcHBzLCBfY2xlYXJDb21wb25lbnRzLCBfY29tcG9uZW50cywgX2dldFByb3ZpZGVyLCBfcmVnaXN0ZXJDb21wb25lbnQsIF9yZW1vdmVTZXJ2aWNlSW5zdGFuY2UsIGRlbGV0ZUFwcCwgZ2V0QXBwLCBnZXRBcHBzLCBpbml0aWFsaXplQXBwLCBvbkxvZywgcmVnaXN0ZXJWZXJzaW9uLCBzZXRMb2dMZXZlbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiIsImltcG9ydCB7IHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuZXhwb3J0ICogZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5cbnZhciBuYW1lID0gXCJmaXJlYmFzZVwiO1xudmFyIHZlcnNpb24gPSBcIjkuMjAuMFwiO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5yZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgJ2FwcCcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgd3JhcHBlciB9IGZyb20gXCIuL2hlbHBlclwiO1xuXG5jb25zdCBfYXBwOiB7W2tleTogc3RyaW5nXTogKC4uLmFueTogYW55KSA9PiBhbnl9ID0ge307XG5cbmltcG9ydCB7IGluaXRpYWxpemVBcHAgfSBmcm9tIFwiZmlyZWJhc2UvYXBwXCI7XG5fYXBwLmluaXRpYWxpemVBcHAgPSB3cmFwcGVyKFwiaW5pdGlhbGl6ZUFwcFwiLCBpbml0aWFsaXplQXBwKTsgXG5cbmltcG9ydCB7IEZpcmViYXNlRXJyb3IgfSBmcm9tIFwiZmlyZWJhc2UvYXBwXCI7XG4vLyBfYXBwLkZpcmViYXNlRXJyb3IgPSBGaXJlYmFzZUVycm9yO1xubGV0IGc6IEZpcmViYXNlRXJyb3I7XG5cbmV4cG9ydCBjb25zdCBhcHAgPSBfYXBwOyIsImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBTREtfVkVSU0lPTiBhcyBTREtfVkVSU0lPTiQxLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBzdHJpbmdpZnksIGpzb25FdmFsLCBjb250YWlucywgYXNzZXJ0LCBpc05vZGVTZGssIHN0cmluZ1RvQnl0ZUFycmF5LCBTaGExLCBiYXNlNjQsIGRlZXBDb3B5LCBiYXNlNjRFbmNvZGUsIGlzTW9iaWxlQ29yZG92YSwgc3RyaW5nTGVuZ3RoLCBEZWZlcnJlZCwgc2FmZUdldCwgaXNBZG1pbiwgaXNWYWxpZEZvcm1hdCwgaXNFbXB0eSwgaXNSZWFjdE5hdGl2ZSwgYXNzZXJ0aW9uRXJyb3IsIG1hcCwgcXVlcnlzdHJpbmcsIGVycm9yUHJlZml4LCBnZXRNb2R1bGFySW5zdGFuY2UsIGdldERlZmF1bHRFbXVsYXRvckhvc3RuYW1lQW5kUG9ydCwgY3JlYXRlTW9ja1VzZXJUb2tlbiB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbmltcG9ydCB7IExvZ2dlciwgTG9nTGV2ZWwgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcblxuY29uc3QgbmFtZSA9IFwiQGZpcmViYXNlL2RhdGFiYXNlXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIwLjE0LjRcIjtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIFRoZSBzZW12ZXIgKHd3dy5zZW12ZXIub3JnKSB2ZXJzaW9uIG9mIHRoZSBTREsuICovXHJcbmxldCBTREtfVkVSU0lPTiA9ICcnO1xyXG4vKipcclxuICogU0RLX1ZFUlNJT04gc2hvdWxkIGJlIHNldCBiZWZvcmUgYW55IGRhdGFiYXNlIGluc3RhbmNlIGlzIGNyZWF0ZWRcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRTREtWZXJzaW9uKHZlcnNpb24pIHtcclxuICAgIFNES19WRVJTSU9OID0gdmVyc2lvbjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogV3JhcHMgYSBET00gU3RvcmFnZSBvYmplY3QgYW5kOlxyXG4gKiAtIGF1dG9tYXRpY2FsbHkgZW5jb2RlIG9iamVjdHMgYXMgSlNPTiBzdHJpbmdzIGJlZm9yZSBzdG9yaW5nIHRoZW0gdG8gYWxsb3cgdXMgdG8gc3RvcmUgYXJiaXRyYXJ5IHR5cGVzLlxyXG4gKiAtIHByZWZpeGVzIG5hbWVzIHdpdGggXCJmaXJlYmFzZTpcIiB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggYXBwIGRhdGEuXHJcbiAqXHJcbiAqIFdlIGF1dG9tYXRpY2FsbHkgKHNlZSBzdG9yYWdlLmpzKSBjcmVhdGUgdHdvIHN1Y2ggd3JhcHBlcnMsIG9uZSBmb3Igc2Vzc2lvblN0b3JhZ2UsXHJcbiAqIGFuZCBvbmUgZm9yIGxvY2FsU3RvcmFnZS5cclxuICpcclxuICovXHJcbmNsYXNzIERPTVN0b3JhZ2VXcmFwcGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGRvbVN0b3JhZ2VfIC0gVGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3QgKGUuZy4gbG9jYWxTdG9yYWdlIG9yIHNlc3Npb25TdG9yYWdlKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihkb21TdG9yYWdlXykge1xyXG4gICAgICAgIHRoaXMuZG9tU3RvcmFnZV8gPSBkb21TdG9yYWdlXztcclxuICAgICAgICAvLyBVc2UgYSBwcmVmaXggdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIG90aGVyIHN0dWZmIHNhdmVkIGJ5IHRoZSBhcHAuXHJcbiAgICAgICAgdGhpcy5wcmVmaXhfID0gJ2ZpcmViYXNlOic7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNhdmUgdGhlIHZhbHVlIHVuZGVyXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgYmVpbmcgc3RvcmVkLCBvciBudWxsIHRvIHJlbW92ZSB0aGUga2V5LlxyXG4gICAgICovXHJcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnNldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSksIHN0cmluZ2lmeSh2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHZhbHVlIHRoYXQgd2FzIHN0b3JlZCB1bmRlciB0aGlzIGtleSwgb3IgbnVsbFxyXG4gICAgICovXHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgY29uc3Qgc3RvcmVkVmFsID0gdGhpcy5kb21TdG9yYWdlXy5nZXRJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgICAgICBpZiAoc3RvcmVkVmFsID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ganNvbkV2YWwoc3RvcmVkVmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5kb21TdG9yYWdlXy5yZW1vdmVJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcclxuICAgIH1cclxuICAgIHByZWZpeGVkTmFtZV8obmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpeF8gKyBuYW1lO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9tU3RvcmFnZV8udG9TdHJpbmcoKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW4tbWVtb3J5IHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gdGhhdCBtYXRjaGVzIHRoZSBBUEkgb2YgRE9NU3RvcmFnZVdyYXBwZXJcclxuICogKFRPRE86IGNyZWF0ZSBpbnRlcmZhY2UgZm9yIGJvdGggdG8gaW1wbGVtZW50KS5cclxuICovXHJcbmNsYXNzIE1lbW9yeVN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZV8gPSB7fTtcclxuICAgICAgICB0aGlzLmlzSW5NZW1vcnlTdG9yYWdlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHNldChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlX1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIGlmIChjb250YWlucyh0aGlzLmNhY2hlXywga2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWNoZV9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBET01TdG9yYWdlV3JhcHBlciBvciBlbHNlIGZhbGwgYmFjayB0byBNZW1vcnlTdG9yYWdlLlxyXG4gKiBUT0RPOiBPbmNlIE1lbW9yeVN0b3JhZ2UgYW5kIERPTVN0b3JhZ2VXcmFwcGVyIGhhdmUgYSBzaGFyZWQgaW50ZXJmYWNlIHRoaXMgbWV0aG9kIGFubm90YXRpb24gc2hvdWxkIGNoYW5nZVxyXG4gKiB0byByZWZsZWN0IHRoaXMgdHlwZVxyXG4gKlxyXG4gKiBAcGFyYW0gZG9tU3RvcmFnZU5hbWUgLSBOYW1lIG9mIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugb2JqZWN0XHJcbiAqICAgKGUuZy4gJ2xvY2FsU3RvcmFnZScgb3IgJ3Nlc3Npb25TdG9yYWdlJykuXHJcbiAqIEByZXR1cm5zIFR1cm5pbmcgb2ZmIHR5cGUgaW5mb3JtYXRpb24gdW50aWwgYSBjb21tb24gaW50ZXJmYWNlIGlzIGRlZmluZWQuXHJcbiAqL1xyXG5jb25zdCBjcmVhdGVTdG9yYWdlZm9yID0gZnVuY3Rpb24gKGRvbVN0b3JhZ2VOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIC8vIE5PVEU6IGp1c3QgYWNjZXNzaW5nIFwibG9jYWxTdG9yYWdlXCIgb3IgXCJ3aW5kb3dbJ2xvY2FsU3RvcmFnZSddXCIgbWF5IHRocm93IGEgc2VjdXJpdHkgZXhjZXB0aW9uLFxyXG4gICAgICAgIC8vIHNvIGl0IG11c3QgYmUgaW5zaWRlIHRoZSB0cnkvY2F0Y2guXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBOZWVkIHRvIHRlc3QgY2FjaGUuIEp1c3QgYmVjYXVzZSBpdCdzIGhlcmUgZG9lc24ndCBtZWFuIGl0IHdvcmtzXHJcbiAgICAgICAgICAgIGNvbnN0IGRvbVN0b3JhZ2UgPSB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdO1xyXG4gICAgICAgICAgICBkb21TdG9yYWdlLnNldEl0ZW0oJ2ZpcmViYXNlOnNlbnRpbmVsJywgJ2NhY2hlJyk7XHJcbiAgICAgICAgICAgIGRvbVN0b3JhZ2UucmVtb3ZlSXRlbSgnZmlyZWJhc2U6c2VudGluZWwnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBET01TdG9yYWdlV3JhcHBlcihkb21TdG9yYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAvLyBGYWlsZWQgdG8gY3JlYXRlIHdyYXBwZXIuICBKdXN0IHJldHVybiBpbi1tZW1vcnkgc3RvcmFnZS5cclxuICAgIC8vIFRPRE86IGxvZz9cclxuICAgIHJldHVybiBuZXcgTWVtb3J5U3RvcmFnZSgpO1xyXG59O1xyXG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IGxhc3RzIGFjcm9zcyBzZXNzaW9ucyAqL1xyXG5jb25zdCBQZXJzaXN0ZW50U3RvcmFnZSA9IGNyZWF0ZVN0b3JhZ2Vmb3IoJ2xvY2FsU3RvcmFnZScpO1xyXG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IG9ubHkgbGFzdHMgb25lIHNlc3Npb24gKi9cclxuY29uc3QgU2Vzc2lvblN0b3JhZ2UgPSBjcmVhdGVTdG9yYWdlZm9yKCdzZXNzaW9uU3RvcmFnZScpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBsb2dDbGllbnQgPSBuZXcgTG9nZ2VyKCdAZmlyZWJhc2UvZGF0YWJhc2UnKTtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBsb2NhbGx5LXVuaXF1ZSBJRCAoZ2VuZXJhdGVkIGJ5IGp1c3QgaW5jcmVtZW50aW5nIHVwIGZyb20gMCBlYWNoIHRpbWUgaXRzIGNhbGxlZCkuXHJcbiAqL1xyXG5jb25zdCBMVUlER2VuZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGxldCBpZCA9IDE7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBpZCsrO1xyXG4gICAgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIFNoYTEgaGFzaCBvZiB0aGUgaW5wdXQgc3RyaW5nXHJcbiAqIEBwYXJhbSBzdHIgLSBUaGUgc3RyaW5nIHRvIGhhc2hcclxuICogQHJldHVybnMgeyFzdHJpbmd9IFRoZSByZXN1bHRpbmcgaGFzaFxyXG4gKi9cclxuY29uc3Qgc2hhMSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIGNvbnN0IHV0ZjhCeXRlcyA9IHN0cmluZ1RvQnl0ZUFycmF5KHN0cik7XHJcbiAgICBjb25zdCBzaGExID0gbmV3IFNoYTEoKTtcclxuICAgIHNoYTEudXBkYXRlKHV0ZjhCeXRlcyk7XHJcbiAgICBjb25zdCBzaGExQnl0ZXMgPSBzaGExLmRpZ2VzdCgpO1xyXG4gICAgcmV0dXJuIGJhc2U2NC5lbmNvZGVCeXRlQXJyYXkoc2hhMUJ5dGVzKTtcclxufTtcclxuY29uc3QgYnVpbGRMb2dNZXNzYWdlXyA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJBcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgYXJnID0gdmFyQXJnc1tpXTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpIHx8XHJcbiAgICAgICAgICAgIChhcmcgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGFyZy5sZW5ndGggPT09ICdudW1iZXInKSkge1xyXG4gICAgICAgICAgICBtZXNzYWdlICs9IGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkobnVsbCwgYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgbWVzc2FnZSArPSBzdHJpbmdpZnkoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYXJnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZXNzYWdlICs9ICcgJztcclxuICAgIH1cclxuICAgIHJldHVybiBtZXNzYWdlO1xyXG59O1xyXG4vKipcclxuICogVXNlIHRoaXMgZm9yIGFsbCBkZWJ1ZyBtZXNzYWdlcyBpbiBGaXJlYmFzZS5cclxuICovXHJcbmxldCBsb2dnZXIgPSBudWxsO1xyXG4vKipcclxuICogRmxhZyB0byBjaGVjayBmb3IgbG9nIGF2YWlsYWJpbGl0eSBvbiBmaXJzdCBsb2cgbWVzc2FnZVxyXG4gKi9cclxubGV0IGZpcnN0TG9nXyA9IHRydWU7XHJcbi8qKlxyXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgRmlyZWJhc2UuZW5hYmxlTG9nZ2luZyAoZGVmaW5lZCBoZXJlIHRvIGJyZWFrIGRlcGVuZGVuY2llcylcclxuICogQHBhcmFtIGxvZ2dlcl8gLSBBIGZsYWcgdG8gdHVybiBvbiBsb2dnaW5nLCBvciBhIGN1c3RvbSBsb2dnZXJcclxuICogQHBhcmFtIHBlcnNpc3RlbnQgLSBXaGV0aGVyIG9yIG5vdCB0byBwZXJzaXN0IGxvZ2dpbmcgc2V0dGluZ3MgYWNyb3NzIHJlZnJlc2hlc1xyXG4gKi9cclxuY29uc3QgZW5hYmxlTG9nZ2luZyQxID0gZnVuY3Rpb24gKGxvZ2dlcl8sIHBlcnNpc3RlbnQpIHtcclxuICAgIGFzc2VydCghcGVyc2lzdGVudCB8fCBsb2dnZXJfID09PSB0cnVlIHx8IGxvZ2dlcl8gPT09IGZhbHNlLCBcIkNhbid0IHR1cm4gb24gY3VzdG9tIGxvZ2dlcnMgcGVyc2lzdGVudGx5LlwiKTtcclxuICAgIGlmIChsb2dnZXJfID09PSB0cnVlKSB7XHJcbiAgICAgICAgbG9nQ2xpZW50LmxvZ0xldmVsID0gTG9nTGV2ZWwuVkVSQk9TRTtcclxuICAgICAgICBsb2dnZXIgPSBsb2dDbGllbnQubG9nLmJpbmQobG9nQ2xpZW50KTtcclxuICAgICAgICBpZiAocGVyc2lzdGVudCkge1xyXG4gICAgICAgICAgICBTZXNzaW9uU3RvcmFnZS5zZXQoJ2xvZ2dpbmdfZW5hYmxlZCcsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBsb2dnZXJfID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgbG9nZ2VyID0gbG9nZ2VyXztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxvZ2dlciA9IG51bGw7XHJcbiAgICAgICAgU2Vzc2lvblN0b3JhZ2UucmVtb3ZlKCdsb2dnaW5nX2VuYWJsZWQnKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgbG9nID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGlmIChmaXJzdExvZ18gPT09IHRydWUpIHtcclxuICAgICAgICBmaXJzdExvZ18gPSBmYWxzZTtcclxuICAgICAgICBpZiAobG9nZ2VyID09PSBudWxsICYmIFNlc3Npb25TdG9yYWdlLmdldCgnbG9nZ2luZ19lbmFibGVkJykgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgZW5hYmxlTG9nZ2luZyQxKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChsb2dnZXIpIHtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRMb2dNZXNzYWdlXy5hcHBseShudWxsLCB2YXJBcmdzKTtcclxuICAgICAgICBsb2dnZXIobWVzc2FnZSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGxvZ1dyYXBwZXIgPSBmdW5jdGlvbiAocHJlZml4KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgICAgICBsb2cocHJlZml4LCAuLi52YXJBcmdzKTtcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IGVycm9yID0gZnVuY3Rpb24gKC4uLnZhckFyZ3MpIHtcclxuICAgIGNvbnN0IG1lc3NhZ2UgPSAnRklSRUJBU0UgSU5URVJOQUwgRVJST1I6ICcgKyBidWlsZExvZ01lc3NhZ2VfKC4uLnZhckFyZ3MpO1xyXG4gICAgbG9nQ2xpZW50LmVycm9yKG1lc3NhZ2UpO1xyXG59O1xyXG5jb25zdCBmYXRhbCA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gYEZJUkVCQVNFIEZBVEFMIEVSUk9SOiAke2J1aWxkTG9nTWVzc2FnZV8oLi4udmFyQXJncyl9YDtcclxuICAgIGxvZ0NsaWVudC5lcnJvcihtZXNzYWdlKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxufTtcclxuY29uc3Qgd2FybiA9IGZ1bmN0aW9uICguLi52YXJBcmdzKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlID0gJ0ZJUkVCQVNFIFdBUk5JTkc6ICcgKyBidWlsZExvZ01lc3NhZ2VfKC4uLnZhckFyZ3MpO1xyXG4gICAgbG9nQ2xpZW50Lndhcm4obWVzc2FnZSk7XHJcbn07XHJcbi8qKlxyXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgY29udGFpbmluZyBwYWdlIHVzZXMgaHR0cHMuIENhbGxlZCB3aGVuIGEgY2FsbCB0byBuZXcgRmlyZWJhc2VcclxuICogZG9lcyBub3QgdXNlIGh0dHBzLlxyXG4gKi9cclxuY29uc3Qgd2FybklmUGFnZUlzU2VjdXJlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gQmUgdmVyeSBjYXJlZnVsIGFjY2Vzc2luZyBicm93c2VyIGdsb2JhbHMuIFdobyBrbm93cyB3aGF0IG1heSBvciBtYXkgbm90IGV4aXN0LlxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICYmXHJcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHBzOicpICE9PSAtMSkge1xyXG4gICAgICAgIHdhcm4oJ0luc2VjdXJlIEZpcmViYXNlIGFjY2VzcyBmcm9tIGEgc2VjdXJlIHBhZ2UuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSBodHRwcyBpbiBjYWxscyB0byBuZXcgRmlyZWJhc2UoKS4nKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBkYXRhIGlzIE5hTiwgb3IgKy8tIEluZmluaXR5LlxyXG4gKi9cclxuY29uc3QgaXNJbnZhbGlkSlNPTk51bWJlciA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJyAmJlxyXG4gICAgICAgIChkYXRhICE9PSBkYXRhIHx8IC8vIE5hTlxyXG4gICAgICAgICAgICBkYXRhID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHxcclxuICAgICAgICAgICAgZGF0YSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSk7XHJcbn07XHJcbmNvbnN0IGV4ZWN1dGVXaGVuRE9NUmVhZHkgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgIGlmIChpc05vZGVTZGsoKSB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgZm4oKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE1vZGVsZWQgYWZ0ZXIgalF1ZXJ5LiBUcnkgRE9NQ29udGVudExvYWRlZCBhbmQgb25yZWFkeXN0YXRlY2hhbmdlICh3aGljaFxyXG4gICAgICAgIC8vIGZpcmUgYmVmb3JlIG9ubG9hZCksIGJ1dCBmYWxsIGJhY2sgdG8gb25sb2FkLlxyXG4gICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCh3cmFwcGVkRm4sIE1hdGguZmxvb3IoMTApKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWNhbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB3cmFwcGVkRm4sIGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gb25sb2FkLlxyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHdyYXBwZWRGbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5hdHRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBJRS5cclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBvbmxvYWQuXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHdpbmRvdy5hdHRhY2hFdmVudCgnb25sb2FkJywgd3JhcHBlZEZuKTtcclxuICAgICAgICAgICAgLy8galF1ZXJ5IGhhcyBhbiBleHRyYSBoYWNrIGZvciBJRSB0aGF0IHdlIGNvdWxkIGVtcGxveSAoYmFzZWQgb25cclxuICAgICAgICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC8pIEJ1dCBpdCBsb29rcyByZWFsbHkgb2xkLlxyXG4gICAgICAgICAgICAvLyBJJ20gaG9waW5nIHdlIGRvbid0IG5lZWQgaXQuXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogTWluaW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBiZWZvcmUgYW55IHZhbGlkIG5hbWVzXHJcbiAqL1xyXG5jb25zdCBNSU5fTkFNRSA9ICdbTUlOX05BTUVdJztcclxuLyoqXHJcbiAqIE1heGltdW0ga2V5IG5hbWUuIEludmFsaWQgZm9yIGFjdHVhbCBkYXRhLCB1c2VkIGFzIGEgbWFya2VyIHRvIHNvcnQgYWJvdmUgYW55IHZhbGlkIG5hbWVzXHJcbiAqL1xyXG5jb25zdCBNQVhfTkFNRSA9ICdbTUFYX05BTUVdJztcclxuLyoqXHJcbiAqIENvbXBhcmVzIHZhbGlkIEZpcmViYXNlIGtleSBuYW1lcywgcGx1cyBtaW4gYW5kIG1heCBuYW1lXHJcbiAqL1xyXG5jb25zdCBuYW1lQ29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICBpZiAoYSA9PT0gYikge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoYSA9PT0gTUlOX05BTUUgfHwgYiA9PT0gTUFYX05BTUUpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiID09PSBNSU5fTkFNRSB8fCBhID09PSBNQVhfTkFNRSkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgYUFzSW50ID0gdHJ5UGFyc2VJbnQoYSksIGJBc0ludCA9IHRyeVBhcnNlSW50KGIpO1xyXG4gICAgICAgIGlmIChhQXNJbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKGJBc0ludCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFBc0ludCAtIGJBc0ludCA9PT0gMCA/IGEubGVuZ3RoIC0gYi5sZW5ndGggOiBhQXNJbnQgLSBiQXNJbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYkFzSW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEByZXR1cm5zIHshbnVtYmVyfSBjb21wYXJpc29uIHJlc3VsdC5cclxuICovXHJcbmNvbnN0IHN0cmluZ0NvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgaWYgKGEgPT09IGIpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGEgPCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IHJlcXVpcmVLZXkgPSBmdW5jdGlvbiAoa2V5LCBvYmopIHtcclxuICAgIGlmIChvYmogJiYga2V5IGluIG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBrZXkgKCcgKyBrZXkgKyAnKSBpbiBvYmplY3Q6ICcgKyBzdHJpbmdpZnkob2JqKSk7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IE9iamVjdFRvVW5pcXVlS2V5ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkob2JqKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGtleXMgPSBbXTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cclxuICAgIGZvciAoY29uc3QgayBpbiBvYmopIHtcclxuICAgICAgICBrZXlzLnB1c2goayk7XHJcbiAgICB9XHJcbiAgICAvLyBFeHBvcnQgYXMganNvbiwgYnV0IHdpdGggdGhlIGtleXMgc29ydGVkLlxyXG4gICAga2V5cy5zb3J0KCk7XHJcbiAgICBsZXQga2V5ID0gJ3snO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGkgIT09IDApIHtcclxuICAgICAgICAgICAga2V5ICs9ICcsJztcclxuICAgICAgICB9XHJcbiAgICAgICAga2V5ICs9IHN0cmluZ2lmeShrZXlzW2ldKTtcclxuICAgICAgICBrZXkgKz0gJzonO1xyXG4gICAgICAgIGtleSArPSBPYmplY3RUb1VuaXF1ZUtleShvYmpba2V5c1tpXV0pO1xyXG4gICAgfVxyXG4gICAga2V5ICs9ICd9JztcclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcbi8qKlxyXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhIG51bWJlciBvZiBzbWFsbGVyIHNlZ21lbnRzIG9mIG1heGltdW0gc2l6ZVxyXG4gKiBAcGFyYW0gc3RyIC0gVGhlIHN0cmluZ1xyXG4gKiBAcGFyYW0gc2Vnc2l6ZSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFycyBpbiB0aGUgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nLCBzcGxpdCBpbnRvIGFwcHJvcHJpYXRlbHktc2l6ZWQgY2h1bmtzXHJcbiAqL1xyXG5jb25zdCBzcGxpdFN0cmluZ0J5U2l6ZSA9IGZ1bmN0aW9uIChzdHIsIHNlZ3NpemUpIHtcclxuICAgIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGg7XHJcbiAgICBpZiAobGVuIDw9IHNlZ3NpemUpIHtcclxuICAgICAgICByZXR1cm4gW3N0cl07XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhU2VncyA9IFtdO1xyXG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBsZW47IGMgKz0gc2Vnc2l6ZSkge1xyXG4gICAgICAgIGlmIChjICsgc2Vnc2l6ZSA+IGxlbikge1xyXG4gICAgICAgICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgbGVuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhU2Vncy5wdXNoKHN0ci5zdWJzdHJpbmcoYywgYyArIHNlZ3NpemUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YVNlZ3M7XHJcbn07XHJcbi8qKlxyXG4gKiBBcHBseSBhIGZ1bmN0aW9uIHRvIGVhY2ggKGtleSwgdmFsdWUpIHBhaXIgaW4gYW4gb2JqZWN0IG9yXHJcbiAqIGFwcGx5IGEgZnVuY3Rpb24gdG8gZWFjaCAoaW5kZXgsIHZhbHVlKSBwYWlyIGluIGFuIGFycmF5XHJcbiAqIEBwYXJhbSBvYmogLSBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcclxuICovXHJcbmZ1bmN0aW9uIGVhY2gob2JqLCBmbikge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQm9ycm93ZWQgZnJvbSBodHRwOi8vaGcuc2Vjb25kbGlmZS5jb20vbGxzZC9zcmMvdGlwL2pzL3R5cGVkYXJyYXkuanMgKE1JVCBMaWNlbnNlKVxyXG4gKiBJIG1hZGUgb25lIG1vZGlmaWNhdGlvbiBhdCB0aGUgZW5kIGFuZCByZW1vdmVkIHRoZSBOYU4gLyBJbmZpbml0eVxyXG4gKiBoYW5kbGluZyAoc2luY2UgaXQgc2VlbWVkIGJyb2tlbiBbY2F1c2VkIGFuIG92ZXJmbG93XSBhbmQgd2UgZG9uJ3QgbmVlZCBpdCkuICBTZWUgTUpMIGNvbW1lbnRzLlxyXG4gKiBAcGFyYW0gdiAtIEEgZG91YmxlXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBkb3VibGVUb0lFRUU3NTRTdHJpbmcgPSBmdW5jdGlvbiAodikge1xyXG4gICAgYXNzZXJ0KCFpc0ludmFsaWRKU09OTnVtYmVyKHYpLCAnSW52YWxpZCBKU09OIG51bWJlcicpOyAvLyBNSkxcclxuICAgIGNvbnN0IGViaXRzID0gMTEsIGZiaXRzID0gNTI7XHJcbiAgICBjb25zdCBiaWFzID0gKDEgPDwgKGViaXRzIC0gMSkpIC0gMTtcclxuICAgIGxldCBzLCBlLCBmLCBsbiwgaTtcclxuICAgIC8vIENvbXB1dGUgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXHJcbiAgICAvLyBTa2lwIE5hTiAvIEluZmluaXR5IGhhbmRsaW5nIC0tTUpMLlxyXG4gICAgaWYgKHYgPT09IDApIHtcclxuICAgICAgICBlID0gMDtcclxuICAgICAgICBmID0gMDtcclxuICAgICAgICBzID0gMSAvIHYgPT09IC1JbmZpbml0eSA/IDEgOiAwO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcyA9IHYgPCAwO1xyXG4gICAgICAgIHYgPSBNYXRoLmFicyh2KTtcclxuICAgICAgICBpZiAodiA+PSBNYXRoLnBvdygyLCAxIC0gYmlhcykpIHtcclxuICAgICAgICAgICAgLy8gTm9ybWFsaXplZFxyXG4gICAgICAgICAgICBsbiA9IE1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2codikgLyBNYXRoLkxOMiksIGJpYXMpO1xyXG4gICAgICAgICAgICBlID0gbG4gKyBiaWFzO1xyXG4gICAgICAgICAgICBmID0gTWF0aC5yb3VuZCh2ICogTWF0aC5wb3coMiwgZmJpdHMgLSBsbikgLSBNYXRoLnBvdygyLCBmYml0cykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gRGVub3JtYWxpemVkXHJcbiAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICBmID0gTWF0aC5yb3VuZCh2IC8gTWF0aC5wb3coMiwgMSAtIGJpYXMgLSBmYml0cykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIFBhY2sgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXHJcbiAgICBjb25zdCBiaXRzID0gW107XHJcbiAgICBmb3IgKGkgPSBmYml0czsgaTsgaSAtPSAxKSB7XHJcbiAgICAgICAgYml0cy5wdXNoKGYgJSAyID8gMSA6IDApO1xyXG4gICAgICAgIGYgPSBNYXRoLmZsb29yKGYgLyAyKTtcclxuICAgIH1cclxuICAgIGZvciAoaSA9IGViaXRzOyBpOyBpIC09IDEpIHtcclxuICAgICAgICBiaXRzLnB1c2goZSAlIDIgPyAxIDogMCk7XHJcbiAgICAgICAgZSA9IE1hdGguZmxvb3IoZSAvIDIpO1xyXG4gICAgfVxyXG4gICAgYml0cy5wdXNoKHMgPyAxIDogMCk7XHJcbiAgICBiaXRzLnJldmVyc2UoKTtcclxuICAgIGNvbnN0IHN0ciA9IGJpdHMuam9pbignJyk7XHJcbiAgICAvLyBSZXR1cm4gdGhlIGRhdGEgYXMgYSBoZXggc3RyaW5nLiAtLU1KTFxyXG4gICAgbGV0IGhleEJ5dGVTdHJpbmcgPSAnJztcclxuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSArPSA4KSB7XHJcbiAgICAgICAgbGV0IGhleEJ5dGUgPSBwYXJzZUludChzdHIuc3Vic3RyKGksIDgpLCAyKS50b1N0cmluZygxNik7XHJcbiAgICAgICAgaWYgKGhleEJ5dGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGhleEJ5dGUgPSAnMCcgKyBoZXhCeXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBoZXhCeXRlU3RyaW5nID0gaGV4Qnl0ZVN0cmluZyArIGhleEJ5dGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGV4Qnl0ZVN0cmluZy50b0xvd2VyQ2FzZSgpO1xyXG59O1xyXG4vKipcclxuICogVXNlZCB0byBkZXRlY3QgaWYgd2UncmUgaW4gYSBDaHJvbWUgY29udGVudCBzY3JpcHQgKHdoaWNoIGV4ZWN1dGVzIGluIGFuXHJcbiAqIGlzb2xhdGVkIGVudmlyb25tZW50IHdoZXJlIGxvbmctcG9sbGluZyBkb2Vzbid0IHdvcmspLlxyXG4gKi9cclxuY29uc3QgaXNDaHJvbWVFeHRlbnNpb25Db250ZW50U2NyaXB0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgd2luZG93WydjaHJvbWUnXSAmJlxyXG4gICAgICAgIHdpbmRvd1snY2hyb21lJ11bJ2V4dGVuc2lvbiddICYmXHJcbiAgICAgICAgIS9eY2hyb21lLy50ZXN0KHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XHJcbn07XHJcbi8qKlxyXG4gKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSdyZSBpbiBhIFdpbmRvd3MgOCBTdG9yZSBhcHAuXHJcbiAqL1xyXG5jb25zdCBpc1dpbmRvd3NTdG9yZUFwcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIENoZWNrIGZvciB0aGUgcHJlc2VuY2Ugb2YgYSBjb3VwbGUgV2luUlQgZ2xvYmFsc1xyXG4gICAgcmV0dXJuIHR5cGVvZiBXaW5kb3dzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2luZG93cy5VSSA9PT0gJ29iamVjdCc7XHJcbn07XHJcbi8qKlxyXG4gKiBDb252ZXJ0cyBhIHNlcnZlciBlcnJvciBjb2RlIHRvIGEgSmF2YXNjcmlwdCBFcnJvclxyXG4gKi9cclxuZnVuY3Rpb24gZXJyb3JGb3JTZXJ2ZXJDb2RlKGNvZGUsIHF1ZXJ5KSB7XHJcbiAgICBsZXQgcmVhc29uID0gJ1Vua25vd24gRXJyb3InO1xyXG4gICAgaWYgKGNvZGUgPT09ICd0b29fYmlnJykge1xyXG4gICAgICAgIHJlYXNvbiA9XHJcbiAgICAgICAgICAgICdUaGUgZGF0YSByZXF1ZXN0ZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBzaXplICcgK1xyXG4gICAgICAgICAgICAgICAgJ3RoYXQgY2FuIGJlIGFjY2Vzc2VkIHdpdGggYSBzaW5nbGUgcmVxdWVzdC4nO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29kZSA9PT0gJ3Blcm1pc3Npb25fZGVuaWVkJykge1xyXG4gICAgICAgIHJlYXNvbiA9IFwiQ2xpZW50IGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGUgZGVzaXJlZCBkYXRhLlwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29kZSA9PT0gJ3VuYXZhaWxhYmxlJykge1xyXG4gICAgICAgIHJlYXNvbiA9ICdUaGUgc2VydmljZSBpcyB1bmF2YWlsYWJsZSc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihjb2RlICsgJyBhdCAnICsgcXVlcnkuX3BhdGgudG9TdHJpbmcoKSArICc6ICcgKyByZWFzb24pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGVycm9yLmNvZGUgPSBjb2RlLnRvVXBwZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn1cclxuLyoqXHJcbiAqIFVzZWQgdG8gdGVzdCBmb3IgaW50ZWdlci1sb29raW5nIHN0cmluZ3NcclxuICovXHJcbmNvbnN0IElOVEVHRVJfUkVHRVhQXyA9IG5ldyBSZWdFeHAoJ14tPygwKilcXFxcZHsxLDEwfSQnKTtcclxuLyoqXHJcbiAqIEZvciB1c2UgaW4ga2V5cywgdGhlIG1pbmltdW0gcG9zc2libGUgMzItYml0IGludGVnZXIuXHJcbiAqL1xyXG5jb25zdCBJTlRFR0VSXzMyX01JTiA9IC0yMTQ3NDgzNjQ4O1xyXG4vKipcclxuICogRm9yIHVzZSBpbiBreWVzLCB0aGUgbWF4aW11bSBwb3NzaWJsZSAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmNvbnN0IElOVEVHRVJfMzJfTUFYID0gMjE0NzQ4MzY0NztcclxuLyoqXHJcbiAqIElmIHRoZSBzdHJpbmcgY29udGFpbnMgYSAzMi1iaXQgaW50ZWdlciwgcmV0dXJuIGl0LiAgRWxzZSByZXR1cm4gbnVsbC5cclxuICovXHJcbmNvbnN0IHRyeVBhcnNlSW50ID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgaWYgKElOVEVHRVJfUkVHRVhQXy50ZXN0KHN0cikpIHtcclxuICAgICAgICBjb25zdCBpbnRWYWwgPSBOdW1iZXIoc3RyKTtcclxuICAgICAgICBpZiAoaW50VmFsID49IElOVEVHRVJfMzJfTUlOICYmIGludFZhbCA8PSBJTlRFR0VSXzMyX01BWCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW50VmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG4vKipcclxuICogSGVscGVyIHRvIHJ1biBzb21lIGNvZGUgYnV0IGNhdGNoIGFueSBleGNlcHRpb25zIGFuZCByZS10aHJvdyB0aGVtIGxhdGVyLlxyXG4gKiBVc2VmdWwgZm9yIHByZXZlbnRpbmcgdXNlciBjYWxsYmFja3MgZnJvbSBicmVha2luZyBpbnRlcm5hbCBjb2RlLlxyXG4gKlxyXG4gKiBSZS10aHJvd2luZyB0aGUgZXhjZXB0aW9uIGZyb20gYSBzZXRUaW1lb3V0IGlzIGEgbGl0dGxlIGV2aWwsIGJ1dCBpdCdzIHZlcnlcclxuICogY29udmVuaWVudCAod2UgZG9uJ3QgaGF2ZSB0byB0cnkgdG8gZmlndXJlIG91dCB3aGVuIGlzIGEgc2FmZSBwb2ludCB0b1xyXG4gKiByZS10aHJvdyBpdCksIGFuZCB0aGUgYmVoYXZpb3Igc2VlbXMgcmVhc29uYWJsZTpcclxuICpcclxuICogKiBJZiB5b3UgYXJlbid0IHBhdXNpbmcgb24gZXhjZXB0aW9ucywgeW91IGdldCBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aXRoXHJcbiAqICAgdGhlIGNvcnJlY3Qgc3RhY2sgdHJhY2UuXHJcbiAqICogSWYgeW91J3JlIHBhdXNpbmcgb24gYWxsIGV4Y2VwdGlvbnMsIHRoZSBkZWJ1Z2dlciB3aWxsIHBhdXNlIG9uIHlvdXJcclxuICogICBleGNlcHRpb24gYW5kIHRoZW4gYWdhaW4gd2hlbiB3ZSByZXRocm93IGl0LlxyXG4gKiAqIElmIHlvdSdyZSBvbmx5IHBhdXNpbmcgb24gdW5jYXVnaHQgZXhjZXB0aW9ucywgdGhlIGRlYnVnZ2VyIHdpbGwgb25seSBwYXVzZVxyXG4gKiAgIG9uIHVzIHJlLXRocm93aW5nIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gZm4gLSBUaGUgY29kZSB0byBndWFyZC5cclxuICovXHJcbmNvbnN0IGV4Y2VwdGlvbkd1YXJkID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGZuKCk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIFJlLXRocm93IGV4Y2VwdGlvbiB3aGVuIGl0J3Mgc2FmZS5cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gSXQgdXNlZCB0byBiZSB0aGF0IFwidGhyb3cgZVwiIHdvdWxkIHJlc3VsdCBpbiBhIGdvb2QgY29uc29sZSBlcnJvciB3aXRoXHJcbiAgICAgICAgICAgIC8vIHJlbGV2YW50IGNvbnRleHQsIGJ1dCBhcyBvZiBDaHJvbWUgMzksIHlvdSBqdXN0IGdldCB0aGUgZmlyZWJhc2UuanNcclxuICAgICAgICAgICAgLy8gZmlsZS9saW5lIG51bWJlciB3aGVyZSB3ZSByZS10aHJvdyBpdCwgd2hpY2ggaXMgdXNlbGVzcy4gU28gd2UgbG9nXHJcbiAgICAgICAgICAgIC8vIGUuc3RhY2sgZXhwbGljaXRseS5cclxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBlLnN0YWNrIHx8ICcnO1xyXG4gICAgICAgICAgICB3YXJuKCdFeGNlcHRpb24gd2FzIHRocm93biBieSB1c2VyIGNhbGxiYWNrLicsIHN0YWNrKTtcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHdlIHRoaW5rIHdlJ3JlIGN1cnJlbnRseSBiZWluZyBjcmF3bGVkLlxyXG4gKi9cclxuY29uc3QgYmVpbmdDcmF3bGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgY29uc3QgdXNlckFnZW50ID0gKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgd2luZG93WyduYXZpZ2F0b3InXSAmJlxyXG4gICAgICAgIHdpbmRvd1snbmF2aWdhdG9yJ11bJ3VzZXJBZ2VudCddKSB8fFxyXG4gICAgICAgICcnO1xyXG4gICAgLy8gRm9yIG5vdyB3ZSB3aGl0ZWxpc3QgdGhlIG1vc3QgcG9wdWxhciBjcmF3bGVycy4gIFdlIHNob3VsZCByZWZpbmUgdGhpcyB0byBiZSB0aGUgc2V0IG9mIGNyYXdsZXJzIHdlXHJcbiAgICAvLyBiZWxpZXZlIHRvIHN1cHBvcnQgSmF2YVNjcmlwdC9BSkFYIHJlbmRlcmluZy5cclxuICAgIC8vIE5PVEU6IEdvb2dsZSBXZWJtYXN0ZXIgVG9vbHMgZG9lc24ndCByZWFsbHkgYmVsb25nLCBidXQgdGhlaXIgXCJUaGlzIGlzIGhvdyBhIHZpc2l0b3IgdG8geW91ciB3ZWJzaXRlXHJcbiAgICAvLyB3b3VsZCBoYXZlIHNlZW4gdGhlIHBhZ2VcIiBpcyBmbGFreSBpZiB3ZSBkb24ndCB0cmVhdCBpdCBhcyBhIGNyYXdsZXIuXHJcbiAgICByZXR1cm4gKHVzZXJBZ2VudC5zZWFyY2goL2dvb2dsZWJvdHxnb29nbGUgd2VibWFzdGVyIHRvb2xzfGJpbmdib3R8eWFob28hIHNsdXJwfGJhaWR1c3BpZGVyfHlhbmRleGJvdHxkdWNrZHVja2JvdC9pKSA+PSAwKTtcclxufTtcclxuLyoqXHJcbiAqIFNhbWUgYXMgc2V0VGltZW91dCgpIGV4Y2VwdCBvbiBOb2RlLkpTIGl0IHdpbGwgL25vdC8gcHJldmVudCB0aGUgcHJvY2VzcyBmcm9tIGV4aXRpbmcuXHJcbiAqXHJcbiAqIEl0IGlzIHJlbW92ZWQgd2l0aCBjbGVhclRpbWVvdXQoKSBhcyBub3JtYWwuXHJcbiAqXHJcbiAqIEBwYXJhbSBmbiAtIEZ1bmN0aW9uIHRvIHJ1bi5cclxuICogQHBhcmFtIHRpbWUgLSBNaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgcnVubmluZy5cclxuICogQHJldHVybnMgVGhlIHNldFRpbWVvdXQoKSByZXR1cm4gdmFsdWUuXHJcbiAqL1xyXG5jb25zdCBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcgPSBmdW5jdGlvbiAoZm4sIHRpbWUpIHtcclxuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCB0aW1lKTtcclxuICAgIC8vIE5vdGU6IGF0IHRoZSB0aW1lIG9mIHRoaXMgY29tbWVudCwgdW5yZWZUaW1lciBpcyB1bmRlciB0aGUgdW5zdGFibGUgc2V0IG9mIEFQSXMuIFJ1biB3aXRoIC0tdW5zdGFibGUgdG8gZW5hYmxlIHRoZSBBUEkuXHJcbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICdudW1iZXInICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBJcyBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgdHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBEZW5vIGFuZCB1bnJlZlRpbWVyIGFyZSBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgRGVub1sndW5yZWZUaW1lciddKSB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBEZW5vIGFuZCB1bnJlZlRpbWVyIGFyZSBvbmx5IGRlZmluZWQgaW4gRGVubyBlbnZpcm9ubWVudHMuXHJcbiAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpbWVvdXQpO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdGltZW91dCA9PT0gJ29iamVjdCcgJiYgdGltZW91dFsndW5yZWYnXSkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgdGltZW91dFsndW5yZWYnXSgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRpbWVvdXQ7XHJcbn07XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgQXBwQ2hlY2sncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBBcHBDaGVja1Rva2VuUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXBwTmFtZV8sIGFwcENoZWNrUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLmFwcE5hbWVfID0gYXBwTmFtZV87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyID0gYXBwQ2hlY2tQcm92aWRlcjtcclxuICAgICAgICB0aGlzLmFwcENoZWNrID0gYXBwQ2hlY2tQcm92aWRlciA9PT0gbnVsbCB8fCBhcHBDaGVja1Byb3ZpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBDaGVja1Byb3ZpZGVyLmdldEltbWVkaWF0ZSh7IG9wdGlvbmFsOiB0cnVlIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5hcHBDaGVjaykge1xyXG4gICAgICAgICAgICBhcHBDaGVja1Byb3ZpZGVyID09PSBudWxsIHx8IGFwcENoZWNrUHJvdmlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcENoZWNrUHJvdmlkZXIuZ2V0KCkudGhlbihhcHBDaGVjayA9PiAodGhpcy5hcHBDaGVjayA9IGFwcENoZWNrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmFwcENoZWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdXBwb3J0IGRlbGF5ZWQgaW5pdGlhbGl6YXRpb24gb2YgRmlyZWJhc2VBcHBDaGVjay4gVGhpcyBhbGxvd3Mgb3VyXHJcbiAgICAgICAgICAgICAgICAvLyBjdXN0b21lcnMgdG8gaW5pdGlhbGl6ZSB0aGUgUlREQiBTREsgYmVmb3JlIGluaXRpYWxpemluZyBGaXJlYmFzZVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwQ2hlY2sgYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hcHBDaGVjay5nZXRUb2tlbihmb3JjZVJlZnJlc2gpO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSB0aGlzLmFwcENoZWNrUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoKS50aGVuKGFwcENoZWNrID0+IGFwcENoZWNrLmFkZFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICB3YXJuKGBQcm92aWRlZCBBcHBDaGVjayBjcmVkZW50aWFscyBmb3IgdGhlIGFwcCBuYW1lZCBcIiR7dGhpcy5hcHBOYW1lX31cIiBgICtcclxuICAgICAgICAgICAgJ2FyZSBpbnZhbGlkLiBUaGlzIHVzdWFsbHkgaW5kaWNhdGVzIHlvdXIgYXBwIHdhcyBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5LicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgRmlyZWJhc2VBcHAncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcE5hbWVfLCBmaXJlYmFzZU9wdGlvbnNfLCBhdXRoUHJvdmlkZXJfKSB7XHJcbiAgICAgICAgdGhpcy5hcHBOYW1lXyA9IGFwcE5hbWVfO1xyXG4gICAgICAgIHRoaXMuZmlyZWJhc2VPcHRpb25zXyA9IGZpcmViYXNlT3B0aW9uc187XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfID0gYXV0aFByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmF1dGhfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhfID0gYXV0aFByb3ZpZGVyXy5nZXRJbW1lZGlhdGUoeyBvcHRpb25hbDogdHJ1ZSB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgYXV0aFByb3ZpZGVyXy5vbkluaXQoYXV0aCA9PiAodGhpcy5hdXRoXyA9IGF1dGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRUb2tlbihmb3JjZVJlZnJlc2gpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZGVsYXllZCBpbml0aWFsaXphdGlvbiBvZiBGaXJlYmFzZUF1dGguIFRoaXMgYWxsb3dzIG91clxyXG4gICAgICAgICAgICAgICAgLy8gY3VzdG9tZXJzIHRvIGluaXRpYWxpemUgdGhlIFJUREIgU0RLIGJlZm9yZSBpbml0aWFsaXppbmcgRmlyZWJhc2VcclxuICAgICAgICAgICAgICAgIC8vIEF1dGggYW5kIGVuc3VyZXMgdGhhdCBhbGwgcmVxdWVzdHMgYXJlIGF1dGhlbnRpY2F0ZWQgaWYgYSB0b2tlblxyXG4gICAgICAgICAgICAgICAgLy8gYmVjb21lcyBhdmFpbGFibGUgYmVmb3JlIHRoZSB0aW1vZW91dCBiZWxvdyBleHBpcmVzLlxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aF8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5hdXRoXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLmNhdGNoKGVycm9yID0+IHtcclxuICAgICAgICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGFsbCB0aGUgY2FzZXMgdGhpcyBpcyByYWlzZWQgYW5kIHdoZXRoZXJcclxuICAgICAgICAgICAgLy8gdGhpcyBtYWtlcyBzZW5zZS5cclxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCcpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnR290IGF1dGgvdG9rZW4tbm90LWluaXRpYWxpemVkIGVycm9yLiAgVHJlYXRpbmcgYXMgbnVsbCB0b2tlbi4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIC8vIFRPRE86IFdlIG1pZ2h0IHdhbnQgdG8gd3JhcCB0aGUgbGlzdGVuZXIgYW5kIGNhbGwgaXQgd2l0aCBubyBhcmdzIHRvXHJcbiAgICAgICAgLy8gYXZvaWQgYSBsZWFreSBhYnN0cmFjdGlvbiwgYnV0IHRoYXQgbWFrZXMgcmVtb3ZpbmcgdGhlIGxpc3RlbmVyIGhhcmRlci5cclxuICAgICAgICBpZiAodGhpcy5hdXRoXykge1xyXG4gICAgICAgICAgICB0aGlzLmF1dGhfLmFkZEF1dGhUb2tlbkxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyX1xyXG4gICAgICAgICAgICAgICAgLmdldCgpXHJcbiAgICAgICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGguYWRkQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXJfXHJcbiAgICAgICAgICAgIC5nZXQoKVxyXG4gICAgICAgICAgICAudGhlbihhdXRoID0+IGF1dGgucmVtb3ZlQXV0aFRva2VuTGlzdGVuZXIobGlzdGVuZXIpKTtcclxuICAgIH1cclxuICAgIG5vdGlmeUZvckludmFsaWRUb2tlbigpIHtcclxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ1Byb3ZpZGVkIGF1dGhlbnRpY2F0aW9uIGNyZWRlbnRpYWxzIGZvciB0aGUgYXBwIG5hbWVkIFwiJyArXHJcbiAgICAgICAgICAgIHRoaXMuYXBwTmFtZV8gK1xyXG4gICAgICAgICAgICAnXCIgYXJlIGludmFsaWQuIFRoaXMgdXN1YWxseSBpbmRpY2F0ZXMgeW91ciBhcHAgd2FzIG5vdCAnICtcclxuICAgICAgICAgICAgJ2luaXRpYWxpemVkIGNvcnJlY3RseS4gJztcclxuICAgICAgICBpZiAoJ2NyZWRlbnRpYWwnIGluIHRoaXMuZmlyZWJhc2VPcHRpb25zXykge1xyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz1cclxuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdGhlIFwiY3JlZGVudGlhbFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Byb2plY3QuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmZpcmViYXNlT3B0aW9uc18pIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcInNlcnZpY2VBY2NvdW50XCIgcHJvcGVydHkgcHJvdmlkZWQgdG8gaW5pdGlhbGl6ZUFwcCgpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpcyBhdXRob3JpemVkIHRvIGFjY2VzcyB0aGUgc3BlY2lmaWVkIFwiZGF0YWJhc2VVUkxcIiBhbmQgaXMgZnJvbSB0aGUgY29ycmVjdCAnICtcclxuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XHJcbiAgICAgICAgICAgICAgICAnTWFrZSBzdXJlIHRoZSBcImFwaUtleVwiIGFuZCBcImRhdGFiYXNlVVJMXCIgcHJvcGVydGllcyBwcm92aWRlZCB0byAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbGl6ZUFwcCgpIG1hdGNoIHRoZSB2YWx1ZXMgcHJvdmlkZWQgZm9yIHlvdXIgYXBwIGF0ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS8uJztcclxuICAgICAgICB9XHJcbiAgICAgICAgd2FybihlcnJvck1lc3NhZ2UpO1xyXG4gICAgfVxyXG59XHJcbi8qIEF1dGhUb2tlblByb3ZpZGVyIHRoYXQgc3VwcGxpZXMgYSBjb25zdGFudCB0b2tlbi4gVXNlZCBieSBBZG1pbiBTREsgb3IgbW9ja1VzZXJUb2tlbiB3aXRoIGVtdWxhdG9ycy4gKi9cclxuY2xhc3MgRW11bGF0b3JUb2tlblByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFjY2Vzc1Rva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IGFjY2Vzc1Rva2VuO1xyXG4gICAgfVxyXG4gICAgZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XHJcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhZGRUb2tlbkNoYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gSW52b2tlIHRoZSBsaXN0ZW5lciBpbW1lZGlhdGVseSB0byBtYXRjaCB0aGUgYmVoYXZpb3IgaW4gRmlyZWJhc2UgQXV0aFxyXG4gICAgICAgIC8vIChzZWUgcGFja2FnZXMvYXV0aC9zcmMvYXV0aC5qcyNMMTgwNylcclxuICAgICAgICBsaXN0ZW5lcih0aGlzLmFjY2Vzc1Rva2VuKTtcclxuICAgIH1cclxuICAgIHJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHsgfVxyXG4gICAgbm90aWZ5Rm9ySW52YWxpZFRva2VuKCkgeyB9XHJcbn1cclxuLyoqIEEgc3RyaW5nIHRoYXQgaXMgdHJlYXRlZCBhcyBhbiBhZG1pbiBhY2Nlc3MgdG9rZW4gYnkgdGhlIFJUREIgZW11bGF0b3IuIFVzZWQgYnkgQWRtaW4gU0RLLiAqL1xyXG5FbXVsYXRvclRva2VuUHJvdmlkZXIuT1dORVIgPSAnb3duZXInO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBQUk9UT0NPTF9WRVJTSU9OID0gJzUnO1xyXG5jb25zdCBWRVJTSU9OX1BBUkFNID0gJ3YnO1xyXG5jb25zdCBUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTSA9ICdzJztcclxuY29uc3QgUkVGRVJFUl9QQVJBTSA9ICdyJztcclxuY29uc3QgRk9SR0VfUkVGID0gJ2YnO1xyXG4vLyBNYXRjaGVzIGNvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbSwgZmlyZWJhc2UtY29uc29sZS0qLmNvcnAuZ29vZ2xlLmNvbSBhbmRcclxuLy8gZmlyZWJhc2UuY29ycC5nb29nbGUuY29tXHJcbmNvbnN0IEZPUkdFX0RPTUFJTl9SRSA9IC8oY29uc29sZVxcLmZpcmViYXNlfGZpcmViYXNlLWNvbnNvbGUtXFx3K1xcLmNvcnB8ZmlyZWJhc2VcXC5jb3JwKVxcLmdvb2dsZVxcLmNvbS87XHJcbmNvbnN0IExBU1RfU0VTU0lPTl9QQVJBTSA9ICdscyc7XHJcbmNvbnN0IEFQUExJQ0FUSU9OX0lEX1BBUkFNID0gJ3AnO1xyXG5jb25zdCBBUFBfQ0hFQ0tfVE9LRU5fUEFSQU0gPSAnYWMnO1xyXG5jb25zdCBXRUJTT0NLRVQgPSAnd2Vic29ja2V0JztcclxuY29uc3QgTE9OR19QT0xMSU5HID0gJ2xvbmdfcG9sbGluZyc7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaG9sZHMgbWV0YWRhdGEgYWJvdXQgYSBSZXBvIG9iamVjdFxyXG4gKi9cclxuY2xhc3MgUmVwb0luZm8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaG9zdCAtIEhvc3RuYW1lIHBvcnRpb24gb2YgdGhlIHVybCBmb3IgdGhlIHJlcG9cclxuICAgICAqIEBwYXJhbSBzZWN1cmUgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIHJlcG8gaXMgYWNjZXNzZWQgb3ZlciBzc2xcclxuICAgICAqIEBwYXJhbSBuYW1lc3BhY2UgLSBUaGUgbmFtZXNwYWNlIHJlcHJlc2VudGVkIGJ5IHRoZSByZXBvXHJcbiAgICAgKiBAcGFyYW0gd2ViU29ja2V0T25seSAtIFdoZXRoZXIgdG8gcHJlZmVyIHdlYnNvY2tldHMgb3ZlciBhbGwgb3RoZXIgdHJhbnNwb3J0cyAodXNlZCBieSBOZXN0KS5cclxuICAgICAqIEBwYXJhbSBub2RlQWRtaW4gLSBXaGV0aGVyIHRoaXMgaW5zdGFuY2UgdXNlcyBBZG1pbiBTREsgY3JlZGVudGlhbHNcclxuICAgICAqIEBwYXJhbSBwZXJzaXN0ZW5jZUtleSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHNlc3Npb24gcGVyc2lzdGVuY2Ugc3RvcmFnZSBrZXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaG9zdCwgc2VjdXJlLCBuYW1lc3BhY2UsIHdlYlNvY2tldE9ubHksIG5vZGVBZG1pbiA9IGZhbHNlLCBwZXJzaXN0ZW5jZUtleSA9ICcnLCBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcyA9IGZhbHNlLCBpc1VzaW5nRW11bGF0b3IgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlO1xyXG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xyXG4gICAgICAgIHRoaXMud2ViU29ja2V0T25seSA9IHdlYlNvY2tldE9ubHk7XHJcbiAgICAgICAgdGhpcy5ub2RlQWRtaW4gPSBub2RlQWRtaW47XHJcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZUtleSA9IHBlcnNpc3RlbmNlS2V5O1xyXG4gICAgICAgIHRoaXMuaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXMgPSBpbmNsdWRlTmFtZXNwYWNlSW5RdWVyeVBhcmFtcztcclxuICAgICAgICB0aGlzLmlzVXNpbmdFbXVsYXRvciA9IGlzVXNpbmdFbXVsYXRvcjtcclxuICAgICAgICB0aGlzLl9ob3N0ID0gaG9zdC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHRoaXMuX2RvbWFpbiA9IHRoaXMuX2hvc3Quc3Vic3RyKHRoaXMuX2hvc3QuaW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPVxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5nZXQoJ2hvc3Q6JyArIGhvc3QpIHx8IHRoaXMuX2hvc3Q7XHJcbiAgICB9XHJcbiAgICBpc0NhY2hlYWJsZUhvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxIb3N0LnN1YnN0cigwLCAyKSA9PT0gJ3MtJztcclxuICAgIH1cclxuICAgIGlzQ3VzdG9tSG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2RvbWFpbiAhPT0gJ2ZpcmViYXNlaW8uY29tJyAmJlxyXG4gICAgICAgICAgICB0aGlzLl9kb21haW4gIT09ICdmaXJlYmFzZWlvLWRlbW8uY29tJyk7XHJcbiAgICB9XHJcbiAgICBnZXQgaG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faG9zdDtcclxuICAgIH1cclxuICAgIHNldCBob3N0KG5ld0hvc3QpIHtcclxuICAgICAgICBpZiAobmV3SG9zdCAhPT0gdGhpcy5pbnRlcm5hbEhvc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPSBuZXdIb3N0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc0NhY2hlYWJsZUhvc3QoKSkge1xyXG4gICAgICAgICAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdob3N0OicgKyB0aGlzLl9ob3N0LCB0aGlzLmludGVybmFsSG9zdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBsZXQgc3RyID0gdGhpcy50b1VSTFN0cmluZygpO1xyXG4gICAgICAgIGlmICh0aGlzLnBlcnNpc3RlbmNlS2V5KSB7XHJcbiAgICAgICAgICAgIHN0ciArPSAnPCcgKyB0aGlzLnBlcnNpc3RlbmNlS2V5ICsgJz4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG4gICAgdG9VUkxTdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zXHJcbiAgICAgICAgICAgID8gYD9ucz0ke3RoaXMubmFtZXNwYWNlfWBcclxuICAgICAgICAgICAgOiAnJztcclxuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9JHt0aGlzLmhvc3R9LyR7cXVlcnl9YDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvSW5mb05lZWRzUXVlcnlQYXJhbShyZXBvSW5mbykge1xyXG4gICAgcmV0dXJuIChyZXBvSW5mby5ob3N0ICE9PSByZXBvSW5mby5pbnRlcm5hbEhvc3QgfHxcclxuICAgICAgICByZXBvSW5mby5pc0N1c3RvbUhvc3QoKSB8fFxyXG4gICAgICAgIHJlcG9JbmZvLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgd2Vic29ja2V0IFVSTCBmb3IgdGhpcyByZXBvXHJcbiAqIEBwYXJhbSByZXBvSW5mbyAtIFJlcG9JbmZvIG9iamVjdFxyXG4gKiBAcGFyYW0gdHlwZSAtIG9mIGNvbm5lY3Rpb25cclxuICogQHBhcmFtIHBhcmFtcyAtIGxpc3RcclxuICogQHJldHVybnMgVGhlIFVSTCBmb3IgdGhpcyByZXBvXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIHR5cGUsIHBhcmFtcykge1xyXG4gICAgYXNzZXJ0KHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJywgJ3R5cGVvZiB0eXBlIG11c3QgPT0gc3RyaW5nJyk7XHJcbiAgICBhc3NlcnQodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcsICd0eXBlb2YgcGFyYW1zIG11c3QgPT0gb2JqZWN0Jyk7XHJcbiAgICBsZXQgY29ublVSTDtcclxuICAgIGlmICh0eXBlID09PSBXRUJTT0NLRVQpIHtcclxuICAgICAgICBjb25uVVJMID1cclxuICAgICAgICAgICAgKHJlcG9JbmZvLnNlY3VyZSA/ICd3c3M6Ly8nIDogJ3dzOi8vJykgKyByZXBvSW5mby5pbnRlcm5hbEhvc3QgKyAnLy53cz8nO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gTE9OR19QT0xMSU5HKSB7XHJcbiAgICAgICAgY29ublVSTCA9XHJcbiAgICAgICAgICAgIChyZXBvSW5mby5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArXHJcbiAgICAgICAgICAgICAgICByZXBvSW5mby5pbnRlcm5hbEhvc3QgK1xyXG4gICAgICAgICAgICAgICAgJy8ubHA/JztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb25uZWN0aW9uIHR5cGU6ICcgKyB0eXBlKTtcclxuICAgIH1cclxuICAgIGlmIChyZXBvSW5mb05lZWRzUXVlcnlQYXJhbShyZXBvSW5mbykpIHtcclxuICAgICAgICBwYXJhbXNbJ25zJ10gPSByZXBvSW5mby5uYW1lc3BhY2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBwYWlycyA9IFtdO1xyXG4gICAgZWFjaChwYXJhbXMsIChrZXksIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgcGFpcnMucHVzaChrZXkgKyAnPScgKyB2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb25uVVJMICsgcGFpcnMuam9pbignJicpO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBUcmFja3MgYSBjb2xsZWN0aW9uIG9mIHN0YXRzLlxyXG4gKi9cclxuY2xhc3MgU3RhdHNDb2xsZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY291bnRlcnNfID0ge307XHJcbiAgICB9XHJcbiAgICBpbmNyZW1lbnRDb3VudGVyKG5hbWUsIGFtb3VudCA9IDEpIHtcclxuICAgICAgICBpZiAoIWNvbnRhaW5zKHRoaXMuY291bnRlcnNfLCBuYW1lKSkge1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzX1tuYW1lXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY291bnRlcnNfW25hbWVdICs9IGFtb3VudDtcclxuICAgIH1cclxuICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gZGVlcENvcHkodGhpcy5jb3VudGVyc18pO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IGNvbGxlY3Rpb25zID0ge307XHJcbmNvbnN0IHJlcG9ydGVycyA9IHt9O1xyXG5mdW5jdGlvbiBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG9JbmZvKSB7XHJcbiAgICBjb25zdCBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcclxuICAgIGlmICghY29sbGVjdGlvbnNbaGFzaFN0cmluZ10pIHtcclxuICAgICAgICBjb2xsZWN0aW9uc1toYXNoU3RyaW5nXSA9IG5ldyBTdGF0c0NvbGxlY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb2xsZWN0aW9uc1toYXNoU3RyaW5nXTtcclxufVxyXG5mdW5jdGlvbiBzdGF0c01hbmFnZXJHZXRPckNyZWF0ZVJlcG9ydGVyKHJlcG9JbmZvLCBjcmVhdG9yRnVuY3Rpb24pIHtcclxuICAgIGNvbnN0IGhhc2hTdHJpbmcgPSByZXBvSW5mby50b1N0cmluZygpO1xyXG4gICAgaWYgKCFyZXBvcnRlcnNbaGFzaFN0cmluZ10pIHtcclxuICAgICAgICByZXBvcnRlcnNbaGFzaFN0cmluZ10gPSBjcmVhdG9yRnVuY3Rpb24oKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXBvcnRlcnNbaGFzaFN0cmluZ107XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgZW5zdXJlcyB0aGUgcGFja2V0cyBmcm9tIHRoZSBzZXJ2ZXIgYXJyaXZlIGluIG9yZGVyXHJcbiAqIFRoaXMgY2xhc3MgdGFrZXMgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgYW5kIGVuc3VyZXMgaXQgZ2V0cyBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tzIGluIG9yZGVyLlxyXG4gKi9cclxuY2xhc3MgUGFja2V0UmVjZWl2ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlX1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihvbk1lc3NhZ2VfKSB7XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfID0gb25NZXNzYWdlXztcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5jbG9zZUFmdGVyUmVzcG9uc2UgPSAtMTtcclxuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgY2xvc2VBZnRlcihyZXNwb25zZU51bSwgY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IHJlc3BvbnNlTnVtO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGlmICh0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA8IHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlciBjb21lcyB3aXRoIGEgcmVzcG9uc2UgbnVtYmVyLCBhbmQgYW4gYXJyYXkgb2YgZGF0YS4gVGhlIHJlc3BvbnNlTnVtYmVyXHJcbiAgICAgKiBhbGxvd3MgdXMgdG8gZW5zdXJlIHRoYXQgd2UgcHJvY2VzcyB0aGVtIGluIHRoZSByaWdodCBvcmRlciwgc2luY2Ugd2UgY2FuJ3QgYmUgZ3VhcmFudGVlZCB0aGF0IGFsbFxyXG4gICAgICogYnJvd3NlcnMgd2lsbCByZXNwb25kIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSByZXF1ZXN0cyB3ZSBzZW50XHJcbiAgICAgKi9cclxuICAgIGhhbmRsZVJlc3BvbnNlKHJlcXVlc3ROdW0sIGRhdGEpIHtcclxuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXNbcmVxdWVzdE51bV0gPSBkYXRhO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvUHJvY2VzcyA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV07XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXNwb25zZXNbdGhpcy5jdXJyZW50UmVzcG9uc2VOdW1dO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUHJvY2Vzcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvUHJvY2Vzc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VfKHRvUHJvY2Vzc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlc3BvbnNlTnVtID09PSB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNwb25zZU51bSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vLyBVUkwgcXVlcnkgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggbG9uZ3BvbGxpbmdcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0gPSAnc3RhcnQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9DTE9TRV9DT01NQU5EID0gJ2Nsb3NlJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ09NTUFORF9DQl9OQU1FID0gJ3BMUENvbW1hbmQnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX0NCX05BTUUgPSAncFJUTFBDQic7XHJcbmNvbnN0IEZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNID0gJ2lkJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU0gPSAncHcnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU0gPSAnc2VyJztcclxuY29uc3QgRklSRUJBU0VfTE9OR1BPTExfQ0FMTEJBQ0tfSURfUEFSQU0gPSAnY2InO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UX05VTV9QQVJBTSA9ICdzZWcnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgPSAndHMnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9EQVRBX1BBUkFNID0gJ2QnO1xyXG5jb25zdCBGSVJFQkFTRV9MT05HUE9MTF9ESVNDT05OX0ZSQU1FX1JFUVVFU1RfUEFSQU0gPSAnZGZyYW1lJztcclxuLy9EYXRhIHNpemUgY29uc3RhbnRzLlxyXG4vL1RPRE86IFBlcmY6IHRoZSBtYXhpbXVtIGxlbmd0aCBhY3R1YWxseSBkaWZmZXJzIGZyb20gYnJvd3NlciB0byBicm93c2VyLlxyXG4vLyBXZSBzaG91bGQgY2hlY2sgd2hhdCBicm93c2VyIHdlJ3JlIG9uIGFuZCBzZXQgYWNjb3JkaW5nbHkuXHJcbmNvbnN0IE1BWF9VUkxfREFUQV9TSVpFID0gMTg3MDtcclxuY29uc3QgU0VHX0hFQURFUl9TSVpFID0gMzA7IC8vaWU6ICZzZWc9ODI5OTIzNCZ0cz05ODIzODkxMjMmZD1cclxuY29uc3QgTUFYX1BBWUxPQURfU0laRSA9IE1BWF9VUkxfREFUQV9TSVpFIC0gU0VHX0hFQURFUl9TSVpFO1xyXG4vKipcclxuICogS2VlcGFsaXZlIHBlcmlvZFxyXG4gKiBzZW5kIGEgZnJlc2ggcmVxdWVzdCBhdCBtaW5pbXVtIGV2ZXJ5IDI1IHNlY29uZHMuIE9wZXJhIGhhcyBhIG1heGltdW0gcmVxdWVzdFxyXG4gKiBsZW5ndGggb2YgMzAgc2Vjb25kcyB0aGF0IHdlIGNhbid0IGV4Y2VlZC5cclxuICovXHJcbmNvbnN0IEtFRVBBTElWRV9SRVFVRVNUX0lOVEVSVkFMID0gMjUwMDA7XHJcbi8qKlxyXG4gKiBIb3cgbG9uZyB0byB3YWl0IGJlZm9yZSBhYm9ydGluZyBhIGxvbmctcG9sbGluZyBjb25uZWN0aW9uIGF0dGVtcHQuXHJcbiAqL1xyXG5jb25zdCBMUF9DT05ORUNUX1RJTUVPVVQgPSAzMDAwMDtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBhIHNpbmdsZSBsb25nLXBvbGxpbmcgY29ubmVjdGlvbi5cclxuICovXHJcbmNsYXNzIEJyb3dzZXJQb2xsQ29ubmVjdGlvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb25uSWQgQW4gaWRlbnRpZmllciBmb3IgdGhpcyBjb25uZWN0aW9uLCB1c2VkIGZvciBsb2dnaW5nXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXHJcbiAgICAgKiBAcGFyYW0gYXBwbGljYXRpb25JZCBUaGUgRmlyZWJhc2UgQXBwIElEIGZvciB0aGlzIHByb2plY3QuXHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbiBUaGUgQXBwQ2hlY2sgdG9rZW4gZm9yIHRoaXMgY2xpZW50LlxyXG4gICAgICogQHBhcmFtIGF1dGhUb2tlbiBUaGUgQXV0aFRva2VuIHRvIHVzZSBmb3IgdGhpcyBjb25uZWN0aW9uLlxyXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uaWQgaWYgd2UgYXJlXHJcbiAgICAgKiByZWNvbm5lY3RpbmcgZm9yIGFuIGV4aXN0aW5nIHRyYW5zcG9ydCBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZSBQZXJzaXN0ZW50Q29ubmVjdGlvbiBoYXNcclxuICAgICAqIGFscmVhZHkgY3JlYXRlZCBhIGNvbm5lY3Rpb24gcHJldmlvdXNseVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25uSWQsIHJlcG9JbmZvLCBhcHBsaWNhdGlvbklkLCBhcHBDaGVja1Rva2VuLCBhdXRoVG9rZW4sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuY29ubklkID0gY29ubklkO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm8gPSByZXBvSW5mbztcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbiA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdXRoVG9rZW47XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQgPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5sYXN0U2Vzc2lvbklkID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB0aGlzLmJ5dGVzU2VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcclxuICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcihjb25uSWQpO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XHJcbiAgICAgICAgdGhpcy51cmxGbiA9IChwYXJhbXMpID0+IHtcclxuICAgICAgICAgICAgLy8gQWx3YXlzIGFkZCB0aGUgdG9rZW4gaWYgd2UgaGF2ZSBvbmUuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtc1tBUFBfQ0hFQ0tfVE9LRU5fUEFSQU1dID0gdGhpcy5hcHBDaGVja1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXBvSW5mb0Nvbm5lY3Rpb25VUkwocmVwb0luZm8sIExPTkdfUE9MTElORywgcGFyYW1zKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cclxuICAgICAqL1xyXG4gICAgb3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgIHRoaXMuY3VyU2VnbWVudE51bSA9IDA7XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyID0gbmV3IFBhY2tldFJlY2VpdmVyKG9uTWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5pc0Nsb3NlZF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byBjb25uZWN0LicpO1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2xlYXIgdGhlIGhvc3QgY2FjaGVcclxuICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihMUF9DT05ORUNUX1RJTUVPVVQpKTtcclxuICAgICAgICAvLyBFbnN1cmUgd2UgZGVsYXkgdGhlIGNyZWF0aW9uIG9mIHRoZSBpZnJhbWUgdW50aWwgdGhlIERPTSBpcyBsb2FkZWQuXHJcbiAgICAgICAgZXhlY3V0ZVdoZW5ET01SZWFkeSgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vU2V0IHVwIGEgY2FsbGJhY2sgdGhhdCBnZXRzIHRyaWdnZXJlZCBvbmNlIGEgY29ubmVjdGlvbiBpcyBzZXQgdXAuXHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyID0gbmV3IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyKCguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbY29tbWFuZCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNF0gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIHdlIGNsb3NlZCB0aGUgY29ubmVjdGlvbi5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCA9PT0gRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gYXJnMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhc3N3b3JkID0gYXJnMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IEZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjbGVhciB0aGUgaG9zdCBjYWNoZS4gV2UgZ290IGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBrbm93IGl0J3MgcmVhY2hhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlbid0IGV4cGVjdGluZyBhbnkgbW9yZSBkYXRhIChvdGhlciB0aGFuIHdoYXQgdGhlIHNlcnZlcidzIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2Ygc2VuZGluZyB1c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIG91ciBhbHJlYWR5IG9wZW4gcG9sbHMpLCBzbyBkb24ndCBzZW5kIGFueSBtb3JlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJnMSBpbiB0aGlzIGNhc2UgaXMgdGhlIGxhc3QgcmVzcG9uc2UgbnVtYmVyIHNlbnQgYnkgdGhlIHNlcnZlci4gV2Ugc2hvdWxkIHRyeSB0byByZWNlaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCBvZiB0aGUgcmVzcG9uc2VzIHVwIHRvIHRoaXMgb25lIGJlZm9yZSBjbG9zaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyLmNsb3NlQWZ0ZXIoYXJnMSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGNvbW1hbmQgcmVjZWl2ZWQ6ICcgKyBjb21tYW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtwTiwgZGF0YV0gPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlQYWNrZXRPcmRlcmVyLmhhbmRsZVJlc3BvbnNlKHBOLCBkYXRhKTtcclxuICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlZF8oKTtcclxuICAgICAgICAgICAgfSwgdGhpcy51cmxGbik7XHJcbiAgICAgICAgICAgIC8vU2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0IHRvIGNvbm5lY3QuIFRoZSBzZXJpYWwgbnVtYmVyIGlzIHNpbXBseSB0byBrZWVwIHRoZSBicm93c2VyIGZyb20gcHVsbGluZyBwcmV2aW91cyByZXN1bHRzXHJcbiAgICAgICAgICAgIC8vZnJvbSBjYWNoZS5cclxuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTV0gPSAndCc7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2NyaXB0VGFnSG9sZGVyLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0NBTExCQUNLX0lEX1BBUkFNXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tWRVJTSU9OX1BBUkFNXSA9IFBST1RPQ09MX1ZFUlNJT047XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydFNlc3Npb25JZCkge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW1RSQU5TUE9SVF9TRVNTSU9OX1BBUkFNXSA9IHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gdGhpcy5sYXN0U2Vzc2lvbklkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tBUFBMSUNBVElPTl9JRF9QQVJBTV0gPSB0aGlzLmFwcGxpY2F0aW9uSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwQ2hlY2tUb2tlbikge1xyXG4gICAgICAgICAgICAgICAgdXJsUGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSB0aGlzLmFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhvc3RuYW1lICYmXHJcbiAgICAgICAgICAgICAgICBGT1JHRV9ET01BSU5fUkUudGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tSRUZFUkVSX1BBUkFNXSA9IEZPUkdFX1JFRjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0VVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3RpbmcgdmlhIGxvbmctcG9sbCB0byAnICsgY29ubmVjdFVSTCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmFkZFRhZyhjb25uZWN0VVJMLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKiBkbyBub3RoaW5nICovXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHRoaXMgd2hlbiBhIGhhbmRzaGFrZSBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSBhbmQgd2Ugd2FudCB0byBjb25zaWRlciB0aGUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZFxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zdGFydExvbmdQb2xsKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xyXG4gICAgICAgIHRoaXMuYWRkRGlzY29ubmVjdFBpbmdGcmFtZSh0aGlzLmlkLCB0aGlzLnBhc3N3b3JkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRm9yY2VzIGxvbmcgcG9sbGluZyB0byBiZSBjb25zaWRlcmVkIGFzIGEgcG90ZW50aWFsIHRyYW5zcG9ydFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZm9yY2VBbGxvdygpIHtcclxuICAgICAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3JjZXMgbG9uZ3BvbGxpbmcgdG8gbm90IGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmb3JjZURpc2FsbG93KCkge1xyXG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBTdGF0aWMgbWV0aG9kLCB1c2Ugc3RyaW5nIGxpdGVyYWwgc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGluIGEgZ2VuZXJpYyB3YXlcclxuICAgIHN0YXRpYyBpc0F2YWlsYWJsZSgpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvd18pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBJbiBSZWFjdC1OYXRpdmUgdGhlcmUncyBub3JtYWxseSBubyAnZG9jdW1lbnQnLCBidXQgaWYgeW91IGRlYnVnIGEgUmVhY3QtTmF0aXZlIGFwcCBpblxyXG4gICAgICAgICAgICAvLyB0aGUgQ2hyb21lIGRlYnVnZ2VyLCAnZG9jdW1lbnQnIGlzIGRlZmluZWQsIGJ1dCBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzIG51bGwgKDIwMTUvMDYvMDgpLlxyXG4gICAgICAgICAgICByZXR1cm4gKCFCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18gJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCgpICYmXHJcbiAgICAgICAgICAgICAgICAhaXNXaW5kb3dzU3RvcmVBcHAoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOby1vcCBmb3IgcG9sbGluZ1xyXG4gICAgICovXHJcbiAgICBtYXJrQ29ubmVjdGlvbkhlYWx0aHkoKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgcG9sbGluZyBhbmQgY2xlYW5zIHVwIHRoZSBpZnJhbWVcclxuICAgICAqL1xyXG4gICAgc2h1dGRvd25fKCkge1xyXG4gICAgICAgIHRoaXMuaXNDbG9zZWRfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5zY3JpcHRUYWdIb2xkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIuY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3JlbW92ZSB0aGUgZGlzY29ubmVjdCBmcmFtZSwgd2hpY2ggd2lsbCB0cmlnZ2VyIGFuIFhIUiBjYWxsIHRvIHRoZSBzZXJ2ZXIgdG8gdGVsbCBpdCB3ZSdyZSBsZWF2aW5nLlxyXG4gICAgICAgIGlmICh0aGlzLm15RGlzY29ubkZyYW1lKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5teURpc2Nvbm5GcmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gdGhpcyB0cmFuc3BvcnQgaXMgY2xvc2VkXHJcbiAgICAgKi9cclxuICAgIG9uQ2xvc2VkXygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTG9uZ3BvbGwgaXMgY2xvc2luZyBpdHNlbGYnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKHRoaXMuZXZlckNvbm5lY3RlZF8pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuIFJlYWxUaW1lIGhhcyByZXF1ZXN0ZWQgd2Ugc2h1dCBkb3duLiBLaWxsIG91ciBjb25uZWN0aW9uIGFuZCB0ZWxsIHRoZSBzZXJ2ZXJcclxuICAgICAqIHRoYXQgd2UndmUgbGVmdC5cclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0xvbmdwb2xsIGlzIGJlaW5nIGNsb3NlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgdGhlIEpTT04gb2JqZWN0IGRvd24gdG8gdGhlIHNlcnZlci4gSXQgd2lsbCBuZWVkIHRvIGJlIHN0cmluZ2lmaWVkLCBiYXNlNjQgZW5jb2RlZCwgYW5kIHRoZW5cclxuICAgICAqIGJyb2tlbiBpbnRvIGNodW5rcyAoc2luY2UgVVJMcyBoYXZlIGEgc21hbGwgbWF4aW11bSBsZW5ndGgpLlxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgSlNPTiBkYXRhIHRvIHRyYW5zbWl0LlxyXG4gICAgICovXHJcbiAgICBzZW5kKGRhdGEpIHtcclxuICAgICAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XHJcbiAgICAgICAgLy9maXJzdCwgbGV0cyBnZXQgdGhlIGJhc2U2NC1lbmNvZGVkIGRhdGFcclxuICAgICAgICBjb25zdCBiYXNlNjRkYXRhID0gYmFzZTY0RW5jb2RlKGRhdGFTdHIpO1xyXG4gICAgICAgIC8vV2UgY2FuIG9ubHkgZml0IGEgY2VydGFpbiBhbW91bnQgaW4gZWFjaCBVUkwsIHNvIHdlIG5lZWQgdG8gc3BsaXQgdGhpcyByZXF1ZXN0XHJcbiAgICAgICAgLy91cCBpbnRvIG11bHRpcGxlIHBpZWNlcyBpZiBpdCBkb2Vzbid0IGZpdCBpbiBvbmUgcmVxdWVzdC5cclxuICAgICAgICBjb25zdCBkYXRhU2VncyA9IHNwbGl0U3RyaW5nQnlTaXplKGJhc2U2NGRhdGEsIE1BWF9QQVlMT0FEX1NJWkUpO1xyXG4gICAgICAgIC8vRW5xdWV1ZSBlYWNoIHNlZ21lbnQgZm9yIHRyYW5zbWlzc2lvbi4gV2UgYXNzaWduIGVhY2ggY2h1bmsgYSBzZXF1ZW50aWFsIElEIGFuZCBhIHRvdGFsIG51bWJlclxyXG4gICAgICAgIC8vb2Ygc2VnbWVudHMgc28gdGhhdCB3ZSBjYW4gcmVhc3NlbWJsZSB0aGUgcGFja2V0IG9uIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5lbnF1ZXVlU2VnbWVudCh0aGlzLmN1clNlZ21lbnROdW0sIGRhdGFTZWdzLmxlbmd0aCwgZGF0YVNlZ3NbaV0pO1xyXG4gICAgICAgICAgICB0aGlzLmN1clNlZ21lbnROdW0rKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgaG93IHdlIG5vdGlmeSB0aGUgc2VydmVyIHRoYXQgd2UncmUgbGVhdmluZy5cclxuICAgICAqIFdlIGFyZW4ndCBhYmxlIHRvIHNlbmQgcmVxdWVzdHMgd2l0aCBESFRNTCBvbiBhIHdpbmRvdyBjbG9zZSBldmVudCwgYnV0IHdlIGNhblxyXG4gICAgICogdHJpZ2dlciBYSFIgcmVxdWVzdHMgaW4gc29tZSBicm93c2VycyAoZXZlcnl0aGluZyBidXQgT3BlcmEgYmFzaWNhbGx5KS5cclxuICAgICAqL1xyXG4gICAgYWRkRGlzY29ubmVjdFBpbmdGcmFtZShpZCwgcHcpIHtcclxuICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTV0gPSAndCc7XHJcbiAgICAgICAgdXJsUGFyYW1zW0ZJUkVCQVNFX0xPTkdQT0xMX0lEX1BBUkFNXSA9IGlkO1xyXG4gICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSBwdztcclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnNyYyA9IHRoaXMudXJsRm4odXJsUGFyYW1zKTtcclxuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm15RGlzY29ubkZyYW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byB0cmFjayB0aGUgYnl0ZXMgcmVjZWl2ZWQgYnkgdGhpcyBjbGllbnRcclxuICAgICAqL1xyXG4gICAgaW5jcmVtZW50SW5jb21pbmdCeXRlc18oYXJncykge1xyXG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYW4gYW5ub3lpbmcgcGVyZiBoaXQganVzdCB0byB0cmFjayB0aGUgbnVtYmVyIG9mIGluY29taW5nIGJ5dGVzLiAgTWF5YmUgaXQgc2hvdWxkIGJlIG9wdC1pbi5cclxuICAgICAgICBjb25zdCBieXRlc1JlY2VpdmVkID0gc3RyaW5naWZ5KGFyZ3MpLmxlbmd0aDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gYnl0ZXNSZWNlaXZlZDtcclxuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19yZWNlaXZlZCcsIGJ5dGVzUmVjZWl2ZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBpZnJhbWUgdGhhdCBpcyB1c2VkIGFzIGEgbG9uZy1wb2xsaW5nIHNjcmlwdCBob2xkZXIuXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbmNsYXNzIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbW1hbmRDQiAtIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBjb250cm9sIGNvbW1hbmRzIGFyZSByZWNldmllZCBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlQ0IgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gcmVzcG9uc2VzIGFycml2ZSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0IC0gVGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgdGFnIGhvbGRlciBpcyBjbG9zZWRcclxuICAgICAqIEBwYXJhbSB1cmxGbiAtIEEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyB0aGUgVVJMIG9mIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRDQiwgb25NZXNzYWdlQ0IsIG9uRGlzY29ubmVjdCwgdXJsRm4pIHtcclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG9uRGlzY29ubmVjdDtcclxuICAgICAgICB0aGlzLnVybEZuID0gdXJsRm47XHJcbiAgICAgICAgLy9XZSBtYWludGFpbiBhIGNvdW50IG9mIGFsbCBvZiB0aGUgb3V0c3RhbmRpbmcgcmVxdWVzdHMsIGJlY2F1c2UgaWYgd2UgaGF2ZSB0b28gbWFueSBhY3RpdmUgYXQgb25jZSBpdCBjYW4gY2F1c2VcclxuICAgICAgICAvL3Byb2JsZW1zIGluIHNvbWUgYnJvd3NlcnMuXHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1JlcXVlc3RzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIC8vQSBxdWV1ZSBvZiB0aGUgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cclxuICAgICAgICB0aGlzLnBlbmRpbmdTZWdzID0gW107XHJcbiAgICAgICAgLy9BIHNlcmlhbCBudW1iZXIuIFdlIHVzZSB0aGlzIGZvciB0d28gdGhpbmdzOlxyXG4gICAgICAgIC8vIDEpIEEgd2F5IHRvIGVuc3VyZSB0aGUgYnJvd3NlciBkb2Vzbid0IGNhY2hlIHJlc3BvbnNlcyB0byBwb2xsc1xyXG4gICAgICAgIC8vIDIpIEEgd2F5IHRvIG1ha2UgdGhlIHNlcnZlciBhd2FyZSB3aGVuIGxvbmctcG9sbHMgYXJyaXZlIGluIGEgZGlmZmVyZW50IG9yZGVyIHRoYW4gd2Ugc3RhcnRlZCB0aGVtLiBUaGVcclxuICAgICAgICAvLyAgICBzZXJ2ZXIgbmVlZHMgdG8gcmVsZWFzZSBib3RoIHBvbGxzIGluIHRoaXMgY2FzZSBvciBpdCB3aWxsIGNhdXNlIHByb2JsZW1zIGluIE9wZXJhIHNpbmNlIE9wZXJhIGNhbiBvbmx5IGV4ZWN1dGVcclxuICAgICAgICAvLyAgICBKU09OUCBjb2RlIGluIHRoZSBvcmRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIGlmcmFtZS5cclxuICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApO1xyXG4gICAgICAgIC8vIFRoaXMgZ2V0cyBzZXQgdG8gZmFsc2Ugd2hlbiB3ZSdyZSBcImNsb3NpbmcgZG93blwiIHRoZSBjb25uZWN0aW9uIChlLmcuIHdlJ3JlIHN3aXRjaGluZyB0cmFuc3BvcnRzIGJ1dCB0aGVyZSdzIHN0aWxsXHJcbiAgICAgICAgLy8gaW5jb21pbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSB3YWl0aW5nIGZvcikuXHJcbiAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSB0cnVlO1xyXG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgLy9FYWNoIHNjcmlwdCBob2xkZXIgcmVnaXN0ZXJzIGEgY291cGxlIG9mIHVuaXF1ZWx5IG5hbWVkIGNhbGxiYWNrcyB3aXRoIHRoZSB3aW5kb3cuIFRoZXNlIGFyZSBjYWxsZWQgZnJvbSB0aGVcclxuICAgICAgICAgICAgLy9pZnJhbWVzIHdoZXJlIHdlIHB1dCB0aGUgbG9uZy1wb2xsaW5nIHNjcmlwdCB0YWdzLiBXZSBoYXZlIHR3byBjYWxsYmFja3M6XHJcbiAgICAgICAgICAgIC8vICAgMSkgQ29tbWFuZCBDYWxsYmFjayAtIFRyaWdnZXJlZCBmb3IgY29udHJvbCBpc3N1ZXMsIGxpa2Ugc3RhcnRpbmcgYSBjb25uZWN0aW9uLlxyXG4gICAgICAgICAgICAvLyAgIDIpIE1lc3NhZ2UgQ2FsbGJhY2sgLSBUcmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBhcnJpdmVzLlxyXG4gICAgICAgICAgICB0aGlzLnVuaXF1ZUNhbGxiYWNrSWRlbnRpZmllciA9IExVSURHZW5lcmF0b3IoKTtcclxuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0NPTU1BTkRfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9IGNvbW1hbmRDQjtcclxuICAgICAgICAgICAgd2luZG93W0ZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9XHJcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2VDQjtcclxuICAgICAgICAgICAgLy9DcmVhdGUgYW4gaWZyYW1lIGZvciB1cyB0byBhZGQgc2NyaXB0IHRhZ3MgdG8uXHJcbiAgICAgICAgICAgIHRoaXMubXlJRnJhbWUgPSBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5jcmVhdGVJRnJhbWVfKCk7XHJcbiAgICAgICAgICAgIC8vIFNldCB0aGUgaWZyYW1lJ3MgY29udGVudHMuXHJcbiAgICAgICAgICAgIGxldCBzY3JpcHQgPSAnJztcclxuICAgICAgICAgICAgLy8gaWYgd2Ugc2V0IGEgamF2YXNjcmlwdCB1cmwsIGl0J3MgSUUgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZSBkb2N1bWVudCBkb21haW4uIFRoZSBqYXZhc2NyaXB0IHVybCBpcyBzdWZmaWNpZW50XHJcbiAgICAgICAgICAgIC8vIGZvciBpZTksIGJ1dCBpZTggbmVlZHMgdG8gZG8gaXQgYWdhaW4gaW4gdGhlIGRvY3VtZW50IGl0c2VsZi5cclxuICAgICAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUuc3JjICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLnNyYy5zdWJzdHIoMCwgJ2phdmFzY3JpcHQ6Jy5sZW5ndGgpID09PSAnamF2YXNjcmlwdDonKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gJzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJyArIGN1cnJlbnREb21haW4gKyAnXCI7PC9zY3JpcHQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpZnJhbWVDb250ZW50cyA9ICc8aHRtbD48Ym9keT4nICsgc2NyaXB0ICsgJzwvYm9keT48L2h0bWw+JztcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLm9wZW4oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLndyaXRlKGlmcmFtZUNvbnRlbnRzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGxvZygnZnJhbWUgd3JpdGluZyBleGNlcHRpb24nKTtcclxuICAgICAgICAgICAgICAgIGlmIChlLnN0YWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKGUuc3RhY2spO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbG9nKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRDQiA9IGNvbW1hbmRDQjtcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2VDQiA9IG9uTWVzc2FnZUNCO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBicm93c2VyIGhhcyBpdHMgb3duIGZ1bm55IHdheSB0byBoYW5kbGUgaWZyYW1lcy4gSGVyZSB3ZSBtdXNoIHRoZW0gYWxsIHRvZ2V0aGVyIGludG8gb25lIG9iamVjdCB0aGF0IEkgY2FuXHJcbiAgICAgKiBhY3R1YWxseSB1c2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVJRnJhbWVfKCkge1xyXG4gICAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xyXG4gICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIGluaXRpYWxpemUgdGhlIGRvY3VtZW50IGluc2lkZSB0aGUgaWZyYW1lXHJcbiAgICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgZG9jdW1lbnQuZG9tYWluIGhhcyBiZWVuIG1vZGlmaWVkIGluIElFLCB0aGlzIHdpbGwgdGhyb3cgYW4gZXJyb3IsIGFuZCB3ZSBuZWVkIHRvIHNldCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGRvbWFpbiBvZiB0aGUgaWZyYW1lJ3MgZG9jdW1lbnQgbWFudWFsbHkuIFdlIGNhbiBkbyB0aGlzIHZpYSBhIGphdmFzY3JpcHQ6IHVybCBhcyB0aGUgc3JjIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgLy8gQWxzbyBub3RlIHRoYXQgd2UgbXVzdCBkbyB0aGlzICphZnRlciogdGhlIGlmcmFtZSBoYXMgYmVlbiBhcHBlbmRlZCB0byB0aGUgcGFnZS4gT3RoZXJ3aXNlIGl0IGRvZXNuJ3Qgd29yay5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcclxuICAgICAgICAgICAgICAgIGlmICghYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwb2xvZ2llcyBmb3IgdGhlIGxvZy1zcGFtLCBJIG5lZWQgdG8gZG8gc29tZXRoaW5nIHRvIGtlZXAgY2xvc3VyZSBmcm9tIG9wdGltaXppbmcgb3V0IHRoZSBhc3NpZ25tZW50IGFib3ZlLlxyXG4gICAgICAgICAgICAgICAgICAgIGxvZygnTm8gSUUgZG9tYWluIHNldHRpbmcgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xyXG4gICAgICAgICAgICAgICAgaWZyYW1lLnNyYyA9XHJcbiAgICAgICAgICAgICAgICAgICAgXCJqYXZhc2NyaXB0OnZvaWQoKGZ1bmN0aW9uKCl7ZG9jdW1lbnQub3BlbigpO2RvY3VtZW50LmRvbWFpbj0nXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic7ZG9jdW1lbnQuY2xvc2UoKTt9KSgpKVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBMb25nUG9sbENvbm5lY3Rpb24gYXR0ZW1wdHMgdG8gZGVsYXkgaW5pdGlhbGl6YXRpb24gdW50aWwgdGhlIGRvY3VtZW50IGlzIHJlYWR5LCBzbyBob3BlZnVsbHkgdGhpc1xyXG4gICAgICAgICAgICAvLyBuZXZlciBnZXRzIGhpdC5cclxuICAgICAgICAgICAgdGhyb3cgJ0RvY3VtZW50IGJvZHkgaGFzIG5vdCBpbml0aWFsaXplZC4gV2FpdCB0byBpbml0aWFsaXplIEZpcmViYXNlIHVudGlsIGFmdGVyIHRoZSBkb2N1bWVudCBpcyByZWFkeS4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZXQgdGhlIGRvY3VtZW50IG9mIHRoZSBpZnJhbWUgaW4gYSBicm93c2VyLXNwZWNpZmljIHdheS5cclxuICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCkge1xyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudDsgLy8gRmlyZWZveCwgT3BlcmEsIFNhZmFyaVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpZnJhbWUuY29udGVudFdpbmRvdykge1xyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7IC8vIEludGVybmV0IEV4cGxvcmVyXHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlmcmFtZS5kb2N1bWVudCkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICBpZnJhbWUuZG9jID0gaWZyYW1lLmRvY3VtZW50OyAvL290aGVycz9cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlmcmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VsIGFsbCBvdXRzdGFuZGluZyBxdWVyaWVzIGFuZCByZW1vdmUgdGhlIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICAvL01hcmsgdGhpcyBpZnJhbWUgYXMgZGVhZCwgc28gbm8gbmV3IHJlcXVlc3RzIGFyZSBzZW50LlxyXG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5teUlGcmFtZSkge1xyXG4gICAgICAgICAgICAvL1dlIGhhdmUgdG8gYWN0dWFsbHkgcmVtb3ZlIGFsbCBvZiB0aGUgaHRtbCBpbnNpZGUgdGhpcyBpZnJhbWUgYmVmb3JlIHJlbW92aW5nIGl0IGZyb20gdGhlXHJcbiAgICAgICAgICAgIC8vd2luZG93LCBvciBJRSB3aWxsIGNvbnRpbnVlIGxvYWRpbmcgYW5kIGV4ZWN1dGluZyB0aGUgc2NyaXB0IHRhZ3Mgd2UndmUgYWxyZWFkeSBhZGRlZCwgd2hpY2hcclxuICAgICAgICAgICAgLy9jYW4gbGVhZCB0byBzb21lIGVycm9ycyBiZWluZyB0aHJvd24uIFNldHRpbmcgdGV4dENvbnRlbnQgc2VlbXMgdG8gYmUgdGhlIHNhZmVzdCB3YXkgdG8gZG8gdGhpcy5cclxuICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuYm9keS50ZXh0Q29udGVudCA9ICcnO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm15SUZyYW1lICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLm15SUZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFByb3RlY3QgZnJvbSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkuXHJcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gdGhpcy5vbkRpc2Nvbm5lY3Q7XHJcbiAgICAgICAgaWYgKG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG51bGw7XHJcbiAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWN0dWFsbHkgc3RhcnQgdGhlIGxvbmctcG9sbGluZyBzZXNzaW9uIGJ5IGFkZGluZyB0aGUgZmlyc3Qgc2NyaXB0IHRhZyhzKSB0byB0aGUgaWZyYW1lLlxyXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICogQHBhcmFtIHB3IC0gVGhlIHBhc3N3b3JkIGZvciB0aGlzIGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgc3RhcnRMb25nUG9sbChpZCwgcHcpIHtcclxuICAgICAgICB0aGlzLm15SUQgPSBpZDtcclxuICAgICAgICB0aGlzLm15UFcgPSBwdztcclxuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcclxuICAgICAgICAvL3NlbmQgdGhlIGluaXRpYWwgcmVxdWVzdC4gSWYgdGhlcmUgYXJlIHJlcXVlc3RzIHF1ZXVlZCwgbWFrZSBzdXJlIHRoYXQgd2UgdHJhbnNtaXQgYXMgbWFueSBhcyB3ZSBhcmUgY3VycmVudGx5IGFibGUgdG8uXHJcbiAgICAgICAgd2hpbGUgKHRoaXMubmV3UmVxdWVzdF8oKSkgeyB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGFueSB0aW1lIHNvbWVvbmUgbWlnaHQgd2FudCBhIHNjcmlwdCB0YWcgdG8gYmUgYWRkZWQuIEl0IGFkZHMgYSBzY3JpcHQgdGFnIHdoZW4gdGhlcmUgYXJlbid0XHJcbiAgICAgKiB0b28gbWFueSBvdXRzdGFuZGluZyByZXF1ZXN0cyBhbmQgd2UgYXJlIHN0aWxsIGFsaXZlLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZXJlIGFyZSBvdXRzdGFuZGluZyBwYWNrZXQgc2VnbWVudHMgdG8gc2VuZCwgaXQgc2VuZHMgb25lLiBJZiB0aGVyZSBhcmVuJ3QsIGl0IHNlbmRzIGEgbG9uZy1wb2xsIGFueXdheXMgaWZcclxuICAgICAqIG5lZWRlZC5cclxuICAgICAqL1xyXG4gICAgbmV3UmVxdWVzdF8oKSB7XHJcbiAgICAgICAgLy8gV2Uga2VlcCBvbmUgb3V0c3RhbmRpbmcgcmVxdWVzdCBvcGVuIGFsbCB0aGUgdGltZSB0byByZWNlaXZlIGRhdGEsIGJ1dCBpZiB3ZSBuZWVkIHRvIHNlbmQgZGF0YVxyXG4gICAgICAgIC8vIChwZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB0aGVuIHdlIGNyZWF0ZSBhIG5ldyByZXF1ZXN0IHRvIHNlbmQgdGhlIGRhdGEuICBUaGUgc2VydmVyIHdpbGwgYXV0b21hdGljYWxseVxyXG4gICAgICAgIC8vIGNsb3NlIHRoZSBvbGQgcmVxdWVzdC5cclxuICAgICAgICBpZiAodGhpcy5hbGl2ZSAmJlxyXG4gICAgICAgICAgICB0aGlzLnNlbmROZXdQb2xscyAmJlxyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuc2l6ZSA8ICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDAgPyAyIDogMSkpIHtcclxuICAgICAgICAgICAgLy9jb25zdHJ1Y3Qgb3VyIHVybFxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXJpYWwrKztcclxuICAgICAgICAgICAgY29uc3QgdXJsUGFyYW1zID0ge307XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTV0gPSB0aGlzLm15SUQ7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTV0gPSB0aGlzLm15UFc7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tGSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gdGhpcy5jdXJyZW50U2VyaWFsO1xyXG4gICAgICAgICAgICBsZXQgdGhlVVJMID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xyXG4gICAgICAgICAgICAvL05vdyBhZGQgYXMgbXVjaCBkYXRhIGFzIHdlIGNhbi5cclxuICAgICAgICAgICAgbGV0IGN1ckRhdGFTdHJpbmcgPSAnJztcclxuICAgICAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL2ZpcnN0LCBsZXRzIHNlZSBpZiB0aGUgbmV4dCBzZWdtZW50IHdpbGwgZml0LlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFNlZyA9IHRoaXMucGVuZGluZ1NlZ3NbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlZy5kLmxlbmd0aCArXHJcbiAgICAgICAgICAgICAgICAgICAgU0VHX0hFQURFUl9TSVpFICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nLmxlbmd0aCA8PVxyXG4gICAgICAgICAgICAgICAgICAgIE1BWF9VUkxfREFUQV9TSVpFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9ncmVhdCwgdGhlIHNlZ21lbnQgd2lsbCBmaXQuIExldHMgYXBwZW5kIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoZVNlZyA9IHRoaXMucGVuZGluZ1NlZ3Muc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJEYXRhU3RyaW5nID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRGF0YVN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVF9OVU1fUEFSQU0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnNlZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfU0VHTUVOVFNfSU5fUEFDS0VUICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy50cyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRklSRUJBU0VfTE9OR1BPTExfREFUQV9QQVJBTSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcuZDtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGVVUkwgPSB0aGVVUkwgKyBjdXJEYXRhU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLmFkZExvbmdQb2xsVGFnXyh0aGVVUkwsIHRoaXMuY3VycmVudFNlcmlhbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUXVldWUgYSBwYWNrZXQgZm9yIHRyYW5zbWlzc2lvbiB0byB0aGUgc2VydmVyLlxyXG4gICAgICogQHBhcmFtIHNlZ251bSAtIEEgc2VxdWVudGlhbCBpZCBmb3IgdGhpcyBwYWNrZXQgc2VnbWVudCB1c2VkIGZvciByZWFzc2VtYmx5XHJcbiAgICAgKiBAcGFyYW0gdG90YWxzZWdzIC0gVGhlIHRvdGFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGlzIHBhY2tldFxyXG4gICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSBmb3IgdGhpcyBzZWdtZW50LlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlU2VnbWVudChzZWdudW0sIHRvdGFsc2VncywgZGF0YSkge1xyXG4gICAgICAgIC8vYWRkIHRoaXMgdG8gdGhlIHF1ZXVlIG9mIHNlZ21lbnRzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5wZW5kaW5nU2Vncy5wdXNoKHsgc2VnOiBzZWdudW0sIHRzOiB0b3RhbHNlZ3MsIGQ6IGRhdGEgfSk7XHJcbiAgICAgICAgLy9zZW5kIHRoZSBkYXRhIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGlzbid0IGFscmVhZHkgZGF0YSBiZWluZyB0cmFuc21pdHRlZCwgdW5sZXNzXHJcbiAgICAgICAgLy9zdGFydExvbmdQb2xsIGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXHJcbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXdSZXF1ZXN0XygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgc2NyaXB0IHRhZyBmb3IgYSByZWd1bGFyIGxvbmctcG9sbCByZXF1ZXN0LlxyXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgb2YgdGhlIHNjcmlwdCB0YWcuXHJcbiAgICAgKiBAcGFyYW0gc2VyaWFsIC0gVGhlIHNlcmlhbCBudW1iZXIgb2YgdGhlIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIGFkZExvbmdQb2xsVGFnXyh1cmwsIHNlcmlhbCkge1xyXG4gICAgICAgIC8vcmVtZW1iZXIgdGhhdCB3ZSBzZW50IHRoaXMgcmVxdWVzdC5cclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuYWRkKHNlcmlhbCk7XHJcbiAgICAgICAgY29uc3QgZG9OZXdSZXF1ZXN0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuZGVsZXRlKHNlcmlhbCk7XHJcbiAgICAgICAgICAgIHRoaXMubmV3UmVxdWVzdF8oKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIElmIHRoaXMgcmVxdWVzdCBkb2Vzbid0IHJldHVybiBvbiBpdHMgb3duIGFjY29yZCAoYnkgdGhlIHNlcnZlciBzZW5kaW5nIHVzIHNvbWUgZGF0YSksIHdlJ2xsXHJcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IG9uZSBhZnRlciB0aGUgS0VFUEFMSVZFIGludGVydmFsIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMga2VlcCBhIGZyZXNoIHJlcXVlc3Qgb3Blbi5cclxuICAgICAgICBjb25zdCBrZWVwYWxpdmVUaW1lb3V0ID0gc2V0VGltZW91dChkb05ld1JlcXVlc3QsIE1hdGguZmxvb3IoS0VFUEFMSVZFX1JFUVVFU1RfSU5URVJWQUwpKTtcclxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ0IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgY29tcGxldGVkLiAgQ2FuY2VsIHRoZSBrZWVwYWxpdmUuXHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVwYWxpdmVUaW1lb3V0KTtcclxuICAgICAgICAgICAgLy8gVHJpZ2dlciBhIG5ldyByZXF1ZXN0IHNvIHdlIGNhbiBjb250aW51ZSByZWNlaXZpbmcgZGF0YS5cclxuICAgICAgICAgICAgZG9OZXdSZXF1ZXN0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFkZFRhZyh1cmwsIHJlYWR5U3RhdGVDQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBhcmJpdHJhcnkgc2NyaXB0IHRhZyB0byB0aGUgaWZyYW1lLlxyXG4gICAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgZm9yIHRoZSBzY3JpcHQgdGFnIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSBsb2FkQ0IgLSBBIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCBvbmNlIHRoZSBzY3JpcHQgaGFzIGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkVGFnKHVybCwgbG9hZENCKSB7XHJcbiAgICAgICAgaWYgKGlzTm9kZVNkaygpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHRoaXMuZG9Ob2RlTG9uZ1BvbGwodXJsLCBsb2FkQ0IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGFscmVhZHkgY2xvc2VkLCBkb24ndCBhZGQgdGhpcyBwb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNlbmROZXdQb2xscykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NjcmlwdCA9IHRoaXMubXlJRnJhbWUuZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQuc3JjID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IG5ld1NjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnN0YXRlID0gbmV3U2NyaXB0LnJlYWR5U3RhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJzdGF0ZSB8fCByc3RhdGUgPT09ICdsb2FkZWQnIHx8IHJzdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0Lm9ubG9hZCA9IG5ld1NjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTY3JpcHQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuZXdTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ0IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHQub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKCdMb25nLXBvbGwgc2NyaXB0IGZhaWxlZCB0byBsb2FkOiAnICsgdXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kTmV3UG9sbHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuYm9keS5hcHBlbmRDaGlsZChuZXdTY3JpcHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3ZSBzaG91bGQgbWFrZSB0aGlzIGVycm9yIHZpc2libGUgc29tZWhvd1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKDEpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFID0gMTYzODQ7XHJcbmNvbnN0IFdFQlNPQ0tFVF9LRUVQQUxJVkVfSU5URVJWQUwgPSA0NTAwMDtcclxubGV0IFdlYlNvY2tldEltcGwgPSBudWxsO1xyXG5pZiAodHlwZW9mIE1veldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBNb3pXZWJTb2NrZXQ7XHJcbn1cclxuZWxzZSBpZiAodHlwZW9mIFdlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIFdlYlNvY2tldEltcGwgPSBXZWJTb2NrZXQ7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyB3ZWJzb2NrZXQgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja3MuXHJcbiAqL1xyXG5jbGFzcyBXZWJTb2NrZXRDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbm5JZCBpZGVudGlmaWVyIGZvciB0aGlzIHRyYW5zcG9ydFxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIFRoZSBpbmZvIGZvciB0aGUgd2Vic29ja2V0IGVuZHBvaW50LlxyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWQgVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0LlxyXG4gICAgICogQHBhcmFtIGFwcENoZWNrVG9rZW4gVGhlIEFwcCBDaGVjayBUb2tlbiBmb3IgdGhpcyBjbGllbnQuXHJcbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuIFRoZSBBdXRoIFRva2VuIGZvciB0aGlzIGNsaWVudC5cclxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZ1xyXG4gICAgICogdG8gYW4gZXhpc3RpbmcgdHJhbnNwb3J0IHNlc3Npb25cclxuICAgICAqIEBwYXJhbSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXNcclxuICAgICAqIGNvbm5lY3Rpb25cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29ubklkLCByZXBvSW5mbywgYXBwbGljYXRpb25JZCwgYXBwQ2hlY2tUb2tlbiwgYXV0aFRva2VuLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQpIHtcclxuICAgICAgICB0aGlzLmNvbm5JZCA9IGNvbm5JZDtcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbiA9IGFwcENoZWNrVG9rZW47XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW4gPSBhdXRoVG9rZW47XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ID0gMDtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMubG9nXyA9IGxvZ1dyYXBwZXIodGhpcy5jb25uSWQpO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfID0gc3RhdHNNYW5hZ2VyR2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XHJcbiAgICAgICAgdGhpcy5jb25uVVJMID0gV2ViU29ja2V0Q29ubmVjdGlvbi5jb25uZWN0aW9uVVJMXyhyZXBvSW5mbywgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkLCBhcHBDaGVja1Rva2VuLCBhcHBsaWNhdGlvbklkKTtcclxuICAgICAgICB0aGlzLm5vZGVBZG1pbiA9IHJlcG9JbmZvLm5vZGVBZG1pbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvIC0gVGhlIGluZm8gZm9yIHRoZSB3ZWJzb2NrZXQgZW5kcG9pbnQuXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0U2Vzc2lvbklkIC0gT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbklkIGlmIHRoaXMgaXMgY29ubmVjdGluZyB0byBhbiBleGlzdGluZyB0cmFuc3BvcnRcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uXHJcbiAgICAgKiBAcGFyYW0gbGFzdFNlc3Npb25JZCAtIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxyXG4gICAgICogQHJldHVybnMgY29ubmVjdGlvbiB1cmxcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbm5lY3Rpb25VUkxfKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQsIGFwcENoZWNrVG9rZW4sIGFwcGxpY2F0aW9uSWQpIHtcclxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7fTtcclxuICAgICAgICB1cmxQYXJhbXNbVkVSU0lPTl9QQVJBTV0gPSBQUk9UT0NPTF9WRVJTSU9OO1xyXG4gICAgICAgIGlmICghaXNOb2RlU2RrKCkgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICBsb2NhdGlvbi5ob3N0bmFtZSAmJlxyXG4gICAgICAgICAgICBGT1JHRV9ET01BSU5fUkUudGVzdChsb2NhdGlvbi5ob3N0bmFtZSkpIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW1JFRkVSRVJfUEFSQU1dID0gRk9SR0VfUkVGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHJhbnNwb3J0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tUUkFOU1BPUlRfU0VTU0lPTl9QQVJBTV0gPSB0cmFuc3BvcnRTZXNzaW9uSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0U2Vzc2lvbklkKSB7XHJcbiAgICAgICAgICAgIHVybFBhcmFtc1tMQVNUX1NFU1NJT05fUEFSQU1dID0gbGFzdFNlc3Npb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgdXJsUGFyYW1zW0FQUF9DSEVDS19UT0tFTl9QQVJBTV0gPSBhcHBDaGVja1Rva2VuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXBwbGljYXRpb25JZCkge1xyXG4gICAgICAgICAgICB1cmxQYXJhbXNbQVBQTElDQVRJT05fSURfUEFSQU1dID0gYXBwbGljYXRpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcG9JbmZvQ29ubmVjdGlvblVSTChyZXBvSW5mbywgV0VCU09DS0VULCB1cmxQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIC0gQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcclxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cclxuICAgICAqL1xyXG4gICAgb3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCkge1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xyXG4gICAgICAgIHRoaXMub25NZXNzYWdlID0gb25NZXNzYWdlO1xyXG4gICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RpbmcgdG8gJyArIHRoaXMuY29ublVSTCk7XHJcbiAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIEFzc3VtZSBmYWlsdXJlIHVudGlsIHByb3ZlbiBvdGhlcndpc2UuXHJcbiAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScsIHRydWUpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGxldCBvcHRpb25zO1xyXG4gICAgICAgICAgICBpZiAoaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRldmljZSA9IHRoaXMubm9kZUFkbWluID8gJ0FkbWluTm9kZScgOiAnTm9kZSc7XHJcbiAgICAgICAgICAgICAgICAvLyBVQSBGb3JtYXQ6IEZpcmViYXNlLzx3aXJlX3Byb3RvY29sPi88c2RrX3ZlcnNpb24+LzxwbGF0Zm9ybT4vPGRldmljZT5cclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlci1BZ2VudCc6IGBGaXJlYmFzZS8ke1BST1RPQ09MX1ZFUlNJT059LyR7U0RLX1ZFUlNJT059LyR7cHJvY2Vzcy5wbGF0Zm9ybX0vJHtkZXZpY2V9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1gtRmlyZWJhc2UtR01QSUQnOiB0aGlzLmFwcGxpY2F0aW9uSWQgfHwgJydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdXNpbmcgTm9kZSB3aXRoIGFkbWluIGNyZWRzLCBBcHBDaGVjay1yZWxhdGVkIGNoZWNrcyBhcmUgdW5uZWNlc3NhcnkuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugc2VuZCB0aGUgY3JlZGVudGlhbHMgaGVyZSBldmVuIGlmIHRoZXkgYXJlbid0IGFkbWluIGNyZWRlbnRpYWxzLCB3aGljaCBpc1xyXG4gICAgICAgICAgICAgICAgLy8gbm90IGEgcHJvYmxlbS5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGhlYWRlciBpcyBqdXN0IHVzZWQgdG8gYnlwYXNzIGFwcGNoZWNrLCBhbmQgdGhlIHRva2VuIHNob3VsZCBzdGlsbCBiZSBzZW50XHJcbiAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIHRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBvbmNlIGl0IGlzIGVzdGFibGlzaGVkLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5hdXRoVG9rZW59YDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ1gtRmlyZWJhc2UtQXBwQ2hlY2snXSA9IHRoaXMuYXBwQ2hlY2tUb2tlbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFBsdW1iIGFwcHJvcHJpYXRlIGh0dHBfcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgaW50byBmYXllLXdlYnNvY2tldCBpZiBpdCBleGlzdHMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbnYgPSBwcm9jZXNzWydlbnYnXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gdGhpcy5jb25uVVJMLmluZGV4T2YoJ3dzczovLycpID09PSAwXHJcbiAgICAgICAgICAgICAgICAgICAgPyBlbnZbJ0hUVFBTX1BST1hZJ10gfHwgZW52WydodHRwc19wcm94eSddXHJcbiAgICAgICAgICAgICAgICAgICAgOiBlbnZbJ0hUVFBfUFJPWFknXSB8fCBlbnZbJ2h0dHBfcHJveHknXTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm94eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ3Byb3h5J10gPSB7IG9yaWdpbjogcHJveHkgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG5ldyBXZWJTb2NrZXRJbXBsKHRoaXMuY29ublVSTCwgW10sIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0Vycm9yIGluc3RhbnRpYXRpbmcgV2ViU29ja2V0LicpO1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGUubWVzc2FnZSB8fCBlLmRhdGE7XHJcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKGVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXlTb2NrLm9ub3BlbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGVkLicpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZXJDb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9uY2xvc2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3Rpb24gd2FzIGRpc2Nvbm5lY3RlZC4nKTtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VkXygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5teVNvY2sub25tZXNzYWdlID0gbSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdGcmFtZShtKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubXlTb2NrLm9uZXJyb3IgPSBlID0+IHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgZXJyb3IuICBDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZS5tZXNzYWdlIHx8IGUuZGF0YTtcclxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTm8tb3AgZm9yIHdlYnNvY2tldHMsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBjb25maXJtZWQgYXMgb3BlblxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHsgfVxyXG4gICAgc3RhdGljIGZvcmNlRGlzYWxsb3coKSB7XHJcbiAgICAgICAgV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNBdmFpbGFibGUoKSB7XHJcbiAgICAgICAgbGV0IGlzT2xkQW5kcm9pZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEFuZHJvaWRSZWdleCA9IC9BbmRyb2lkIChbMC05XXswLH1cXC5bMC05XXswLH0pLztcclxuICAgICAgICAgICAgY29uc3Qgb2xkQW5kcm9pZE1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChvbGRBbmRyb2lkUmVnZXgpO1xyXG4gICAgICAgICAgICBpZiAob2xkQW5kcm9pZE1hdGNoICYmIG9sZEFuZHJvaWRNYXRjaC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChvbGRBbmRyb2lkTWF0Y2hbMV0pIDwgNC40KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNPbGRBbmRyb2lkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCFpc09sZEFuZHJvaWQgJiZcclxuICAgICAgICAgICAgV2ViU29ja2V0SW1wbCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAhV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93Xyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB3ZSBwcmV2aW91c2x5IGZhaWxlZCB0byBjb25uZWN0IHdpdGggdGhpcyB0cmFuc3BvcnQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBwcmV2aW91c2x5RmFpbGVkKCkge1xyXG4gICAgICAgIC8vIElmIG91ciBwZXJzaXN0ZW50IHN0b3JhZ2UgaXMgYWN0dWFsbHkgb25seSBpbi1tZW1vcnkgc3RvcmFnZSxcclxuICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIGFzc3VtaW5nIHRoYXQgaXQgcHJldmlvdXNseSBmYWlsZWQgdG8gYmUgc2FmZS5cclxuICAgICAgICByZXR1cm4gKFBlcnNpc3RlbnRTdG9yYWdlLmlzSW5NZW1vcnlTdG9yYWdlIHx8XHJcbiAgICAgICAgICAgIFBlcnNpc3RlbnRTdG9yYWdlLmdldCgncHJldmlvdXNfd2Vic29ja2V0X2ZhaWx1cmUnKSA9PT0gdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBtYXJrQ29ubmVjdGlvbkhlYWx0aHkoKSB7XHJcbiAgICAgICAgUGVyc2lzdGVudFN0b3JhZ2UucmVtb3ZlKCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScpO1xyXG4gICAgfVxyXG4gICAgYXBwZW5kRnJhbWVfKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmZyYW1lcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcy5sZW5ndGggPT09IHRoaXMudG90YWxGcmFtZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgZnVsbE1lc3MgPSB0aGlzLmZyYW1lcy5qb2luKCcnKTtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBqc29uTWVzcyA9IGpzb25FdmFsKGZ1bGxNZXNzKTtcclxuICAgICAgICAgICAgLy9oYW5kbGUgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoanNvbk1lc3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZyYW1lQ291bnQgLSBUaGUgbnVtYmVyIG9mIGZyYW1lcyB3ZSBhcmUgZXhwZWN0aW5nIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBoYW5kbGVOZXdGcmFtZUNvdW50XyhmcmFtZUNvdW50KSB7XHJcbiAgICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGZyYW1lQ291bnQ7XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gcGFyc2UgYSBmcmFtZSBjb3VudCBvdXQgb2Ygc29tZSB0ZXh0LiBJZiBpdCBjYW4ndCwgYXNzdW1lcyBhIHZhbHVlIG9mIDFcclxuICAgICAqIEByZXR1cm5zIEFueSByZW1haW5pbmcgZGF0YSB0byBiZSBwcm9jZXNzLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmVcclxuICAgICAqL1xyXG4gICAgZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5mcmFtZXMgPT09IG51bGwsICdXZSBhbHJlYWR5IGhhdmUgYSBmcmFtZSBidWZmZXInKTtcclxuICAgICAgICAvLyBUT0RPOiBUaGUgc2VydmVyIGlzIG9ubHkgc3VwcG9zZWQgdG8gc2VuZCB1cCB0byA5OTk5IGZyYW1lcyAoaS5lLiBsZW5ndGggPD0gNCksIGJ1dCB0aGF0IGlzbid0IGJlaW5nIGVuZm9yY2VkXHJcbiAgICAgICAgLy8gY3VycmVudGx5LiAgU28gYWxsb3dpbmcgbGFyZ2VyIGZyYW1lIGNvdW50cyAobGVuZ3RoIDw9IDYpLiAgU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wL3NlYXJjaC84Njg4NTk4OTk4MzgwLzgyMzc2MDgwNDI1MDhcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gNikge1xyXG4gICAgICAgICAgICBjb25zdCBmcmFtZUNvdW50ID0gTnVtYmVyKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKGZyYW1lQ291bnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU5ld0ZyYW1lQ291bnRfKGZyYW1lQ291bnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVOZXdGcmFtZUNvdW50XygxKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyBhIHdlYnNvY2tldCBmcmFtZSB0aGF0IGhhcyBhcnJpdmVkIGZyb20gdGhlIHNlcnZlci5cclxuICAgICAqIEBwYXJhbSBtZXNzIC0gVGhlIGZyYW1lIGRhdGFcclxuICAgICAqL1xyXG4gICAgaGFuZGxlSW5jb21pbmdGcmFtZShtZXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubXlTb2NrID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gQ2hyb21lIGFwcGFyZW50bHkgZGVsaXZlcnMgaW5jb21pbmcgcGFja2V0cyBldmVuIGFmdGVyIHdlIC5jbG9zZSgpIHRoZSBjb25uZWN0aW9uIHNvbWV0aW1lcy5cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IG1lc3NbJ2RhdGEnXTtcclxuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcignYnl0ZXNfcmVjZWl2ZWQnLCBkYXRhLmxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmZyYW1lcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyB3ZSdyZSBidWZmZXJpbmdcclxuICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0cnkgdG8gcGFyc2Ugb3V0IGEgZnJhbWUgY291bnQsIG90aGVyd2lzZSwgYXNzdW1lIDEgYW5kIHByb2Nlc3MgaXRcclxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGF0YSA9IHRoaXMuZXh0cmFjdEZyYW1lQ291bnRfKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8ocmVtYWluaW5nRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXJcclxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIEpTT04gb2JqZWN0IHRvIHRyYW5zbWl0XHJcbiAgICAgKi9cclxuICAgIHNlbmQoZGF0YSkge1xyXG4gICAgICAgIHRoaXMucmVzZXRLZWVwQWxpdmUoKTtcclxuICAgICAgICBjb25zdCBkYXRhU3RyID0gc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3NlbnQnLCBkYXRhU3RyLmxlbmd0aCk7XHJcbiAgICAgICAgLy9XZSBjYW4gb25seSBmaXQgYSBjZXJ0YWluIGFtb3VudCBpbiBlYWNoIHdlYnNvY2tldCBmcmFtZSwgc28gd2UgbmVlZCB0byBzcGxpdCB0aGlzIHJlcXVlc3RcclxuICAgICAgICAvL3VwIGludG8gbXVsdGlwbGUgcGllY2VzIGlmIGl0IGRvZXNuJ3QgZml0IGluIG9uZSByZXF1ZXN0LlxyXG4gICAgICAgIGNvbnN0IGRhdGFTZWdzID0gc3BsaXRTdHJpbmdCeVNpemUoZGF0YVN0ciwgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFKTtcclxuICAgICAgICAvL1NlbmQgdGhlIGxlbmd0aCBoZWFkZXJcclxuICAgICAgICBpZiAoZGF0YVNlZ3MubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKFN0cmluZyhkYXRhU2Vncy5sZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9TZW5kIHRoZSBhY3R1YWwgZGF0YSBpbiBzZWdtZW50cy5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oZGF0YVNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNodXRkb3duXygpIHtcclxuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZVRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm15U29jaykge1xyXG4gICAgICAgICAgICB0aGlzLm15U29jay5jbG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm15U29jayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25DbG9zZWRfKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgaXMgY2xvc2luZyBpdHNlbGYnKTtcclxuICAgICAgICAgICAgdGhpcy5zaHV0ZG93bl8oKTtcclxuICAgICAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhbiBpbnRlcm5hbCBjbG9zZSwgdHJpZ2dlciB0aGUgY2xvc2UgbGlzdGVuZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCh0aGlzLmV2ZXJDb25uZWN0ZWRfKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuXHJcbiAgICAgKiBDbG9zZSB0aGUgd2Vic29ja2V0IGFuZCBraWxsIHRoZSBjb25uZWN0aW9uLlxyXG4gICAgICovXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGJlaW5nIGNsb3NlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogS2lsbCB0aGUgY3VycmVudCBrZWVwYWxpdmUgdGltZXIgYW5kIHN0YXJ0IGEgbmV3IG9uZSwgdG8gZW5zdXJlIHRoYXQgaXQgYWx3YXlzIGZpcmVzIE4gc2Vjb25kcyBhZnRlclxyXG4gICAgICogdGhlIGxhc3QgYWN0aXZpdHkuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0S2VlcEFsaXZlKCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XHJcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgLy9JZiB0aGVyZSBoYXMgYmVlbiBubyB3ZWJzb2NrZXQgYWN0aXZpdHkgZm9yIGEgd2hpbGUsIHNlbmQgYSBuby1vcFxyXG4gICAgICAgICAgICBpZiAodGhpcy5teVNvY2spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0cmluZ18oJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihXRUJTT0NLRVRfS0VFUEFMSVZFX0lOVEVSVkFMKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNlbmQgYSBzdHJpbmcgb3ZlciB0aGUgd2Vic29ja2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gc2VuZC5cclxuICAgICAqL1xyXG4gICAgc2VuZFN0cmluZ18oc3RyKSB7XHJcbiAgICAgICAgLy8gRmlyZWZveCBzZWVtcyB0byBzb21ldGltZXMgdGhyb3cgZXhjZXB0aW9ucyAoTlNfRVJST1JfVU5FWFBFQ1RFRCkgZnJvbSB3ZWJzb2NrZXQgLnNlbmQoKVxyXG4gICAgICAgIC8vIGNhbGxzIGZvciBzb21lIHVua25vd24gcmVhc29uLiAgV2UgdHJlYXQgdGhlc2UgYXMgYW4gZXJyb3IgYW5kIGRpc2Nvbm5lY3QuXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wLzU4OTI2MTExNDAyMjkyLzY4MDIxMzQwMjUwNDEwXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5teVNvY2suc2VuZChzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0V4Y2VwdGlvbiB0aHJvd24gZnJvbSBXZWJTb2NrZXQuc2VuZCgpOicsIGUubWVzc2FnZSB8fCBlLmRhdGEsICdDbG9zaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5vbkNsb3NlZF8uYmluZCh0aGlzKSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBOdW1iZXIgb2YgcmVzcG9uc2UgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBjb25uZWN0aW9uIFwiaGVhbHRoeS5cIlxyXG4gKi9cclxuV2ViU29ja2V0Q29ubmVjdGlvbi5yZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5ID0gMjtcclxuLyoqXHJcbiAqIFRpbWUgdG8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdGUgYmVjb21lIGhlYWx0aHkgYmVmb3JlIGdpdmluZyB1cC5cclxuICovXHJcbldlYlNvY2tldENvbm5lY3Rpb24uaGVhbHRoeVRpbWVvdXQgPSAzMDAwMDtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEN1cnJlbnRseSBzaW1wbGlzdGljLCB0aGlzIGNsYXNzIG1hbmFnZXMgd2hhdCB0cmFuc3BvcnQgYSBDb25uZWN0aW9uIHNob3VsZCB1c2UgYXQgdmFyaW91cyBzdGFnZXMgb2YgaXRzXHJcbiAqIGxpZmVjeWNsZS5cclxuICpcclxuICogSXQgc3RhcnRzIHdpdGggbG9uZ3BvbGxpbmcgaW4gYSBicm93c2VyLCBhbmQgaHR0cHBvbGxpbmcgb24gbm9kZS4gSXQgdGhlbiB1cGdyYWRlcyB0byB3ZWJzb2NrZXRzIGlmXHJcbiAqIHRoZXkgYXJlIGF2YWlsYWJsZS5cclxuICovXHJcbmNsYXNzIFRyYW5zcG9ydE1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcmVwb0luZm8gLSBNZXRhZGF0YSBhcm91bmQgdGhlIG5hbWVzcGFjZSB3ZSdyZSBjb25uZWN0aW5nIHRvXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvKSB7XHJcbiAgICAgICAgdGhpcy5pbml0VHJhbnNwb3J0c18ocmVwb0luZm8pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBBTExfVFJBTlNQT1JUUygpIHtcclxuICAgICAgICByZXR1cm4gW0Jyb3dzZXJQb2xsQ29ubmVjdGlvbiwgV2ViU29ja2V0Q29ubmVjdGlvbl07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0cmFuc3BvcnQgaGFzIGJlZW4gc2VsZWN0ZWQgdG8gZW5zdXJlIFdlYlNvY2tldENvbm5lY3Rpb24gb3IgQnJvd3NlclBvbGxDb25uZWN0aW9uIGFyZSBub3QgY2FsbGVkIGFmdGVyXHJcbiAgICAgKiBUcmFuc3BvcnRNYW5hZ2VyIGhhcyBhbHJlYWR5IHNldCB1cCB0cmFuc3BvcnRzX1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IElTX1RSQU5TUE9SVF9JTklUSUFMSVpFRCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF87XHJcbiAgICB9XHJcbiAgICBpbml0VHJhbnNwb3J0c18ocmVwb0luZm8pIHtcclxuICAgICAgICBjb25zdCBpc1dlYlNvY2tldHNBdmFpbGFibGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uICYmIFdlYlNvY2tldENvbm5lY3Rpb25bJ2lzQXZhaWxhYmxlJ10oKTtcclxuICAgICAgICBsZXQgaXNTa2lwUG9sbENvbm5lY3Rpb24gPSBpc1dlYlNvY2tldHNBdmFpbGFibGUgJiYgIVdlYlNvY2tldENvbm5lY3Rpb24ucHJldmlvdXNseUZhaWxlZCgpO1xyXG4gICAgICAgIGlmIChyZXBvSW5mby53ZWJTb2NrZXRPbmx5KSB7XHJcbiAgICAgICAgICAgIGlmICghaXNXZWJTb2NrZXRzQXZhaWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpc1NraXBQb2xsQ29ubmVjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1NraXBQb2xsQ29ubmVjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHNfID0gW1dlYlNvY2tldENvbm5lY3Rpb25dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0cyA9ICh0aGlzLnRyYW5zcG9ydHNfID0gW10pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRyYW5zcG9ydCBvZiBUcmFuc3BvcnRNYW5hZ2VyLkFMTF9UUkFOU1BPUlRTKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0ICYmIHRyYW5zcG9ydFsnaXNBdmFpbGFibGUnXSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgVHJhbnNwb3J0TWFuYWdlci5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgaW5pdGlhbCB0cmFuc3BvcnQgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxUcmFuc3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIG5leHQgdHJhbnNwb3J0LCBvciBudWxsXHJcbiAgICAgKi9cclxuICAgIHVwZ3JhZGVUcmFuc3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0c18ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1sxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSBUcmFuc3BvcnRNYW5hZ2VyIGhhcyBhbHJlYWR5IGNob3NlbiBhIHRyYW5zcG9ydCB0byB1c2VcclxuVHJhbnNwb3J0TWFuYWdlci5nbG9iYWxUcmFuc3BvcnRJbml0aWFsaXplZF8gPSBmYWxzZTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gQWJvcnQgdXBncmFkZSBhdHRlbXB0IGlmIGl0IHRha2VzIGxvbmdlciB0aGFuIDYwcy5cclxuY29uc3QgVVBHUkFERV9USU1FT1VUID0gNjAwMDA7XHJcbi8vIEZvciBzb21lIHRyYW5zcG9ydHMgKFdlYlNvY2tldHMpLCB3ZSBuZWVkIHRvIFwidmFsaWRhdGVcIiB0aGUgdHJhbnNwb3J0IGJ5IGV4Y2hhbmdpbmcgYSBmZXcgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy5cclxuLy8gSWYgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB3aXRoaW4gNXMsIHdlJ2xsIHN0YXJ0IHNlbmRpbmcgbm9vcCBwaW5nIHJlcXVlc3RzLlxyXG5jb25zdCBERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUyA9IDUwMDA7XHJcbi8vIElmIHRoZSBpbml0aWFsIGRhdGEgc2VudCB0cmlnZ2VycyBhIGxvdCBvZiBiYW5kd2lkdGggKGkuZS4gaXQncyBhIGxhcmdlIHB1dCBvciBhIGxpc3RlbiBmb3IgYSBsYXJnZSBhbW91bnQgb2YgZGF0YSlcclxuLy8gdGhlbiB3ZSBtYXkgbm90IGJlIGFibGUgdG8gZXhjaGFuZ2Ugb3VyIHBpbmcvcG9uZyByZXF1ZXN0cyB3aXRoaW4gdGhlIGhlYWx0aHkgdGltZW91dC4gIFNvIGlmIHdlIHJlYWNoIHRoZSB0aW1lb3V0XHJcbi8vIGJ1dCB3ZSd2ZSBzZW50L3JlY2VpdmVkIGVub3VnaCBieXRlcywgd2UgZG9uJ3QgY2FuY2VsIHRoZSBjb25uZWN0aW9uLlxyXG5jb25zdCBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUgPSAxMCAqIDEwMjQ7XHJcbmNvbnN0IEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUgPSAxMDAgKiAxMDI0O1xyXG5jb25zdCBNRVNTQUdFX1RZUEUgPSAndCc7XHJcbmNvbnN0IE1FU1NBR0VfREFUQSA9ICdkJztcclxuY29uc3QgQ09OVFJPTF9TSFVURE9XTiA9ICdzJztcclxuY29uc3QgQ09OVFJPTF9SRVNFVCA9ICdyJztcclxuY29uc3QgQ09OVFJPTF9FUlJPUiA9ICdlJztcclxuY29uc3QgQ09OVFJPTF9QT05HID0gJ28nO1xyXG5jb25zdCBTV0lUQ0hfQUNLID0gJ2EnO1xyXG5jb25zdCBFTkRfVFJBTlNNSVNTSU9OID0gJ24nO1xyXG5jb25zdCBQSU5HID0gJ3AnO1xyXG5jb25zdCBTRVJWRVJfSEVMTE8gPSAnaCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWwtdGltZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIgdXNpbmcgd2hpY2hldmVyIG1ldGhvZCB3b3Jrc1xyXG4gKiBiZXN0IGluIHRoZSBjdXJyZW50IGJyb3dzZXIuXHJcbiAqL1xyXG5jbGFzcyBDb25uZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkIC0gYW4gaWQgZm9yIHRoaXMgY29ubmVjdGlvblxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIHRoZSBpbmZvIGZvciB0aGUgZW5kcG9pbnQgdG8gY29ubmVjdCB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gdGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gYXBwQ2hlY2tUb2tlbl8gLSBUaGUgQXBwIENoZWNrIFRva2VuIGZvciB0aGlzIGRldmljZS5cclxuICAgICAqIEBwYXJhbSBhdXRoVG9rZW5fIC0gVGhlIGF1dGggdG9rZW4gZm9yIHRoaXMgc2Vzc2lvbi5cclxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgc2VydmVyLXB1c2ggbWVzc2FnZSBhcnJpdmVzXHJcbiAgICAgKiBAcGFyYW0gb25SZWFkeV8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGlzIHJlYWR5IHRvIHNlbmQgbWVzc2FnZXMuXHJcbiAgICAgKiBAcGFyYW0gb25EaXNjb25uZWN0XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiBhIGNvbm5lY3Rpb24gd2FzIGxvc3RcclxuICAgICAqIEBwYXJhbSBvbktpbGxfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBoYXMgcGVybWFuZW50bHkgc2h1dCBkb3duLlxyXG4gICAgICogQHBhcmFtIGxhc3RTZXNzaW9uSWQgLSBsYXN0IHNlc3Npb24gaWQgaW4gcGVyc2lzdGVudCBjb25uZWN0aW9uLiBpcyB1c2VkIHRvIGNsZWFuIHVwIG9sZCBzZXNzaW9uIGluIHJlYWwtdGltZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHJlcG9JbmZvXywgYXBwbGljYXRpb25JZF8sIGFwcENoZWNrVG9rZW5fLCBhdXRoVG9rZW5fLCBvbk1lc3NhZ2VfLCBvblJlYWR5Xywgb25EaXNjb25uZWN0Xywgb25LaWxsXywgbGFzdFNlc3Npb25JZCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnJlcG9JbmZvXyA9IHJlcG9JbmZvXztcclxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uSWRfID0gYXBwbGljYXRpb25JZF87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IGFwcENoZWNrVG9rZW5fO1xyXG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IGF1dGhUb2tlbl87XHJcbiAgICAgICAgdGhpcy5vbk1lc3NhZ2VfID0gb25NZXNzYWdlXztcclxuICAgICAgICB0aGlzLm9uUmVhZHlfID0gb25SZWFkeV87XHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0XztcclxuICAgICAgICB0aGlzLm9uS2lsbF8gPSBvbktpbGxfO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IGxhc3RTZXNzaW9uSWQ7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMCAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RJTkcgKi87XHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcignYzonICsgdGhpcy5pZCArICc6Jyk7XHJcbiAgICAgICAgdGhpcy50cmFuc3BvcnRNYW5hZ2VyXyA9IG5ldyBUcmFuc3BvcnRNYW5hZ2VyKHJlcG9JbmZvXyk7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGNyZWF0ZWQnKTtcclxuICAgICAgICB0aGlzLnN0YXJ0XygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBjb25uZWN0aW9uIGF0dGVtcHRcclxuICAgICAqL1xyXG4gICAgc3RhcnRfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLmluaXRpYWxUcmFuc3BvcnQoKTtcclxuICAgICAgICB0aGlzLmNvbm5fID0gbmV3IGNvbm4odGhpcy5uZXh0VHJhbnNwb3J0SWRfKCksIHRoaXMucmVwb0luZm9fLCB0aGlzLmFwcGxpY2F0aW9uSWRfLCB0aGlzLmFwcENoZWNrVG9rZW5fLCB0aGlzLmF1dGhUb2tlbl8sIG51bGwsIHRoaXMubGFzdFNlc3Npb25JZCk7XHJcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXHJcbiAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID0gY29ublsncmVzcG9uc2VzUmVxdWlyZWRUb0JlSGVhbHRoeSddIHx8IDA7XHJcbiAgICAgICAgY29uc3Qgb25NZXNzYWdlUmVjZWl2ZWQgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5jb25uXyk7XHJcbiAgICAgICAgY29uc3Qgb25Db25uZWN0aW9uTG9zdCA9IHRoaXMuZGlzY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcclxuICAgICAgICB0aGlzLnR4XyA9IHRoaXMuY29ubl87XHJcbiAgICAgICAgdGhpcy5yeF8gPSB0aGlzLmNvbm5fO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IGZhbHNlO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogRmlyZWZveCBkb2Vzbid0IGxpa2Ugd2hlbiBjb2RlIGZyb20gb25lIGlmcmFtZSB0cmllcyB0byBjcmVhdGUgYW5vdGhlciBpZnJhbWUgYnkgd2F5IG9mIHRoZSBwYXJlbnQgZnJhbWUuXHJcbiAgICAgICAgICogVGhpcyBjYW4gb2NjdXIgaW4gdGhlIGNhc2Ugb2YgYSByZWRpcmVjdCwgaS5lLiB3ZSBndWVzc2VkIHdyb25nIG9uIHdoYXQgc2VydmVyIHRvIGNvbm5lY3QgdG8gYW5kIHJlY2VpdmVkIGEgcmVzZXQuXHJcbiAgICAgICAgICogU29tZWhvdywgc2V0VGltZW91dCBzZWVtcyB0byBtYWtlIHRoaXMgb2suIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlIGZyb20gYSBzZWN1cml0eSBwZXJzcGVjdGl2ZSwgc2luY2UgeW91IHNob3VsZFxyXG4gICAgICAgICAqIHN0aWxsIGhhdmUgdGhlIGNvbnRleHQgb2YgeW91ciBvcmlnaW5hdGluZyBmcmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgLy8gdGhpcy5jb25uXyBnZXRzIHNldCB0byBudWxsIGluIHNvbWUgb2YgdGhlIHRlc3RzLiBDaGVjayB0byBtYWtlIHN1cmUgaXQgc3RpbGwgZXhpc3RzIGJlZm9yZSB1c2luZyBpdFxyXG4gICAgICAgICAgICB0aGlzLmNvbm5fICYmIHRoaXMuY29ubl8ub3Blbihvbk1lc3NhZ2VSZWNlaXZlZCwgb25Db25uZWN0aW9uTG9zdCk7XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XHJcbiAgICAgICAgY29uc3QgaGVhbHRoeVRpbWVvdXRNUyA9IGNvbm5bJ2hlYWx0aHlUaW1lb3V0J10gfHwgMDtcclxuICAgICAgICBpZiAoaGVhbHRoeVRpbWVvdXRNUyA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFsdGh5VGltZW91dF8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uXyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzUmVjZWl2ZWQgPiBCWVRFU19SRUNFSVZFRF9IRUFMVEhZX09WRVJSSURFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyByZWNlaXZlZCAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8uYnl0ZXNSZWNlaXZlZCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29ubl8gJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uXy5ieXRlc1NlbnQgPiBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGV4Y2VlZGVkIGhlYWx0aHkgdGltZW91dCBidXQgaGFzIHNlbnQgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLmJ5dGVzU2VudCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTGVhdmluZyBjb25uZWN0aW9uIGFsaXZlLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCB3YW50IHRvIG1hcmsgaXQgaGVhbHRoeSwgc2luY2Ugd2UgaGF2ZSBubyBndWFyYW50ZWUgdGhhdCB0aGUgYnl0ZXMgaGF2ZSBtYWRlIGl0IHRvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0Nsb3NpbmcgdW5oZWFsdGh5IGNvbm5lY3Rpb24gYWZ0ZXIgdGltZW91dC4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoaGVhbHRoeVRpbWVvdXRNUykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG5leHRUcmFuc3BvcnRJZF8oKSB7XHJcbiAgICAgICAgcmV0dXJuICdjOicgKyB0aGlzLmlkICsgJzonICsgdGhpcy5jb25uZWN0aW9uQ291bnQrKztcclxuICAgIH1cclxuICAgIGRpc2Nvbm5SZWNlaXZlcl8oY29ubikge1xyXG4gICAgICAgIHJldHVybiBldmVyQ29ubmVjdGVkID0+IHtcclxuICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMuY29ubl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uTG9zdF8oZXZlckNvbm5lY3RlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdTZWNvbmRhcnkgY29ubmVjdGlvbiBsb3N0LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdjbG9zaW5nIGFuIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29ublJlY2VpdmVyXyhjb25uKSB7XHJcbiAgICAgICAgcmV0dXJuIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMiAvKiBSZWFsdGltZVN0YXRlLkRJU0NPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbm4gPT09IHRoaXMucnhfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblByaW1hcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gdGhpcy5zZWNvbmRhcnlDb25uXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdtZXNzYWdlIG9uIG9sZCBjb25uZWN0aW9uJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZGF0YU1zZyAtIEFuIGFyYml0cmFyeSBkYXRhIG1lc3NhZ2UgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXHJcbiAgICAgKi9cclxuICAgIHNlbmRSZXF1ZXN0KGRhdGFNc2cpIHtcclxuICAgICAgICAvLyB3cmFwIGluIGEgZGF0YSBtZXNzYWdlIGVudmVsb3BlIGFuZCBzZW5kIGl0IG9uXHJcbiAgICAgICAgY29uc3QgbXNnID0geyB0OiAnZCcsIGQ6IGRhdGFNc2cgfTtcclxuICAgICAgICB0aGlzLnNlbmREYXRhXyhtc2cpO1xyXG4gICAgfVxyXG4gICAgdHJ5Q2xlYW51cENvbm5lY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fICYmIHRoaXMucnhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnY2xlYW5pbmcgdXAgYW5kIHByb21vdGluZyBhIGNvbm5lY3Rpb246ICcgKyB0aGlzLnNlY29uZGFyeUNvbm5fLmNvbm5JZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciB3aWxsIHNodXRkb3duIHRoZSBvbGQgY29ubmVjdGlvblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5Q29udHJvbF8oY29udHJvbERhdGEpIHtcclxuICAgICAgICBpZiAoTUVTU0FHRV9UWVBFIGluIGNvbnRyb2xEYXRhKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGNvbnRyb2xEYXRhW01FU1NBR0VfVFlQRV07XHJcbiAgICAgICAgICAgIGlmIChjbWQgPT09IFNXSVRDSF9BQ0spIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE1vc3QgbGlrZWx5IHRoZSBzZXNzaW9uIHdhc24ndCB2YWxpZC4gQWJhbmRvbiB0aGUgc3dpdGNoIGF0dGVtcHRcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnR290IGEgcmVzZXQgb24gc2Vjb25kYXJ5LCBjbG9zaW5nIGl0Jyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFscmVhZHkgdXNpbmcgdGhpcyBjb25uZWN0aW9uIGZvciBzb21ldGhpbmcsIHRoYW4gd2UgbmVlZCB0byBmdWxseSBjbG9zZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyhwYXJzZWREYXRhKSB7XHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uU2Vjb25kYXJ5Q29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgLy8gZ290IGEgZGF0YSBtZXNzYWdlLCBidXQgd2UncmUgc3RpbGwgc2Vjb25kIGNvbm5lY3Rpb24uIE5lZWQgdG8gYnVmZmVyIGl0IHVwXHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RhdGFNZXNzYWdlcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByb3RvY29sIGxheWVyOiAnICsgbGF5ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZWVkV2l0aFVwZ3JhZGVfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTZW5kIGEgcGluZyB0byBtYWtlIHN1cmUgdGhlIGNvbm5lY3Rpb24gaXMgaGVhbHRoeS5cclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gc2Vjb25kYXJ5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZWVkV2l0aFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIC8vIHRlbGwgdGhpcyBjb25uZWN0aW9uIHRvIGNvbnNpZGVyIGl0c2VsZiBvcGVuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zdGFydCgpO1xyXG4gICAgICAgIC8vIHNlbmQgYWNrXHJcbiAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIGNsaWVudCBhY2sgb24gc2Vjb25kYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IFNXSVRDSF9BQ0ssIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgLy8gc2VuZCBlbmQgcGFja2V0IG9uIHByaW1hcnkgdHJhbnNwb3J0LCBzd2l0Y2ggdG8gc2VuZGluZyBvbiB0aGlzIG9uZVxyXG4gICAgICAgIC8vIGNhbiByZWNlaXZlIG9uIHRoaXMgb25lLCBidWZmZXIgcmVzcG9uc2VzIHVudGlsIGVuZCByZWNlaXZlZCBvbiBwcmltYXJ5IHRyYW5zcG9ydFxyXG4gICAgICAgIHRoaXMubG9nXygnRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IEVORF9UUkFOU01JU1NJT04sIGQ6IHt9IH0gfSk7XHJcbiAgICAgICAgdGhpcy50eF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xyXG4gICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcclxuICAgIH1cclxuICAgIG9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8ocGFyc2VkRGF0YSkge1xyXG4gICAgICAgIC8vIE11c3QgcmVmZXIgdG8gcGFyc2VkRGF0YSBwcm9wZXJ0aWVzIGluIHF1b3Rlcywgc28gY2xvc3VyZSBkb2Vzbid0IHRvdWNoIHRoZW0uXHJcbiAgICAgICAgY29uc3QgbGF5ZXIgPSByZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcclxuICAgICAgICBpZiAobGF5ZXIgPT09ICdjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ29udHJvbF8oZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09PSAnZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyhkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRhdGFNZXNzYWdlXyhtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcclxuICAgICAgICAvLyBXZSBkb24ndCBkbyBhbnl0aGluZyB3aXRoIGRhdGEgbWVzc2FnZXMsIGp1c3Qga2ljayB0aGVtIHVwIGEgbGV2ZWxcclxuICAgICAgICB0aGlzLm9uTWVzc2FnZV8obWVzc2FnZSk7XHJcbiAgICB9XHJcbiAgICBvblByaW1hcnlSZXNwb25zZV8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcclxuICAgICAgICAgICAgdGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfLS07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNIZWFsdGh5XyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25Db250cm9sXyhjb250cm9sRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNtZCA9IHJlcXVpcmVLZXkoTUVTU0FHRV9UWVBFLCBjb250cm9sRGF0YSk7XHJcbiAgICAgICAgaWYgKE1FU1NBR0VfREFUQSBpbiBjb250cm9sRGF0YSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gY29udHJvbERhdGFbTUVTU0FHRV9EQVRBXTtcclxuICAgICAgICAgICAgaWYgKGNtZCA9PT0gU0VSVkVSX0hFTExPKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kc2hha2VQYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgcGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18uaXNVc2luZ0VtdWxhdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBvbiBjb25uZWN0aW5nLCB0aGUgZW11bGF0b3Igd2lsbCBwYXNzIHRoZSBob3N0bmFtZSB0aGF0IGl0J3MgYXdhcmUgb2YsIGJ1dCB3ZSBwcmVmZXIgdGhlIHVzZXIncyBzZXQgaG9zdG5hbWUgdmlhIGBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcmAgb3ZlciB3aGF0IHRoZSBlbXVsYXRvciBwYXNzZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZHNoYWtlUGF5bG9hZC5oID0gdGhpcy5yZXBvSW5mb18uaG9zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kc2hha2VfKGhhbmRzaGFrZVBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gRU5EX1RSQU5TTUlTU0lPTikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdyZWN2ZCBlbmQgdHJhbnNtaXNzaW9uIG9uIHByaW1hcnknKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucnhfID0gdGhpcy5zZWNvbmRhcnlDb25uXztcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFNZXNzYWdlXyh0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeUNsZWFudXBDb25uZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1NIVVRET1dOKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcyBwcmV2aW91c2x5IHRoZSAnb25LaWxsJyBjYWxsYmFjayBwYXNzZWQgdG8gdGhlIGxvd2VyLWxldmVsIGNvbm5lY3Rpb25cclxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQgaW4gdGhpcyBjYXNlIGlzIHRoZSByZWFzb24gZm9yIHRoZSBzaHV0ZG93bi4gR2VuZXJhbGx5IGEgaHVtYW4tcmVhZGFibGUgZXJyb3JcclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uU2h1dGRvd25fKHBheWxvYWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9SRVNFVCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIGhvc3Qgd2Ugc2hvdWxkIGNvbnRhY3RcclxuICAgICAgICAgICAgICAgIHRoaXMub25SZXNldF8ocGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX0VSUk9SKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignU2VydmVyIEVycm9yOiAnICsgcGF5bG9hZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1BPTkcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnZ290IHBvbmcgb24gcHJpbWFyeS4nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub25QcmltYXJ5UmVzcG9uc2VfKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcignVW5rbm93biBjb250cm9sIHBhY2tldCBjb21tYW5kOiAnICsgY21kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGhhbmRzaGFrZSAtIFRoZSBoYW5kc2hha2UgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgb25IYW5kc2hha2VfKGhhbmRzaGFrZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGhhbmRzaGFrZS50cztcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gaGFuZHNoYWtlLnY7XHJcbiAgICAgICAgY29uc3QgaG9zdCA9IGhhbmRzaGFrZS5oO1xyXG4gICAgICAgIHRoaXMuc2Vzc2lvbklkID0gaGFuZHNoYWtlLnM7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgLy8gaWYgd2UndmUgYWxyZWFkeSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24sIHRoZW4gZG9uJ3QgYm90aGVyIHRyeWluZyB0byBwcm9ncmVzcyBmdXJ0aGVyXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAwIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyAqLykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5fLnN0YXJ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uRXN0YWJsaXNoZWRfKHRoaXMuY29ubl8sIHRpbWVzdGFtcCk7XHJcbiAgICAgICAgICAgIGlmIChQUk9UT0NPTF9WRVJTSU9OICE9PSB2ZXJzaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKCdQcm90b2NvbCB2ZXJzaW9uIG1pc21hdGNoIGRldGVjdGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETzogZG8gd2Ugd2FudCB0byB1cGdyYWRlPyB3aGVuPyBtYXliZSBhIGRlbGF5P1xyXG4gICAgICAgICAgICB0aGlzLnRyeVN0YXJ0VXBncmFkZV8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cnlTdGFydFVwZ3JhZGVfKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbm4gPSB0aGlzLnRyYW5zcG9ydE1hbmFnZXJfLnVwZ3JhZGVUcmFuc3BvcnQoKTtcclxuICAgICAgICBpZiAoY29ubikge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VXBncmFkZV8oY29ubik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhcnRVcGdyYWRlXyhjb25uKSB7XHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG5ldyBjb25uKHRoaXMubmV4dFRyYW5zcG9ydElkXygpLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5hcHBsaWNhdGlvbklkXywgdGhpcy5hcHBDaGVja1Rva2VuXywgdGhpcy5hdXRoVG9rZW5fLCB0aGlzLnNlc3Npb25JZCk7XHJcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxyXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXHJcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8gPVxyXG4gICAgICAgICAgICBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcclxuICAgICAgICBjb25zdCBvbk1lc3NhZ2UgPSB0aGlzLmNvbm5SZWNlaXZlcl8odGhpcy5zZWNvbmRhcnlDb25uXyk7XHJcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuc2Vjb25kYXJ5Q29ubl8pO1xyXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8ub3Blbihvbk1lc3NhZ2UsIG9uRGlzY29ubmVjdCk7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBzdWNjZXNzZnVsbHkgdXBncmFkZWQgYWZ0ZXIgVVBHUkFERV9USU1FT1VULCBnaXZlIHVwIGFuZCBraWxsIHRoZSBzZWNvbmRhcnkuXHJcbiAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXygnVGltZWQgb3V0IHRyeWluZyB0byB1cGdyYWRlLicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcihVUEdSQURFX1RJTUVPVVQpKTtcclxuICAgIH1cclxuICAgIG9uUmVzZXRfKGhvc3QpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ1Jlc2V0IHBhY2tldCByZWNlaXZlZC4gIE5ldyBob3N0OiAnICsgaG9zdCk7XHJcbiAgICAgICAgdGhpcy5yZXBvSW5mb18uaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgLy8gVE9ETzogaWYgd2UncmUgYWxyZWFkeSBcImNvbm5lY3RlZFwiLCB3ZSBuZWVkIHRvIHRyaWdnZXIgYSBkaXNjb25uZWN0IGF0IHRoZSBuZXh0IGxheWVyIHVwLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IHJlc2V0cyBhZnRlciB0aGUgY29ubmVjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGVzdGFibGlzaGVkXHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09PSAxIC8qIFJlYWx0aW1lU3RhdGUuQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENsb3NlIHdoYXRldmVyIGNvbm5lY3Rpb25zIHdlIGhhdmUgb3BlbiBhbmQgc3RhcnQgYWdhaW4uXHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8oY29ubiwgdGltZXN0YW1wKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGVzdGFibGlzaGVkLicpO1xyXG4gICAgICAgIHRoaXMuY29ubl8gPSBjb25uO1xyXG4gICAgICAgIHRoaXMuc3RhdGVfID0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLztcclxuICAgICAgICBpZiAodGhpcy5vblJlYWR5Xykge1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfKHRpbWVzdGFtcCwgdGhpcy5zZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYWZ0ZXIgNSBzZWNvbmRzIHdlIGhhdmVuJ3Qgc2VudCBlbm91Z2ggcmVxdWVzdHMgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIGNvbm5lY3Rpb24gaGVhbHRoeSxcclxuICAgICAgICAvLyBzZW5kIHNvbWUgcGluZ3MuXHJcbiAgICAgICAgaWYgKHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dE5vbkJsb2NraW5nKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBpbmdPblByaW1hcnlJZk5lY2Vzc2FyeV8oKTtcclxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcihERUxBWV9CRUZPUkVfU0VORElOR19FWFRSQV9SRVFVRVNUUykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCkge1xyXG4gICAgICAgIC8vIElmIHRoZSBjb25uZWN0aW9uIGlzbid0IGNvbnNpZGVyZWQgaGVhbHRoeSB5ZXQsIHdlJ2xsIHNlbmQgYSBub29wIHBpbmcgcGFja2V0IHJlcXVlc3QuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8gJiYgdGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdzZW5kaW5nIHBpbmcgb24gcHJpbWFyeS4nKTtcclxuICAgICAgICAgICAgdGhpcy5zZW5kRGF0YV8oeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpIHtcclxuICAgICAgICBjb25zdCBjb25uID0gdGhpcy5zZWNvbmRhcnlDb25uXztcclxuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy50eF8gPT09IGNvbm4gfHwgdGhpcy5yeF8gPT09IGNvbm4pIHtcclxuICAgICAgICAgICAgLy8gd2UgYXJlIHJlbHlpbmcgb24gdGhpcyBjb25uZWN0aW9uIGFscmVhZHkgaW4gc29tZSBjYXBhY2l0eS4gVGhlcmVmb3JlLCBhIGZhaWx1cmUgaXMgcmVhbFxyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZlckNvbm5lY3RlZCAtIFdoZXRoZXIgb3Igbm90IHRoZSBjb25uZWN0aW9uIGV2ZXIgcmVhY2hlZCBhIHNlcnZlci4gVXNlZCB0byBkZXRlcm1pbmUgaWZcclxuICAgICAqIHdlIHNob3VsZCBmbHVzaCB0aGUgaG9zdCBjYWNoZVxyXG4gICAgICovXHJcbiAgICBvbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XHJcbiAgICAgICAgLy8gTk9URTogSUYgeW91J3JlIHNlZWluZyBhIEZpcmVmb3ggZXJyb3IgZm9yIHRoaXMgbGluZSwgSSB0aGluayBpdCBtaWdodCBiZSBiZWNhdXNlIGl0J3MgZ2V0dGluZ1xyXG4gICAgICAgIC8vIGNhbGxlZCBvbiB3aW5kb3cgY2xvc2UgYW5kIFJlYWx0aW1lU3RhdGUuQ09OTkVDVElORyBpcyBubyBsb25nZXIgZGVmaW5lZC4gIEp1c3QgYSBndWVzcy5cclxuICAgICAgICBpZiAoIWV2ZXJDb25uZWN0ZWQgJiYgdGhpcy5zdGF0ZV8gPT09IDAgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBmYWlsZWQuJyk7XHJcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGZhaWxlZCB0byBjb25uZWN0IGF0IGFsbCwgY2xlYXIgYW55IGNhY2hlZCBlbnRyeSBmb3IgdGhpcyBuYW1lc3BhY2UgaW4gY2FzZSB0aGUgbWFjaGluZSB3ZW50IGF3YXlcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLmlzQ2FjaGVhYmxlSG9zdCgpKSB7XHJcbiAgICAgICAgICAgICAgICBQZXJzaXN0ZW50U3RvcmFnZS5yZW1vdmUoJ2hvc3Q6JyArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludGVybmFsIGhvc3QgdG8gd2hhdCB3ZSB3b3VsZCBzaG93IHRoZSB1c2VyLCBpLmUuIDxucz4uZmlyZWJhc2Vpby5jb21cclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmludGVybmFsSG9zdCA9IHRoaXMucmVwb0luZm9fLmhvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZV8gPT09IDEgLyogUmVhbHRpbWVTdGF0ZS5DT05ORUNURUQgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGxvc3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuICAgIG9uQ29ubmVjdGlvblNodXRkb3duXyhyZWFzb24pIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gc2h1dGRvd24gY29tbWFuZCByZWNlaXZlZC4gU2h1dHRpbmcgZG93bi4uLicpO1xyXG4gICAgICAgIGlmICh0aGlzLm9uS2lsbF8pIHtcclxuICAgICAgICAgICAgdGhpcy5vbktpbGxfKHJlYXNvbik7XHJcbiAgICAgICAgICAgIHRoaXMub25LaWxsXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3Qgd2FudCB0byBmaXJlIG9uRGlzY29ubmVjdCAoa2lsbCBpcyBhIGRpZmZlcmVudCBjYXNlKSxcclxuICAgICAgICAvLyBzbyBjbGVhciB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcbiAgICBzZW5kRGF0YV8oZGF0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMSAvKiBSZWFsdGltZVN0YXRlLkNPTk5FQ1RFRCAqLykge1xyXG4gICAgICAgICAgICB0aHJvdyAnQ29ubmVjdGlvbiBpcyBub3QgY29ubmVjdGVkJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHhfLnNlbmQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbnMgdXAgdGhpcyBjb25uZWN0aW9uLCBjYWxsaW5nIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcclxuICAgICAqL1xyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSAyIC8qIFJlYWx0aW1lU3RhdGUuRElTQ09OTkVDVEVEICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyByZWFsdGltZSBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YXRlXyA9IDIgLyogUmVhbHRpbWVTdGF0ZS5ESVNDT05ORUNURUQgKi87XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvc2VDb25uZWN0aW9uc18oKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdTaHV0dGluZyBkb3duIGFsbCBjb25uZWN0aW9ucycpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeUNvbm5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhlYWx0aHlUaW1lb3V0Xykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oZWFsdGh5VGltZW91dF8pO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBJbnRlcmZhY2UgZGVmaW5pbmcgdGhlIHNldCBvZiBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBhZ2FpbnN0IHRoZSBGaXJlYmFzZSBzZXJ2ZXJcclxuICogKGJhc2ljYWxseSBjb3JyZXNwb25kcyB0byBvdXIgd2lyZSBwcm90b2NvbCkuXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFNlcnZlckFjdGlvbnMge1xyXG4gICAgcHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHsgfVxyXG4gICAgbWVyZ2UocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkgeyB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2hlcyB0aGUgYXV0aCB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgY29ubmVjdGlvbi5cclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIFRoZSBhdXRoZW50aWNhdGlvbiB0b2tlblxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQXV0aFRva2VuKHRva2VuKSB7IH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaGVzIHRoZSBhcHAgY2hlY2sgdG9rZW4gZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIGFwcCBjaGVjayB0b2tlblxyXG4gICAgICovXHJcbiAgICByZWZyZXNoQXBwQ2hlY2tUb2tlbih0b2tlbikgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RQdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkgeyB9XHJcbiAgICBvbkRpc2Nvbm5lY3RNZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIG9uRGlzY29ubmVjdENhbmNlbChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7IH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7IH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQmFzZSBjbGFzcyB0byBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIGVtaXQgZXZlbnRzLiBDYWxsIHRoZSBjb25zdHJ1Y3RvciB3aXRoXHJcbiAqIHRoZSBzZXQgb2YgYWxsb3dlZCBldmVudCBuYW1lcy5cclxuICovXHJcbmNsYXNzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhbGxvd2VkRXZlbnRzXykge1xyXG4gICAgICAgIHRoaXMuYWxsb3dlZEV2ZW50c18gPSBhbGxvd2VkRXZlbnRzXztcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc18gPSB7fTtcclxuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShhbGxvd2VkRXZlbnRzXykgJiYgYWxsb3dlZEV2ZW50c18ubGVuZ3RoID4gMCwgJ1JlcXVpcmVzIGEgbm9uLWVtcHR5IGFycmF5Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvIGJlIGNhbGxlZCBieSBkZXJpdmVkIGNsYXNzZXMgdG8gdHJpZ2dlciBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIHRyaWdnZXIoZXZlbnRUeXBlLCAuLi52YXJBcmdzKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0pKSB7XHJcbiAgICAgICAgICAgIC8vIENsb25lIHRoZSBsaXN0LCBzaW5jZSBjYWxsYmFja3MgY291bGQgYWRkL3JlbW92ZSBsaXN0ZW5lcnMuXHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFsuLi50aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXV07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbGJhY2suYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIHZhckFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb24oZXZlbnRUeXBlLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSB8fCBbXTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXS5wdXNoKHsgY2FsbGJhY2ssIGNvbnRleHQgfSk7XHJcbiAgICAgICAgY29uc3QgZXZlbnREYXRhID0gdGhpcy5nZXRJbml0aWFsRXZlbnQoZXZlbnRUeXBlKTtcclxuICAgICAgICBpZiAoZXZlbnREYXRhKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGV2ZW50RGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlRXZlbnRUeXBlXyhldmVudFR5cGUpO1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uY2FsbGJhY2sgPT09IGNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgICAgICAoIWNvbnRleHQgfHwgY29udGV4dCA9PT0gbGlzdGVuZXJzW2ldLmNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVFdmVudFR5cGVfKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmFsbG93ZWRFdmVudHNfLmZpbmQoZXQgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZXQgPT09IGV2ZW50VHlwZTtcclxuICAgICAgICB9KSwgJ1Vua25vd24gZXZlbnQ6ICcgKyBldmVudFR5cGUpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBNb25pdG9ycyBvbmxpbmUgc3RhdGUgKGFzIHJlcG9ydGVkIGJ5IHdpbmRvdy5vbmxpbmUvb2ZmbGluZSBldmVudHMpLlxyXG4gKlxyXG4gKiBUaGUgZXhwZWN0YXRpb24gaXMgdGhhdCB0aGlzIGNvdWxkIGhhdmUgbWFueSBmYWxzZSBwb3NpdGl2ZXMgKHRoaW5rcyB3ZSBhcmUgb25saW5lXHJcbiAqIHdoZW4gd2UncmUgbm90KSwgYnV0IG5vIGZhbHNlIG5lZ2F0aXZlcy4gIFNvIHdlIGNhbiBzYWZlbHkgdXNlIGl0IHRvIGRldGVybWluZSB3aGVuXHJcbiAqIHdlIGRlZmluaXRlbHkgY2Fubm90IHJlYWNoIHRoZSBpbnRlcm5ldC5cclxuICovXHJcbmNsYXNzIE9ubGluZU1vbml0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoWydvbmxpbmUnXSk7XHJcbiAgICAgICAgdGhpcy5vbmxpbmVfID0gdHJ1ZTtcclxuICAgICAgICAvLyBXZSd2ZSBoYWQgcmVwZWF0ZWQgY29tcGxhaW50cyB0aGF0IENvcmRvdmEgYXBwcyBjYW4gZ2V0IHN0dWNrIFwib2ZmbGluZVwiLCBlLmcuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9mb3J1bS5pb25pY2ZyYW1ld29yay5jb20vdC9maXJlYmFzZS1jb25uZWN0aW9uLWlzLWxvc3QtYW5kLW5ldmVyLWNvbWUtYmFjay80MzgxMFxyXG4gICAgICAgIC8vIEl0IHdvdWxkIHNlZW0gdGhhdCB0aGUgJ29ubGluZScgZXZlbnQgZG9lcyBub3QgYWx3YXlzIGZpcmUgY29uc2lzdGVudGx5LiBTbyB3ZSBkaXNhYmxlIGl0XHJcbiAgICAgICAgLy8gZm9yIENvcmRvdmEuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgIWlzTW9iaWxlQ29yZG92YSgpKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub25saW5lXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25saW5lXyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdvbmxpbmUnLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubGluZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ubGluZV8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29ubGluZScsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE9ubGluZU1vbml0b3IoKTtcclxuICAgIH1cclxuICAgIGdldEluaXRpYWxFdmVudChldmVudFR5cGUpIHtcclxuICAgICAgICBhc3NlcnQoZXZlbnRUeXBlID09PSAnb25saW5lJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9ubGluZV9dO1xyXG4gICAgfVxyXG4gICAgY3VycmVudGx5T25saW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9ubGluZV87XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqIE1heGltdW0ga2V5IGRlcHRoLiAqL1xyXG5jb25zdCBNQVhfUEFUSF9ERVBUSCA9IDMyO1xyXG4vKiogTWF4aW11bSBudW1iZXIgb2YgKFVURjgpIGJ5dGVzIGluIGEgRmlyZWJhc2UgcGF0aC4gKi9cclxuY29uc3QgTUFYX1BBVEhfTEVOR1RIX0JZVEVTID0gNzY4O1xyXG4vKipcclxuICogQW4gaW1tdXRhYmxlIG9iamVjdCByZXByZXNlbnRpbmcgYSBwYXJzZWQgcGF0aC4gIEl0J3MgaW1tdXRhYmxlIHNvIHRoYXQgeW91XHJcbiAqIGNhbiBwYXNzIHRoZW0gYXJvdW5kIHRvIG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHRoZW0gY2hhbmdpbmdcclxuICogaXQuXHJcbiAqL1xyXG5jbGFzcyBQYXRoIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdGhPclN0cmluZyAtIFBhdGggc3RyaW5nIHRvIHBhcnNlLCBvciBhbm90aGVyIHBhdGgsIG9yIHRoZSByYXdcclxuICAgICAqIHRva2VucyBhcnJheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoT3JTdHJpbmcsIHBpZWNlTnVtKSB7XHJcbiAgICAgICAgaWYgKHBpZWNlTnVtID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBlbXB0eSBwaWVjZXMuXHJcbiAgICAgICAgICAgIGxldCBjb3B5VG8gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWVjZXNfW2NvcHlUb10gPSB0aGlzLnBpZWNlc19baV07XHJcbiAgICAgICAgICAgICAgICAgICAgY29weVRvKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfLmxlbmd0aCA9IGNvcHlUbztcclxuICAgICAgICAgICAgdGhpcy5waWVjZU51bV8gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5waWVjZXNfID0gcGF0aE9yU3RyaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IHBpZWNlTnVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIGxldCBwYXRoU3RyaW5nID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBpZWNlc19baV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICs9ICcvJyArIHRoaXMucGllY2VzX1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbmV3RW1wdHlQYXRoKCkge1xyXG4gICAgcmV0dXJuIG5ldyBQYXRoKCcnKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoR2V0RnJvbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXRoLnBpZWNlc19bcGF0aC5waWVjZU51bV9dO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aEdldExlbmd0aChwYXRoKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfLmxlbmd0aCAtIHBhdGgucGllY2VOdW1fO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhQb3BGcm9udChwYXRoKSB7XHJcbiAgICBsZXQgcGllY2VOdW0gPSBwYXRoLnBpZWNlTnVtXztcclxuICAgIGlmIChwaWVjZU51bSA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICBwaWVjZU51bSsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBhdGgucGllY2VzXywgcGllY2VOdW0pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhHZXRCYWNrKHBhdGgpIHtcclxuICAgIGlmIChwYXRoLnBpZWNlTnVtXyA8IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gcGF0aC5waWVjZXNfW3BhdGgucGllY2VzXy5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhUb1VybEVuY29kZWRTdHJpbmcocGF0aCkge1xyXG4gICAgbGV0IHBhdGhTdHJpbmcgPSAnJztcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmcgKz0gJy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhwYXRoLnBpZWNlc19baV0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XHJcbn1cclxuLyoqXHJcbiAqIFNoYWxsb3cgY29weSBvZiB0aGUgcGFydHMgb2YgdGhlIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXRoU2xpY2UocGF0aCwgYmVnaW4gPSAwKSB7XHJcbiAgICByZXR1cm4gcGF0aC5waWVjZXNfLnNsaWNlKHBhdGgucGllY2VOdW1fICsgYmVnaW4pO1xyXG59XHJcbmZ1bmN0aW9uIHBhdGhQYXJlbnQocGF0aCkge1xyXG4gICAgaWYgKHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHBpZWNlcyA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fOyBpIDwgcGF0aC5waWVjZXNfLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgIHBpZWNlcy5wdXNoKHBhdGgucGllY2VzX1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoQ2hpbGQocGF0aCwgY2hpbGRQYXRoT2JqKSB7XHJcbiAgICBjb25zdCBwaWVjZXMgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSBwYXRoLnBpZWNlTnVtXzsgaSA8IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHBpZWNlcy5wdXNoKHBhdGgucGllY2VzX1tpXSk7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hpbGRQYXRoT2JqIGluc3RhbmNlb2YgUGF0aCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBjaGlsZFBhdGhPYmoucGllY2VOdW1fOyBpIDwgY2hpbGRQYXRoT2JqLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQYXRoT2JqLnBpZWNlc19baV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGllY2VzID0gY2hpbGRQYXRoT2JqLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZFBpZWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRQaWVjZXNbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQaWVjZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBQYXRoKHBpZWNlcywgMCk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlcmUgYXJlIG5vIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aElzRW1wdHkocGF0aCkge1xyXG4gICAgcmV0dXJuIHBhdGgucGllY2VOdW1fID49IHBhdGgucGllY2VzXy5sZW5ndGg7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBwYXRoIGZyb20gb3V0ZXJQYXRoIHRvIGlubmVyUGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gbmV3UmVsYXRpdmVQYXRoKG91dGVyUGF0aCwgaW5uZXJQYXRoKSB7XHJcbiAgICBjb25zdCBvdXRlciA9IHBhdGhHZXRGcm9udChvdXRlclBhdGgpLCBpbm5lciA9IHBhdGhHZXRGcm9udChpbm5lclBhdGgpO1xyXG4gICAgaWYgKG91dGVyID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGlubmVyUGF0aDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG91dGVyID09PSBpbm5lcikge1xyXG4gICAgICAgIHJldHVybiBuZXdSZWxhdGl2ZVBhdGgocGF0aFBvcEZyb250KG91dGVyUGF0aCksIHBhdGhQb3BGcm9udChpbm5lclBhdGgpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoJyArXHJcbiAgICAgICAgICAgIGlubmVyUGF0aCArXHJcbiAgICAgICAgICAgICcpIGlzIG5vdCB3aXRoaW4gJyArXHJcbiAgICAgICAgICAgICdvdXRlclBhdGggKCcgK1xyXG4gICAgICAgICAgICBvdXRlclBhdGggK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyAtMSwgMCwgMSBpZiBsZWZ0IGlzIGxlc3MsIGVxdWFsLCBvciBncmVhdGVyIHRoYW4gdGhlIHJpZ2h0LlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aENvbXBhcmUobGVmdCwgcmlnaHQpIHtcclxuICAgIGNvbnN0IGxlZnRLZXlzID0gcGF0aFNsaWNlKGxlZnQsIDApO1xyXG4gICAgY29uc3QgcmlnaHRLZXlzID0gcGF0aFNsaWNlKHJpZ2h0LCAwKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjbXAgPSBuYW1lQ29tcGFyZShsZWZ0S2V5c1tpXSwgcmlnaHRLZXlzW2ldKTtcclxuICAgICAgICBpZiAoY21wICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnRLZXlzLmxlbmd0aCA9PT0gcmlnaHRLZXlzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlZnRLZXlzLmxlbmd0aCA8IHJpZ2h0S2V5cy5sZW5ndGggPyAtMSA6IDE7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIHRydWUgaWYgcGF0aHMgYXJlIHRoZSBzYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gcGF0aEVxdWFscyhwYXRoLCBvdGhlcikge1xyXG4gICAgaWYgKHBhdGhHZXRMZW5ndGgocGF0aCkgIT09IHBhdGhHZXRMZW5ndGgob3RoZXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IHBhdGgucGllY2VOdW1fLCBqID0gb3RoZXIucGllY2VOdW1fOyBpIDw9IHBhdGgucGllY2VzXy5sZW5ndGg7IGkrKywgaisrKSB7XHJcbiAgICAgICAgaWYgKHBhdGgucGllY2VzX1tpXSAhPT0gb3RoZXIucGllY2VzX1tqXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBwYXRoIGlzIGEgcGFyZW50IG9mIChvciB0aGUgc2FtZSBhcykgb3RoZXJcclxuICovXHJcbmZ1bmN0aW9uIHBhdGhDb250YWlucyhwYXRoLCBvdGhlcikge1xyXG4gICAgbGV0IGkgPSBwYXRoLnBpZWNlTnVtXztcclxuICAgIGxldCBqID0gb3RoZXIucGllY2VOdW1fO1xyXG4gICAgaWYgKHBhdGhHZXRMZW5ndGgocGF0aCkgPiBwYXRoR2V0TGVuZ3RoKG90aGVyKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHdoaWxlIChpIDwgcGF0aC5waWVjZXNfLmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChwYXRoLnBpZWNlc19baV0gIT09IG90aGVyLnBpZWNlc19bal0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICArK2k7XHJcbiAgICAgICAgKytqO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIER5bmFtaWMgKG11dGFibGUpIHBhdGggdXNlZCB0byBjb3VudCBwYXRoIGxlbmd0aHMuXHJcbiAqXHJcbiAqIFRoaXMgY2xhc3MgaXMgdXNlZCB0byBlZmZpY2llbnRseSBjaGVjayBwYXRocyBmb3IgdmFsaWRcclxuICogbGVuZ3RoIChpbiBVVEY4IGJ5dGVzKSBhbmQgZGVwdGggKHVzZWQgaW4gcGF0aCB2YWxpZGF0aW9uKS5cclxuICpcclxuICogVGhyb3dzIEVycm9yIGV4Y2VwdGlvbiBpZiBwYXRoIGlzIGV2ZXIgaW52YWxpZC5cclxuICpcclxuICogVGhlIGRlZmluaXRpb24gb2YgYSBwYXRoIGFsd2F5cyBiZWdpbnMgd2l0aCAnLycuXHJcbiAqL1xyXG5jbGFzcyBWYWxpZGF0aW9uUGF0aCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gSW5pdGlhbCBQYXRoLlxyXG4gICAgICogQHBhcmFtIGVycm9yUHJlZml4XyAtIFByZWZpeCBmb3IgYW55IGVycm9yIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBlcnJvclByZWZpeF8pIHtcclxuICAgICAgICB0aGlzLmVycm9yUHJlZml4XyA9IGVycm9yUHJlZml4XztcclxuICAgICAgICB0aGlzLnBhcnRzXyA9IHBhdGhTbGljZShwYXRoLCAwKTtcclxuICAgICAgICAvKiogSW5pdGlhbGl6ZSB0byBudW1iZXIgb2YgJy8nIGNoYXJzIG5lZWRlZCBpbiBwYXRoLiAqL1xyXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gPSBNYXRoLm1heCgxLCB0aGlzLnBhcnRzXy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJ0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgodGhpcy5wYXJ0c19baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YWxpZGF0aW9uUGF0aENoZWNrVmFsaWQodGhpcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhQdXNoKHZhbGlkYXRpb25QYXRoLCBjaGlsZCkge1xyXG4gICAgLy8gQ291bnQgdGhlIG5lZWRlZCAnLydcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfICs9IDE7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5wYXJ0c18ucHVzaChjaGlsZCk7XHJcbiAgICB2YWxpZGF0aW9uUGF0aC5ieXRlTGVuZ3RoXyArPSBzdHJpbmdMZW5ndGgoY2hpbGQpO1xyXG4gICAgdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHZhbGlkYXRpb25QYXRoKTtcclxufVxyXG5mdW5jdGlvbiB2YWxpZGF0aW9uUGF0aFBvcCh2YWxpZGF0aW9uUGF0aCkge1xyXG4gICAgY29uc3QgbGFzdCA9IHZhbGlkYXRpb25QYXRoLnBhcnRzXy5wb3AoKTtcclxuICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfIC09IHN0cmluZ0xlbmd0aChsYXN0KTtcclxuICAgIC8vIFVuLWNvdW50IHRoZSBwcmV2aW91cyAnLydcclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhbGlkYXRpb25QYXRoLmJ5dGVMZW5ndGhfIC09IDE7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhDaGVja1ZhbGlkKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gPiBNQVhfUEFUSF9MRU5HVEhfQllURVMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvblBhdGguZXJyb3JQcmVmaXhfICtcclxuICAgICAgICAgICAgJ2hhcyBhIGtleSBwYXRoIGxvbmdlciB0aGFuICcgK1xyXG4gICAgICAgICAgICBNQVhfUEFUSF9MRU5HVEhfQllURVMgK1xyXG4gICAgICAgICAgICAnIGJ5dGVzICgnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGguYnl0ZUxlbmd0aF8gK1xyXG4gICAgICAgICAgICAnKS4nKTtcclxuICAgIH1cclxuICAgIGlmICh2YWxpZGF0aW9uUGF0aC5wYXJ0c18ubGVuZ3RoID4gTUFYX1BBVEhfREVQVEgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodmFsaWRhdGlvblBhdGguZXJyb3JQcmVmaXhfICtcclxuICAgICAgICAgICAgJ3BhdGggc3BlY2lmaWVkIGV4Y2VlZHMgdGhlIG1heGltdW0gZGVwdGggdGhhdCBjYW4gYmUgd3JpdHRlbiAoJyArXHJcbiAgICAgICAgICAgIE1BWF9QQVRIX0RFUFRIICtcclxuICAgICAgICAgICAgJykgb3Igb2JqZWN0IGNvbnRhaW5zIGEgY3ljbGUgJyArXHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyh2YWxpZGF0aW9uUGF0aCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTdHJpbmcgZm9yIHVzZSBpbiBlcnJvciBtZXNzYWdlcyAtIHVzZXMgJy4nIG5vdGF0aW9uIGZvciBwYXRoLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHZhbGlkYXRpb25QYXRoKSB7XHJcbiAgICBpZiAodmFsaWRhdGlvblBhdGgucGFydHNfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBcImluIHByb3BlcnR5ICdcIiArIHZhbGlkYXRpb25QYXRoLnBhcnRzXy5qb2luKCcuJykgKyBcIidcIjtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBWaXNpYmlsaXR5TW9uaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihbJ3Zpc2libGUnXSk7XHJcbiAgICAgICAgbGV0IGhpZGRlbjtcclxuICAgICAgICBsZXQgdmlzaWJpbGl0eUNoYW5nZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgICAgICB0eXBlb2YgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudFsnaGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPcGVyYSAxMi4xMCBhbmQgRmlyZWZveCAxOCBhbmQgbGF0ZXIgc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnbW96SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21vekhpZGRlbic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50Wydtc0hpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21zSGlkZGVuJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnRbJ3dlYmtpdEhpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICAgICAgICAgIGhpZGRlbiA9ICd3ZWJraXRIaWRkZW4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluaXRpYWxseSwgd2UgYWx3YXlzIGFzc3VtZSB3ZSBhcmUgdmlzaWJsZS4gVGhpcyBlbnN1cmVzIHRoYXQgaW4gYnJvd3NlcnNcclxuICAgICAgICAvLyB3aXRob3V0IHBhZ2UgdmlzaWJpbGl0eSBzdXBwb3J0IG9yIGluIGNhc2VzIHdoZXJlIHdlIGFyZSBuZXZlciB2aXNpYmxlXHJcbiAgICAgICAgLy8gKGUuZy4gY2hyb21lIGV4dGVuc2lvbiksIHdlIGFjdCBhcyBpZiB3ZSBhcmUgdmlzaWJsZSwgaS5lLiBkb24ndCBkZWxheVxyXG4gICAgICAgIC8vIHJlY29ubmVjdHNcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gdHJ1ZTtcclxuICAgICAgICBpZiAodmlzaWJpbGl0eUNoYW5nZSkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHZpc2liaWxpdHlDaGFuZ2UsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSAhZG9jdW1lbnRbaGlkZGVuXTtcclxuICAgICAgICAgICAgICAgIGlmICh2aXNpYmxlICE9PSB0aGlzLnZpc2libGVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlXyA9IHZpc2libGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd2aXNpYmxlJywgdmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWaXNpYmlsaXR5TW9uaXRvcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGFzc2VydChldmVudFR5cGUgPT09ICd2aXNpYmxlJywgJ1Vua25vd24gZXZlbnQgdHlwZTogJyArIGV2ZW50VHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnZpc2libGVfXTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBSRUNPTk5FQ1RfTUlOX0RFTEFZID0gMTAwMDtcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUID0gNjAgKiA1ICogMTAwMDsgLy8gNSBtaW51dGVzIGluIG1pbGxpc2Vjb25kcyAoQ2FzZTogMTg1OClcclxuY29uc3QgUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TID0gMzAgKiAxMDAwOyAvLyAzMCBzZWNvbmRzIGZvciBhZG1pbiBjbGllbnRzIChsaWtlbHkgdG8gYmUgYSBiYWNrZW5kIHNlcnZlcilcclxuY29uc3QgUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIgPSAxLjM7XHJcbmNvbnN0IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUID0gMzAwMDA7IC8vIFJlc2V0IGRlbGF5IGJhY2sgdG8gTUlOX0RFTEFZIGFmdGVyIGJlaW5nIGNvbm5lY3RlZCBmb3IgMzBzZWMuXHJcbmNvbnN0IFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04gPSAnc2VydmVyX2tpbGwnO1xyXG4vLyBJZiBhdXRoIGZhaWxzIHJlcGVhdGVkbHksIHdlJ2xsIGFzc3VtZSBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxvZyBhIHdhcm5pbmcgLyBiYWNrIG9mZi5cclxuY29uc3QgSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQgPSAzO1xyXG4vKipcclxuICogRmlyZWJhc2UgY29ubmVjdGlvbi4gIEFic3RyYWN0cyB3aXJlIHByb3RvY29sIGFuZCBoYW5kbGVzIHJlY29ubmVjdGluZy5cclxuICpcclxuICogTk9URTogQWxsIEpTT04gb2JqZWN0cyBzZW50IHRvIHRoZSByZWFsdGltZSBjb25uZWN0aW9uIG11c3QgaGF2ZSBwcm9wZXJ0eSBuYW1lcyBlbmNsb3NlZFxyXG4gKiBpbiBxdW90ZXMgdG8gbWFrZSBzdXJlIHRoZSBjbG9zdXJlIGNvbXBpbGVyIGRvZXMgbm90IG1pbmlmeSB0aGVtLlxyXG4gKi9cclxuY2xhc3MgUGVyc2lzdGVudENvbm5lY3Rpb24gZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIGFwcGxpY2F0aW9uSWRfIC0gVGhlIEZpcmViYXNlIEFwcCBJRCBmb3IgdGhpcyBwcm9qZWN0XHJcbiAgICAgKiBAcGFyYW0gb25EYXRhVXBkYXRlXyAtIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvSW5mb18sIGFwcGxpY2F0aW9uSWRfLCBvbkRhdGFVcGRhdGVfLCBvbkNvbm5lY3RTdGF0dXNfLCBvblNlcnZlckluZm9VcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8sIGF1dGhPdmVycmlkZV8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb25JZF8gPSBhcHBsaWNhdGlvbklkXztcclxuICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xyXG4gICAgICAgIHRoaXMub25Db25uZWN0U3RhdHVzXyA9IG9uQ29ubmVjdFN0YXR1c187XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfID0gb25TZXJ2ZXJJbmZvVXBkYXRlXztcclxuICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcclxuICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8gPSBhcHBDaGVja1Rva2VuUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuYXV0aE92ZXJyaWRlXyA9IGF1dGhPdmVycmlkZV87XHJcbiAgICAgICAgLy8gVXNlZCBmb3IgZGlhZ25vc3RpYyBsb2dnaW5nLlxyXG4gICAgICAgIHRoaXMuaWQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICB0aGlzLmxvZ18gPSBsb2dXcmFwcGVyKCdwOicgKyB0aGlzLmlkICsgJzonKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfID0ge307XHJcbiAgICAgICAgdGhpcy5saXN0ZW5zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXyA9IFtdO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRDb3VudF8gPSAwO1xyXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcclxuICAgICAgICB0aGlzLm1heFJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVDtcclxuICAgICAgICB0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZpc2libGVfID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQmVmb3JlIHdlIGdldCBjb25uZWN0ZWQsIHdlIGtlZXAgYSBxdWV1ZSBvZiBwZW5kaW5nIG1lc3NhZ2VzIHRvIHNlbmQuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIHRoaXMucmVxdWVzdE51bWJlcl8gPSAwO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmludmFsaWRBcHBDaGVja1Rva2VuQ291bnRfID0gMDtcclxuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfID0gbnVsbDtcclxuICAgICAgICBpZiAoYXV0aE92ZXJyaWRlXyAmJiAhaXNOb2RlU2RrKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoIG92ZXJyaWRlIHNwZWNpZmllZCBpbiBvcHRpb25zLCBidXQgbm90IHN1cHBvcnRlZCBvbiBub24gTm9kZS5qcyBwbGF0Zm9ybXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgVmlzaWJpbGl0eU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5vbigndmlzaWJsZScsIHRoaXMub25WaXNpYmxlXywgdGhpcyk7XHJcbiAgICAgICAgaWYgKHJlcG9JbmZvXy5ob3N0LmluZGV4T2YoJ2ZibG9jYWwnKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCdvbmxpbmUnLCB0aGlzLm9uT25saW5lXywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFJlcXVlc3QoYWN0aW9uLCBib2R5LCBvblJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgY3VyUmVxTnVtID0gKyt0aGlzLnJlcXVlc3ROdW1iZXJfO1xyXG4gICAgICAgIGNvbnN0IG1zZyA9IHsgcjogY3VyUmVxTnVtLCBhOiBhY3Rpb24sIGI6IGJvZHkgfTtcclxuICAgICAgICB0aGlzLmxvZ18oc3RyaW5naWZ5KG1zZykpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmNvbm5lY3RlZF8sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfLnNlbmRSZXF1ZXN0KG1zZyk7XHJcbiAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tjdXJSZXFOdW1dID0gb25SZXNwb25zZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgcDogcXVlcnkuX3BhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgcTogcXVlcnkuX3F1ZXJ5T2JqZWN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBvdXRzdGFuZGluZ0dldCA9IHtcclxuICAgICAgICAgICAgYWN0aW9uOiAnZycsXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gbWVzc2FnZVsnZCddO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VbJ3MnXSA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QocGF5bG9hZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub3V0c3RhbmRpbmdHZXRzXy5wdXNoKG91dHN0YW5kaW5nR2V0KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nR2V0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZEdldF8oaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxuICAgIGxpc3RlbihxdWVyeSwgY3VycmVudEhhc2hGbiwgdGFnLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpc3RlbnMuaGFzKHBhdGhTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVucy5zZXQocGF0aFN0cmluZywgbmV3IE1hcCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KHF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSB8fCAhcXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpLCAnbGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnknKTtcclxuICAgICAgICBhc3NlcnQoIXRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuaGFzKHF1ZXJ5SWQpLCBgbGlzdGVuKCkgY2FsbGVkIHR3aWNlIGZvciBzYW1lIHBhdGgvcXVlcnlJZC5gKTtcclxuICAgICAgICBjb25zdCBsaXN0ZW5TcGVjID0ge1xyXG4gICAgICAgICAgICBvbkNvbXBsZXRlLFxyXG4gICAgICAgICAgICBoYXNoRm46IGN1cnJlbnRIYXNoRm4sXHJcbiAgICAgICAgICAgIHF1ZXJ5LFxyXG4gICAgICAgICAgICB0YWdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuc2V0KHF1ZXJ5SWQsIGxpc3RlblNwZWMpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kTGlzdGVuXyhsaXN0ZW5TcGVjKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kR2V0XyhpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGdldCA9IHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpbmRleF07XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdCgnZycsIGdldC5yZXF1ZXN0LCAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ0dldHNfW2luZGV4XTtcclxuICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldENvdW50Xy0tO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ0dldENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ0dldHNfID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGdldC5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBnZXQub25Db21wbGV0ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2VuZExpc3Rlbl8obGlzdGVuU3BlYykge1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbGlzdGVuU3BlYy5xdWVyeTtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBjb25zdCByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSAncSc7XHJcbiAgICAgICAgLy8gT25seSBib3RoZXIgdG8gc2VuZCBxdWVyeSBpZiBpdCdzIG5vbi1kZWZhdWx0LlxyXG4gICAgICAgIGlmIChsaXN0ZW5TcGVjLnRhZykge1xyXG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5Ll9xdWVyeU9iamVjdDtcclxuICAgICAgICAgICAgcmVxWyd0J10gPSBsaXN0ZW5TcGVjLnRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVxWyAvKmhhc2gqLydoJ10gPSBsaXN0ZW5TcGVjLmhhc2hGbigpO1xyXG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXEsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlWyAvKmRhdGEqLydkJ107XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IG1lc3NhZ2VbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAvLyBwcmludCB3YXJuaW5ncyBpbiBhbnkgY2FzZS4uLlxyXG4gICAgICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi53YXJuT25MaXN0ZW5XYXJuaW5nc18ocGF5bG9hZCwgcXVlcnkpO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TGlzdGVuU3BlYyA9IHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykgJiZcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVucy5nZXQocGF0aFN0cmluZykuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgICAgICAvLyBvbmx5IHRyaWdnZXIgYWN0aW9ucyBpZiB0aGUgbGlzdGVuIGhhc24ndCBiZWVuIHJlbW92ZWQgYW5kIHJlYWRkZWRcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5TcGVjID09PSBsaXN0ZW5TcGVjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ2xpc3RlbiByZXNwb25zZScsIG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5TcGVjLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5TcGVjLm9uQ29tcGxldGUoc3RhdHVzLCBwYXlsb2FkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHdhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSkge1xyXG4gICAgICAgIGlmIChwYXlsb2FkICYmIHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JyAmJiBjb250YWlucyhwYXlsb2FkLCAndycpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdzID0gc2FmZUdldChwYXlsb2FkLCAndycpO1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3YXJuaW5ncykgJiYgfndhcm5pbmdzLmluZGV4T2YoJ25vX2luZGV4JykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4U3BlYyA9ICdcIi5pbmRleE9uXCI6IFwiJyArIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpLnRvU3RyaW5nKCkgKyAnXCInO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXhQYXRoID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIHdhcm4oYFVzaW5nIGFuIHVuc3BlY2lmaWVkIGluZGV4LiBZb3VyIGRhdGEgd2lsbCBiZSBkb3dubG9hZGVkIGFuZCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgZmlsdGVyZWQgb24gdGhlIGNsaWVudC4gQ29uc2lkZXIgYWRkaW5nICR7aW5kZXhTcGVjfSBhdCBgICtcclxuICAgICAgICAgICAgICAgICAgICBgJHtpbmRleFBhdGh9IHRvIHlvdXIgc2VjdXJpdHkgcnVsZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZnJlc2hBdXRoVG9rZW4odG9rZW4pIHtcclxuICAgICAgICB0aGlzLmF1dGhUb2tlbl8gPSB0b2tlbjtcclxuICAgICAgICB0aGlzLmxvZ18oJ0F1dGggdG9rZW4gcmVmcmVzaGVkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuXykge1xyXG4gICAgICAgICAgICB0aGlzLnRyeUF1dGgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy4gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgc2ltcGx5IGRlbGV0ZVxyXG4gICAgICAgICAgICAvL3RoZSBjcmVkZW50aWFsIHNvIHdlIGRvbnQgYmVjb21lIGF1dGhlbnRpY2F0ZWQgbmV4dCB0aW1lIHdlIGNvbm5lY3QuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXV0aCcsIHt9LCAoKSA9PiB7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8odG9rZW4pO1xyXG4gICAgfVxyXG4gICAgcmVkdWNlUmVjb25uZWN0RGVsYXlJZkFkbWluQ3JlZGVudGlhbF8oY3JlZGVudGlhbCkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgaXNuJ3QgaW50ZW5kZWQgdG8gYmUgYnVsbGV0cHJvb2YgKGEgbWFsaWNpb3VzIGRldmVsb3BlciBjYW4gYWx3YXlzIGp1c3QgbW9kaWZ5IHRoZSBjbGllbnQpLlxyXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSwgd2UgZG9uJ3QgYm90aGVyIHJlc2V0dGluZyB0aGUgbWF4IGRlbGF5IGJhY2sgdG8gdGhlIGRlZmF1bHQgaWYgYXV0aCBmYWlscyAvIGV4cGlyZXMuXHJcbiAgICAgICAgY29uc3QgaXNGaXJlYmFzZVNlY3JldCA9IGNyZWRlbnRpYWwgJiYgY3JlZGVudGlhbC5sZW5ndGggPT09IDQwO1xyXG4gICAgICAgIGlmIChpc0ZpcmViYXNlU2VjcmV0IHx8IGlzQWRtaW4oY3JlZGVudGlhbCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdBZG1pbiBhdXRoIGNyZWRlbnRpYWwgZGV0ZWN0ZWQuICBSZWR1Y2luZyBtYXggcmVjb25uZWN0IHRpbWUuJyk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZnJlc2hBcHBDaGVja1Rva2VuKHRva2VuKSB7XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IHRva2VuO1xyXG4gICAgICAgIHRoaXMubG9nXygnQXBwIGNoZWNrIHRva2VuIHJlZnJlc2hlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzLmFwcENoZWNrVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5QXBwQ2hlY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vSWYgd2UncmUgY29ubmVjdGVkIHdlIHdhbnQgdG8gbGV0IHRoZSBzZXJ2ZXIga25vdyB0byB1bmF1dGhlbnRpY2F0ZSB1cy5cclxuICAgICAgICAgICAgLy9JZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBzaW1wbHkgZGVsZXRlIHRoZSBjcmVkZW50aWFsIHNvIHdlIGRvbnQgYmVjb21lXHJcbiAgICAgICAgICAgIC8vIGF1dGhlbnRpY2F0ZWQgbmV4dCB0aW1lIHdlIGNvbm5lY3QuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoJ3VuYXBwZWNrJywge30sICgpID0+IHsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiBjcmVkZW50aWFscy4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uIGF0dGVtcHQgZmFpbHMsIGl0J3MgdHJpZ2dlcmVkIGxpa2VcclxuICAgICAqIGEgYXV0aCByZXZva2VkICh0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQpLlxyXG4gICAgICovXHJcbiAgICB0cnlBdXRoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hdXRoVG9rZW5fKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5hdXRoVG9rZW5fO1xyXG4gICAgICAgICAgICBjb25zdCBhdXRoTWV0aG9kID0gaXNWYWxpZEZvcm1hdCh0b2tlbikgPyAnYXV0aCcgOiAnZ2F1dGgnO1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHsgY3JlZDogdG9rZW4gfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXV0aE92ZXJyaWRlXyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ25vYXV0aCddID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5hdXRoT3ZlcnJpZGVfID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ2F1dGh2YXInXSA9IHRoaXMuYXV0aE92ZXJyaWRlXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGF1dGhNZXRob2QsIHJlcXVlc3REYXRhLCAocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc1sgLypkYXRhKi8nZCddIHx8ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRoVG9rZW5fID09PSB0b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXJzIHJlY29ubmVjdCBhbmQgZm9yY2UgcmVmcmVzaCBmb3IgYXV0aCB0b2tlblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKHN0YXR1cywgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGVtcHRzIHRvIGF1dGhlbnRpY2F0ZSB3aXRoIHRoZSBnaXZlbiB0b2tlbi4gSWYgdGhlIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAgKiBhdHRlbXB0IGZhaWxzLCBpdCdzIHRyaWdnZXJlZCBsaWtlIHRoZSB0b2tlbiB3YXMgcmV2b2tlZCAodGhlIGNvbm5lY3Rpb24gaXNcclxuICAgICAqIGNsb3NlZCkuXHJcbiAgICAgKi9cclxuICAgIHRyeUFwcENoZWNrKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hcHBDaGVja1Rva2VuXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCdhcHBjaGVjaycsIHsgJ3Rva2VuJzogdGhpcy5hcHBDaGVja1Rva2VuXyB9LCAocmVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNbIC8qc3RhdHVzKi8ncyddO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlc1sgLypkYXRhKi8nZCddIHx8ICdlcnJvcic7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXBwQ2hlY2tUb2tlbkNvdW50XyA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQXBwQ2hlY2tSZXZva2VkXyhzdGF0dXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0RG9jXHJcbiAgICAgKi9cclxuICAgIHVubGlzdGVuKHF1ZXJ5LCB0YWcpIHtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmxvZ18oJ1VubGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpIHx8ICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCksICd1bmxpc3RlbigpIGNhbGxlZCBmb3Igbm9uLWRlZmF1bHQgYnV0IGNvbXBsZXRlIHF1ZXJ5Jyk7XHJcbiAgICAgICAgY29uc3QgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW4gJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFVubGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkLCBxdWVyeS5fcXVlcnlPYmplY3QsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFVubGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkLCBxdWVyeU9iaiwgdGFnKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdVbmxpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcclxuICAgICAgICBjb25zdCByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSAnbic7XHJcbiAgICAgICAgLy8gT25seSBib3RoZXIgc2VuZGluZyBxdWVyeUlkIGlmIGl0J3Mgbm9uLWRlZmF1bHQuXHJcbiAgICAgICAgaWYgKHRhZykge1xyXG4gICAgICAgICAgICByZXFbJ3EnXSA9IHF1ZXJ5T2JqO1xyXG4gICAgICAgICAgICByZXFbJ3QnXSA9IHRhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcSk7XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RQdXQocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbycsXHJcbiAgICAgICAgICAgICAgICBkYXRhLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkRpc2Nvbm5lY3RNZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ29tJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnb20nLFxyXG4gICAgICAgICAgICAgICAgZGF0YSxcclxuICAgICAgICAgICAgICAgIG9uQ29tcGxldGVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EaXNjb25uZWN0Q2FuY2VsKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uXygpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0Xygnb2MnLCBwYXRoU3RyaW5nLCBudWxsLCBvbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvYycsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzZW5kT25EaXNjb25uZWN0XyhhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0geyAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLCAvKmRhdGEqLyBkOiBkYXRhIH07XHJcbiAgICAgICAgdGhpcy5sb2dfKCdvbkRpc2Nvbm5lY3QgJyArIGFjdGlvbiwgcmVxdWVzdCk7XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShyZXNwb25zZVsgLypzdGF0dXMqLydzJ10sIHJlc3BvbnNlWyAvKiBkYXRhICovJ2QnXSk7XHJcbiAgICAgICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcHV0KHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcclxuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdwJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9XHJcbiAgICBtZXJnZShwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgdGhpcy5wdXRJbnRlcm5hbCgnbScsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpO1xyXG4gICAgfVxyXG4gICAgcHV0SW50ZXJuYWwoYWN0aW9uLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XHJcbiAgICAgICAgdGhpcy5pbml0Q29ubmVjdGlvbl8oKTtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLFxyXG4gICAgICAgICAgICAvKmRhdGEqLyBkOiBkYXRhXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlcXVlc3RbIC8qaGFzaCovJ2gnXSA9IGhhc2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IE9ubHkga2VlcCB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgcHV0IGZvciBhIGdpdmVuIHBhdGg/XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLnB1c2goe1xyXG4gICAgICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgICAgIHJlcXVlc3QsXHJcbiAgICAgICAgICAgIG9uQ29tcGxldGVcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfKys7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdCdWZmZXJpbmcgcHV0OiAnICsgcGF0aFN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2VuZFB1dF8oaW5kZXgpIHtcclxuICAgICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLmFjdGlvbjtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5yZXF1ZXN0O1xyXG4gICAgICAgIGNvbnN0IG9uQ29tcGxldGUgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLm9uQ29tcGxldGU7XHJcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5xdWV1ZWQgPSB0aGlzLmNvbm5lY3RlZF87XHJcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXyhhY3Rpb24gKyAnIHJlc3BvbnNlJywgbWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdO1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG1lc3NhZ2VbIC8qc3RhdHVzKi8ncyddLCBtZXNzYWdlWyAvKiBkYXRhICovJ2QnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7XHJcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGNvbm5lY3RlZCwgd2UganVzdCBkcm9wIHRoZSBzdGF0cy5cclxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7IC8qY291bnRlcnMqLyBjOiBzdGF0cyB9O1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3JlcG9ydFN0YXRzJywgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoLypzdGF0cyovICdzJywgcmVxdWVzdCwgcmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IHJlc3VsdFsgLypzdGF0dXMqLydzJ107XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICE9PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSByZXN1bHRbIC8qIGRhdGEgKi8nZCddO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygncmVwb3J0U3RhdHMnLCAnRXJyb3Igc2VuZGluZyBzdGF0czogJyArIGVycm9yUmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25EYXRhTWVzc2FnZV8obWVzc2FnZSkge1xyXG4gICAgICAgIGlmICgncicgaW4gbWVzc2FnZSkge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgcmVzcG9uc2VcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdmcm9tIHNlcnZlcjogJyArIHN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcU51bSA9IG1lc3NhZ2VbJ3InXTtcclxuICAgICAgICAgICAgY29uc3Qgb25SZXNwb25zZSA9IHRoaXMucmVxdWVzdENCSGFzaF9bcmVxTnVtXTtcclxuICAgICAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlcXVlc3RDQkhhc2hfW3JlcU51bV07XHJcbiAgICAgICAgICAgICAgICBvblJlc3BvbnNlKG1lc3NhZ2VbIC8qYm9keSovJ2InXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ2Vycm9yJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdBIHNlcnZlci1zaWRlIGVycm9yIGhhcyBvY2N1cnJlZDogJyArIG1lc3NhZ2VbJ2Vycm9yJ107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdhJyBpbiBtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIGEgYW5kIGIgYXJlIGFjdGlvbiBhbmQgYm9keSwgcmVzcGVjdGl2ZWx5XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhUHVzaF8obWVzc2FnZVsnYSddLCBtZXNzYWdlWydiJ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uRGF0YVB1c2hfKGFjdGlvbiwgYm9keSkge1xyXG4gICAgICAgIHRoaXMubG9nXygnaGFuZGxlU2VydmVyTWVzc2FnZScsIGFjdGlvbiwgYm9keSk7XHJcbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhib2R5WyAvKnBhdGgqLydwJ10sIGJvZHlbIC8qZGF0YSovJ2QnXSwgXHJcbiAgICAgICAgICAgIC8qaXNNZXJnZSovIGZhbHNlLCBib2R5Wyd0J10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdtJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8oYm9keVsgLypwYXRoKi8ncCddLCBib2R5WyAvKmRhdGEqLydkJ10sIFxyXG4gICAgICAgICAgICAvKmlzTWVyZ2U9Ki8gdHJ1ZSwgYm9keVsndCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnYycpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkxpc3RlblJldm9rZWRfKGJvZHlbIC8qcGF0aCovJ3AnXSwgYm9keVsgLypxdWVyeSovJ3EnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FjJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQXV0aFJldm9rZWRfKGJvZHlbIC8qc3RhdHVzIGNvZGUqLydzJ10sIGJvZHlbIC8qIGV4cGxhbmF0aW9uICovJ2QnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FwYycpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkFwcENoZWNrUmV2b2tlZF8oYm9keVsgLypzdGF0dXMgY29kZSovJ3MnXSwgYm9keVsgLyogZXhwbGFuYXRpb24gKi8nZCddKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09PSAnc2QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25TZWN1cml0eURlYnVnUGFja2V0Xyhib2R5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgYWN0aW9uIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICtcclxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShhY3Rpb24pICtcclxuICAgICAgICAgICAgICAgICdcXG5BcmUgeW91IHVzaW5nIHRoZSBsYXRlc3QgY2xpZW50PycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVhZHlfKHRpbWVzdGFtcCwgc2Vzc2lvbklkKSB7XHJcbiAgICAgICAgdGhpcy5sb2dfKCdjb25uZWN0aW9uIHJlYWR5Jyk7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVGltZXN0YW1wXyh0aW1lc3RhbXApO1xyXG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IHNlc3Npb25JZDtcclxuICAgICAgICBpZiAodGhpcy5maXJzdENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbm5lY3RTdGF0c18oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGVfKCk7XHJcbiAgICAgICAgdGhpcy5maXJzdENvbm5lY3Rpb25fID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfKHRydWUpO1xyXG4gICAgfVxyXG4gICAgc2NoZWR1bGVDb25uZWN0Xyh0aW1lb3V0KSB7XHJcbiAgICAgICAgYXNzZXJ0KCF0aGlzLnJlYWx0aW1lXywgXCJTY2hlZHVsaW5nIGEgY29ubmVjdCB3aGVuIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkL2luZz9cIik7XHJcbiAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTk9URTogRXZlbiB3aGVuIHRpbWVvdXQgaXMgMCwgaXQncyBpbXBvcnRhbnQgdG8gZG8gYSBzZXRUaW1lb3V0IHRvIHdvcmsgYXJvdW5kIGFuIGluZnVyaWF0aW5nIFwiU2VjdXJpdHkgRXJyb3JcIiBpblxyXG4gICAgICAgIC8vIEZpcmVmb3ggd2hlbiB0cnlpbmcgdG8gd3JpdGUgdG8gb3VyIGxvbmctcG9sbGluZyBpZnJhbWUgaW4gc29tZSBzY2VuYXJpb3MgKGUuZy4gRm9yZ2Ugb3Igb3VyIHVuaXQgdGVzdHMpLlxyXG4gICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25fKCk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgfSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XHJcbiAgICB9XHJcbiAgICBpbml0Q29ubmVjdGlvbl8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXyAmJiB0aGlzLmZpcnN0Q29ubmVjdGlvbl8pIHtcclxuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uVmlzaWJsZV8odmlzaWJsZSkge1xyXG4gICAgICAgIC8vIE5PVEU6IFRhYmJpbmcgYXdheSBhbmQgYmFjayB0byBhIHdpbmRvdyB3aWxsIGRlZmVhdCBvdXIgcmVjb25uZWN0IGJhY2tvZmYsIGJ1dCBJIHRoaW5rIHRoYXQncyBmaW5lLlxyXG4gICAgICAgIGlmICh2aXNpYmxlICYmXHJcbiAgICAgICAgICAgICF0aGlzLnZpc2libGVfICYmXHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID09PSB0aGlzLm1heFJlY29ubmVjdERlbGF5Xykge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1dpbmRvdyBiZWNhbWUgdmlzaWJsZS4gIFJlZHVjaW5nIGRlbGF5LicpO1xyXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpc2libGVfID0gdmlzaWJsZTtcclxuICAgIH1cclxuICAgIG9uT25saW5lXyhvbmxpbmUpIHtcclxuICAgICAgICBpZiAob25saW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9ubGluZS4nKTtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb24uJyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uUmVhbHRpbWVEaXNjb25uZWN0XygpIHtcclxuICAgICAgICB0aGlzLmxvZ18oJ2RhdGEgY2xpZW50IGRpc2Nvbm5lY3RlZCcpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucmVhbHRpbWVfID0gbnVsbDtcclxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrbm93IGlmIG91ciBzZW50IHRyYW5zYWN0aW9ucyBzdWNjZWVkZWQgb3Igbm90LCB3ZSBuZWVkIHRvIGNhbmNlbCB0aGVtLlxyXG4gICAgICAgIHRoaXMuY2FuY2VsU2VudFRyYW5zYWN0aW9uc18oKTtcclxuICAgICAgICAvLyBDbGVhciBvdXQgdGhlIHBlbmRpbmcgcmVxdWVzdHMuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdF8oKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMudmlzaWJsZV8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gdGhpcy5tYXhSZWNvbm5lY3REZWxheV87XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8pIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGJlZW4gY29ubmVjdGVkIGxvbmcgZW5vdWdoLCByZXNldCByZWNvbm5lY3QgZGVsYXkgdG8gbWluaW11bS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0Q29ubmVjdFN1Y2NlZWRlZCA+IFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RDb25uZWN0QXR0ZW1wdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXztcclxuICAgICAgICAgICAgbGV0IHJlY29ubmVjdERlbGF5ID0gTWF0aC5tYXgoMCwgdGhpcy5yZWNvbm5lY3REZWxheV8gLSB0aW1lU2luY2VMYXN0Q29ubmVjdEF0dGVtcHQpO1xyXG4gICAgICAgICAgICByZWNvbm5lY3REZWxheSA9IE1hdGgucmFuZG9tKCkgKiByZWNvbm5lY3REZWxheTtcclxuICAgICAgICAgICAgdGhpcy5sb2dfKCdUcnlpbmcgdG8gcmVjb25uZWN0IGluICcgKyByZWNvbm5lY3REZWxheSArICdtcycpO1xyXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8ocmVjb25uZWN0RGVsYXkpO1xyXG4gICAgICAgICAgICAvLyBBZGp1c3QgcmVjb25uZWN0IGRlbGF5IGZvciBuZXh0IHRpbWUuXHJcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gTWF0aC5taW4odGhpcy5tYXhSZWNvbm5lY3REZWxheV8sIHRoaXMucmVjb25uZWN0RGVsYXlfICogUkVDT05ORUNUX0RFTEFZX01VTFRJUExJRVIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uQ29ubmVjdFN0YXR1c18oZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZXN0YWJsaXNoQ29ubmVjdGlvbl8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0XygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnTWFraW5nIGEgY29ubmVjdGlvbiBhdHRlbXB0Jyk7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBvbkRhdGFNZXNzYWdlID0gdGhpcy5vbkRhdGFNZXNzYWdlXy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvblJlYWR5ID0gdGhpcy5vblJlYWR5Xy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uUmVhbHRpbWVEaXNjb25uZWN0Xy5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICBjb25zdCBjb25uSWQgPSB0aGlzLmlkICsgJzonICsgUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8rKztcclxuICAgICAgICAgICAgY29uc3QgbGFzdFNlc3Npb25JZCA9IHRoaXMubGFzdFNlc3Npb25JZDtcclxuICAgICAgICAgICAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBjb25uZWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9uRGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBzZW5kUmVxdWVzdEZuID0gZnVuY3Rpb24gKG1zZykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KGNvbm5lY3Rpb24sIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kUmVxdWVzdChtc2cpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXyA9IHtcclxuICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZUZuLFxyXG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3Q6IHNlbmRSZXF1ZXN0Rm5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVRva2VuUmVmcmVzaF87XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBmZXRjaCBhdXRoIGFuZCBhcHAgY2hlY2sgdG9rZW4sIGFuZCBlc3RhYmxpc2ggY29ubmVjdGlvbiBhZnRlclxyXG4gICAgICAgICAgICAgICAgLy8gZmV0Y2hpbmcgdGhlIHRva2VuIHdhcyBzdWNjZXNzZnVsXHJcbiAgICAgICAgICAgICAgICBjb25zdCBbYXV0aFRva2VuLCBhcHBDaGVja1Rva2VuXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5nZXRUb2tlbihmb3JjZVJlZnJlc2gpXHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2coJ2dldFRva2VuKCkgY29tcGxldGVkLiBDcmVhdGluZyBjb25uZWN0aW9uLicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4uYWNjZXNzVG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuXyA9IGFwcENoZWNrVG9rZW4gJiYgYXBwQ2hlY2tUb2tlbi50b2tlbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oY29ubklkLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5hcHBsaWNhdGlvbklkXywgdGhpcy5hcHBDaGVja1Rva2VuXywgdGhpcy5hdXRoVG9rZW5fLCBvbkRhdGFNZXNzYWdlLCBvblJlYWR5LCBvbkRpc2Nvbm5lY3QsIFxyXG4gICAgICAgICAgICAgICAgICAgIC8qIG9uS2lsbD0gKi8gcmVhc29uID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihyZWFzb24gKyAnICgnICsgdGhpcy5yZXBvSW5mb18udG9TdHJpbmcoKSArICcpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJydXB0KFNFUlZFUl9LSUxMX0lOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIGxhc3RTZXNzaW9uSWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9nKCdnZXRUb2tlbigpIGNvbXBsZXRlZCBidXQgd2FzIGNhbmNlbGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ18oJ0ZhaWxlZCB0byBnZXQgdG9rZW46ICcgKyBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwb0luZm9fLm5vZGVBZG1pbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBhIGNyaXRpY2FsIGVycm9yIGZvciB0aGUgQWRtaW4gTm9kZS5qcyBTREssIHNvIGxvZyBhIHdhcm5pbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJ1dCBnZXRUb2tlbigpIG1heSBhbHNvIGp1c3QgaGF2ZSB0ZW1wb3JhcmlseSBmYWlsZWQsIHNvIHdlIHN0aWxsIHdhbnQgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgcmV0cnlpbmcuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9zZUZuKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnRlcnJ1cHQocmVhc29uKSB7XHJcbiAgICAgICAgbG9nKCdJbnRlcnJ1cHRpbmcgY29ubmVjdGlvbiBmb3IgcmVhc29uOiAnICsgcmVhc29uKTtcclxuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl0gPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWx0aW1lXykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXykge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25SZWFsdGltZURpc2Nvbm5lY3RfKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bWUocmVhc29uKSB7XHJcbiAgICAgICAgbG9nKCdSZXN1bWluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl07XHJcbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5pbnRlcnJ1cHRSZWFzb25zXykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8oMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCkge1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gdGltZXN0YW1wIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5vblNlcnZlckluZm9VcGRhdGVfKHsgc2VydmVyVGltZU9mZnNldDogZGVsdGEgfSk7XHJcbiAgICB9XHJcbiAgICBjYW5jZWxTZW50VHJhbnNhY3Rpb25zXygpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwdXQgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baV07XHJcbiAgICAgICAgICAgIGlmIChwdXQgJiYgLypoYXNoKi8gJ2gnIGluIHB1dC5yZXF1ZXN0ICYmIHB1dC5xdWV1ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwdXQub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1dC5vbkNvbXBsZXRlKCdkaXNjb25uZWN0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50Xy0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFuIHVwIGFycmF5IG9jY2FzaW9uYWxseS5cclxuICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c18gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkxpc3RlblJldm9rZWRfKHBhdGhTdHJpbmcsIHF1ZXJ5KSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW4gYW5kIG1hbnVmYWN0dXJlIGEgXCJwZXJtaXNzaW9uX2RlbmllZFwiIGVycm9yIGZvciB0aGUgZmFpbGVkIGxpc3Rlbi5cclxuICAgICAgICBsZXQgcXVlcnlJZDtcclxuICAgICAgICBpZiAoIXF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSAnZGVmYXVsdCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWVyeUlkID0gcXVlcnkubWFwKHEgPT4gT2JqZWN0VG9VbmlxdWVLZXkocSkpLmpvaW4oJyQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xyXG4gICAgICAgIGlmIChsaXN0ZW4gJiYgbGlzdGVuLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgbGlzdGVuLm9uQ29tcGxldGUoJ3Blcm1pc3Npb25fZGVuaWVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlTGlzdGVuXyhwYXRoU3RyaW5nLCBxdWVyeUlkKSB7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFBhdGhTdHJpbmcgPSBuZXcgUGF0aChwYXRoU3RyaW5nKS50b1N0cmluZygpOyAvLyBub3JtYWxpemUgcGF0aC5cclxuICAgICAgICBsZXQgbGlzdGVuO1xyXG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnMuaGFzKG5vcm1hbGl6ZWRQYXRoU3RyaW5nKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtYXAgPSB0aGlzLmxpc3RlbnMuZ2V0KG5vcm1hbGl6ZWRQYXRoU3RyaW5nKTtcclxuICAgICAgICAgICAgbGlzdGVuID0gbWFwLmdldChxdWVyeUlkKTtcclxuICAgICAgICAgICAgbWFwLmRlbGV0ZShxdWVyeUlkKTtcclxuICAgICAgICAgICAgaWYgKG1hcC5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbnMuZGVsZXRlKG5vcm1hbGl6ZWRQYXRoU3RyaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gYWxsIGxpc3RlbnMgZm9yIHRoaXMgcGF0aCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWRcclxuICAgICAgICAgICAgbGlzdGVuID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGlzdGVuO1xyXG4gICAgfVxyXG4gICAgb25BdXRoUmV2b2tlZF8oc3RhdHVzQ29kZSwgZXhwbGFuYXRpb24pIHtcclxuICAgICAgICBsb2coJ0F1dGggdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcclxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICAgICAgLy8gV2UnbGwgd2FpdCBhIGNvdXBsZSB0aW1lcyBiZWZvcmUgbG9nZ2luZyB0aGUgd2FybmluZyAvIGluY3JlYXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEF1dGhUb2tlbkNvdW50XysrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID49IElOVkFMSURfVE9LRU5fVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgYSBsb25nIHJlY29ubmVjdCBkZWxheSBiZWNhdXNlIHJlY292ZXJ5IGlzIHVubGlrZWx5XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfRk9SX0FETUlOUztcclxuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSB0aGUgYXV0aCB0b2tlbiBwcm92aWRlciB0aGF0IHRoZSB0b2tlbiBpcyBpbnZhbGlkLCB3aGljaCB3aWxsIGxvZ1xyXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGhUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uQXBwQ2hlY2tSZXZva2VkXyhzdGF0dXNDb2RlLCBleHBsYW5hdGlvbikge1xyXG4gICAgICAgIGxvZygnQXBwIGNoZWNrIHRva2VuIHJldm9rZWQ6ICcgKyBzdGF0dXNDb2RlICsgJy8nICsgZXhwbGFuYXRpb24pO1xyXG4gICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlbl8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcclxuICAgICAgICAvLyBOb3RlOiBXZSBkb24ndCBjbG9zZSB0aGUgY29ubmVjdGlvbiBhcyB0aGUgZGV2ZWxvcGVyIG1heSBub3QgaGF2ZVxyXG4gICAgICAgIC8vIGVuZm9yY2VtZW50IGVuYWJsZWQuIFRoZSBiYWNrZW5kIGNsb3NlcyBjb25uZWN0aW9ucyB3aXRoIGVuZm9yY2VtZW50cy5cclxuICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gJ2ludmFsaWRfdG9rZW4nIHx8IHN0YXR1c0NvZGUgPT09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcclxuICAgICAgICAgICAgLy8gV2UnbGwgd2FpdCBhIGNvdXBsZSB0aW1lcyBiZWZvcmUgbG9nZ2luZyB0aGUgd2FybmluZyAvIGluY3JlYXNpbmcgdGhlXHJcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxyXG4gICAgICAgICAgICAvLyBqdXN0IGV4cGlyZWQuIFBsdXMgdGhlcmUgbWF5IGJlIHRyYW5zaWVudCBpc3N1ZXMgdGhhdCByZXNvbHZlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8rKztcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW52YWxpZEFwcENoZWNrVG9rZW5Db3VudF8gPj0gSU5WQUxJRF9UT0tFTl9USFJFU0hPTEQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwQ2hlY2tUb2tlblByb3ZpZGVyXy5ub3RpZnlGb3JJbnZhbGlkVG9rZW4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uU2VjdXJpdHlEZWJ1Z1BhY2tldF8oYm9keSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlY3VyaXR5RGVidWdDYWxsYmFja18pIHtcclxuICAgICAgICAgICAgdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfKGJvZHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKCdtc2cnIGluIGJvZHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGSVJFQkFTRTogJyArIGJvZHlbJ21zZyddLnJlcGxhY2UoJ1xcbicsICdcXG5GSVJFQkFTRTogJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdG9yZVN0YXRlXygpIHtcclxuICAgICAgICAvL1JlLWF1dGhlbnRpY2F0ZSBvdXJzZWx2ZXMgaWYgd2UgaGF2ZSBhIGNyZWRlbnRpYWwgc3RvcmVkLlxyXG4gICAgICAgIHRoaXMudHJ5QXV0aCgpO1xyXG4gICAgICAgIHRoaXMudHJ5QXBwQ2hlY2soKTtcclxuICAgICAgICAvLyBQdXRzIGRlcGVuZCBvbiBoYXZpbmcgcmVjZWl2ZWQgdGhlIGNvcnJlc3BvbmRpbmcgZGF0YSB1cGRhdGUgZnJvbSB0aGUgc2VydmVyIGJlZm9yZSB0aGV5IGNvbXBsZXRlLCBzbyB3ZSBtdXN0XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHNlbmQgbGlzdGVucyBiZWZvcmUgcHV0cy5cclxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJpZXMgb2YgdGhpcy5saXN0ZW5zLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuU3BlYyBvZiBxdWVyaWVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm91dHN0YW5kaW5nUHV0c19baV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFB1dF8oaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKHJlcXVlc3QuYWN0aW9uLCByZXF1ZXN0LnBhdGhTdHJpbmcsIHJlcXVlc3QuZGF0YSwgcmVxdWVzdC5vbkNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHN0YW5kaW5nR2V0c18ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdHZXRzX1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kR2V0XyhpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgY2xpZW50IHN0YXRzIGZvciBmaXJzdCBjb25uZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHNlbmRDb25uZWN0U3RhdHNfKCkge1xyXG4gICAgICAgIGNvbnN0IHN0YXRzID0ge307XHJcbiAgICAgICAgbGV0IGNsaWVudE5hbWUgPSAnanMnO1xyXG4gICAgICAgIGlmIChpc05vZGVTZGsoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXBvSW5mb18ubm9kZUFkbWluKSB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnROYW1lID0gJ2FkbWluX25vZGUnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50TmFtZSA9ICdub2RlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0c1snc2RrLicgKyBjbGllbnROYW1lICsgJy4nICsgU0RLX1ZFUlNJT04ucmVwbGFjZSgvXFwuL2csICctJyldID0gMTtcclxuICAgICAgICBpZiAoaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcclxuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5jb3Jkb3ZhJ10gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcclxuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5yZWFjdG5hdGl2ZSddID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXBvcnRTdGF0cyhzdGF0cyk7XHJcbiAgICB9XHJcbiAgICBzaG91bGRSZWNvbm5lY3RfKCkge1xyXG4gICAgICAgIGNvbnN0IG9ubGluZSA9IE9ubGluZU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5jdXJyZW50bHlPbmxpbmUoKTtcclxuICAgICAgICByZXR1cm4gaXNFbXB0eSh0aGlzLmludGVycnVwdFJlYXNvbnNfKSAmJiBvbmxpbmU7XHJcbiAgICB9XHJcbn1cclxuUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dFBlcnNpc3RlbnRDb25uZWN0aW9uSWRfID0gMDtcclxuLyoqXHJcbiAqIENvdW50ZXIgZm9yIG51bWJlciBvZiBjb25uZWN0aW9ucyBjcmVhdGVkLiBNYWlubHkgdXNlZCBmb3IgdGFnZ2luZyBpbiB0aGUgbG9nc1xyXG4gKi9cclxuUGVyc2lzdGVudENvbm5lY3Rpb24ubmV4dENvbm5lY3Rpb25JZF8gPSAwO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBOYW1lZE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgbm9kZSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBXcmFwKG5hbWUsIG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jbGFzcyBJbmRleCB7XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEEgc3RhbmRhbG9uZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvclxyXG4gICAgICogdGhpcyBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRDb21wYXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBiZWZvcmUgYW5kIGFmdGVyIHZhbHVlIGZvciBhIG5vZGUsIGRldGVybWluZSBpZiB0aGUgaW5kZXhlZCB2YWx1ZSBoYXMgY2hhbmdlZC4gRXZlbiBpZiB0aGV5IGFyZSBkaWZmZXJlbnQsXHJcbiAgICAgKiBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGNoYW5nZXMgYXJlIGlzb2xhdGVkIHRvIHBhcnRzIG9mIHRoZSBzbmFwc2hvdCB0aGF0IGFyZSBub3QgaW5kZXhlZC5cclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcG9ydGlvbiBvZiB0aGUgc25hcHNob3QgYmVpbmcgaW5kZXhlZCBjaGFuZ2VkIGJldHdlZW4gb2xkTm9kZSBhbmQgbmV3Tm9kZVxyXG4gICAgICovXHJcbiAgICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICBjb25zdCBvbGRXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShNSU5fTkFNRSwgb2xkTm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV3V3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIG5ld05vZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob2xkV3JhcHBlZCwgbmV3V3JhcHBlZCkgIT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGEgbm9kZSB3cmFwcGVyIHRoYXQgd2lsbCBzb3J0IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICogYW55IG90aGVyIG5vZGUgd3JhcHBlciwgdXNpbmcgdGhpcyBpbmRleFxyXG4gICAgICovXHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IF9fRU1QVFlfTk9ERTtcclxuY2xhc3MgS2V5SW5kZXggZXh0ZW5kcyBJbmRleCB7XHJcbiAgICBzdGF0aWMgZ2V0IF9fRU1QVFlfTk9ERSgpIHtcclxuICAgICAgICByZXR1cm4gX19FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBfX0VNUFRZX05PREUodmFsKSB7XHJcbiAgICAgICAgX19FTVBUWV9OT0RFID0gdmFsO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICAvLyBXZSBjb3VsZCBwcm9iYWJseSByZXR1cm4gdHJ1ZSBoZXJlIChzaW5jZSBldmVyeSBub2RlIGhhcyBhIGtleSksIGJ1dCBpdCdzIG5ldmVyIGNhbGxlZFxyXG4gICAgICAgIC8vIHNvIGp1c3QgbGVhdmluZyB1bmltcGxlbWVudGVkIGZvciBub3cuXHJcbiAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ0tleUluZGV4LmlzRGVmaW5lZE9uIG5vdCBleHBlY3RlZCB0byBiZSBjYWxsZWQuJyk7XHJcbiAgICB9XHJcbiAgICBpbmRleGVkVmFsdWVDaGFuZ2VkKG9sZE5vZGUsIG5ld05vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFRoZSBrZXkgZm9yIGEgbm9kZSBuZXZlciBjaGFuZ2VzLlxyXG4gICAgfVxyXG4gICAgbWluUG9zdCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUlOO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZWFsbHkgYmUgY3JlYXRlZCBvbmNlIGFuZCBjYWNoZWQgaW4gYSBzdGF0aWMgcHJvcGVydHksIGJ1dFxyXG4gICAgICAgIC8vIE5hbWVkTm9kZSBpc24ndCBkZWZpbmVkIHlldCwgc28gSSBjYW4ndCB1c2UgaXQgaW4gYSBzdGF0aWMuICBCbGVoLlxyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBfX0VNUFRZX05PREUpO1xyXG4gICAgfVxyXG4gICAgbWFrZVBvc3QoaW5kZXhWYWx1ZSwgbmFtZSkge1xyXG4gICAgICAgIGFzc2VydCh0eXBlb2YgaW5kZXhWYWx1ZSA9PT0gJ3N0cmluZycsICdLZXlJbmRleCBpbmRleFZhbHVlIG11c3QgYWx3YXlzIGJlIGEgc3RyaW5nLicpO1xyXG4gICAgICAgIC8vIFdlIGp1c3QgdXNlIGVtcHR5IG5vZGUsIGJ1dCBpdCdsbCBuZXZlciBiZSBjb21wYXJlZCwgc2luY2Ugb3VyIGNvbXBhcmF0b3Igb25seSBsb29rcyBhdCBuYW1lLlxyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKGluZGV4VmFsdWUsIF9fRU1QVFlfTk9ERSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJy5rZXknO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IEtFWV9JTkRFWCA9IG5ldyBLZXlJbmRleCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaXRlcmF0b3Igb3ZlciBhbiBMTFJCTm9kZS5cclxuICovXHJcbmNsYXNzIFNvcnRlZE1hcEl0ZXJhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGl0ZXJhdGUuXHJcbiAgICAgKiBAcGFyYW0gaXNSZXZlcnNlXyAtIFdoZXRoZXIgb3Igbm90IHRvIGl0ZXJhdGUgaW4gcmV2ZXJzZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlXywgcmVzdWx0R2VuZXJhdG9yXyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmlzUmV2ZXJzZV8gPSBpc1JldmVyc2VfO1xyXG4gICAgICAgIHRoaXMucmVzdWx0R2VuZXJhdG9yXyA9IHJlc3VsdEdlbmVyYXRvcl87XHJcbiAgICAgICAgdGhpcy5ub2RlU3RhY2tfID0gW107XHJcbiAgICAgICAgbGV0IGNtcCA9IDE7XHJcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZTtcclxuICAgICAgICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xyXG4gICAgICAgICAgICAvLyBmbGlwIHRoZSBjb21wYXJpc29uIGlmIHdlJ3JlIGdvaW5nIGluIHJldmVyc2VcclxuICAgICAgICAgICAgaWYgKGlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgIGNtcCAqPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGxlc3MgdGhhbiBvdXIgc3RhcnQga2V5LiBpZ25vcmUgaXRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzUmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG5vZGUgaXMgZXhhY3RseSBlcXVhbCB0byBvdXIgc3RhcnQga2V5LiBQdXNoIGl0IG9uIHRoZSBzdGFjaywgYnV0IHN0b3AgaXRlcmF0aW5nO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZSB0byB0aGUgbmV4dCBvbmVcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE5leHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlU3RhY2tfLnBvcCgpO1xyXG4gICAgICAgIGxldCByZXN1bHQ7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZVN0YWNrXy5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgcGVlaygpIHtcclxuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZVN0YWNrX1t0aGlzLm5vZGVTdGFja18ubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0R2VuZXJhdG9yXykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRHZW5lcmF0b3JfKG5vZGUua2V5LCBub2RlLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIHZhbHVlOiBub2RlLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgbm9kZSBpbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2sgdHJlZS5cclxuICovXHJcbmNsYXNzIExMUkJOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cclxuICAgICAqIEBwYXJhbSBjb2xvciAtIFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cclxuICAgICAqIEBwYXJhbSBsZWZ0IC0gTGVmdCBjaGlsZC5cclxuICAgICAqIEBwYXJhbSByaWdodCAtIFJpZ2h0IGNoaWxkLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBjb2xvciwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yICE9IG51bGwgPyBjb2xvciA6IExMUkJOb2RlLlJFRDtcclxuICAgICAgICB0aGlzLmxlZnQgPVxyXG4gICAgICAgICAgICBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9XHJcbiAgICAgICAgICAgIHJpZ2h0ICE9IG51bGwgPyByaWdodCA6IFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLCBvcHRpb25hbGx5IHJlcGxhY2luZyBwaWVjZXMgb2YgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAtIE5ldyBrZXkgZm9yIHRoZSBub2RlLCBvciBudWxsLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gTmV3IHZhbHVlIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSBjb2xvciAtIE5ldyBjb2xvciBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gbGVmdCAtIE5ldyBsZWZ0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cclxuICAgICAqIEBwYXJhbSByaWdodCAtIE5ldyByaWdodCBjaGlsZCBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbm9kZSBjb3B5LlxyXG4gICAgICovXHJcbiAgICBjb3B5KGtleSwgdmFsdWUsIGNvbG9yLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5ICE9IG51bGwgPyBrZXkgOiB0aGlzLmtleSwgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy52YWx1ZSwgY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogdGhpcy5jb2xvciwgbGVmdCAhPSBudWxsID8gbGVmdCA6IHRoaXMubGVmdCwgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogdGhpcy5yaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY291bnQoKSArIDEgKyB0aGlzLnJpZ2h0LmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4ga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2ggbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAgICAgKiAgIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVGhlIGZpcnN0IHRydXRoeSB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb24sIG9yIHRoZSBsYXN0IGZhbHNleVxyXG4gICAgICogICB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb25cclxuICAgICAqL1xyXG4gICAgaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgISFhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxyXG4gICAgICogZm9yIGVhY2ggbm9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXHJcbiAgICAgKiBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5yaWdodC5yZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikgfHxcclxuICAgICAgICAgICAgYWN0aW9uKHRoaXMua2V5LCB0aGlzLnZhbHVlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1pbmltdW0gbm9kZSBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgbWluXygpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQubWluXygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluXygpLmtleTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG1heGltdW0ga2V5IGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Lm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAtIEtleSB0byBpbnNlcnQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBpbnNlcnQuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBjb25zdCBjbXAgPSBjb21wYXJhdG9yKGtleSwgbi5rZXkpO1xyXG4gICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0Lmluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIHZhbHVlLCBudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIHdpdGggdGhlIG1pbmltdW0ga2V5IHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZU1pbl8oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbiA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRMZWZ0XygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmVNaW5fKCksIG51bGwpO1xyXG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCB0aGUgc3BlY2lmaWVkIGl0ZW0gcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGtleSwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIGxldCBuLCBzbWFsbGVzdDtcclxuICAgICAgICBuID0gdGhpcztcclxuICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5tb3ZlUmVkTGVmdF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIW4ucmlnaHQuaXNFbXB0eSgpICYmICFuLnJpZ2h0LmlzUmVkXygpICYmICFuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgICAgIG4gPSBuLm1vdmVSZWRSaWdodF8oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihrZXksIG4ua2V5KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG4ucmlnaHQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3QgPSBuLnJpZ2h0Lm1pbl8oKTtcclxuICAgICAgICAgICAgICAgICAgICBuID0gbi5jb3B5KHNtYWxsZXN0LmtleSwgc21hbGxlc3QudmFsdWUsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlTWluXygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQucmVtb3ZlKGtleSwgY29tcGFyYXRvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGlzIGlzIGEgUkVEIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGlzUmVkXygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgZml4VXBfKCkge1xyXG4gICAgICAgIGxldCBuID0gdGhpcztcclxuICAgICAgICBpZiAobi5yaWdodC5pc1JlZF8oKSAmJiAhbi5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIG4gPSBuLnJvdGF0ZUxlZnRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5sZWZ0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHRfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5yaWdodC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgYWZ0ZXIgbW92ZVJlZExlZnQuXHJcbiAgICAgKi9cclxuICAgIG1vdmVSZWRMZWZ0XygpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xyXG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJvdGF0ZVJpZ2h0XygpKTtcclxuICAgICAgICAgICAgbiA9IG4ucm90YXRlTGVmdF8oKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIG1vdmVSZWRSaWdodC5cclxuICAgICAqL1xyXG4gICAgbW92ZVJlZFJpZ2h0XygpIHtcclxuICAgICAgICBsZXQgbiA9IHRoaXMuY29sb3JGbGlwXygpO1xyXG4gICAgICAgIGlmIChuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xyXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVSaWdodF8oKTtcclxuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZUxlZnQuXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZUxlZnRfKCkge1xyXG4gICAgICAgIGNvbnN0IG5sID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgbnVsbCwgdGhpcy5yaWdodC5sZWZ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZVJpZ2h0LlxyXG4gICAgICovXHJcbiAgICByb3RhdGVSaWdodF8oKSB7XHJcbiAgICAgICAgY29uc3QgbnIgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCB0aGlzLmxlZnQucmlnaHQsIG51bGwpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnQuY29weShudWxsLCBudWxsLCB0aGlzLmNvbG9yLCBudWxsLCBucik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5ld3QgcmVlLCBhZnRlciBjb2xvckZsaXAuXHJcbiAgICAgKi9cclxuICAgIGNvbG9yRmxpcF8oKSB7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsICF0aGlzLmxlZnQuY29sb3IsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsICF0aGlzLnJpZ2h0LmNvbG9yLCBudWxsLCBudWxsKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIG51bGwsICF0aGlzLmNvbG9yLCBsZWZ0LCByaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZvciB0ZXN0aW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYWxsIGlzIHdlbGwuXHJcbiAgICAgKi9cclxuICAgIGNoZWNrTWF4RGVwdGhfKCkge1xyXG4gICAgICAgIGNvbnN0IGJsYWNrRGVwdGggPSB0aGlzLmNoZWNrXygpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLjAsIGJsYWNrRGVwdGgpIDw9IHRoaXMuY291bnQoKSArIDE7XHJcbiAgICB9XHJcbiAgICBjaGVja18oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZWRfKCkgJiYgdGhpcy5sZWZ0LmlzUmVkXygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVkIG5vZGUgaGFzIHJlZCBjaGlsZCgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNSZWRfKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSaWdodCBjaGlsZCBvZiAoJyArIHRoaXMua2V5ICsgJywnICsgdGhpcy52YWx1ZSArICcpIGlzIHJlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBibGFja0RlcHRoID0gdGhpcy5sZWZ0LmNoZWNrXygpO1xyXG4gICAgICAgIGlmIChibGFja0RlcHRoICE9PSB0aGlzLnJpZ2h0LmNoZWNrXygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmxhY2sgZGVwdGhzIGRpZmZlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJsYWNrRGVwdGggKyAodGhpcy5pc1JlZF8oKSA/IDAgOiAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuTExSQk5vZGUuUkVEID0gdHJ1ZTtcclxuTExSQk5vZGUuQkxBQ0sgPSBmYWxzZTtcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cclxuICovXHJcbmNsYXNzIExMUkJFbXB0eU5vZGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBub2RlIGNvcHkuXHJcbiAgICAgKi9cclxuICAgIGNvcHkoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQga2V5L3ZhbHVlIGFkZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBhZGRlZC5cclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIC0gQ29tcGFyYXRvci5cclxuICAgICAqIEByZXR1cm5zIE5ldyB0cmVlLCB3aXRoIGl0ZW0gYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChrZXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMTFJCTm9kZShrZXksIHZhbHVlLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byByZW1vdmUuXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciAtIENvbXBhcmF0b3IuXHJcbiAgICAgKiBAcmV0dXJucyBOZXcgdHJlZSwgd2l0aCBpdGVtIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShrZXksIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgdHJlZS5cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIGlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgdGhlIHRyZWUgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcclxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWluS2V5KCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgbWF4S2V5KCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY2hlY2tfKCkge1xyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgbm9kZSBpcyByZWQuXHJcbiAgICAgKi9cclxuICAgIGlzUmVkXygpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcclxuICogdHJlZS5cclxuICovXHJcbmNsYXNzIFNvcnRlZE1hcCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yXyAtIEtleSBjb21wYXJhdG9yLlxyXG4gICAgICogQHBhcmFtIHJvb3RfIC0gT3B0aW9uYWwgcm9vdCBub2RlIGZvciB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yXywgcm9vdF8gPSBTb3J0ZWRNYXAuRU1QVFlfTk9ERSkge1xyXG4gICAgICAgIHRoaXMuY29tcGFyYXRvcl8gPSBjb21wYXJhdG9yXztcclxuICAgICAgICB0aGlzLnJvb3RfID0gcm9vdF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQgb3IgcmVwbGFjZWQuXHJcbiAgICAgKiAoVE9ETzogV2Ugc2hvdWxkIHBlcmhhcHMgcmVuYW1lIHRoaXMgbWV0aG9kIHRvICdwdXQnKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBLZXkgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBiZSBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIE5ldyBtYXAsIHdpdGggaXRlbSBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGtleSwgdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcCh0aGlzLmNvbXBhcmF0b3JfLCB0aGlzLnJvb3RfXHJcbiAgICAgICAgICAgIC5pbnNlcnQoa2V5LCB2YWx1ZSwgdGhpcy5jb21wYXJhdG9yXylcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHJlbW92ZS5cclxuICAgICAqIEByZXR1cm5zIE5ldyBtYXAsIHdpdGggaXRlbSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yXywgdGhpcy5yb290X1xyXG4gICAgICAgICAgICAucmVtb3ZlKGtleSwgdGhpcy5jb21wYXJhdG9yXylcclxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGxvb2sgdXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIG5vZGUgd2l0aCB0aGUgZ2l2ZW4ga2V5LCBvciBudWxsIGlmIHRoZVxyXG4gICAgICoga2V5IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICAgKi9cclxuICAgIGdldChrZXkpIHtcclxuICAgICAgICBsZXQgY21wO1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5yb290XztcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGtleSBvZiB0aGUgaXRlbSAqYmVmb3JlKiB0aGUgc3BlY2lmaWVkIGtleSwgb3IgbnVsbCBpZiBrZXkgaXMgdGhlIGZpcnN0IGl0ZW0uXHJcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBmaW5kIHRoZSBwcmVkZWNlc3NvciBvZlxyXG4gICAgICogQHJldHVybnMgVGhlIHByZWRlY2Vzc29yIGtleS5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JLZXkoa2V5KSB7XHJcbiAgICAgICAgbGV0IGNtcCwgbm9kZSA9IHRoaXMucm9vdF8sIHJpZ2h0UGFyZW50ID0gbnVsbDtcclxuICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuY29tcGFyYXRvcl8oa2V5LCBub2RlLmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLnJpZ2h0LmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRQYXJlbnQua2V5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGZpcnN0IGl0ZW0uXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodFBhcmVudCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBmaW5kIHByZWRlY2Vzc29yIGtleSBmb3IgYSBub25leGlzdGVudCBrZXkuICBXaGF0IGdpdmVzPycpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBtYXAgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbnVtYmVyIG9mIG5vZGVzIGluIHRoZSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBtaW5pbXVtIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBtaW5LZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWluS2V5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgbWFwLlxyXG4gICAgICovXHJcbiAgICBtYXhLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ubWF4S2V5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XHJcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxyXG4gICAgICovXHJcbiAgICBpbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIHRoZSBtYXAgaW4gcmV2ZXJzZSBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXHJcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci4gIElmIGFjdGlvbiByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxyXG4gICAgICovXHJcbiAgICByZXZlcnNlVHJhdmVyc2FsKGFjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLnJldmVyc2VUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgaXRlcmF0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldEl0ZXJhdG9yKHJlc3VsdEdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290XywgbnVsbCwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvckZyb20oa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGtleSwgcmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBrZXksIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IocmVzdWx0R2VuZXJhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCB0cnVlLCByZXN1bHRHZW5lcmF0b3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbHdheXMgdXNlIHRoZSBzYW1lIGVtcHR5IG5vZGUsIHRvIHJlZHVjZSBtZW1vcnkuXHJcbiAqL1xyXG5Tb3J0ZWRNYXAuRU1QVFlfTk9ERSA9IG5ldyBMTFJCRW1wdHlOb2RlKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIE5BTUVfT05MWV9DT01QQVJBVE9SKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICByZXR1cm4gbmFtZUNvbXBhcmUobGVmdC5uYW1lLCByaWdodC5uYW1lKTtcclxufVxyXG5mdW5jdGlvbiBOQU1FX0NPTVBBUkFUT1IobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBuYW1lQ29tcGFyZShsZWZ0LCByaWdodCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IE1BWF9OT0RFJDI7XHJcbmZ1bmN0aW9uIHNldE1heE5vZGUkMSh2YWwpIHtcclxuICAgIE1BWF9OT0RFJDIgPSB2YWw7XHJcbn1cclxuY29uc3QgcHJpb3JpdHlIYXNoVGV4dCA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgaWYgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICByZXR1cm4gJ251bWJlcjonICsgZG91YmxlVG9JRUVFNzU0U3RyaW5nKHByaW9yaXR5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAnc3RyaW5nOicgKyBwcmlvcml0eTtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IGEgcHJpb3JpdHkgc25hcHNob3QgTm9kZSBpcyB2YWxpZC5cclxuICovXHJcbmNvbnN0IHZhbGlkYXRlUHJpb3JpdHlOb2RlID0gZnVuY3Rpb24gKHByaW9yaXR5Tm9kZSkge1xyXG4gICAgaWYgKHByaW9yaXR5Tm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSBwcmlvcml0eU5vZGUudmFsKCk7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiBjb250YWlucyh2YWwsICcuc3YnKSksICdQcmlvcml0eSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci4nKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFJDIgfHwgcHJpb3JpdHlOb2RlLmlzRW1wdHkoKSwgJ3ByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS4nKTtcclxuICAgIH1cclxuICAgIC8vIERvbid0IGNhbGwgZ2V0UHJpb3JpdHkoKSBvbiBNQVhfTk9ERSB0byBhdm9pZCBoaXR0aW5nIGFzc2VydGlvbi5cclxuICAgIGFzc2VydChwcmlvcml0eU5vZGUgPT09IE1BWF9OT0RFJDIgfHwgcHJpb3JpdHlOb2RlLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpLCBcIlByaW9yaXR5IG5vZGVzIGNhbid0IGhhdmUgYSBwcmlvcml0eSBvZiB0aGVpciBvd24uXCIpO1xyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvcjtcclxuLyoqXHJcbiAqIExlYWZOb2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgbGVhZiBub2RlcyBpbiBhIERhdGFTbmFwc2hvdC4gIEl0XHJcbiAqIGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSAoYSBzdHJpbmcsXHJcbiAqIG51bWJlciwgb3IgYm9vbGVhbikgYWNjZXNzaWJsZSB2aWEgZ2V0VmFsdWUoKS5cclxuICovXHJcbmNsYXNzIExlYWZOb2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHZhbHVlXyAtIFRoZSB2YWx1ZSB0byBzdG9yZSBpbiB0aGlzIGxlYWYgbm9kZS4gVGhlIG9iamVjdCB0eXBlIGlzXHJcbiAgICAgKiBwb3NzaWJsZSBpbiB0aGUgZXZlbnQgb2YgYSBkZWZlcnJlZCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHByaW9yaXR5Tm9kZV8gLSBUaGUgcHJpb3JpdHkgb2YgdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZV8sIHByaW9yaXR5Tm9kZV8gPSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcclxuICAgICAgICB0aGlzLnZhbHVlXyA9IHZhbHVlXztcclxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcclxuICAgICAgICBhc3NlcnQodGhpcy52YWx1ZV8gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlXyAhPT0gbnVsbCwgXCJMZWFmTm9kZSBzaG91bGRuJ3QgYmUgY3JlYXRlZCB3aXRoIG51bGwvdW5kZWZpbmVkIHZhbHVlLlwiKTtcclxuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBfX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgICAgIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzTGVhZk5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUodGhpcy52YWx1ZV8sIG5ld1ByaW9yaXR5Tm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIC8vIEhhY2sgdG8gdHJlYXQgcHJpb3JpdHkgYXMgYSByZWd1bGFyIGNoaWxkXHJcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0NoaWxkKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpIHtcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpICYmIGNoaWxkTmFtZSAhPT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKS51cGRhdGVQcmlvcml0eSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdXBkYXRlQ2hpbGQocGF0aCwgbmV3Q2hpbGROb2RlKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkgJiYgZnJvbnQgIT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KGZyb250ICE9PSAnLnByaW9yaXR5JyB8fCBwYXRoR2V0TGVuZ3RoKHBhdGgpID09PSAxLCAnLnByaW9yaXR5IG11c3QgYmUgdGhlIGxhc3QgdG9rZW4gaW4gYSBwYXRoJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGZyb250LCBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUudXBkYXRlQ2hpbGQocGF0aFBvcEZyb250KHBhdGgpLCBuZXdDaGlsZE5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBudW1DaGlsZHJlbigpIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZm9yRWFjaENoaWxkKGluZGV4LCBhY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YWwoZXhwb3J0Rm9ybWF0KSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydEZvcm1hdCAmJiAhdGhpcy5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgJy52YWx1ZSc6IHRoaXMuZ2V0VmFsdWUoKSxcclxuICAgICAgICAgICAgICAgICcucHJpb3JpdHknOiB0aGlzLmdldFByaW9yaXR5KCkudmFsKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBoYXNoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxhenlIYXNoXyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXQgdG9IYXNoID0gJyc7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmlvcml0eU5vZGVfLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgdG9IYXNoICs9XHJcbiAgICAgICAgICAgICAgICAgICAgJ3ByaW9yaXR5OicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eUhhc2hUZXh0KHRoaXMucHJpb3JpdHlOb2RlXy52YWwoKSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcclxuICAgICAgICAgICAgdG9IYXNoICs9IHR5cGUgKyAnOic7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdG9IYXNoICs9IGRvdWJsZVRvSUVFRTc1NFN0cmluZyh0aGlzLnZhbHVlXyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz0gdGhpcy52YWx1ZV87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBzaGExKHRvSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGxlYWYgbm9kZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgbm9kZS5cclxuICAgICAqL1xyXG4gICAgZ2V0VmFsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyIGluc3RhbmNlb2YgTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQob3RoZXIuaXNMZWFmTm9kZSgpLCAnVW5rbm93biBub2RlIHR5cGUnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvTGVhZk5vZGVfKG90aGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmlzb24gc3BlY2lmaWNhbGx5IGZvciB0d28gbGVhZiBub2Rlc1xyXG4gICAgICovXHJcbiAgICBjb21wYXJlVG9MZWFmTm9kZV8ob3RoZXJMZWFmKSB7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJMZWFmVHlwZSA9IHR5cGVvZiBvdGhlckxlYWYudmFsdWVfO1xyXG4gICAgICAgIGNvbnN0IHRoaXNMZWFmVHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcclxuICAgICAgICBjb25zdCBvdGhlckluZGV4ID0gTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUi5pbmRleE9mKG90aGVyTGVhZlR5cGUpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNJbmRleCA9IExlYWZOb2RlLlZBTFVFX1RZUEVfT1JERVIuaW5kZXhPZih0aGlzTGVhZlR5cGUpO1xyXG4gICAgICAgIGFzc2VydChvdGhlckluZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIG90aGVyTGVhZlR5cGUpO1xyXG4gICAgICAgIGFzc2VydCh0aGlzSW5kZXggPj0gMCwgJ1Vua25vd24gbGVhZiB0eXBlOiAnICsgdGhpc0xlYWZUeXBlKTtcclxuICAgICAgICBpZiAob3RoZXJJbmRleCA9PT0gdGhpc0luZGV4KSB7XHJcbiAgICAgICAgICAgIC8vIFNhbWUgdHlwZSwgY29tcGFyZSB2YWx1ZXNcclxuICAgICAgICAgICAgaWYgKHRoaXNMZWFmVHlwZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkIHZhbHVlIG5vZGVzIGFyZSBhbGwgZXF1YWwsIGJ1dCB3ZSBzaG91bGQgYWxzbyBuZXZlciBnZXQgdG8gdGhpcyBwb2ludC4uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3b3JrcyBiZWNhdXNlIHRydWUgPiBmYWxzZSwgYWxsIG90aGVycyBhcmUgbnVtYmVyIG9yIHN0cmluZyBjb21wYXJpc29uc1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVfIDwgb3RoZXJMZWFmLnZhbHVlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVfID09PSBvdGhlckxlYWYudmFsdWVfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNJbmRleCAtIG90aGVySW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2l0aEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaXNJbmRleGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJMZWFmID0gb3RoZXI7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YWx1ZV8gPT09IG90aGVyTGVhZi52YWx1ZV8gJiZcclxuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXy5lcXVhbHMob3RoZXJMZWFmLnByaW9yaXR5Tm9kZV8pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBzb3J0IG9yZGVyIGZvciBjb21wYXJpbmcgbGVhZiBub2RlcyBvZiBkaWZmZXJlbnQgdHlwZXMuIElmIHR3byBsZWFmIG5vZGVzIGhhdmVcclxuICogdGhlIHNhbWUgdHlwZSwgdGhlIGNvbXBhcmlzb24gZmFsbHMgYmFjayB0byB0aGVpciB2YWx1ZVxyXG4gKi9cclxuTGVhZk5vZGUuVkFMVUVfVFlQRV9PUkRFUiA9IFsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ3N0cmluZyddO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5sZXQgbm9kZUZyb21KU09OJDE7XHJcbmxldCBNQVhfTk9ERSQxO1xyXG5mdW5jdGlvbiBzZXROb2RlRnJvbUpTT04odmFsKSB7XHJcbiAgICBub2RlRnJvbUpTT04kMSA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzZXRNYXhOb2RlKHZhbCkge1xyXG4gICAgTUFYX05PREUkMSA9IHZhbDtcclxufVxyXG5jbGFzcyBQcmlvcml0eUluZGV4IGV4dGVuZHMgSW5kZXgge1xyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYVByaW9yaXR5ID0gYS5ub2RlLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgY29uc3QgYlByaW9yaXR5ID0gYi5ub2RlLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhDbXAgPSBhUHJpb3JpdHkuY29tcGFyZVRvKGJQcmlvcml0eSk7XHJcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNEZWZpbmVkT24obm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhbm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5nZXRQcmlvcml0eSgpLmVxdWFscyhuZXdOb2RlLmdldFByaW9yaXR5KCkpO1xyXG4gICAgfVxyXG4gICAgbWluUG9zdCgpIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG4gICAgICAgIHJldHVybiBOYW1lZE5vZGUuTUlOO1xyXG4gICAgfVxyXG4gICAgbWF4UG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShNQVhfTkFNRSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBNQVhfTk9ERSQxKSk7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgcHJpb3JpdHlOb2RlID0gbm9kZUZyb21KU09OJDEoaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUobmFtZSwgbmV3IExlYWZOb2RlKCdbUFJJT1JJVFktUE9TVF0nLCBwcmlvcml0eU5vZGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgU3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBpbmNsdXNpb24gaW4gYSBxdWVyeSBzcGVjXHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAnLnByaW9yaXR5JztcclxuICAgIH1cclxufVxyXG5jb25zdCBQUklPUklUWV9JTkRFWCA9IG5ldyBQcmlvcml0eUluZGV4KCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNvbnN0IExPR18yID0gTWF0aC5sb2coMik7XHJcbmNsYXNzIEJhc2UxMk51bSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBsb2dCYXNlMiA9IChudW0pID0+IFxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcGFyc2VJbnQoKE1hdGgubG9nKG51bSkgLyBMT0dfMiksIDEwKTtcclxuICAgICAgICBjb25zdCBiaXRNYXNrID0gKGJpdHMpID0+IHBhcnNlSW50KEFycmF5KGJpdHMgKyAxKS5qb2luKCcxJyksIDIpO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBsb2dCYXNlMihsZW5ndGggKyAxKTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRfID0gdGhpcy5jb3VudCAtIDE7XHJcbiAgICAgICAgY29uc3QgbWFzayA9IGJpdE1hc2sodGhpcy5jb3VudCk7XHJcbiAgICAgICAgdGhpcy5iaXRzXyA9IChsZW5ndGggKyAxKSAmIG1hc2s7XHJcbiAgICB9XHJcbiAgICBuZXh0Qml0SXNPbmUoKSB7XHJcbiAgICAgICAgLy9ub2luc3BlY3Rpb24gSlNCaXR3aXNlT3BlcmF0b3JVc2FnZVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICEodGhpcy5iaXRzXyAmICgweDEgPDwgdGhpcy5jdXJyZW50XykpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudF8tLTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUYWtlcyBhIGxpc3Qgb2YgY2hpbGQgbm9kZXMgYW5kIGNvbnN0cnVjdHMgYSBTb3J0ZWRTZXQgdXNpbmcgdGhlIGdpdmVuIGNvbXBhcmlzb25cclxuICogZnVuY3Rpb25cclxuICpcclxuICogVXNlcyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZCBpbiB0aGUgcGFwZXIgbGlua2VkIGhlcmU6XHJcbiAqIGh0dHA6Ly9jaXRlc2VlcnguaXN0LnBzdS5lZHUvdmlld2RvYy9zdW1tYXJ5P2RvaT0xMC4xLjEuNDYuMTQ1OFxyXG4gKlxyXG4gKiBAcGFyYW0gY2hpbGRMaXN0IC0gVW5zb3J0ZWQgbGlzdCBvZiBjaGlsZHJlblxyXG4gKiBAcGFyYW0gY21wIC0gVGhlIGNvbXBhcmlzb24gbWV0aG9kIHRvIGJlIHVzZWRcclxuICogQHBhcmFtIGtleUZuIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXh0cmFjdCBLIGZyb20gYSBub2RlIHdyYXBwZXIsIGlmIEsnc1xyXG4gKiB0eXBlIGlzIG5vdCBOYW1lZE5vZGVcclxuICogQHBhcmFtIG1hcFNvcnRGbiAtIEFuIG9wdGlvbmFsIG92ZXJyaWRlIGZvciBjb21wYXJhdG9yIHVzZWQgYnkgdGhlIGdlbmVyYXRlZCBzb3J0ZWQgbWFwXHJcbiAqL1xyXG5jb25zdCBidWlsZENoaWxkU2V0ID0gZnVuY3Rpb24gKGNoaWxkTGlzdCwgY21wLCBrZXlGbiwgbWFwU29ydEZuKSB7XHJcbiAgICBjaGlsZExpc3Quc29ydChjbXApO1xyXG4gICAgY29uc3QgYnVpbGRCYWxhbmNlZFRyZWUgPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaGlnaCAtIGxvdztcclxuICAgICAgICBsZXQgbmFtZWROb2RlO1xyXG4gICAgICAgIGxldCBrZXk7XHJcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFtsb3ddO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29uc3QgbWlkZGxlID0gcGFyc2VJbnQoKGxlbmd0aCAvIDIpLCAxMCkgKyBsb3c7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBidWlsZEJhbGFuY2VkVHJlZShsb3csIG1pZGRsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gYnVpbGRCYWxhbmNlZFRyZWUobWlkZGxlICsgMSwgaGlnaCk7XHJcbiAgICAgICAgICAgIG5hbWVkTm9kZSA9IGNoaWxkTGlzdFttaWRkbGVdO1xyXG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgTExSQk5vZGUuQkxBQ0ssIGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgYnVpbGRGcm9tMTJBcnJheSA9IGZ1bmN0aW9uIChiYXNlMTIpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgbGV0IHJvb3QgPSBudWxsO1xyXG4gICAgICAgIGxldCBpbmRleCA9IGNoaWxkTGlzdC5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYnVpbGRQZW5uYW50ID0gZnVuY3Rpb24gKGNodW5rU2l6ZSwgY29sb3IpIHtcclxuICAgICAgICAgICAgY29uc3QgbG93ID0gaW5kZXggLSBjaHVua1NpemU7XHJcbiAgICAgICAgICAgIGNvbnN0IGhpZ2ggPSBpbmRleDtcclxuICAgICAgICAgICAgaW5kZXggLT0gY2h1bmtTaXplO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSBidWlsZEJhbGFuY2VkVHJlZShsb3cgKyAxLCBoaWdoKTtcclxuICAgICAgICAgICAgY29uc3QgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcclxuICAgICAgICAgICAgYXR0YWNoUGVubmFudChuZXcgTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgY29sb3IsIG51bGwsIGNoaWxkVHJlZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgYXR0YWNoUGVubmFudCA9IGZ1bmN0aW9uIChwZW5uYW50KSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb290ID0gcGVubmFudDtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBwZW5uYW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2UxMi5jb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzT25lID0gYmFzZTEyLm5leHRCaXRJc09uZSgpO1xyXG4gICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIG5vZGVzIHRha2VuIGluIGVhY2ggc2xpY2UgaXMgMl4oYXJyLmxlbmd0aCAtIChpICsgMSkpXHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgucG93KDIsIGJhc2UxMi5jb3VudCAtIChpICsgMSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNPbmUpIHtcclxuICAgICAgICAgICAgICAgIGJ1aWxkUGVubmFudChjaHVua1NpemUsIExMUkJOb2RlLkJMQUNLKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgPT0gMlxyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuQkxBQ0spO1xyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgTExSQk5vZGUuUkVEKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH07XHJcbiAgICBjb25zdCBiYXNlMTIgPSBuZXcgQmFzZTEyTnVtKGNoaWxkTGlzdC5sZW5ndGgpO1xyXG4gICAgY29uc3Qgcm9vdCA9IGJ1aWxkRnJvbTEyQXJyYXkoYmFzZTEyKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcChtYXBTb3J0Rm4gfHwgY21wLCByb290KTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IF9kZWZhdWx0SW5kZXhNYXA7XHJcbmNvbnN0IGZhbGxiYWNrT2JqZWN0ID0ge307XHJcbmNsYXNzIEluZGV4TWFwIHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4ZXNfLCBpbmRleFNldF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4ZXNfID0gaW5kZXhlc187XHJcbiAgICAgICAgdGhpcy5pbmRleFNldF8gPSBpbmRleFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IEluZGV4TWFwIGZvciBub2RlcyB3aXRob3V0IGEgcHJpb3JpdHlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICAgIGFzc2VydChmYWxsYmFja09iamVjdCAmJiBQUklPUklUWV9JTkRFWCwgJ0NoaWxkcmVuTm9kZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XHJcbiAgICAgICAgX2RlZmF1bHRJbmRleE1hcCA9XHJcbiAgICAgICAgICAgIF9kZWZhdWx0SW5kZXhNYXAgfHxcclxuICAgICAgICAgICAgICAgIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBmYWxsYmFja09iamVjdCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KTtcclxuICAgICAgICByZXR1cm4gX2RlZmF1bHRJbmRleE1hcDtcclxuICAgIH1cclxuICAgIGdldChpbmRleEtleSkge1xyXG4gICAgICAgIGNvbnN0IHNvcnRlZE1hcCA9IHNhZmVHZXQodGhpcy5pbmRleGVzXywgaW5kZXhLZXkpO1xyXG4gICAgICAgIGlmICghc29ydGVkTWFwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5kZXggZGVmaW5lZCBmb3IgJyArIGluZGV4S2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvcnRlZE1hcCBpbnN0YW5jZW9mIFNvcnRlZE1hcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc29ydGVkTWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGluZGV4IGV4aXN0cywgYnV0IGl0IGZhbGxzIGJhY2sgdG8ganVzdCBuYW1lIGNvbXBhcmlzb24uIFJldHVybiBudWxsIHNvIHRoYXQgdGhlIGNhbGxpbmcgY29kZSB1c2VzIHRoZVxyXG4gICAgICAgICAgICAvLyByZWd1bGFyIGNoaWxkIG1hcFxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNJbmRleChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gY29udGFpbnModGhpcy5pbmRleFNldF8sIGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpKTtcclxuICAgIH1cclxuICAgIGFkZEluZGV4KGluZGV4RGVmaW5pdGlvbiwgZXhpc3RpbmdDaGlsZHJlbikge1xyXG4gICAgICAgIGFzc2VydChpbmRleERlZmluaXRpb24gIT09IEtFWV9JTkRFWCwgXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCIpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCBzYXdJbmRleGVkVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBpdGVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXRJdGVyYXRvcihOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB3aGlsZSAobmV4dCkge1xyXG4gICAgICAgICAgICBzYXdJbmRleGVkVmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgc2F3SW5kZXhlZFZhbHVlIHx8IGluZGV4RGVmaW5pdGlvbi5pc0RlZmluZWRPbihuZXh0Lm5vZGUpO1xyXG4gICAgICAgICAgICBjaGlsZExpc3QucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3SW5kZXg7XHJcbiAgICAgICAgaWYgKHNhd0luZGV4ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICBuZXdJbmRleCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleERlZmluaXRpb24uZ2V0Q29tcGFyZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4ID0gZmFsbGJhY2tPYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGluZGV4TmFtZSA9IGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IG5ld0luZGV4U2V0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbmRleFNldF8pO1xyXG4gICAgICAgIG5ld0luZGV4U2V0W2luZGV4TmFtZV0gPSBpbmRleERlZmluaXRpb247XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW5kZXhlc18pO1xyXG4gICAgICAgIG5ld0luZGV4ZXNbaW5kZXhOYW1lXSA9IG5ld0luZGV4O1xyXG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgbmV3SW5kZXhTZXQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGlzIG5vZGUgaXMgcHJvcGVybHkgdHJhY2tlZCBpbiBhbnkgaW5kZXhlcyB0aGF0IHdlJ3JlIG1haW50YWluaW5nXHJcbiAgICAgKi9cclxuICAgIGFkZFRvSW5kZXhlcyhuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcclxuICAgICAgICBjb25zdCBuZXdJbmRleGVzID0gbWFwKHRoaXMuaW5kZXhlc18sIChpbmRleGVkQ2hpbGRyZW4sIGluZGV4TmFtZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHNhZmVHZXQodGhpcy5pbmRleFNldF8sIGluZGV4TmFtZSk7XHJcbiAgICAgICAgICAgIGFzc2VydChpbmRleCwgJ01pc3NpbmcgaW5kZXggaW1wbGVtZW50YXRpb24gZm9yICcgKyBpbmRleE5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXhlZENoaWxkcmVuID09PSBmYWxsYmFja09iamVjdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gaW5kZXggZXZlcnl0aGluZ1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4LmlzRGVmaW5lZE9uKG5hbWVkTm9kZS5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYnVpbGQgdGhpcyBpbmRleFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5hbWVkTm9kZS5XcmFwKTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Lm5hbWUgIT09IG5hbWVkTm9kZS5uYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZExpc3QucHVzaChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5hbWVkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleC5nZXRDb21wYXJlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCB0aGlzIHJlbWFpbnMgYSBmYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFja09iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU25hcCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5hbWVkTm9kZS5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbiA9IGluZGV4ZWRDaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1NuYXApIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IG5ld0NoaWxkcmVuLnJlbW92ZShuZXcgTmFtZWROb2RlKG5hbWVkTm9kZS5uYW1lLCBleGlzdGluZ1NuYXApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZHJlbi5pbnNlcnQobmFtZWROb2RlLCBuYW1lZE5vZGUubm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IEluZGV4TWFwIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRnJvbUluZGV4ZXMobmFtZWROb2RlLCBleGlzdGluZ0NoaWxkcmVuKSB7XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IG1hcCh0aGlzLmluZGV4ZXNfLCAoaW5kZXhlZENoaWxkcmVuKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmYWxsYmFjay4gSnVzdCByZXR1cm4gaXQsIG5vdGhpbmcgdG8gZG8gaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW4ucmVtb3ZlKG5ldyBOYW1lZE5vZGUobmFtZWROb2RlLm5hbWUsIGV4aXN0aW5nU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkIG9mIHRoaXMgY2hpbGRcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhlZENoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE1hcChuZXdJbmRleGVzLCB0aGlzLmluZGV4U2V0Xyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gVE9ETzogRm9yIG1lbW9yeSBzYXZpbmdzLCBkb24ndCBzdG9yZSBwcmlvcml0eU5vZGVfIGlmIGl0J3MgZW1wdHkuXHJcbmxldCBFTVBUWV9OT0RFO1xyXG4vKipcclxuICogQ2hpbGRyZW5Ob2RlIGlzIGEgY2xhc3MgZm9yIHN0b3JpbmcgaW50ZXJuYWwgbm9kZXMgaW4gYSBEYXRhU25hcHNob3RcclxuICogKGkuZS4gbm9kZXMgd2l0aCBjaGlsZHJlbikuICBJdCBpbXBsZW1lbnRzIE5vZGUgYW5kIHN0b3JlcyB0aGVcclxuICogbGlzdCBvZiBjaGlsZHJlbiBpbiB0aGUgY2hpbGRyZW4gcHJvcGVydHksIHNvcnRlZCBieSBjaGlsZCBuYW1lLlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRyZW5Ob2RlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNoaWxkcmVuXyAtIExpc3Qgb2YgY2hpbGRyZW4gb2YgdGhpcyBub2RlLi5cclxuICAgICAqIEBwYXJhbSBwcmlvcml0eU5vZGVfIC0gVGhlIHByaW9yaXR5IG9mIHRoaXMgbm9kZSAoYXMgYSBzbmFwc2hvdCBub2RlKS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW5fLCBwcmlvcml0eU5vZGVfLCBpbmRleE1hcF8pIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IGNoaWxkcmVuXztcclxuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xyXG4gICAgICAgIHRoaXMuaW5kZXhNYXBfID0gaW5kZXhNYXBfO1xyXG4gICAgICAgIHRoaXMubGF6eUhhc2hfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOb3RlOiBUaGUgb25seSByZWFzb24gd2UgYWxsb3cgbnVsbCBwcmlvcml0eSBpcyBmb3IgRU1QVFlfTk9ERSwgc2luY2Ugd2UgY2FuJ3QgdXNlXHJcbiAgICAgICAgICogRU1QVFlfTk9ERSBhcyB0aGUgcHJpb3JpdHkgb2YgRU1QVFlfTk9ERS4gIFdlIG1pZ2h0IHdhbnQgdG8gY29uc2lkZXIgbWFraW5nIEVNUFRZX05PREUgaXRzIG93blxyXG4gICAgICAgICAqIGNsYXNzIGluc3RlYWQgb2YgYW4gZW1wdHkgQ2hpbGRyZW5Ob2RlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLnByaW9yaXR5Tm9kZV8pIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVQcmlvcml0eU5vZGUodGhpcy5wcmlvcml0eU5vZGVfKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICBhc3NlcnQoIXRoaXMucHJpb3JpdHlOb2RlXyB8fCB0aGlzLnByaW9yaXR5Tm9kZV8uaXNFbXB0eSgpLCAnQW4gZW1wdHkgbm9kZSBjYW5ub3QgaGF2ZSBhIHByaW9yaXR5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBFTVBUWV9OT0RFKCkge1xyXG4gICAgICAgIHJldHVybiAoRU1QVFlfTk9ERSB8fFxyXG4gICAgICAgICAgICAoRU1QVFlfTk9ERSA9IG5ldyBDaGlsZHJlbk5vZGUobmV3IFNvcnRlZE1hcChOQU1FX0NPTVBBUkFUT1IpLCBudWxsLCBJbmRleE1hcC5EZWZhdWx0KSkpO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBpc0xlYWZOb2RlKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJpb3JpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXyB8fCBFTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVQcmlvcml0eShuZXdQcmlvcml0eU5vZGUpIHtcclxuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGFsbG93IHByaW9yaXRpZXMgb24gZW1wdHkgbm9kZXNcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgbmV3UHJpb3JpdHlOb2RlLCB0aGlzLmluZGV4TWFwXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICAvLyBIYWNrIHRvIHRyZWF0IHByaW9yaXR5IGFzIGEgcmVndWxhciBjaGlsZFxyXG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByaW9yaXR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGQgPT09IG51bGwgPyBFTVBUWV9OT0RFIDogY2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICBnZXRDaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKGZyb250ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkuZ2V0Q2hpbGQocGF0aFBvcEZyb250KHBhdGgpKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgaGFzQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICB1cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGFzc2VydChuZXdDaGlsZE5vZGUsICdXZSBzaG91bGQgYWx3YXlzIGJlIHBhc3Npbmcgc25hcHNob3Qgbm9kZXMnKTtcclxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbiwgbmV3SW5kZXhNYXA7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZE5vZGUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5fLnJlbW92ZShjaGlsZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5yZW1vdmVGcm9tSW5kZXhlcyhuYW1lZE5vZGUsIHRoaXMuY2hpbGRyZW5fKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbl8uaW5zZXJ0KGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8uYWRkVG9JbmRleGVzKG5hbWVkTm9kZSwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ByaW9yaXR5ID0gbmV3Q2hpbGRyZW4uaXNFbXB0eSgpXHJcbiAgICAgICAgICAgICAgICA/IEVNUFRZX05PREVcclxuICAgICAgICAgICAgICAgIDogdGhpcy5wcmlvcml0eU5vZGVfO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShuZXdDaGlsZHJlbiwgbmV3UHJpb3JpdHksIG5ld0luZGV4TWFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHVwZGF0ZUNoaWxkKHBhdGgsIG5ld0NoaWxkTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgIGlmIChmcm9udCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3Q2hpbGROb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRGcm9udChwYXRoKSAhPT0gJy5wcmlvcml0eScgfHwgcGF0aEdldExlbmd0aChwYXRoKSA9PT0gMSwgJy5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aCcpO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJbW1lZGlhdGVDaGlsZCA9IHRoaXMuZ2V0SW1tZWRpYXRlQ2hpbGQoZnJvbnQpLnVwZGF0ZUNoaWxkKHBhdGhQb3BGcm9udChwYXRoKSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIG5ld0ltbWVkaWF0ZUNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgbnVtQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmNvdW50KCk7XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIHZhbChleHBvcnRGb3JtYXQpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xyXG4gICAgICAgIGxldCBudW1LZXlzID0gMCwgbWF4S2V5ID0gMCwgYWxsSW50ZWdlcktleXMgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgb2JqW2tleV0gPSBjaGlsZE5vZGUudmFsKGV4cG9ydEZvcm1hdCk7XHJcbiAgICAgICAgICAgIG51bUtleXMrKztcclxuICAgICAgICAgICAgaWYgKGFsbEludGVnZXJLZXlzICYmIENoaWxkcmVuTm9kZS5JTlRFR0VSX1JFR0VYUF8udGVzdChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhLZXkgPSBNYXRoLm1heChtYXhLZXksIE51bWJlcihrZXkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFsbEludGVnZXJLZXlzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIWV4cG9ydEZvcm1hdCAmJiBhbGxJbnRlZ2VyS2V5cyAmJiBtYXhLZXkgPCAyICogbnVtS2V5cykge1xyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIGFycmF5LlxyXG4gICAgICAgICAgICBjb25zdCBhcnJheSA9IFtdO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChleHBvcnRGb3JtYXQgJiYgIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIG9ialsnLnByaW9yaXR5J10gPSB0aGlzLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgIGhhc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGF6eUhhc2hfID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGxldCB0b0hhc2ggPSAnJztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz1cclxuICAgICAgICAgICAgICAgICAgICAncHJpb3JpdHk6JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5SGFzaFRleHQodGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEhhc2ggPSBjaGlsZE5vZGUuaGFzaCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkSGFzaCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0hhc2ggKz0gJzonICsga2V5ICsgJzonICsgY2hpbGRIYXNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSB0b0hhc2ggPT09ICcnID8gJycgOiBzaGExKHRvSGFzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoY2hpbGROYW1lLCBjaGlsZE5vZGUsIGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4KTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZWRlY2Vzc29yID0gaWR4LmdldFByZWRlY2Vzc29yS2V5KG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByZWRlY2Vzc29yID8gcHJlZGVjZXNzb3IubmFtZSA6IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0UHJlZGVjZXNzb3JLZXkoY2hpbGROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbktleSA9IGlkeC5taW5LZXkoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1pbktleSAmJiBtaW5LZXkubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuXy5taW5LZXkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRGaXJzdENoaWxkKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IG1pbktleSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAobWluS2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG1pbktleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1pbktleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhbiBpbmRleCwgcmV0dXJuIHRoZSBrZXkgbmFtZSBvZiB0aGUgbGFyZ2VzdCB2YWx1ZSB3ZSBoYXZlLCBhY2NvcmRpbmcgdG8gdGhhdCBpbmRleFxyXG4gICAgICovXHJcbiAgICBnZXRMYXN0Q2hpbGROYW1lKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF4S2V5ID0gaWR4Lm1heEtleSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF4S2V5ICYmIG1heEtleS5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1heEtleSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldExhc3RDaGlsZChpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBtYXhLZXkgPSB0aGlzLmdldExhc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAobWF4S2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG1heEtleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1heEtleSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yRWFjaENoaWxkKGluZGV4LCBhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5pbm9yZGVyVHJhdmVyc2FsKHdyYXBwZWROb2RlID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24od3JhcHBlZE5vZGUubmFtZSwgd3JhcHBlZE5vZGUubm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRJdGVyYXRvcihpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJdGVyYXRvckZyb20oaW5kZXhEZWZpbml0aW9uLm1pblBvc3QoKSwgaW5kZXhEZWZpbml0aW9uKTtcclxuICAgIH1cclxuICAgIGdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xyXG4gICAgICAgIGlmIChpZHgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBrZXkgPT4ga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5jaGlsZHJlbl8uZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIHN0YXJ0UG9zdCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRSZXZlcnNlSXRlcmF0b3IoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWF4UG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBpbmRleERlZmluaXRpb24pIHtcclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcclxuICAgICAgICBpZiAoaWR4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpZHguZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShlbmRQb3N0LCBrZXkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuY2hpbGRyZW5fLmdldFJldmVyc2VJdGVyYXRvckZyb20oZW5kUG9zdC5uYW1lLCBOYW1lZE5vZGUuV3JhcCk7XHJcbiAgICAgICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPSBudWxsICYmIGluZGV4RGVmaW5pdGlvbi5jb21wYXJlKG5leHQsIGVuZFBvc3QpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0b3IuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29tcGFyZVRvKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSB8fCBvdGhlci5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyID09PSBNQVhfTk9ERSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNdXN0IGJlIGFub3RoZXIgbm9kZSB3aXRoIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB3aXRoSW5kZXgoaW5kZXhEZWZpbml0aW9uKSB7XHJcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS0VZX0lOREVYIHx8XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYXBfLmhhc0luZGV4KGluZGV4RGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdJbmRleE1hcCA9IHRoaXMuaW5kZXhNYXBfLmFkZEluZGV4KGluZGV4RGVmaW5pdGlvbiwgdGhpcy5jaGlsZHJlbl8pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZSh0aGlzLmNoaWxkcmVuXywgdGhpcy5wcmlvcml0eU5vZGVfLCBuZXdJbmRleE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNJbmRleGVkKGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSBLRVlfSU5ERVggfHwgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgZXF1YWxzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgb3RoZXJDaGlsZHJlbk5vZGUgPSBvdGhlcjtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuZXF1YWxzKG90aGVyQ2hpbGRyZW5Ob2RlLmdldFByaW9yaXR5KCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHJlbl8uY291bnQoKSA9PT0gb3RoZXJDaGlsZHJlbk5vZGUuY2hpbGRyZW5fLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNJdGVyID0gdGhpcy5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckl0ZXIgPSBvdGhlckNoaWxkcmVuTm9kZS5nZXRJdGVyYXRvcihQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgb3RoZXJDdXJyZW50ID0gb3RoZXJJdGVyLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzQ3VycmVudCAmJiBvdGhlckN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0N1cnJlbnQubmFtZSAhPT0gb3RoZXJDdXJyZW50Lm5hbWUgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXNDdXJyZW50Lm5vZGUuZXF1YWxzKG90aGVyQ3VycmVudC5ub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNDdXJyZW50ID0gdGhpc0l0ZXIuZ2V0TmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyQ3VycmVudCA9IG90aGVySXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0N1cnJlbnQgPT09IG51bGwgJiYgb3RoZXJDdXJyZW50ID09PSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgU29ydGVkTWFwIG9yZGVyZWQgYnkgaW5kZXgsIG9yIG51bGwgaWYgdGhlIGRlZmF1bHQgKGJ5LWtleSkgb3JkZXJpbmcgY2FuIGJlIHVzZWRcclxuICAgICAqIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICByZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbikge1xyXG4gICAgICAgIGlmIChpbmRleERlZmluaXRpb24gPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFwXy5nZXQoaW5kZXhEZWZpbml0aW9uLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5DaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfID0gL14oMHxbMS05XVxcZCopJC87XHJcbmNsYXNzIE1heE5vZGUgZXh0ZW5kcyBDaGlsZHJlbk5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIobmV3IFNvcnRlZE1hcChOQU1FX0NPTVBBUkFUT1IpLCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgSW5kZXhNYXAuRGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcclxuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlcXVhbHMob3RoZXIpIHtcclxuICAgICAgICAvLyBOb3QgdGhhdCB3ZSBldmVyeSBjb21wYXJlIGl0LCBidXQgTUFYX05PREUgaXMgb25seSBldmVyIGVxdWFsIHRvIGl0c2VsZlxyXG4gICAgICAgIHJldHVybiBvdGhlciA9PT0gdGhpcztcclxuICAgIH1cclxuICAgIGdldFByaW9yaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hcmtlciB0aGF0IHdpbGwgc29ydCBoaWdoZXIgdGhhbiBhbnkgb3RoZXIgc25hcHNob3QuXHJcbiAqL1xyXG5jb25zdCBNQVhfTk9ERSA9IG5ldyBNYXhOb2RlKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE5hbWVkTm9kZSwge1xyXG4gICAgTUlOOiB7XHJcbiAgICAgICAgdmFsdWU6IG5ldyBOYW1lZE5vZGUoTUlOX05BTUUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKVxyXG4gICAgfSxcclxuICAgIE1BWDoge1xyXG4gICAgICAgIHZhbHVlOiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBNQVhfTk9ERSlcclxuICAgIH1cclxufSk7XHJcbi8qKlxyXG4gKiBSZWZlcmVuY2UgRXh0ZW5zaW9uc1xyXG4gKi9cclxuS2V5SW5kZXguX19FTVBUWV9OT0RFID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbkxlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IgPSBDaGlsZHJlbk5vZGU7XHJcbnNldE1heE5vZGUkMShNQVhfTk9ERSk7XHJcbnNldE1heE5vZGUoTUFYX05PREUpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBVU0VfSElOWkUgPSB0cnVlO1xyXG4vKipcclxuICogQ29uc3RydWN0cyBhIHNuYXBzaG90IG5vZGUgcmVwcmVzZW50aW5nIHRoZSBwYXNzZWQgSlNPTiBhbmQgcmV0dXJucyBpdC5cclxuICogQHBhcmFtIGpzb24gLSBKU09OIHRvIGNyZWF0ZSBhIG5vZGUgZm9yLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBPcHRpb25hbCBwcmlvcml0eSB0byB1c2UuICBUaGlzIHdpbGwgYmUgaWdub3JlZCBpZiB0aGVcclxuICogcGFzc2VkIEpTT04gY29udGFpbnMgYSAucHJpb3JpdHkgcHJvcGVydHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlRnJvbUpTT04oanNvbiwgcHJpb3JpdHkgPSBudWxsKSB7XHJcbiAgICBpZiAoanNvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcgJiYgJy5wcmlvcml0eScgaW4ganNvbikge1xyXG4gICAgICAgIHByaW9yaXR5ID0ganNvblsnLnByaW9yaXR5J107XHJcbiAgICB9XHJcbiAgICBhc3NlcnQocHJpb3JpdHkgPT09IG51bGwgfHxcclxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgdHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICh0eXBlb2YgcHJpb3JpdHkgPT09ICdvYmplY3QnICYmICcuc3YnIGluIHByaW9yaXR5KSwgJ0ludmFsaWQgcHJpb3JpdHkgdHlwZSBmb3VuZDogJyArIHR5cGVvZiBwcmlvcml0eSk7XHJcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcudmFsdWUnIGluIGpzb24gJiYganNvblsnLnZhbHVlJ10gIT09IG51bGwpIHtcclxuICAgICAgICBqc29uID0ganNvblsnLnZhbHVlJ107XHJcbiAgICB9XHJcbiAgICAvLyBWYWxpZCBsZWFmIG5vZGVzIGluY2x1ZGUgbm9uLW9iamVjdHMgb3Igc2VydmVyLXZhbHVlIHdyYXBwZXIgb2JqZWN0c1xyXG4gICAgaWYgKHR5cGVvZiBqc29uICE9PSAnb2JqZWN0JyB8fCAnLnN2JyBpbiBqc29uKSB7XHJcbiAgICAgICAgY29uc3QganNvbkxlYWYgPSBqc29uO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGVhZk5vZGUoanNvbkxlYWYsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKCEoanNvbiBpbnN0YW5jZW9mIEFycmF5KSAmJiBVU0VfSElOWkUpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbkhhdmVQcmlvcml0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGhpbnplSnNvbk9iaiA9IGpzb247XHJcbiAgICAgICAgZWFjaChoaW56ZUpzb25PYmosIChrZXksIGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDEpICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBtZXRhZGF0YSBub2Rlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuSGF2ZVByaW9yaXR5ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5IYXZlUHJpb3JpdHkgfHwgIWNoaWxkTm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoa2V5LCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZFNldCA9IGJ1aWxkQ2hpbGRTZXQoY2hpbGRyZW4sIE5BTUVfT05MWV9DT01QQVJBVE9SLCBuYW1lZE5vZGUgPT4gbmFtZWROb2RlLm5hbWUsIE5BTUVfQ09NUEFSQVRPUik7XHJcbiAgICAgICAgaWYgKGNoaWxkcmVuSGF2ZVByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZENoaWxkU2V0ID0gYnVpbGRDaGlsZFNldChjaGlsZHJlbiwgUFJJT1JJVFlfSU5ERVguZ2V0Q29tcGFyZSgpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGUoY2hpbGRTZXQsIG5vZGVGcm9tSlNPTihwcmlvcml0eSksIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBzb3J0ZWRDaGlsZFNldCB9LCB7ICcucHJpb3JpdHknOiBQUklPUklUWV9JTkRFWCB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShjaGlsZFNldCwgbm9kZUZyb21KU09OKHByaW9yaXR5KSwgSW5kZXhNYXAuRGVmYXVsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICBlYWNoKGpzb24sIChrZXksIGNoaWxkRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY29udGFpbnMoanNvbiwga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdWJzdHJpbmcoMCwgMSkgIT09ICcuJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtZXRhZGF0YSBub2Rlcy5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGREYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlLmlzTGVhZk5vZGUoKSB8fCAhY2hpbGROb2RlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlUHJpb3JpdHkobm9kZUZyb21KU09OKHByaW9yaXR5KSk7XHJcbiAgICB9XHJcbn1cclxuc2V0Tm9kZUZyb21KU09OKG5vZGVGcm9tSlNPTik7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIFBhdGhJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4UGF0aF8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhQYXRoXyA9IGluZGV4UGF0aF87XHJcbiAgICAgICAgYXNzZXJ0KCFwYXRoSXNFbXB0eShpbmRleFBhdGhfKSAmJiBwYXRoR2V0RnJvbnQoaW5kZXhQYXRoXykgIT09ICcucHJpb3JpdHknLCBcIkNhbid0IGNyZWF0ZSBQYXRoSW5kZXggd2l0aCBlbXB0eSBwYXRoIG9yIC5wcmlvcml0eSBrZXlcIik7XHJcbiAgICB9XHJcbiAgICBleHRyYWN0Q2hpbGQoc25hcCkge1xyXG4gICAgICAgIHJldHVybiBzbmFwLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXyk7XHJcbiAgICB9XHJcbiAgICBpc0RlZmluZWRPbihub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuICFub2RlLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXykuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgY29tcGFyZShhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYUNoaWxkID0gdGhpcy5leHRyYWN0Q2hpbGQoYS5ub2RlKTtcclxuICAgICAgICBjb25zdCBiQ2hpbGQgPSB0aGlzLmV4dHJhY3RDaGlsZChiLm5vZGUpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4Q21wID0gYUNoaWxkLmNvbXBhcmVUbyhiQ2hpbGQpO1xyXG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG1ha2VQb3N0KGluZGV4VmFsdWUsIG5hbWUpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgdmFsdWVOb2RlKTtcclxuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcclxuICAgIH1cclxuICAgIG1heFBvc3QoKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgTUFYX05PREUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKE1BWF9OQU1FLCBub2RlKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoU2xpY2UodGhpcy5pbmRleFBhdGhfLCAwKS5qb2luKCcvJyk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgVmFsdWVJbmRleCBleHRlbmRzIEluZGV4IHtcclxuICAgIGNvbXBhcmUoYSwgYikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4Q21wID0gYS5ub2RlLmNvbXBhcmVUbyhiLm5vZGUpO1xyXG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmFtZUNvbXBhcmUoYS5uYW1lLCBiLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Q21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzRGVmaW5lZE9uKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGluZGV4ZWRWYWx1ZUNoYW5nZWQob2xkTm9kZSwgbmV3Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5lcXVhbHMobmV3Tm9kZSk7XHJcbiAgICB9XHJcbiAgICBtaW5Qb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NSU47XHJcbiAgICB9XHJcbiAgICBtYXhQb3N0KCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgcmV0dXJuIE5hbWVkTm9kZS5NQVg7XHJcbiAgICB9XHJcbiAgICBtYWtlUG9zdChpbmRleFZhbHVlLCBuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gbm9kZUZyb21KU09OKGluZGV4VmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTmFtZWROb2RlKG5hbWUsIHZhbHVlTm9kZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xyXG4gICAgICovXHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gJy52YWx1ZSc7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgVkFMVUVfSU5ERVggPSBuZXcgVmFsdWVJbmRleCgpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGFuZ2VWYWx1ZShzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwidmFsdWVcIiAvKiBDaGFuZ2VUeXBlLlZBTFVFICovLCBzbmFwc2hvdE5vZGUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZEFkZGVkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGROYW1lLCBzbmFwc2hvdE5vZGUsIG9sZFNuYXApIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovLFxyXG4gICAgICAgIHNuYXBzaG90Tm9kZSxcclxuICAgICAgICBjaGlsZE5hbWUsXHJcbiAgICAgICAgb2xkU25hcFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBjaGFuZ2VDaGlsZE1vdmVkKGNoaWxkTmFtZSwgc25hcHNob3ROb2RlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlOiBcImNoaWxkX21vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9NT1ZFRCAqLywgc25hcHNob3ROb2RlLCBjaGlsZE5hbWUgfTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRG9lc24ndCByZWFsbHkgZmlsdGVyIG5vZGVzIGJ1dCBhcHBsaWVzIGFuIGluZGV4IHRvIHRoZSBub2RlIGFuZCBrZWVwcyB0cmFjayBvZiBhbnkgY2hhbmdlc1xyXG4gKi9cclxuY2xhc3MgSW5kZXhlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbmRleF8pIHtcclxuICAgICAgICB0aGlzLmluZGV4XyA9IGluZGV4XztcclxuICAgIH1cclxuICAgIHVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGFzc2VydChzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksICdBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkJyk7XHJcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBzbmFwLmdldEltbWVkaWF0ZUNoaWxkKGtleSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55dGhpbmcgYWN0dWFsbHkgY2hhbmdlZC5cclxuICAgICAgICBpZiAob2xkQ2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKS5lcXVhbHMobmV3Q2hpbGQuZ2V0Q2hpbGQoYWZmZWN0ZWRQYXRoKSkpIHtcclxuICAgICAgICAgICAgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjaGlsZCBjYW4gZW50ZXIgb3IgbGVhdmUgdGhlIHZpZXcgYmVjYXVzZSBhZmZlY3RlZFBhdGggd2FzIHNldCB0byBudWxsLlxyXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFmZmVjdGVkUGF0aCB3aWxsIGFwcGVhciBudWxsIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHNuYXBzaG90cy4gIFNvIHdlIG5lZWRcclxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgdHJlYXRpbmcgdGhlc2UgY2FzZXMgYXMgXCJub3RoaW5nIGNoYW5nZWQuXCJcclxuICAgICAgICAgICAgaWYgKG9sZENoaWxkLmlzRW1wdHkoKSA9PT0gbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIGNoYW5nZWQuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXHJcbiAgICAgICAgICAgICAgICAvL2Fzc2VydChvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpLCAnT2xkIGFuZCBuZXcgc25hcHNob3RzIHNob3VsZCBiZSBlcXVhbC4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzbmFwLmhhc0NoaWxkKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIG9sZENoaWxkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhc3NlcnQoc25hcC5pc0xlYWZOb2RlKCksICdBIGNoaWxkIHJlbW92ZSB3aXRob3V0IGFuIG9sZCBjaGlsZCBvbmx5IG1ha2VzIHNlbnNlIG9uIGEgbGVhZiBub2RlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoa2V5LCBuZXdDaGlsZCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoa2V5LCBuZXdDaGlsZCwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5pc0xlYWZOb2RlKCkgJiYgbmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBub2RlIGlzIGluZGV4ZWRcclxuICAgICAgICAgICAgcmV0dXJuIHNuYXAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBuZXdDaGlsZCkud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGlmIChvcHRDaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICghb2xkU25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFNuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1NuYXAuaGFzQ2hpbGQoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkUmVtb3ZlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmV3U25hcC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkU25hcC5oYXNDaGlsZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkU25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZENoaWxkLmVxdWFscyhjaGlsZE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQ2hhbmdlZChrZXksIGNoaWxkTm9kZSwgb2xkQ2hpbGQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZEFkZGVkKGtleSwgY2hpbGROb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld1NuYXAud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByaW9yaXR5KG9sZFNuYXAsIG5ld1ByaW9yaXR5KSB7XHJcbiAgICAgICAgaWYgKG9sZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaWx0ZXJzTm9kZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogRmlsdGVycyBub2RlcyBieSByYW5nZSBhbmQgdXNlcyBhbiBJbmRleEZpbHRlciB0byB0cmFjayBhbnkgY2hhbmdlcyBhZnRlciBmaWx0ZXJpbmcgdGhlIG5vZGVcclxuICovXHJcbmNsYXNzIFJhbmdlZEZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmluZGV4ZWRGaWx0ZXJfID0gbmV3IEluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5zdGFydFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldFN0YXJ0UG9zdF8ocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmVuZFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldEVuZFBvc3RfKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5zdGFydElzSW5jbHVzaXZlXyA9ICFwYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICAgICAgdGhpcy5lbmRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICBnZXRTdGFydFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRQb3N0XztcclxuICAgIH1cclxuICAgIGdldEVuZFBvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kUG9zdF87XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG5vZGUpIHtcclxuICAgICAgICBjb25zdCBpc1dpdGhpblN0YXJ0ID0gdGhpcy5zdGFydElzSW5jbHVzaXZlX1xyXG4gICAgICAgICAgICA/IHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPD0gMFxyXG4gICAgICAgICAgICA6IHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPCAwO1xyXG4gICAgICAgIGNvbnN0IGlzV2l0aGluRW5kID0gdGhpcy5lbmRJc0luY2x1c2l2ZV9cclxuICAgICAgICAgICAgPyB0aGlzLmluZGV4Xy5jb21wYXJlKG5vZGUsIHRoaXMuZ2V0RW5kUG9zdCgpKSA8PSAwXHJcbiAgICAgICAgICAgIDogdGhpcy5pbmRleF8uY29tcGFyZShub2RlLCB0aGlzLmdldEVuZFBvc3QoKSkgPCAwO1xyXG4gICAgICAgIHJldHVybiBpc1dpdGhpblN0YXJ0ICYmIGlzV2l0aGluRW5kO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoZXMobmV3IE5hbWVkTm9kZShrZXksIG5ld0NoaWxkKSkpIHtcclxuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZEZpbHRlcl8udXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKG5ld1NuYXAuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2hpbGRyZW4gbm9kZSB3aXRoIHRoZSBjb3JyZWN0IGluZGV4LCBub3QgYSBsZWFmIG5vZGU7XHJcbiAgICAgICAgICAgIG5ld1NuYXAgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXHJcbiAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgbmV3U25hcC5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChrZXksIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXNlbGYubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgY2hpbGROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXztcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRTdGFydFBvc3RfKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzU3RhcnQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydE5hbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKSwgc3RhcnROYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuZ2V0SW5kZXgoKS5taW5Qb3N0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEVuZFBvc3RfKHBhcmFtcykge1xyXG4gICAgICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZW5kTmFtZSA9IHBhcmFtcy5nZXRJbmRleEVuZE5hbWUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCksIGVuZE5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1heFBvc3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBsaW1pdCBhbmQgYSByYW5nZSB0byBhIG5vZGUgYW5kIHVzZXMgUmFuZ2VkRmlsdGVyIHRvIGRvIHRoZSBoZWF2eSBsaWZ0aW5nIHdoZXJlIHBvc3NpYmxlXHJcbiAqL1xyXG5jbGFzcyBMaW1pdGVkRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xyXG4gICAgICAgIHRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydCA9IChub2RlKSA9PiB0aGlzLnJldmVyc2VfID8gdGhpcy53aXRoaW5FbmRQb3N0KG5vZGUpIDogdGhpcy53aXRoaW5TdGFydFBvc3Qobm9kZSk7XHJcbiAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZCA9IChub2RlKSA9PiB0aGlzLnJldmVyc2VfID8gdGhpcy53aXRoaW5TdGFydFBvc3Qobm9kZSkgOiB0aGlzLndpdGhpbkVuZFBvc3Qobm9kZSk7XHJcbiAgICAgICAgdGhpcy53aXRoaW5TdGFydFBvc3QgPSAobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wYXJlUmVzID0gdGhpcy5pbmRleF8uY29tcGFyZSh0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCksIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydElzSW5jbHVzaXZlXyA/IGNvbXBhcmVSZXMgPD0gMCA6IGNvbXBhcmVSZXMgPCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy53aXRoaW5FbmRQb3N0ID0gKG5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGFyZVJlcyA9IHRoaXMuaW5kZXhfLmNvbXBhcmUobm9kZSwgdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEVuZFBvc3QoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZElzSW5jbHVzaXZlXyA/IGNvbXBhcmVSZXMgPD0gMCA6IGNvbXBhcmVSZXMgPCAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yYW5nZWRGaWx0ZXJfID0gbmV3IFJhbmdlZEZpbHRlcihwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhfID0gcGFyYW1zLmdldEluZGV4KCk7XHJcbiAgICAgICAgdGhpcy5saW1pdF8gPSBwYXJhbXMuZ2V0TGltaXQoKTtcclxuICAgICAgICB0aGlzLnJldmVyc2VfID0gIXBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJc0luY2x1c2l2ZV8gPSAhcGFyYW1zLnN0YXJ0QWZ0ZXJTZXRfO1xyXG4gICAgICAgIHRoaXMuZW5kSXNJbmNsdXNpdmVfID0gIXBhcmFtcy5lbmRCZWZvcmVTZXRfO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXcgTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xyXG4gICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpLmVxdWFscyhuZXdDaGlsZCkpIHtcclxuICAgICAgICAgICAgLy8gTm8gY2hhbmdlXHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzbmFwLm51bUNoaWxkcmVuKCkgPCB0aGlzLmxpbWl0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfXHJcbiAgICAgICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgICAgICAudXBkYXRlQ2hpbGQoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBrZXksIG5ld0NoaWxkLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xyXG4gICAgICAgIGxldCBmaWx0ZXJlZDtcclxuICAgICAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkgfHwgbmV3U25hcC5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjaGlsZHJlbiBub2RlIHdpdGggdGhlIGNvcnJlY3QgaW5kZXgsIG5vdCBhIGxlYWYgbm9kZTtcclxuICAgICAgICAgICAgZmlsdGVyZWQgPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGltaXRfICogMiA8IG5ld1NuYXAubnVtQ2hpbGRyZW4oKSAmJlxyXG4gICAgICAgICAgICAgICAgbmV3U25hcC5pc0luZGV4ZWQodGhpcy5pbmRleF8pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFYXNpZXIgdG8gYnVpbGQgdXAgYSBzbmFwc2hvdCwgc2luY2Ugd2hhdCB3ZSdyZSBnaXZlbiBoYXMgbW9yZSB0aGFuIHR3aWNlIHRoZSBlbGVtZW50cyB3ZSB3YW50XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgdG8gdGhlIHN0YXJ0UG9zdCwgZW5kUG9zdCwgb3IgbGFzdCBlbGVtZW50IGFzIGFwcHJvcHJpYXRlXHJcbiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCksIHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCB0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSAmJiBjb3VudCA8IHRoaXMubGltaXRfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMud2l0aGluRGlyZWN0aW9uYWxTdGFydChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIHRoZSBzdGFydCwgc2tpcCB0byB0aGUgbmV4dCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZChuZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCwgc3RvcCBhZGRpbmcgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgbmV4dC5ub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgc25hcCBjb250YWlucyBsZXNzIHRoYW4gdHdpY2UgdGhlIGxpbWl0LiBGYXN0ZXIgdG8gZGVsZXRlIGZyb20gdGhlIHNuYXAgdGhhbiBidWlsZCB1cCBhIG5ldyBvbmVcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xyXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcclxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldFJldmVyc2VJdGVyYXRvcih0aGlzLmluZGV4Xyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldEl0ZXJhdG9yKHRoaXMuaW5kZXhfKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLmdldE5leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpblJhbmdlID0gY291bnQgPCB0aGlzLmxpbWl0XyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhpbkRpcmVjdGlvbmFsU3RhcnQobmV4dCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53aXRoaW5EaXJlY3Rpb25hbEVuZChuZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5SYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChuZXh0Lm5hbWUsIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VkRmlsdGVyX1xyXG4gICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXHJcbiAgICAgICAgICAgIC51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpb3JpdHkob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcclxuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xyXG4gICAgICAgIHJldHVybiBvbGRTbmFwO1xyXG4gICAgfVxyXG4gICAgZmlsdGVyc05vZGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0SW5kZXhlZEZpbHRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZWRGaWx0ZXJfLmdldEluZGV4ZWRGaWx0ZXIoKTtcclxuICAgIH1cclxuICAgIGdldEluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcclxuICAgIH1cclxuICAgIGZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyhzbmFwLCBjaGlsZEtleSwgY2hpbGRTbmFwLCBzb3VyY2UsIGNoYW5nZUFjY3VtdWxhdG9yKSB7XHJcbiAgICAgICAgLy8gVE9ETzogcmVuYW1lIGFsbCBjYWNoZSBzdHVmZiBldGMgdG8gZ2VuZXJhbCBzbmFwIHRlcm1pbm9sb2d5XHJcbiAgICAgICAgbGV0IGNtcDtcclxuICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleENtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcclxuICAgICAgICAgICAgY21wID0gKGEsIGIpID0+IGluZGV4Q21wKGIsIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY21wID0gdGhpcy5pbmRleF8uZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvbGRFdmVudENhY2hlID0gc25hcDtcclxuICAgICAgICBhc3NlcnQob2xkRXZlbnRDYWNoZS5udW1DaGlsZHJlbigpID09PSB0aGlzLmxpbWl0XywgJycpO1xyXG4gICAgICAgIGNvbnN0IG5ld0NoaWxkTmFtZWROb2RlID0gbmV3IE5hbWVkTm9kZShjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICBjb25zdCB3aW5kb3dCb3VuZGFyeSA9IHRoaXMucmV2ZXJzZV9cclxuICAgICAgICAgICAgPyBvbGRFdmVudENhY2hlLmdldEZpcnN0Q2hpbGQodGhpcy5pbmRleF8pXHJcbiAgICAgICAgICAgIDogb2xkRXZlbnRDYWNoZS5nZXRMYXN0Q2hpbGQodGhpcy5pbmRleF8pO1xyXG4gICAgICAgIGNvbnN0IGluUmFuZ2UgPSB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXdDaGlsZE5hbWVkTm9kZSk7XHJcbiAgICAgICAgaWYgKG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkU25hcCA9IG9sZEV2ZW50Q2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICBsZXQgbmV4dENoaWxkID0gc291cmNlLmdldENoaWxkQWZ0ZXJDaGlsZCh0aGlzLmluZGV4Xywgd2luZG93Qm91bmRhcnksIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB3aGlsZSAobmV4dENoaWxkICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIChuZXh0Q2hpbGQubmFtZSA9PT0gY2hpbGRLZXkgfHwgb2xkRXZlbnRDYWNoZS5oYXNDaGlsZChuZXh0Q2hpbGQubmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIHdlaXJkIGVkZ2UgY2FzZSB3aGVyZSBhIG5vZGUgaXMgdXBkYXRlZCBhcyBwYXJ0IG9mIGEgbWVyZ2UgaW4gdGhlIHdyaXRlIHRyZWUsIGJ1dCBoYXNuJ3RcclxuICAgICAgICAgICAgICAgIC8vIGJlZW4gYXBwbGllZCB0byB0aGUgbGltaXRlZCBmaWx0ZXIgeWV0LiBJZ25vcmUgdGhpcyBuZXh0IGNoaWxkIHdoaWNoIHdpbGwgYmUgdXBkYXRlZCBsYXRlciBpblxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxpbWl0ZWQgZmlsdGVyLi4uXHJcbiAgICAgICAgICAgICAgICBuZXh0Q2hpbGQgPSBzb3VyY2UuZ2V0Q2hpbGRBZnRlckNoaWxkKHRoaXMuaW5kZXhfLCBuZXh0Q2hpbGQsIHRoaXMucmV2ZXJzZV8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVOZXh0ID0gbmV4dENoaWxkID09IG51bGwgPyAxIDogY21wKG5leHRDaGlsZCwgbmV3Q2hpbGROYW1lZE5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1haW5zSW5XaW5kb3cgPSBpblJhbmdlICYmICFjaGlsZFNuYXAuaXNFbXB0eSgpICYmIGNvbXBhcmVOZXh0ID49IDA7XHJcbiAgICAgICAgICAgIGlmIChyZW1haW5zSW5XaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZENoYW5nZWQoY2hpbGRLZXksIGNoaWxkU25hcCwgb2xkQ2hpbGRTbmFwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkRXZlbnRDYWNoZS51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZEtleSwgY2hpbGRTbmFwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShjaGFuZ2VDaGlsZFJlbW92ZWQoY2hpbGRLZXksIG9sZENoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZEluUmFuZ2UgPSBuZXh0Q2hpbGQgIT0gbnVsbCAmJiB0aGlzLnJhbmdlZEZpbHRlcl8ubWF0Y2hlcyhuZXh0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZEluUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHRDaGlsZC5uYW1lLCBuZXh0Q2hpbGQubm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjaGlsZFNuYXAuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIC8vIHdlJ3JlIGRlbGV0aW5nIGEgbm9kZSwgYnV0IGl0IHdhcyBub3QgaW4gdGhlIHdpbmRvdywgc28gaWdub3JlIGl0XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblJhbmdlKSB7XHJcbiAgICAgICAgICAgIGlmIChjbXAod2luZG93Qm91bmRhcnksIG5ld0NoaWxkTmFtZWROb2RlKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoY2hhbmdlQ2hpbGRSZW1vdmVkKHdpbmRvd0JvdW5kYXJ5Lm5hbWUsIHdpbmRvd0JvdW5kYXJ5Lm5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKGNoYW5nZUNoaWxkQWRkZWQoY2hpbGRLZXksIGNoaWxkU25hcCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcClcclxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlSW1tZWRpYXRlQ2hpbGQod2luZG93Qm91bmRhcnkubmFtZSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyBhbiBpbW11dGFibGUtZnJvbS10aGUtcHVibGljLWFwaSBzdHJ1Y3QgY29udGFpbmluZyBhIHNldCBvZiBxdWVyeSBwYXJhbWV0ZXJzIGRlZmluaW5nIGFcclxuICogcmFuZ2UgdG8gYmUgcmV0dXJuZWQgZm9yIGEgcGFydGljdWxhciBsb2NhdGlvbi4gSXQgaXMgYXNzdW1lZCB0aGF0IHZhbGlkYXRpb24gb2YgcGFyYW1ldGVycyBpcyBkb25lIGF0IHRoZVxyXG4gKiB1c2VyLWZhY2luZyBBUEkgbGV2ZWwsIHNvIGl0IGlzIG5vdCBkb25lIGhlcmUuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuY2xhc3MgUXVlcnlQYXJhbXMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdFNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0YXJ0U2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRBZnRlclNldF8gPSBmYWxzZTsgLy8gY2FuIG9ubHkgYmUgdHJ1ZSBpZiBzdGFydFNldF8gaXMgdHJ1ZVxyXG4gICAgICAgIHRoaXMuZW5kU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVuZEJlZm9yZVNldF8gPSBmYWxzZTsgLy8gY2FuIG9ubHkgYmUgdHJ1ZSBpZiBlbmRTZXRfIGlzIHRydWVcclxuICAgICAgICB0aGlzLmxpbWl0XyA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3RnJvbV8gPSAnJztcclxuICAgICAgICB0aGlzLmluZGV4U3RhcnRWYWx1ZV8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhTdGFydE5hbWVfID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleEVuZFZhbHVlXyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEVuZE5hbWVfID0gJyc7XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSBQUklPUklUWV9JTkRFWDtcclxuICAgIH1cclxuICAgIGhhc1N0YXJ0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2V0XztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBpdCB3b3VsZCByZXR1cm4gZnJvbSBsZWZ0LlxyXG4gICAgICovXHJcbiAgICBpc1ZpZXdGcm9tTGVmdCgpIHtcclxuICAgICAgICBpZiAodGhpcy52aWV3RnJvbV8gPT09ICcnKSB7XHJcbiAgICAgICAgICAgIC8vIGxpbWl0KCksIHJhdGhlciB0aGFuIGxpbWl0VG9GaXJzdCBvciBsaW1pdFRvTGFzdCB3YXMgY2FsbGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgb25seSBvbmUgb2Ygc3RhcnRTZXRfIGFuZCBlbmRTZXRfIGlzIHRydWUuIFVzZSB0aGVtXHJcbiAgICAgICAgICAgIC8vIHRvIGNhbGN1bGF0ZSB3aGljaCBzaWRlIG9mIHRoZSB2aWV3IHRvIGFuY2hvciB0by4gSWYgbmVpdGhlciBpcyBzZXQsXHJcbiAgICAgICAgICAgIC8vIGFuY2hvciB0byB0aGUgZW5kLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydFNldF87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3RnJvbV8gPT09IFwibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9MRUZUICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc1N0YXJ0KCkgcmV0dXJucyB0cnVlXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4U3RhcnRWYWx1ZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5zdGFydFNldF8sICdPbmx5IHZhbGlkIGlmIHN0YXJ0IGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIFJldHVybnMgdGhlIHN0YXJ0aW5nIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4U3RhcnROYW1lKCkge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLnN0YXJ0U2V0XywgJ09ubHkgdmFsaWQgaWYgc3RhcnQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gTUlOX05BTUU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzRW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4RW5kVmFsdWUoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzRW5kKCkgcmV0dXJucyB0cnVlLlxyXG4gICAgICogUmV0dXJucyB0aGUgZW5kIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXHJcbiAgICAgKi9cclxuICAgIGdldEluZGV4RW5kTmFtZSgpIHtcclxuICAgICAgICBhc3NlcnQodGhpcy5lbmRTZXRfLCAnT25seSB2YWxpZCBpZiBlbmQgaGFzIGJlZW4gc2V0Jyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kTmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhFbmROYW1lXztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfTkFNRTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYSBsaW1pdCBoYXMgYmVlbiBzZXQgYW5kIGl0IGhhcyBiZWVuIGV4cGxpY2l0bHkgYW5jaG9yZWRcclxuICAgICAqL1xyXG4gICAgaGFzQW5jaG9yZWRMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF8gJiYgdGhpcy52aWV3RnJvbV8gIT09ICcnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzTGltaXQoKSByZXR1cm5zIHRydWVcclxuICAgICAqL1xyXG4gICAgZ2V0TGltaXQoKSB7XHJcbiAgICAgICAgYXNzZXJ0KHRoaXMubGltaXRTZXRfLCAnT25seSB2YWxpZCBpZiBsaW1pdCBoYXMgYmVlbiBzZXQnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5saW1pdF87XHJcbiAgICB9XHJcbiAgICBnZXRJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XHJcbiAgICB9XHJcbiAgICBsb2Fkc0FsbERhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuICEodGhpcy5zdGFydFNldF8gfHwgdGhpcy5lbmRTZXRfIHx8IHRoaXMubGltaXRTZXRfKTtcclxuICAgIH1cclxuICAgIGlzRGVmYXVsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2Fkc0FsbERhdGEoKSAmJiB0aGlzLmluZGV4XyA9PT0gUFJJT1JJVFlfSU5ERVg7XHJcbiAgICB9XHJcbiAgICBjb3B5KCkge1xyXG4gICAgICAgIGNvbnN0IGNvcHkgPSBuZXcgUXVlcnlQYXJhbXMoKTtcclxuICAgICAgICBjb3B5LmxpbWl0U2V0XyA9IHRoaXMubGltaXRTZXRfO1xyXG4gICAgICAgIGNvcHkubGltaXRfID0gdGhpcy5saW1pdF87XHJcbiAgICAgICAgY29weS5zdGFydFNldF8gPSB0aGlzLnN0YXJ0U2V0XztcclxuICAgICAgICBjb3B5LnN0YXJ0QWZ0ZXJTZXRfID0gdGhpcy5zdGFydEFmdGVyU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4U3RhcnRWYWx1ZV8gPSB0aGlzLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICAgICAgY29weS5zdGFydE5hbWVTZXRfID0gdGhpcy5zdGFydE5hbWVTZXRfO1xyXG4gICAgICAgIGNvcHkuaW5kZXhTdGFydE5hbWVfID0gdGhpcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgY29weS5lbmRTZXRfID0gdGhpcy5lbmRTZXRfO1xyXG4gICAgICAgIGNvcHkuZW5kQmVmb3JlU2V0XyA9IHRoaXMuZW5kQmVmb3JlU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kVmFsdWVfID0gdGhpcy5pbmRleEVuZFZhbHVlXztcclxuICAgICAgICBjb3B5LmVuZE5hbWVTZXRfID0gdGhpcy5lbmROYW1lU2V0XztcclxuICAgICAgICBjb3B5LmluZGV4RW5kTmFtZV8gPSB0aGlzLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgY29weS5pbmRleF8gPSB0aGlzLmluZGV4XztcclxuICAgICAgICBjb3B5LnZpZXdGcm9tXyA9IHRoaXMudmlld0Zyb21fO1xyXG4gICAgICAgIHJldHVybiBjb3B5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zR2V0Tm9kZUZpbHRlcihxdWVyeVBhcmFtcykge1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRmlsdGVyKHF1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocXVlcnlQYXJhbXMuaGFzTGltaXQoKSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGltaXRlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlZEZpbHRlcihxdWVyeVBhcmFtcyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvRmlyc3QocXVlcnlQYXJhbXMsIG5ld0xpbWl0KSB7XHJcbiAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtcy5jb3B5KCk7XHJcbiAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcclxuICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcclxuICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBcImxcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNMaW1pdFRvTGFzdChxdWVyeVBhcmFtcywgbmV3TGltaXQpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xyXG4gICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xyXG4gICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9IFwiclwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLlZJRVdfRlJPTV9SSUdIVCAqLztcclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEF0KHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zLmNvcHkoKTtcclxuICAgIG5ld1BhcmFtcy5zdGFydFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV8gPSBpbmRleFZhbHVlO1xyXG4gICAgaWYgKGtleSAhPSBudWxsKSB7XHJcbiAgICAgICAgbmV3UGFyYW1zLnN0YXJ0TmFtZVNldF8gPSB0cnVlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IGZhbHNlO1xyXG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcclxuICAgIH1cclxuICAgIHJldHVybiBuZXdQYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNTdGFydEFmdGVyKHF1ZXJ5UGFyYW1zLCBpbmRleFZhbHVlLCBrZXkpIHtcclxuICAgIGxldCBwYXJhbXM7XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaW5kZXhfID09PSBLRVlfSU5ERVggfHwgISFrZXkpIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwYXJhbXMgPSBxdWVyeVBhcmFtc1N0YXJ0QXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIE1BWF9OQU1FKTtcclxuICAgIH1cclxuICAgIHBhcmFtcy5zdGFydEFmdGVyU2V0XyA9IHRydWU7XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIGtleSkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmVuZFNldF8gPSB0cnVlO1xyXG4gICAgaWYgKGluZGV4VmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbmV3UGFyYW1zLmluZGV4RW5kVmFsdWVfID0gaW5kZXhWYWx1ZTtcclxuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IHRydWU7XHJcbiAgICAgICAgbmV3UGFyYW1zLmluZGV4RW5kTmFtZV8gPSBrZXk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBuZXdQYXJhbXMuZW5kTmFtZVNldF8gPSBmYWxzZTtcclxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9ICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0VuZEJlZm9yZShxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KSB7XHJcbiAgICBsZXQgcGFyYW1zO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmluZGV4XyA9PT0gS0VZX0lOREVYIHx8ICEha2V5KSB7XHJcbiAgICAgICAgcGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeVBhcmFtcywgaW5kZXhWYWx1ZSwga2V5KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHBhcmFtcyA9IHF1ZXJ5UGFyYW1zRW5kQXQocXVlcnlQYXJhbXMsIGluZGV4VmFsdWUsIE1JTl9OQU1FKTtcclxuICAgIH1cclxuICAgIHBhcmFtcy5lbmRCZWZvcmVTZXRfID0gdHJ1ZTtcclxuICAgIHJldHVybiBwYXJhbXM7XHJcbn1cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5UGFyYW1zLCBpbmRleCkge1xyXG4gICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXMuY29weSgpO1xyXG4gICAgbmV3UGFyYW1zLmluZGV4XyA9IGluZGV4O1xyXG4gICAgcmV0dXJuIG5ld1BhcmFtcztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHNldCBvZiBSRVNUIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzIHJlcHJlc2VudGluZyB0aGlzIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xyXG4gKi9cclxuZnVuY3Rpb24gcXVlcnlQYXJhbXNUb1Jlc3RRdWVyeVN0cmluZ1BhcmFtZXRlcnMocXVlcnlQYXJhbXMpIHtcclxuICAgIGNvbnN0IHFzID0ge307XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuaXNEZWZhdWx0KCkpIHtcclxuICAgICAgICByZXR1cm4gcXM7XHJcbiAgICB9XHJcbiAgICBsZXQgb3JkZXJCeTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJHByaW9yaXR5XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuUFJJT1JJVFlfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IFZBTFVFX0lOREVYKSB7XHJcbiAgICAgICAgb3JkZXJCeSA9IFwiJHZhbHVlXCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuVkFMVUVfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgIG9yZGVyQnkgPSBcIiRrZXlcIiAvKiBSRVNUX1FVRVJZX0NPTlNUQU5UUy5LRVlfSU5ERVggKi87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhc3NlcnQocXVlcnlQYXJhbXMuaW5kZXhfIGluc3RhbmNlb2YgUGF0aEluZGV4LCAnVW5yZWNvZ25pemVkIGluZGV4IHR5cGUhJyk7XHJcbiAgICAgICAgb3JkZXJCeSA9IHF1ZXJ5UGFyYW1zLmluZGV4Xy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcXNbXCJvcmRlckJ5XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuT1JERVJfQlkgKi9dID0gc3RyaW5naWZ5KG9yZGVyQnkpO1xyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0U2V0Xykge1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0UGFyYW0gPSBxdWVyeVBhcmFtcy5zdGFydEFmdGVyU2V0X1xyXG4gICAgICAgICAgICA/IFwic3RhcnRBZnRlclwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLlNUQVJUX0FGVEVSICovXHJcbiAgICAgICAgICAgIDogXCJzdGFydEF0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuU1RBUlRfQVQgKi87XHJcbiAgICAgICAgcXNbc3RhcnRQYXJhbV0gPSBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhTdGFydFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgcXNbc3RhcnRQYXJhbV0gKz0gJywnICsgc3RyaW5naWZ5KHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnROYW1lXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZFNldF8pIHtcclxuICAgICAgICBjb25zdCBlbmRQYXJhbSA9IHF1ZXJ5UGFyYW1zLmVuZEJlZm9yZVNldF9cclxuICAgICAgICAgICAgPyBcImVuZEJlZm9yZVwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLkVORF9CRUZPUkUgKi9cclxuICAgICAgICAgICAgOiBcImVuZEF0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuRU5EX0FUICovO1xyXG4gICAgICAgIHFzW2VuZFBhcmFtXSA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcy5pbmRleEVuZFZhbHVlXyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmVuZE5hbWVTZXRfKSB7XHJcbiAgICAgICAgICAgIHFzW2VuZFBhcmFtXSArPSAnLCcgKyBzdHJpbmdpZnkocXVlcnlQYXJhbXMuaW5kZXhFbmROYW1lXyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHF1ZXJ5UGFyYW1zLmxpbWl0U2V0Xykge1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpKSB7XHJcbiAgICAgICAgICAgIHFzW1wibGltaXRUb0ZpcnN0XCIgLyogUkVTVF9RVUVSWV9DT05TVEFOVFMuTElNSVRfVE9fRklSU1QgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcXNbXCJsaW1pdFRvTGFzdFwiIC8qIFJFU1RfUVVFUllfQ09OU1RBTlRTLkxJTUlUX1RPX0xBU1QgKi9dID0gcXVlcnlQYXJhbXMubGltaXRfO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBxcztcclxufVxyXG5mdW5jdGlvbiBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICBjb25zdCBvYmogPSB7fTtcclxuICAgIGlmIChxdWVyeVBhcmFtcy5zdGFydFNldF8pIHtcclxuICAgICAgICBvYmpbXCJzcFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX1ZBTFVFICovXSA9XHJcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmluZGV4U3RhcnRWYWx1ZV87XHJcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLnN0YXJ0TmFtZVNldF8pIHtcclxuICAgICAgICAgICAgb2JqW1wic25cIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9OQU1FICovXSA9XHJcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5pbmRleFN0YXJ0TmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcInNpblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX1NUQVJUX0lTX0lOQ0xVU0lWRSAqL10gPVxyXG4gICAgICAgICAgICAhcXVlcnlQYXJhbXMuc3RhcnRBZnRlclNldF87XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMuZW5kU2V0Xykge1xyXG4gICAgICAgIG9ialtcImVwXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfRU5EX1ZBTFVFICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kVmFsdWVfO1xyXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5lbmROYW1lU2V0Xykge1xyXG4gICAgICAgICAgICBvYmpbXCJlblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9OQU1FICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4RW5kTmFtZV87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcImVpblwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9JU19JTkNMVVNJVkUgKi9dID1cclxuICAgICAgICAgICAgIXF1ZXJ5UGFyYW1zLmVuZEJlZm9yZVNldF87XHJcbiAgICB9XHJcbiAgICBpZiAocXVlcnlQYXJhbXMubGltaXRTZXRfKSB7XHJcbiAgICAgICAgb2JqW1wibFwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLkxJTUlUICovXSA9IHF1ZXJ5UGFyYW1zLmxpbWl0XztcclxuICAgICAgICBsZXQgdmlld0Zyb20gPSBxdWVyeVBhcmFtcy52aWV3RnJvbV87XHJcbiAgICAgICAgaWYgKHZpZXdGcm9tID09PSAnJykge1xyXG4gICAgICAgICAgICBpZiAocXVlcnlQYXJhbXMuaXNWaWV3RnJvbUxlZnQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmlld0Zyb20gPSBcImxcIiAvKiBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVCAqLztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gXCJyXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX1JJR0hUICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ialtcInZmXCIgLyogV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NICovXSA9IHZpZXdGcm9tO1xyXG4gICAgfVxyXG4gICAgLy8gRm9yIG5vdywgcHJpb3JpdHkgaW5kZXggaXMgdGhlIGRlZmF1bHQsIHNvIHdlIG9ubHkgc3BlY2lmeSBpZiBpdCdzIHNvbWUgb3RoZXIgaW5kZXhcclxuICAgIGlmIChxdWVyeVBhcmFtcy5pbmRleF8gIT09IFBSSU9SSVRZX0lOREVYKSB7XHJcbiAgICAgICAgb2JqW1wiaVwiIC8qIFdJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYICovXSA9IHF1ZXJ5UGFyYW1zLmluZGV4Xy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgU2VydmVyQWN0aW9ucyB0aGF0IGNvbW11bmljYXRlcyB3aXRoIHRoZSBzZXJ2ZXIgdmlhIFJFU1QgcmVxdWVzdHMuXHJcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGNyYXdsZXJzLCB3aGVyZSB3ZSBkb24ndCB3YW50IHRvIHNwaW4gdXAgYSBmdWxsXHJcbiAqIHBlcnNpc3RlbnQgY29ubmVjdGlvbiAodXNpbmcgV2ViU29ja2V0cyBvciBsb25nLXBvbGxpbmcpXHJcbiAqL1xyXG5jbGFzcyBSZWFkb25seVJlc3RDbGllbnQgZXh0ZW5kcyBTZXJ2ZXJBY3Rpb25zIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHJlcG9JbmZvXyAtIERhdGEgYWJvdXQgdGhlIG5hbWVzcGFjZSB3ZSBhcmUgY29ubmVjdGluZyB0b1xyXG4gICAgICogQHBhcmFtIG9uRGF0YVVwZGF0ZV8gLSBBIGNhbGxiYWNrIGZvciBuZXcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocmVwb0luZm9fLCBvbkRhdGFVcGRhdGVfLCBhdXRoVG9rZW5Qcm92aWRlcl8sIGFwcENoZWNrVG9rZW5Qcm92aWRlcl8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyA9IG9uRGF0YVVwZGF0ZV87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Rva2VuUHJvdmlkZXJfID0gYXBwQ2hlY2tUb2tlblByb3ZpZGVyXztcclxuICAgICAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKC4uLlsqXSl9ICovXHJcbiAgICAgICAgdGhpcy5sb2dfID0gbG9nV3JhcHBlcigncDpyZXN0OicpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdlIGRvbid0IGFjdHVhbGx5IG5lZWQgdG8gdHJhY2sgbGlzdGVucywgZXhjZXB0IHRvIHByZXZlbnQgdXMgY2FsbGluZyBhbiBvbkNvbXBsZXRlIGZvciBhIGxpc3RlblxyXG4gICAgICAgICAqIHRoYXQncyBiZWVuIHJlbW92ZWQuIDotL1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGlzdGVuc18gPSB7fTtcclxuICAgIH1cclxuICAgIHJlcG9ydFN0YXRzKHN0YXRzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldExpc3RlbklkXyhxdWVyeSwgdGFnKSB7XHJcbiAgICAgICAgaWYgKHRhZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndGFnJCcgKyB0YWc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhc3NlcnQocXVlcnkuX3F1ZXJ5UGFyYW1zLmlzRGVmYXVsdCgpLCBcInNob3VsZCBoYXZlIGEgdGFnIGlmIGl0J3Mgbm90IGEgZGVmYXVsdCBxdWVyeS5cIik7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgbGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcclxuICAgICAgICBjb25zdCBwYXRoU3RyaW5nID0gcXVlcnkuX3BhdGgudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcik7XHJcbiAgICAgICAgLy8gTWFyayB0aGlzIGxpc3RlbmVyIHNvIHdlIGNhbiB0ZWxsIGlmIGl0J3MgcmVtb3ZlZC5cclxuICAgICAgICBjb25zdCBsaXN0ZW5JZCA9IFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8ocXVlcnksIHRhZyk7XHJcbiAgICAgICAgY29uc3QgdGhpc0xpc3RlbiA9IHt9O1xyXG4gICAgICAgIHRoaXMubGlzdGVuc19bbGlzdGVuSWRdID0gdGhpc0xpc3RlbjtcclxuICAgICAgICBjb25zdCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeS5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIHRoaXMucmVzdFJlcXVlc3RfKHBhdGhTdHJpbmcgKyAnLmpzb24nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMsIChlcnJvciwgcmVzdWx0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGVycm9yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8ocGF0aFN0cmluZywgZGF0YSwgLyppc01lcmdlPSovIGZhbHNlLCB0YWcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzYWZlR2V0KHRoaXMubGlzdGVuc18sIGxpc3RlbklkKSA9PT0gdGhpc0xpc3Rlbikge1xyXG4gICAgICAgICAgICAgICAgbGV0IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAnb2snO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXJyb3IgPT09IDQwMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9ICdwZXJtaXNzaW9uX2RlbmllZCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSAncmVzdF9lcnJvcjonICsgZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKHN0YXR1cywgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgdW5saXN0ZW4ocXVlcnksIHRhZykge1xyXG4gICAgICAgIGNvbnN0IGxpc3RlbklkID0gUmVhZG9ubHlSZXN0Q2xpZW50LmdldExpc3RlbklkXyhxdWVyeSwgdGFnKTtcclxuICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5zX1tsaXN0ZW5JZF07XHJcbiAgICB9XHJcbiAgICBnZXQocXVlcnkpIHtcclxuICAgICAgICBjb25zdCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSBxdWVyeVBhcmFtc1RvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyhxdWVyeS5fcXVlcnlQYXJhbXMpO1xyXG4gICAgICAgIGNvbnN0IHBhdGhTdHJpbmcgPSBxdWVyeS5fcGF0aC50b1N0cmluZygpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgdGhpcy5yZXN0UmVxdWVzdF8ocGF0aFN0cmluZyArICcuanNvbicsIHF1ZXJ5U3RyaW5nUGFyYW1ldGVycywgKGVycm9yLCByZXN1bHQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSByZXN1bHQ7XHJcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gNDA0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25EYXRhVXBkYXRlXyhwYXRoU3RyaW5nLCBkYXRhLCBcclxuICAgICAgICAgICAgICAgIC8qaXNNZXJnZT0qLyBmYWxzZSwgXHJcbiAgICAgICAgICAgICAgICAvKnRhZz0qLyBudWxsKTtcclxuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QobmV3IEVycm9yKGRhdGEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICByZWZyZXNoQXV0aFRva2VuKHRva2VuKSB7XHJcbiAgICAgICAgLy8gbm8tb3Agc2luY2Ugd2UganVzdCBhbHdheXMgY2FsbCBnZXRUb2tlbi5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBSRVNUIHJlcXVlc3QgdG8gdGhlIGdpdmVuIHBhdGgsIHdpdGggdGhlIHByb3ZpZGVkIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLFxyXG4gICAgICogYW5kIGFueSBhdXRoIGNyZWRlbnRpYWxzIHdlIGhhdmUuXHJcbiAgICAgKi9cclxuICAgIHJlc3RSZXF1ZXN0XyhwYXRoU3RyaW5nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSB7fSwgY2FsbGJhY2spIHtcclxuICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2Zvcm1hdCddID0gJ2V4cG9ydCc7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8uZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpLFxyXG4gICAgICAgICAgICB0aGlzLmFwcENoZWNrVG9rZW5Qcm92aWRlcl8uZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpXHJcbiAgICAgICAgXSkudGhlbigoW2F1dGhUb2tlbiwgYXBwQ2hlY2tUb2tlbl0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGF1dGhUb2tlbiAmJiBhdXRoVG9rZW4uYWNjZXNzVG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYXV0aCddID0gYXV0aFRva2VuLmFjY2Vzc1Rva2VuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcHBDaGVja1Rva2VuICYmIGFwcENoZWNrVG9rZW4udG9rZW4pIHtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RyaW5nUGFyYW1ldGVyc1snYWMnXSA9IGFwcENoZWNrVG9rZW4udG9rZW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdXJsID0gKHRoaXMucmVwb0luZm9fLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwb0luZm9fLmhvc3QgK1xyXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArXHJcbiAgICAgICAgICAgICAgICAnPycgK1xyXG4gICAgICAgICAgICAgICAgJ25zPScgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18ubmFtZXNwYWNlICtcclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nKHF1ZXJ5U3RyaW5nUGFyYW1ldGVycyk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nXygnU2VuZGluZyBSRVNUIHJlcXVlc3QgZm9yICcgKyB1cmwpO1xyXG4gICAgICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nXygnUkVTVCBSZXNwb25zZSBmb3IgJyArIHVybCArICcgcmVjZWl2ZWQuIHN0YXR1czonLCB4aHIuc3RhdHVzLCAncmVzcG9uc2U6JywgeGhyLnJlc3BvbnNlVGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGpzb25FdmFsKHhoci5yZXNwb25zZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuKCdGYWlsZWQgdG8gcGFyc2UgSlNPTiByZXNwb25zZSBmb3IgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDAxIGFuZCA0MDQgYXJlIGV4cGVjdGVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gNDAxICYmIHhoci5zdGF0dXMgIT09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybignR290IHVuc3VjY2Vzc2Z1bCBSRVNUIHJlc3BvbnNlIGZvciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgU3RhdHVzOiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayh4aHIuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCAvKmFzeW5jaHJvbm91cz0qLyB0cnVlKTtcclxuICAgICAgICAgICAgeGhyLnNlbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogTXV0YWJsZSBvYmplY3Qgd2hpY2ggYmFzaWNhbGx5IGp1c3Qgc3RvcmVzIGEgcmVmZXJlbmNlIHRvIHRoZSBcImxhdGVzdFwiIGltbXV0YWJsZSBzbmFwc2hvdC5cclxuICovXHJcbmNsYXNzIFNuYXBzaG90SG9sZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucm9vdE5vZGVfID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICB9XHJcbiAgICBnZXROb2RlKHBhdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZV8uZ2V0Q2hpbGQocGF0aCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTbmFwc2hvdChwYXRoLCBuZXdTbmFwc2hvdE5vZGUpIHtcclxuICAgICAgICB0aGlzLnJvb3ROb2RlXyA9IHRoaXMucm9vdE5vZGVfLnVwZGF0ZUNoaWxkKHBhdGgsIG5ld1NuYXBzaG90Tm9kZSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3U3BhcnNlU25hcHNob3RUcmVlKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWx1ZTogbnVsbCxcclxuICAgICAgICBjaGlsZHJlbjogbmV3IE1hcCgpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBTdG9yZXMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZVxyXG4gKiBhdCBhIHNoYWxsb3dlciBwYXRoLCBpdCBtZXJnZXMgdGhlIG5ldyBkYXRhIGludG8gdGhhdCBzbmFwc2hvdCBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXHJcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG5ldyBkYXRhLCBvciBudWxsLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoc3BhcnNlU25hcHNob3RUcmVlLCBwYXRoLCBkYXRhKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBkYXRhO1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlLnVwZGF0ZUNoaWxkKHBhdGgsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICAgICAgaWYgKCFzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uaGFzKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2V0KGNoaWxkS2V5LCBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmdldChjaGlsZEtleSk7XHJcbiAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihjaGlsZCwgcGF0aCwgZGF0YSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFB1cmdlIHRoZSBkYXRhIGF0IHBhdGggZnJvbSB0aGUgY2FjaGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCB0byBsb29rIHVwIHNuYXBzaG90IGZvci5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGlzIG5vZGUgc2hvdWxkIG5vdyBiZSByZW1vdmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yZ2V0KHNwYXJzZVNuYXBzaG90VHJlZSwgcGF0aCkge1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlID0gbnVsbDtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uY2xlYXIoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHRyeWluZyB0byBmb3JnZXQgYSBub2RlIHRoYXQgZG9lc24ndCBleGlzdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWUudmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoa2V5LCB0cmVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIoc3BhcnNlU25hcHNob3RUcmVlLCBuZXcgUGF0aChrZXkpLCB0cmVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChzcGFyc2VTbmFwc2hvdFRyZWUsIHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5zaXplID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgcGF0aCA9IHBhdGhQb3BGcm9udChwYXRoKTtcclxuICAgICAgICAgICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5oYXMoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzYWZlVG9SZW1vdmUgPSBzcGFyc2VTbmFwc2hvdFRyZWVGb3JnZXQoc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmdldChjaGlsZEtleSksIHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhZmVUb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZS5jaGlsZHJlbi5kZWxldGUoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzcGFyc2VTbmFwc2hvdFRyZWUuY2hpbGRyZW4uc2l6ZSA9PT0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgb2YgdGhlIHN0b3JlZCB0cmVlIGFuZCBjYWxscyB0aGVcclxuICogY2FsbGJhY2sgb24gZWFjaCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwcmVmaXhQYXRoIC0gUGF0aCB0byBsb29rIHVwIG5vZGUgZm9yLlxyXG4gKiBAcGFyYW0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlKHNwYXJzZVNuYXBzaG90VHJlZSwgcHJlZml4UGF0aCwgZnVuYykge1xyXG4gICAgaWYgKHNwYXJzZVNuYXBzaG90VHJlZS52YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGZ1bmMocHJlZml4UGF0aCwgc3BhcnNlU25hcHNob3RUcmVlLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hDaGlsZChzcGFyc2VTbmFwc2hvdFRyZWUsIChrZXksIHRyZWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IG5ldyBQYXRoKHByZWZpeFBhdGgudG9TdHJpbmcoKSArICcvJyArIGtleSk7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvckVhY2hUcmVlKHRyZWUsIHBhdGgsIGZ1bmMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggaW1tZWRpYXRlIGNoaWxkIGFuZCB0cmlnZ2VycyB0aGUgY2FsbGJhY2suXHJcbiAqIE9ubHkgc2VlbXMgdG8gYmUgdXNlZCBpbiB0ZXN0cy5cclxuICpcclxuICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaENoaWxkKHNwYXJzZVNuYXBzaG90VHJlZSwgZnVuYykge1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlLmNoaWxkcmVuLmZvckVhY2goKHRyZWUsIGtleSkgPT4ge1xyXG4gICAgICAgIGZ1bmMoa2V5LCB0cmVlKTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkZWx0YSBmcm9tIHRoZSBwcmV2aW91cyBjYWxsIHRvIGdldCBzdGF0cy5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb25fIC0gVGhlIGNvbGxlY3Rpb24gdG8gXCJsaXN0ZW5cIiB0by5cclxuICovXHJcbmNsYXNzIFN0YXRzTGlzdGVuZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGVjdGlvbl8pIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25fID0gY29sbGVjdGlvbl87XHJcbiAgICAgICAgdGhpcy5sYXN0XyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U3RhdHMgPSB0aGlzLmNvbGxlY3Rpb25fLmdldCgpO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gT2JqZWN0LmFzc2lnbih7fSwgbmV3U3RhdHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RfKSB7XHJcbiAgICAgICAgICAgIGVhY2godGhpcy5sYXN0XywgKHN0YXQsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBkZWx0YVtzdGF0XSA9IGRlbHRhW3N0YXRdIC0gdmFsdWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RfID0gbmV3U3RhdHM7XHJcbiAgICAgICAgcmV0dXJuIGRlbHRhO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8vIEFzc3VtaW5nIHNvbWUgYXBwcyBtYXkgaGF2ZSBhIHNob3J0IGFtb3VudCBvZiB0aW1lIG9uIHBhZ2UsIGFuZCBhIGJ1bGsgb2YgZmlyZWJhc2Ugb3BlcmF0aW9ucyBwcm9iYWJseVxyXG4vLyBoYXBwZW4gb24gcGFnZSBsb2FkLCB3ZSB0cnkgdG8gcmVwb3J0IG91ciBmaXJzdCBzZXQgb2Ygc3RhdHMgcHJldHR5IHF1aWNrbHksIGJ1dCB3ZSB3YWl0IGF0IGxlYXN0IDEwXHJcbi8vIHNlY29uZHMgdG8gdHJ5IHRvIGVuc3VyZSB0aGUgRmlyZWJhc2UgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCAvIHNldHRsZWQuXHJcbmNvbnN0IEZJUlNUX1NUQVRTX01JTl9USU1FID0gMTAgKiAxMDAwO1xyXG5jb25zdCBGSVJTVF9TVEFUU19NQVhfVElNRSA9IDMwICogMTAwMDtcclxuLy8gV2UnbGwgY29udGludWUgdG8gcmVwb3J0IHN0YXRzIG9uIGF2ZXJhZ2UgZXZlcnkgNSBtaW51dGVzLlxyXG5jb25zdCBSRVBPUlRfU1RBVFNfSU5URVJWQUwgPSA1ICogNjAgKiAxMDAwO1xyXG5jbGFzcyBTdGF0c1JlcG9ydGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxlY3Rpb24sIHNlcnZlcl8pIHtcclxuICAgICAgICB0aGlzLnNlcnZlcl8gPSBzZXJ2ZXJfO1xyXG4gICAgICAgIHRoaXMuc3RhdHNUb1JlcG9ydF8gPSB7fTtcclxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbmV3IFN0YXRzTGlzdGVuZXIoY29sbGVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgdGltZW91dCA9IEZJUlNUX1NUQVRTX01JTl9USU1FICtcclxuICAgICAgICAgICAgKEZJUlNUX1NUQVRTX01BWF9USU1FIC0gRklSU1RfU1RBVFNfTUlOX1RJTUUpICogTWF0aC5yYW5kb20oKTtcclxuICAgICAgICBzZXRUaW1lb3V0Tm9uQmxvY2tpbmcodGhpcy5yZXBvcnRTdGF0c18uYmluZCh0aGlzKSwgTWF0aC5mbG9vcih0aW1lb3V0KSk7XHJcbiAgICB9XHJcbiAgICByZXBvcnRTdGF0c18oKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnN0YXRzTGlzdGVuZXJfLmdldCgpO1xyXG4gICAgICAgIGNvbnN0IHJlcG9ydGVkU3RhdHMgPSB7fTtcclxuICAgICAgICBsZXQgaGF2ZVN0YXRzVG9SZXBvcnQgPSBmYWxzZTtcclxuICAgICAgICBlYWNoKHN0YXRzLCAoc3RhdCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID4gMCAmJiBjb250YWlucyh0aGlzLnN0YXRzVG9SZXBvcnRfLCBzdGF0KSkge1xyXG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRTdGF0c1tzdGF0XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaGF2ZVN0YXRzVG9SZXBvcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGhhdmVTdGF0c1RvUmVwb3J0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyXy5yZXBvcnRTdGF0cyhyZXBvcnRlZFN0YXRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcXVldWUgb3VyIG5leHQgcnVuLlxyXG4gICAgICAgIHNldFRpbWVvdXROb25CbG9ja2luZyh0aGlzLnJlcG9ydFN0YXRzXy5iaW5kKHRoaXMpLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyICogUkVQT1JUX1NUQVRTX0lOVEVSVkFMKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqXHJcbiAqIEBlbnVtXHJcbiAqL1xyXG52YXIgT3BlcmF0aW9uVHlwZTtcclxuKGZ1bmN0aW9uIChPcGVyYXRpb25UeXBlKSB7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJPVkVSV1JJVEVcIl0gPSAwXSA9IFwiT1ZFUldSSVRFXCI7XHJcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJNRVJHRVwiXSA9IDFdID0gXCJNRVJHRVwiO1xyXG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiQUNLX1VTRVJfV1JJVEVcIl0gPSAyXSA9IFwiQUNLX1VTRVJfV1JJVEVcIjtcclxuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIkxJU1RFTl9DT01QTEVURVwiXSA9IDNdID0gXCJMSVNURU5fQ09NUExFVEVcIjtcclxufSkoT3BlcmF0aW9uVHlwZSB8fCAoT3BlcmF0aW9uVHlwZSA9IHt9KSk7XHJcbmZ1bmN0aW9uIG5ld09wZXJhdGlvblNvdXJjZVVzZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiB0cnVlLFxyXG4gICAgICAgIGZyb21TZXJ2ZXI6IGZhbHNlLFxyXG4gICAgICAgIHF1ZXJ5SWQ6IG51bGwsXHJcbiAgICAgICAgdGFnZ2VkOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiBmYWxzZSxcclxuICAgICAgICBmcm9tU2VydmVyOiB0cnVlLFxyXG4gICAgICAgIHF1ZXJ5SWQ6IG51bGwsXHJcbiAgICAgICAgdGFnZ2VkOiBmYWxzZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGZyb21Vc2VyOiBmYWxzZSxcclxuICAgICAgICBmcm9tU2VydmVyOiB0cnVlLFxyXG4gICAgICAgIHF1ZXJ5SWQsXHJcbiAgICAgICAgdGFnZ2VkOiB0cnVlXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEFja1VzZXJXcml0ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhZmZlY3RlZFRyZWUgLSBBIHRyZWUgY29udGFpbmluZyB0cnVlIGZvciBlYWNoIGFmZmVjdGVkIHBhdGguIEFmZmVjdGVkIHBhdGhzIGNhbid0IG92ZXJsYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIHBhdGgsIFxyXG4gICAgLyoqIEBpbmhlcml0RG9jICovIGFmZmVjdGVkVHJlZSwgXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gcmV2ZXJ0KSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZTtcclxuICAgICAgICB0aGlzLnJldmVydCA9IHJldmVydDtcclxuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gbmV3T3BlcmF0aW9uU291cmNlVXNlcigpO1xyXG4gICAgfVxyXG4gICAgb3BlcmF0aW9uRm9yQ2hpbGQoY2hpbGROYW1lKSB7XHJcbiAgICAgICAgaWYgKCFwYXRoSXNFbXB0eSh0aGlzLnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGFzc2VydChwYXRoR2V0RnJvbnQodGhpcy5wYXRoKSA9PT0gY2hpbGROYW1lLCAnb3BlcmF0aW9uRm9yQ2hpbGQgY2FsbGVkIGZvciB1bnJlbGF0ZWQgY2hpbGQuJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWNrVXNlcldyaXRlKHBhdGhQb3BGcm9udCh0aGlzLnBhdGgpLCB0aGlzLmFmZmVjdGVkVHJlZSwgdGhpcy5yZXZlcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGFzc2VydCh0aGlzLmFmZmVjdGVkVHJlZS5jaGlsZHJlbi5pc0VtcHR5KCksICdhZmZlY3RlZFRyZWUgc2hvdWxkIG5vdCBoYXZlIG92ZXJsYXBwaW5nIGFmZmVjdGVkIHBhdGhzLicpO1xyXG4gICAgICAgICAgICAvLyBBbGwgY2hpbGQgbG9jYXRpb25zIGFyZSBhZmZlY3RlZCBhcyB3ZWxsOyBqdXN0IHJldHVybiBzYW1lIG9wZXJhdGlvbi5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmFmZmVjdGVkVHJlZS5zdWJ0cmVlKG5ldyBQYXRoKGNoaWxkTmFtZSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFja1VzZXJXcml0ZShuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlLCB0aGlzLnJldmVydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIExpc3RlbkNvbXBsZXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgcGF0aCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEU7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RlbkNvbXBsZXRlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIE92ZXJ3cml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHBhdGgsIHNuYXApIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XHJcbiAgICAgICAgLyoqIEBpbmhlcml0RG9jICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEU7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE92ZXJ3cml0ZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIHRoaXMuc25hcC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5zbmFwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY2xhc3MgTWVyZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAvKiogQGluaGVyaXREb2MgKi8gc291cmNlLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBwYXRoLCBcclxuICAgIC8qKiBAaW5oZXJpdERvYyAqLyBjaGlsZHJlbikge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IE9wZXJhdGlvblR5cGUuTUVSR0U7XHJcbiAgICB9XHJcbiAgICBvcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5wYXRoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFRyZWUgPSB0aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFBhdGgoY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIHVuYWZmZWN0ZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNuYXBzaG90IGZvciB0aGUgY2hpbGQgaW4gcXVlc3Rpb24uICBUaGlzIGJlY29tZXMgYW4gb3ZlcndyaXRlIG9mIHRoZSBjaGlsZC5cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBuZXdFbXB0eVBhdGgoKSwgY2hpbGRUcmVlLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXJnZSBhdCBhIGRlZXBlciBsZXZlbFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgbmV3RW1wdHlQYXRoKCksIGNoaWxkVHJlZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChwYXRoR2V0RnJvbnQodGhpcy5wYXRoKSA9PT0gY2hpbGROYW1lLCBcIkNhbid0IGdldCBhIG1lcmdlIGZvciBhIGNoaWxkIG5vdCBvbiB0aGUgcGF0aCBvZiB0aGUgb3BlcmF0aW9uXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCBwYXRoUG9wRnJvbnQodGhpcy5wYXRoKSwgdGhpcy5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgnT3BlcmF0aW9uKCcgK1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggK1xyXG4gICAgICAgICAgICAnOiAnICtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcgbWVyZ2U6ICcgK1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAnKScpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG5vZGUgb25seSBzdG9yZXMgY29tcGxldGUgY2hpbGRyZW4uIEFkZGl0aW9uYWxseSBpdCBob2xkcyBhIGZsYWcgd2hldGhlciB0aGUgbm9kZSBjYW4gYmUgY29uc2lkZXJlZCBmdWxseVxyXG4gKiBpbml0aWFsaXplZCBpbiB0aGUgc2Vuc2UgdGhhdCB3ZSBrbm93IGF0IG9uZSBwb2ludCBpbiB0aW1lIHRoaXMgcmVwcmVzZW50ZWQgYSB2YWxpZCBzdGF0ZSBvZiB0aGUgd29ybGQsIGUuZy5cclxuICogaW5pdGlhbGl6ZWQgd2l0aCBkYXRhIGZyb20gdGhlIHNlcnZlciwgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudC4gVGhlIGZpbHRlcmVkIGZsYWcgYWxzbyB0cmFja3NcclxuICogd2hldGhlciBhIG5vZGUgcG90ZW50aWFsbHkgaGFkIGNoaWxkcmVuIHJlbW92ZWQgZHVlIHRvIGEgZmlsdGVyLlxyXG4gKi9cclxuY2xhc3MgQ2FjaGVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGVfLCBmdWxseUluaXRpYWxpemVkXywgZmlsdGVyZWRfKSB7XHJcbiAgICAgICAgdGhpcy5ub2RlXyA9IG5vZGVfO1xyXG4gICAgICAgIHRoaXMuZnVsbHlJbml0aWFsaXplZF8gPSBmdWxseUluaXRpYWxpemVkXztcclxuICAgICAgICB0aGlzLmZpbHRlcmVkXyA9IGZpbHRlcmVkXztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgbm9kZSB3YXMgZnVsbHkgaW5pdGlhbGl6ZWQgd2l0aCBlaXRoZXIgc2VydmVyIGRhdGEgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudFxyXG4gICAgICovXHJcbiAgICBpc0Z1bGx5SW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVsbHlJbml0aWFsaXplZF87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgaXMgcG90ZW50aWFsbHkgbWlzc2luZyBjaGlsZHJlbiBkdWUgdG8gYSBmaWx0ZXIgYXBwbGllZCB0byB0aGUgbm9kZVxyXG4gICAgICovXHJcbiAgICBpc0ZpbHRlcmVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmVkXztcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGVGb3JQYXRoKHBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZUZvckNoaWxkKGtleSkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaXNGdWxseUluaXRpYWxpemVkKCkgJiYgIXRoaXMuZmlsdGVyZWRfKSB8fCB0aGlzLm5vZGVfLmhhc0NoaWxkKGtleSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQW4gRXZlbnRHZW5lcmF0b3IgaXMgdXNlZCB0byBjb252ZXJ0IFwicmF3XCIgY2hhbmdlcyAoQ2hhbmdlKSBhcyBjb21wdXRlZCBieSB0aGVcclxuICogQ2FjaGVEaWZmZXIgaW50byBhY3R1YWwgZXZlbnRzIChFdmVudCkgdGhhdCBjYW4gYmUgcmFpc2VkLiAgU2VlIGdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcygpXHJcbiAqIGZvciBkZXRhaWxzLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgRXZlbnRHZW5lcmF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IocXVlcnlfKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeV8gPSBxdWVyeV87XHJcbiAgICAgICAgdGhpcy5pbmRleF8gPSB0aGlzLnF1ZXJ5Xy5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2l2ZW4gYSBzZXQgb2YgcmF3IGNoYW5nZXMgKG5vIG1vdmVkIGV2ZW50cyBhbmQgcHJldk5hbWUgbm90IHNwZWNpZmllZCB5ZXQpLCBhbmQgYSBzZXQgb2ZcclxuICogRXZlbnRSZWdpc3RyYXRpb25zIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHRoZXNlIGNoYW5nZXMsIGdlbmVyYXRlIHRoZSBhY3R1YWwgZXZlbnRzIHRvIGJlIHJhaXNlZC5cclxuICpcclxuICogTm90ZXM6XHJcbiAqICAtIGNoaWxkX21vdmVkIGV2ZW50cyB3aWxsIGJlIHN5bnRoZXNpemVkIGF0IHRoaXMgdGltZSBmb3IgYW55IGNoaWxkX2NoYW5nZWQgZXZlbnRzIHRoYXQgYWZmZWN0XHJcbiAqICAgIG91ciBpbmRleC5cclxuICogIC0gcHJldk5hbWUgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBpbmRleCBvcmRlcmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKGV2ZW50R2VuZXJhdG9yLCBjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbnMpIHtcclxuICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xyXG4gICAgY29uc3QgbW92ZXMgPSBbXTtcclxuICAgIGNoYW5nZXMuZm9yRWFjaChjaGFuZ2UgPT4ge1xyXG4gICAgICAgIGlmIChjaGFuZ2UudHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovICYmXHJcbiAgICAgICAgICAgIGV2ZW50R2VuZXJhdG9yLmluZGV4Xy5pbmRleGVkVmFsdWVDaGFuZ2VkKGNoYW5nZS5vbGRTbmFwLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSkge1xyXG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGNoYW5nZUNoaWxkTW92ZWQoY2hhbmdlLmNoaWxkTmFtZSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovLCBjaGFuZ2VzLCBldmVudFJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpO1xyXG4gICAgZXZlbnRHZW5lcmF0b3JHZW5lcmF0ZUV2ZW50c0ZvclR5cGUoZXZlbnRHZW5lcmF0b3IsIGV2ZW50cywgXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX21vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9NT1ZFRCAqLywgbW92ZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8sIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XHJcbiAgICBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yVHlwZShldmVudEdlbmVyYXRvciwgZXZlbnRzLCBcInZhbHVlXCIgLyogQ2hhbmdlVHlwZS5WQUxVRSAqLywgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcclxuICAgIHJldHVybiBldmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGNoYW5nZXMgb2YgYSBzaW5nbGUgY2hhbmdlIHR5cGUsIGdlbmVyYXRlIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50cy5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yR2VuZXJhdGVFdmVudHNGb3JUeXBlKGV2ZW50R2VuZXJhdG9yLCBldmVudHMsIGV2ZW50VHlwZSwgY2hhbmdlcywgcmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSkge1xyXG4gICAgY29uc3QgZmlsdGVyZWRDaGFuZ2VzID0gY2hhbmdlcy5maWx0ZXIoY2hhbmdlID0+IGNoYW5nZS50eXBlID09PSBldmVudFR5cGUpO1xyXG4gICAgZmlsdGVyZWRDaGFuZ2VzLnNvcnQoKGEsIGIpID0+IGV2ZW50R2VuZXJhdG9yQ29tcGFyZUNoYW5nZXMoZXZlbnRHZW5lcmF0b3IsIGEsIGIpKTtcclxuICAgIGZpbHRlcmVkQ2hhbmdlcy5mb3JFYWNoKGNoYW5nZSA9PiB7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWxpemVkQ2hhbmdlID0gZXZlbnRHZW5lcmF0b3JNYXRlcmlhbGl6ZVNpbmdsZUNoYW5nZShldmVudEdlbmVyYXRvciwgY2hhbmdlLCBldmVudENhY2hlKTtcclxuICAgICAgICByZWdpc3RyYXRpb25zLmZvckVhY2gocmVnaXN0cmF0aW9uID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbi5yZXNwb25kc1RvKGNoYW5nZS50eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2gocmVnaXN0cmF0aW9uLmNyZWF0ZUV2ZW50KG1hdGVyaWFsaXplZENoYW5nZSwgZXZlbnRHZW5lcmF0b3IucXVlcnlfKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGV2ZW50R2VuZXJhdG9yTWF0ZXJpYWxpemVTaW5nbGVDaGFuZ2UoZXZlbnRHZW5lcmF0b3IsIGNoYW5nZSwgZXZlbnRDYWNoZSkge1xyXG4gICAgaWYgKGNoYW5nZS50eXBlID09PSAndmFsdWUnIHx8IGNoYW5nZS50eXBlID09PSAnY2hpbGRfcmVtb3ZlZCcpIHtcclxuICAgICAgICByZXR1cm4gY2hhbmdlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY2hhbmdlLnByZXZOYW1lID0gZXZlbnRDYWNoZS5nZXRQcmVkZWNlc3NvckNoaWxkTmFtZShjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlLCBldmVudEdlbmVyYXRvci5pbmRleF8pO1xyXG4gICAgICAgIHJldHVybiBjaGFuZ2U7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRHZW5lcmF0b3JDb21wYXJlQ2hhbmdlcyhldmVudEdlbmVyYXRvciwgYSwgYikge1xyXG4gICAgaWYgKGEuY2hpbGROYW1lID09IG51bGwgfHwgYi5jaGlsZE5hbWUgPT0gbnVsbCkge1xyXG4gICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdTaG91bGQgb25seSBjb21wYXJlIGNoaWxkXyBldmVudHMuJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhV3JhcHBlZCA9IG5ldyBOYW1lZE5vZGUoYS5jaGlsZE5hbWUsIGEuc25hcHNob3ROb2RlKTtcclxuICAgIGNvbnN0IGJXcmFwcGVkID0gbmV3IE5hbWVkTm9kZShiLmNoaWxkTmFtZSwgYi5zbmFwc2hvdE5vZGUpO1xyXG4gICAgcmV0dXJuIGV2ZW50R2VuZXJhdG9yLmluZGV4Xy5jb21wYXJlKGFXcmFwcGVkLCBiV3JhcHBlZCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gbmV3Vmlld0NhY2hlKGV2ZW50Q2FjaGUsIHNlcnZlckNhY2hlKSB7XHJcbiAgICByZXR1cm4geyBldmVudENhY2hlLCBzZXJ2ZXJDYWNoZSB9O1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIGV2ZW50U25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSB7XHJcbiAgICByZXR1cm4gbmV3Vmlld0NhY2hlKG5ldyBDYWNoZU5vZGUoZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpLCB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAodmlld0NhY2hlLCBzZXJ2ZXJTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcclxuICAgIHJldHVybiBuZXdWaWV3Q2FjaGUodmlld0NhY2hlLmV2ZW50Q2FjaGUsIG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgY29tcGxldGUsIGZpbHRlcmVkKSk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAodmlld0NhY2hlKSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLmV2ZW50Q2FjaGUuaXNGdWxseUluaXRpYWxpemVkKClcclxuICAgICAgICA/IHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKVxyXG4gICAgICAgIDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpXHJcbiAgICAgICAgPyB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpXHJcbiAgICAgICAgOiBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmxldCBlbXB0eUNoaWxkcmVuU2luZ2xldG9uO1xyXG4vKipcclxuICogU2luZ2xldG9uIGVtcHR5IGNoaWxkcmVuIGNvbGxlY3Rpb24uXHJcbiAqXHJcbiAqL1xyXG5jb25zdCBFbXB0eUNoaWxkcmVuID0gKCkgPT4ge1xyXG4gICAgaWYgKCFlbXB0eUNoaWxkcmVuU2luZ2xldG9uKSB7XHJcbiAgICAgICAgZW1wdHlDaGlsZHJlblNpbmdsZXRvbiA9IG5ldyBTb3J0ZWRNYXAoc3RyaW5nQ29tcGFyZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZW1wdHlDaGlsZHJlblNpbmdsZXRvbjtcclxufTtcclxuLyoqXHJcbiAqIEEgdHJlZSB3aXRoIGltbXV0YWJsZSBlbGVtZW50cy5cclxuICovXHJcbmNsYXNzIEltbXV0YWJsZVRyZWUge1xyXG4gICAgY29uc3RydWN0b3IodmFsdWUsIGNoaWxkcmVuID0gRW1wdHlDaGlsZHJlbigpKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KG9iaikge1xyXG4gICAgICAgIGxldCB0cmVlID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgZWFjaChvYmosIChjaGlsZFBhdGgsIGNoaWxkU25hcCkgPT4ge1xyXG4gICAgICAgICAgICB0cmVlID0gdHJlZS5zZXQobmV3IFBhdGgoY2hpbGRQYXRoKSwgY2hpbGRTbmFwKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdHJlZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgZW1wdHkgYW5kIHRoZXJlIGFyZSBubyBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBudWxsICYmIHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIHBhdGggYW5kIHByZWRpY2F0ZSwgcmV0dXJuIHRoZSBmaXJzdCBub2RlIGFuZCB0aGUgcGF0aCB0byB0aGF0IG5vZGVcclxuICAgICAqIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIFRPRE8gRG8gYSBwZXJmIHRlc3QgLS0gSWYgd2UncmUgY3JlYXRpbmcgYSBidW5jaCBvZiBge3BhdGg6IHZhbHVlOn1gXHJcbiAgICAgKiBvYmplY3RzIG9uIHRoZSB3YXkgYmFjayBvdXQsIGl0IG1heSBiZSBiZXR0ZXIgdG8gcGFzcyBkb3duIGEgcGF0aFNvRmFyIG9iai5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gVGhlIHJlbWFpbmRlciBvZiB0aGUgcGF0aFxyXG4gICAgICogQHBhcmFtIHByZWRpY2F0ZSAtIFRoZSBwcmVkaWNhdGUgdG8gc2F0aXNmeSB0byByZXR1cm4gYSBub2RlXHJcbiAgICAgKi9cclxuICAgIGZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlKHJlbGF0aXZlUGF0aCwgcHJlZGljYXRlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT0gbnVsbCAmJiBwcmVkaWNhdGUodGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aDogbmV3RW1wdHlQYXRoKCksIHZhbHVlOiB0aGlzLnZhbHVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlID0gY2hpbGQuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocGF0aFBvcEZyb250KHJlbGF0aXZlUGF0aCksIHByZWRpY2F0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhDaGlsZChuZXcgUGF0aChmcm9udCksIGNoaWxkRXhpc3RpbmdQYXRoQW5kVmFsdWUucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGZ1bGxQYXRoLCB2YWx1ZTogY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS52YWx1ZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQsIGlmIGl0IGV4aXN0cywgdGhlIHNob3J0ZXN0IHN1YnBhdGggb2YgdGhlIGdpdmVuIHBhdGggdGhhdCBwb2ludHMgYSBkZWZpbmVkXHJcbiAgICAgKiB2YWx1ZSBpbiB0aGUgdHJlZVxyXG4gICAgICovXHJcbiAgICBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLCAoKSA9PiB0cnVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHN1YnRyZWUgYXQgdGhlIGdpdmVuIHBhdGhcclxuICAgICAqL1xyXG4gICAgc3VidHJlZShyZWxhdGl2ZVBhdGgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkVHJlZS5zdWJ0cmVlKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byBzZXQgdmFsdWUgYXQuXHJcbiAgICAgKiBAcGFyYW0gdG9TZXQgLSBWYWx1ZSB0byBzZXQuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgc2V0KHJlbGF0aXZlUGF0aCwgdG9TZXQpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodG9TZXQsIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0KHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpLCB0b1NldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHZhbHVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byB2YWx1ZSB0byByZW1vdmUuXHJcbiAgICAgKiBAcmV0dXJucyBSZXN1bHRpbmcgdHJlZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKHJlbGF0aXZlUGF0aCkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKG51bGwsIHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkLnJlbW92ZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3Q2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCAmJiBuZXdDaGlsZHJlbi5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUodGhpcy52YWx1ZSwgbmV3Q2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0cmVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZWxhdGl2ZVBhdGggLSBQYXRoIHRvIGdldCB2YWx1ZSBmb3IuXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZSBhdCBwYXRoLCBvciBudWxsLlxyXG4gICAgICovXHJcbiAgICBnZXQocmVsYXRpdmVQYXRoKSB7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHJlbGF0aXZlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBmcm9udCA9IHBhdGhHZXRGcm9udChyZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuZ2V0KHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIHRoZSBzdWJ0cmVlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIHRoZSBnaXZlbiBuZXcgdHJlZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVQYXRoIC0gUGF0aCB0byByZXBsYWNlIHN1YnRyZWUgZm9yLlxyXG4gICAgICogQHBhcmFtIG5ld1RyZWUgLSBOZXcgdHJlZS5cclxuICAgICAqIEByZXR1cm5zIFJlc3VsdGluZyB0cmVlLlxyXG4gICAgICovXHJcbiAgICBzZXRUcmVlKHJlbGF0aXZlUGF0aCwgbmV3VHJlZSkge1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdUcmVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCkgfHwgbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gY2hpbGQuc2V0VHJlZShwYXRoUG9wRnJvbnQocmVsYXRpdmVQYXRoKSwgbmV3VHJlZSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgZGVwdGggZmlyc3QgZm9sZCBvbiB0aGlzIHRyZWUuIFRyYW5zZm9ybXMgYSB0cmVlIGludG8gYSBzaW5nbGVcclxuICAgICAqIHZhbHVlLCBnaXZlbiBhIGZ1bmN0aW9uIHRoYXQgb3BlcmF0ZXMgb24gdGhlIHBhdGggdG8gYSBub2RlLCBhbiBvcHRpb25hbFxyXG4gICAgICogY3VycmVudCB2YWx1ZSwgYW5kIGEgbWFwIG9mIGNoaWxkIG5hbWVzIHRvIGZvbGRlZCBzdWJ0cmVlc1xyXG4gICAgICovXHJcbiAgICBmb2xkKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZF8obmV3RW1wdHlQYXRoKCksIGZuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjdXJzaXZlIGhlbHBlciBmb3IgcHVibGljLWZhY2luZyBmb2xkKCkgbWV0aG9kXHJcbiAgICAgKi9cclxuICAgIGZvbGRfKHBhdGhTb0ZhciwgZm4pIHtcclxuICAgICAgICBjb25zdCBhY2N1bSA9IHt9O1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bVtjaGlsZEtleV0gPSBjaGlsZFRyZWUuZm9sZF8ocGF0aENoaWxkKHBhdGhTb0ZhciwgY2hpbGRLZXkpLCBmbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZuKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSwgYWNjdW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCBtYXRjaGluZyB2YWx1ZSBvbiB0aGUgZ2l2ZW4gcGF0aC4gUmV0dXJuIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgZiB0byBpdC5cclxuICAgICAqL1xyXG4gICAgZmluZE9uUGF0aChwYXRoLCBmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZE9uUGF0aF8ocGF0aCwgbmV3RW1wdHlQYXRoKCksIGYpO1xyXG4gICAgfVxyXG4gICAgZmluZE9uUGF0aF8ocGF0aFRvRm9sbG93LCBwYXRoU29GYXIsIGYpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnZhbHVlID8gZihwYXRoU29GYXIsIHRoaXMudmFsdWUpIDogZmFsc2U7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhdGhUb0ZvbGxvdykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aFRvRm9sbG93KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENoaWxkLmZpbmRPblBhdGhfKHBhdGhQb3BGcm9udChwYXRoVG9Gb2xsb3cpLCBwYXRoQ2hpbGQocGF0aFNvRmFyLCBmcm9udCksIGYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoT25QYXRoKHBhdGgsIGYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JlYWNoT25QYXRoXyhwYXRoLCBuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoT25QYXRoXyhwYXRoVG9Gb2xsb3csIGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aFRvRm9sbG93KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBmKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gcGF0aEdldEZyb250KHBhdGhUb0ZvbGxvdyk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcclxuICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaGlsZC5mb3JlYWNoT25QYXRoXyhwYXRoUG9wRnJvbnQocGF0aFRvRm9sbG93KSwgcGF0aENoaWxkKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGZyb250KSwgZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBub2RlIGluIHRoZSB0cmVlIHRoYXQgaGFzIGEgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGYgLSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBwYXRoIGZyb20gdGhlIHJvb3Qgb2YgdGhlIHRyZWUgdG9cclxuICAgICAqIGEgbm9kZSwgYW5kIHRoZSB2YWx1ZSBhdCB0aGF0IG5vZGUuIENhbGxlZCBpbiBkZXB0aC1maXJzdCBvcmRlci5cclxuICAgICAqL1xyXG4gICAgZm9yZWFjaChmKSB7XHJcbiAgICAgICAgdGhpcy5mb3JlYWNoXyhuZXdFbXB0eVBhdGgoKSwgZik7XHJcbiAgICB9XHJcbiAgICBmb3JlYWNoXyhjdXJyZW50UmVsYXRpdmVQYXRoLCBmKSB7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZE5hbWUsIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgICAgICBjaGlsZFRyZWUuZm9yZWFjaF8ocGF0aENoaWxkKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGNoaWxkTmFtZSksIGYpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIGYoY3VycmVudFJlbGF0aXZlUGF0aCwgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yZWFjaENoaWxkKGYpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGYoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaG9sZHMgYSBjb2xsZWN0aW9uIG9mIHdyaXRlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIG5vZGVzIGluIHVuaXNvbi4gSXQgYWJzdHJhY3RzIGF3YXkgdGhlIGxvZ2ljIHdpdGhcclxuICogZGVhbGluZyB3aXRoIHByaW9yaXR5IHdyaXRlcyBhbmQgbXVsdGlwbGUgbmVzdGVkIHdyaXRlcy4gQXQgYW55IGdpdmVuIHBhdGggdGhlcmUgaXMgb25seSBhbGxvd2VkIHRvIGJlIG9uZSB3cml0ZVxyXG4gKiBtb2RpZnlpbmcgdGhhdCBwYXRoLiBBbnkgd3JpdGUgdG8gYW4gZXhpc3RpbmcgcGF0aCBvciBzaGFkb3dpbmcgYW4gZXhpc3RpbmcgcGF0aCB3aWxsIG1vZGlmeSB0aGF0IGV4aXN0aW5nIHdyaXRlXHJcbiAqIHRvIHJlZmxlY3QgdGhlIHdyaXRlIGFkZGVkLlxyXG4gKi9cclxuY2xhc3MgQ29tcG91bmRXcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3cml0ZVRyZWVfKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZVRyZWVfID0gd3JpdGVUcmVlXztcclxuICAgIH1cclxuICAgIHN0YXRpYyBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUobnVsbCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCBwYXRoLCBub2RlKSB7XHJcbiAgICBpZiAocGF0aElzRW1wdHkocGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUobm9kZSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgcm9vdG1vc3QgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoKHBhdGgpO1xyXG4gICAgICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvb3RNb3N0UGF0aCA9IHJvb3Rtb3N0LnBhdGg7XHJcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHJvb3Rtb3N0LnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocm9vdE1vc3RQYXRoLCBwYXRoKTtcclxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIG5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUoY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLnNldChyb290TW9zdFBhdGgsIHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzdWJ0cmVlID0gbmV3IEltbXV0YWJsZVRyZWUobm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1dyaXRlVHJlZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zZXRUcmVlKHBhdGgsIHN1YnRyZWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3V3JpdGVUcmVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCBwYXRoLCB1cGRhdGVzKSB7XHJcbiAgICBsZXQgbmV3V3JpdGUgPSBjb21wb3VuZFdyaXRlO1xyXG4gICAgZWFjaCh1cGRhdGVzLCAoY2hpbGRLZXksIG5vZGUpID0+IHtcclxuICAgICAgICBuZXdXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShuZXdXcml0ZSwgcGF0aENoaWxkKHBhdGgsIGNoaWxkS2V5KSwgbm9kZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBuZXdXcml0ZTtcclxufVxyXG4vKipcclxuICogV2lsbCByZW1vdmUgYSB3cml0ZSBhdCB0aGUgZ2l2ZW4gcGF0aCBhbmQgZGVlcGVyIHBhdGhzLiBUaGlzIHdpbGwgPGVtPm5vdDwvZW0+IG1vZGlmeSBhIHdyaXRlIGF0IGEgaGlnaGVyXHJcbiAqIGxvY2F0aW9uLCB3aGljaCBtdXN0IGJlIHJlbW92ZWQgYnkgY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIHRoYXQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNvbXBvdW5kV3JpdGUgLSBUaGUgQ29tcG91bmRXcml0ZSB0byByZW1vdmUuXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYXQgd2hpY2ggYSB3cml0ZSBhbmQgYWxsIGRlZXBlciB3cml0ZXMgc2hvdWxkIGJlIHJlbW92ZWRcclxuICogQHJldHVybnMgVGhlIG5ldyBDb21wb3VuZFdyaXRlIHdpdGggdGhlIHJlbW92ZWQgcGF0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBDb21wb3VuZFdyaXRlLmVtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBuZXdXcml0ZVRyZWUgPSBjb21wb3VuZFdyaXRlLndyaXRlVHJlZV8uc2V0VHJlZShwYXRoLCBuZXcgSW1tdXRhYmxlVHJlZShudWxsKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgd2lsbCBmdWxseSBvdmVyd3JpdGUgYSBub2RlIGF0IGEgZ2l2ZW4gbG9jYXRpb24gYW5kIGNhbiB0aGVyZWZvcmUgYmVcclxuICogY29uc2lkZXJlZCBcImNvbXBsZXRlXCIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gY2hlY2suXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gY2hlY2sgZm9yXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlcmUgaXMgYSBjb21wbGV0ZSB3cml0ZSBhdCB0aGF0IHBhdGhcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIHJldHVybiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpICE9IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGZvciBhIHBhdGggaWYgYW5kIG9ubHkgaWYgdGhlIG5vZGUgaXMgYSBcImNvbXBsZXRlXCIgb3ZlcndyaXRlIGF0IHRoYXQgcGF0aC4gVGhpcyB3aWxsIG5vdCBhZ2dyZWdhdGVcclxuICogd3JpdGVzIGZyb20gZGVlcGVyIHBhdGhzLCBidXQgd2lsbCByZXR1cm4gY2hpbGQgbm9kZXMgZnJvbSBhIG1vcmUgc2hhbGxvdyBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcG91bmRXcml0ZSAtIFRoZSBDb21wb3VuZFdyaXRlIHRvIGdldCB0aGUgbm9kZSBmcm9tLlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIGdldCBhIGNvbXBsZXRlIHdyaXRlXHJcbiAqIEByZXR1cm5zIFRoZSBub2RlIGlmIGNvbXBsZXRlIGF0IHRoYXQgcGF0aCwgb3IgbnVsbCBvdGhlcndpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVOb2RlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGNvbnN0IHJvb3Rtb3N0ID0gY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcclxuICAgIGlmIChyb290bW9zdCAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlX1xyXG4gICAgICAgICAgICAuZ2V0KHJvb3Rtb3N0LnBhdGgpXHJcbiAgICAgICAgICAgIC5nZXRDaGlsZChuZXdSZWxhdGl2ZVBhdGgocm9vdG1vc3QucGF0aCwgcGF0aCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYWxsIGNoaWxkcmVuIHRoYXQgYXJlIGd1YXJhbnRlZWQgdG8gYmUgYSBjb21wbGV0ZSBvdmVyd3JpdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb21wb3VuZFdyaXRlIC0gVGhlIENvbXBvdW5kV3JpdGUgdG8gZ2V0IGNoaWxkcmVuIGZyb20uXHJcbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBhbGwgY29tcGxldGUgY2hpbGRyZW4uXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihjb21wb3VuZFdyaXRlKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xyXG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy52YWx1ZTtcclxuICAgIGlmIChub2RlICE9IG51bGwpIHtcclxuICAgICAgICAvLyBJZiBpdCdzIGEgbGVhZiBub2RlLCBpdCBoYXMgbm8gY2hpbGRyZW47IHNvIG5vdGhpbmcgdG8gZG8uXHJcbiAgICAgICAgaWYgKCFub2RlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgICAgICBub2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29tcG91bmRXcml0ZS53cml0ZVRyZWVfLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGRUcmVlLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5mdW5jdGlvbiBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShwYXRoKSkge1xyXG4gICAgICAgIHJldHVybiBjb21wb3VuZFdyaXRlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUoY29tcG91bmRXcml0ZSwgcGF0aCk7XHJcbiAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWUoc2hhZG93aW5nTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5zdWJ0cmVlKHBhdGgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIENvbXBvdW5kV3JpdGUgaXMgZW1wdHkgYW5kIHRoZXJlZm9yZSBkb2VzIG5vdCBtb2RpZnkgYW55IG5vZGVzLlxyXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoaXMgQ29tcG91bmRXcml0ZSBpcyBlbXB0eVxyXG4gKi9cclxuZnVuY3Rpb24gY29tcG91bmRXcml0ZUlzRW1wdHkoY29tcG91bmRXcml0ZSkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXy5pc0VtcHR5KCk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhpcyBDb21wb3VuZFdyaXRlIHRvIGEgbm9kZS4gVGhlIG5vZGUgaXMgcmV0dXJuZWQgd2l0aCBhbGwgd3JpdGVzIGZyb20gdGhpcyBDb21wb3VuZFdyaXRlIGFwcGxpZWQgdG8gdGhlXHJcbiAqIG5vZGVcclxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBhcHBseSB0aGlzIENvbXBvdW5kV3JpdGUgdG9cclxuICogQHJldHVybnMgVGhlIG5vZGUgd2l0aCBhbGwgd3JpdGVzIGFwcGxpZWRcclxuICovXHJcbmZ1bmN0aW9uIGNvbXBvdW5kV3JpdGVBcHBseShjb21wb3VuZFdyaXRlLCBub2RlKSB7XHJcbiAgICByZXR1cm4gYXBwbHlTdWJ0cmVlV3JpdGUobmV3RW1wdHlQYXRoKCksIGNvbXBvdW5kV3JpdGUud3JpdGVUcmVlXywgbm9kZSk7XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlTdWJ0cmVlV3JpdGUocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUsIG5vZGUpIHtcclxuICAgIGlmICh3cml0ZVRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGEgd3JpdGUgaXMgYWx3YXlzIGEgbGVhZiwgd2UncmUgZG9uZSBoZXJlXHJcbiAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHByaW9yaXR5V3JpdGUgPSBudWxsO1xyXG4gICAgICAgIHdyaXRlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKChjaGlsZEtleSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHByaW9yaXRpZXMgYXQgdGhlIGVuZCBzbyB3ZSBkb24ndCB1cGRhdGUgcHJpb3JpdGllcyBmb3IgZWl0aGVyIGVtcHR5IG5vZGVzIG9yIGZvcmdldFxyXG4gICAgICAgICAgICAgICAgLy8gdG8gYXBwbHkgcHJpb3JpdGllcyB0byBlbXB0eSBub2RlcyB0aGF0IGFyZSBsYXRlciBmaWxsZWRcclxuICAgICAgICAgICAgICAgIGFzc2VydChjaGlsZFRyZWUudmFsdWUgIT09IG51bGwsICdQcmlvcml0eSB3cml0ZXMgbXVzdCBhbHdheXMgYmUgbGVhZiBub2RlcycpO1xyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHlXcml0ZSA9IGNoaWxkVHJlZS52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBhcHBseVN1YnRyZWVXcml0ZShwYXRoQ2hpbGQocmVsYXRpdmVQYXRoLCBjaGlsZEtleSksIGNoaWxkVHJlZSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmlvcml0eSB3cml0ZSwgd2Ugb25seSBhcHBseSBpdCBpZiB0aGUgbm9kZSBpcyBub3QgZW1wdHlcclxuICAgICAgICBpZiAoIW5vZGUuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKS5pc0VtcHR5KCkgJiYgcHJpb3JpdHlXcml0ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChwYXRoQ2hpbGQocmVsYXRpdmVQYXRoLCAnLnByaW9yaXR5JyksIHByaW9yaXR5V3JpdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFdyaXRlVHJlZVJlZiBmb3IgdGhlIGdpdmVuIHBhdGguIEZvciB1c2Ugd2l0aCBhIG5ldyBzeW5jIHBvaW50IGF0IHRoZSBnaXZlbiBwYXRoLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2hpbGRXcml0ZXMod3JpdGVUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gbmV3V3JpdGVUcmVlUmVmKHBhdGgsIHdyaXRlVHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY29yZCBhIG5ldyBvdmVyd3JpdGUgZnJvbSB1c2VyIGNvZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2aXNpYmxlIC0gVGhpcyBpcyBzZXQgdG8gZmFsc2UgYnkgc29tZSB0cmFuc2FjdGlvbnMuIEl0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIGV2ZW50IGNhY2hlc1xyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQWRkT3ZlcndyaXRlKHdyaXRlVHJlZSwgcGF0aCwgc25hcCwgd3JpdGVJZCwgdmlzaWJsZSkge1xyXG4gICAgYXNzZXJ0KHdyaXRlSWQgPiB3cml0ZVRyZWUubGFzdFdyaXRlSWQsICdTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lcycpO1xyXG4gICAgaWYgKHZpc2libGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZpc2libGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcmVlLmFsbFdyaXRlcy5wdXNoKHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHNuYXAsXHJcbiAgICAgICAgd3JpdGVJZCxcclxuICAgICAgICB2aXNpYmxlXHJcbiAgICB9KTtcclxuICAgIGlmICh2aXNpYmxlKSB7XHJcbiAgICAgICAgd3JpdGVUcmVlLnZpc2libGVXcml0ZXMgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgsIHNuYXApO1xyXG4gICAgfVxyXG4gICAgd3JpdGVUcmVlLmxhc3RXcml0ZUlkID0gd3JpdGVJZDtcclxufVxyXG4vKipcclxuICogUmVjb3JkIGEgbmV3IG1lcmdlIGZyb20gdXNlciBjb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQWRkTWVyZ2Uod3JpdGVUcmVlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpIHtcclxuICAgIGFzc2VydCh3cml0ZUlkID4gd3JpdGVUcmVlLmxhc3RXcml0ZUlkLCAnU3RhY2tpbmcgYW4gb2xkZXIgbWVyZ2Ugb24gdG9wIG9mIG5ld2VyIG9uZXMnKTtcclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMucHVzaCh7XHJcbiAgICAgICAgcGF0aCxcclxuICAgICAgICBjaGlsZHJlbjogY2hhbmdlZENoaWxkcmVuLFxyXG4gICAgICAgIHdyaXRlSWQsXHJcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZXMod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPSB3cml0ZUlkO1xyXG59XHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUdldFdyaXRlKHdyaXRlVHJlZSwgd3JpdGVJZCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVjb3JkID0gd3JpdGVUcmVlLmFsbFdyaXRlc1tpXTtcclxuICAgICAgICBpZiAocmVjb3JkLndyaXRlSWQgPT09IHdyaXRlSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlY29yZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGEgd3JpdGUgKGVpdGhlciBhbiBvdmVyd3JpdGUgb3IgbWVyZ2UpIHRoYXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGFja25vd2xlZGdlIGJ5IHRoZSBzZXJ2ZXIuIFJlY2FsY3VsYXRlc1xyXG4gKiB0aGUgdHJlZSBpZiBuZWNlc3NhcnkuICBXZSByZXR1cm4gdHJ1ZSBpZiBpdCBtYXkgaGF2ZSBiZWVuIHZpc2libGUsIG1lYW5pbmcgdmlld3MgbmVlZCB0byByZWV2YWx1YXRlLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSB3cml0ZSBtYXkgaGF2ZSBiZWVuIHZpc2libGUgKG1lYW5pbmcgd2UnbGwgbmVlZCB0byByZWV2YWx1YXRlIC8gcmFpc2VcclxuICogZXZlbnRzIGFzIGEgcmVzdWx0KS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlbW92ZVdyaXRlKHdyaXRlVHJlZSwgd3JpdGVJZCkge1xyXG4gICAgLy8gTm90ZTogZGlzYWJsaW5nIHRoaXMgY2hlY2suIEl0IGNvdWxkIGJlIGEgdHJhbnNhY3Rpb24gdGhhdCBwcmVlbXB0ZWQgYW5vdGhlciB0cmFuc2FjdGlvbiwgYW5kIHRodXMgd2FzIGFwcGxpZWRcclxuICAgIC8vIG91dCBvZiBvcmRlci5cclxuICAgIC8vY29uc3QgdmFsaWRDbGVhciA9IHJldmVydCB8fCB0aGlzLmFsbFdyaXRlc18ubGVuZ3RoID09PSAwIHx8IHdyaXRlSWQgPD0gdGhpcy5hbGxXcml0ZXNfWzBdLndyaXRlSWQ7XHJcbiAgICAvL2Fzc2VydCh2YWxpZENsZWFyLCBcIkVpdGhlciB3ZSBkb24ndCBoYXZlIHRoaXMgd3JpdGUsIG9yIGl0J3MgdGhlIGZpcnN0IG9uZSBpbiB0aGUgcXVldWVcIik7XHJcbiAgICBjb25zdCBpZHggPSB3cml0ZVRyZWUuYWxsV3JpdGVzLmZpbmRJbmRleChzID0+IHtcclxuICAgICAgICByZXR1cm4gcy53cml0ZUlkID09PSB3cml0ZUlkO1xyXG4gICAgfSk7XHJcbiAgICBhc3NlcnQoaWR4ID49IDAsICdyZW1vdmVXcml0ZSBjYWxsZWQgd2l0aCBub25leGlzdGVudCB3cml0ZUlkLicpO1xyXG4gICAgY29uc3Qgd3JpdGVUb1JlbW92ZSA9IHdyaXRlVHJlZS5hbGxXcml0ZXNbaWR4XTtcclxuICAgIHdyaXRlVHJlZS5hbGxXcml0ZXMuc3BsaWNlKGlkeCwgMSk7XHJcbiAgICBsZXQgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IHdyaXRlVG9SZW1vdmUudmlzaWJsZTtcclxuICAgIGxldCByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IGZhbHNlO1xyXG4gICAgbGV0IGkgPSB3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAocmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSAmJiBpID49IDApIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50V3JpdGUgPSB3cml0ZVRyZWUuYWxsV3JpdGVzW2ldO1xyXG4gICAgICAgIGlmIChjdXJyZW50V3JpdGUudmlzaWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoaSA+PSBpZHggJiZcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZVJlY29yZENvbnRhaW5zUGF0aF8oY3VycmVudFdyaXRlLCB3cml0ZVRvUmVtb3ZlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVtb3ZlZCB3cml0ZSB3YXMgY29tcGxldGVseSBzaGFkb3dlZCBieSBhIHN1YnNlcXVlbnQgd3JpdGUuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVXYXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlVG9SZW1vdmUucGF0aCwgY3VycmVudFdyaXRlLnBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgd2UncmUgY292ZXJpbmcgc29tZSB3cml0ZXMgb3IgdGhleSdyZSBjb3ZlcmluZyBwYXJ0IG9mIHVzIChkZXBlbmRpbmcgb24gd2hpY2ggY2FtZSBmaXJzdCkuXHJcbiAgICAgICAgICAgICAgICByZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaS0tO1xyXG4gICAgfVxyXG4gICAgaWYgKCFyZW1vdmVkV3JpdGVXYXNWaXNpYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMpIHtcclxuICAgICAgICAvLyBUaGVyZSdzIHNvbWUgc2hhZG93aW5nIGdvaW5nIG9uLiBKdXN0IHJlYnVpbGQgdGhlIHZpc2libGUgd3JpdGVzIGZyb20gc2NyYXRjaC5cclxuICAgICAgICB3cml0ZVRyZWVSZXNldFRyZWVfKHdyaXRlVHJlZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGVyZSdzIG5vIHNoYWRvd2luZy4gIFdlIGNhbiBzYWZlbHkganVzdCByZW1vdmUgdGhlIHdyaXRlKHMpIGZyb20gdmlzaWJsZVdyaXRlcy5cclxuICAgICAgICBpZiAod3JpdGVUb1JlbW92ZS5zbmFwKSB7XHJcbiAgICAgICAgICAgIHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzID0gY29tcG91bmRXcml0ZVJlbW92ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB3cml0ZVRvUmVtb3ZlLnBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB3cml0ZVRvUmVtb3ZlLmNoaWxkcmVuO1xyXG4gICAgICAgICAgICBlYWNoKGNoaWxkcmVuLCAoY2hpbGROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IGNvbXBvdW5kV3JpdGVSZW1vdmVXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aENoaWxkKHdyaXRlVG9SZW1vdmUucGF0aCwgY2hpbGROYW1lKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWNvcmRDb250YWluc1BhdGhfKHdyaXRlUmVjb3JkLCBwYXRoKSB7XHJcbiAgICBpZiAod3JpdGVSZWNvcmQuc25hcCkge1xyXG4gICAgICAgIHJldHVybiBwYXRoQ29udGFpbnMod3JpdGVSZWNvcmQucGF0aCwgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTmFtZSBpbiB3cml0ZVJlY29yZC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBpZiAod3JpdGVSZWNvcmQuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoY2hpbGROYW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgcGF0aENvbnRhaW5zKHBhdGhDaGlsZCh3cml0ZVJlY29yZC5wYXRoLCBjaGlsZE5hbWUpLCBwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZS1sYXllciB0aGUgd3JpdGVzIGFuZCBtZXJnZXMgaW50byBhIHRyZWUgc28gd2UgY2FuIGVmZmljaWVudGx5IGNhbGN1bGF0ZSBldmVudCBzbmFwc2hvdHNcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlc2V0VHJlZV8od3JpdGVUcmVlKSB7XHJcbiAgICB3cml0ZVRyZWUudmlzaWJsZVdyaXRlcyA9IHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVUcmVlLmFsbFdyaXRlcywgd3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8sIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIGlmICh3cml0ZVRyZWUuYWxsV3JpdGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB3cml0ZVRyZWUubGFzdFdyaXRlSWQgPVxyXG4gICAgICAgICAgICB3cml0ZVRyZWUuYWxsV3JpdGVzW3dyaXRlVHJlZS5hbGxXcml0ZXMubGVuZ3RoIC0gMV0ud3JpdGVJZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdyaXRlVHJlZS5sYXN0V3JpdGVJZCA9IC0xO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBmaWx0ZXIgdXNlZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgdHJlZS4gS2VlcCBldmVyeXRoaW5nIHRoYXQncyB2aXNpYmxlLlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlRGVmYXVsdEZpbHRlcl8od3JpdGUpIHtcclxuICAgIHJldHVybiB3cml0ZS52aXNpYmxlO1xyXG59XHJcbi8qKlxyXG4gKiBTdGF0aWMgbWV0aG9kLiBHaXZlbiBhbiBhcnJheSBvZiBXcml0ZVJlY29yZHMsIGEgZmlsdGVyIGZvciB3aGljaCBvbmVzIHRvIGluY2x1ZGUsIGFuZCBhIHBhdGgsIGNvbnN0cnVjdCB0aGUgdHJlZSBvZlxyXG4gKiBldmVudCBkYXRhIGF0IHRoYXQgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUxheWVyVHJlZV8od3JpdGVzLCBmaWx0ZXIsIHRyZWVSb290KSB7XHJcbiAgICBsZXQgY29tcG91bmRXcml0ZSA9IENvbXBvdW5kV3JpdGUuZW1wdHkoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JpdGVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3Qgd3JpdGUgPSB3cml0ZXNbaV07XHJcbiAgICAgICAgLy8gVGhlb3J5LCBhIGxhdGVyIHNldCB3aWxsIGVpdGhlcjpcclxuICAgICAgICAvLyBhKSBhYm9ydCBhIHJlbGV2YW50IHRyYW5zYWN0aW9uLCBzbyBubyBuZWVkIHRvIHdvcnJ5IGFib3V0IGV4Y2x1ZGluZyBpdCBmcm9tIGNhbGN1bGF0aW5nIHRoYXQgdHJhbnNhY3Rpb25cclxuICAgICAgICAvLyBiKSBub3QgYmUgcmVsZXZhbnQgdG8gYSB0cmFuc2FjdGlvbiAoc2VwYXJhdGUgYnJhbmNoKSwgc28gYWdhaW4gd2lsbCBub3QgYWZmZWN0IHRoZSBkYXRhIGZvciB0aGF0IHRyYW5zYWN0aW9uXHJcbiAgICAgICAgaWYgKGZpbHRlcih3cml0ZSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgd3JpdGVQYXRoID0gd3JpdGUucGF0aDtcclxuICAgICAgICAgICAgbGV0IHJlbGF0aXZlUGF0aDtcclxuICAgICAgICAgICAgaWYgKHdyaXRlLnNuYXApIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXRoQ29udGFpbnModHJlZVJvb3QsIHdyaXRlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgodHJlZVJvb3QsIHdyaXRlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGVBZGRXcml0ZShjb21wb3VuZFdyaXRlLCByZWxhdGl2ZVBhdGgsIHdyaXRlLnNuYXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGF0aENvbnRhaW5zKHdyaXRlUGF0aCwgdHJlZVJvb3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIHdyaXRlLnNuYXAuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3cml0ZS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhDb250YWlucyh0cmVlUm9vdCwgd3JpdGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh0cmVlUm9vdCwgd3JpdGVQYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCByZWxhdGl2ZVBhdGgsIHdyaXRlLmNoaWxkcmVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhdGhDb250YWlucyh3cml0ZVBhdGgsIHRyZWVSb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aCh3cml0ZVBhdGgsIHRyZWVSb290KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGF0aElzRW1wdHkocmVsYXRpdmVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZUFkZFdyaXRlcyhjb21wb3VuZFdyaXRlLCBuZXdFbXB0eVBhdGgoKSwgd3JpdGUuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBzYWZlR2V0KHdyaXRlLmNoaWxkcmVuLCBwYXRoR2V0RnJvbnQocmVsYXRpdmVQYXRoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgZXhpc3RzIGEgY2hpbGQgaW4gdGhpcyBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgcm9vdCBwYXRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWVwTm9kZSA9IGNoaWxkLmdldENoaWxkKHBhdGhQb3BGcm9udChyZWxhdGl2ZVBhdGgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlQWRkV3JpdGUoY29tcG91bmRXcml0ZSwgbmV3RW1wdHlQYXRoKCksIGRlZXBOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgYXNzZXJ0aW9uRXJyb3IoJ1dyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGU7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhbmQgYW4gb3B0aW9uYWwgc2V0IG9mIGNvbnN0cmFpbnRzIChleGNsdWRlIHNvbWUgc2V0cywgaW5jbHVkZSBoaWRkZW5cclxuICogd3JpdGVzKSwgYXR0ZW1wdCB0byBjYWxjdWxhdGUgYSBjb21wbGV0ZSBzbmFwc2hvdCBmb3IgdGhlIGdpdmVuIHBhdGhcclxuICpcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQW4gb3B0aW9uYWwgc2V0IHRvIGJlIGV4Y2x1ZGVkXHJcbiAqIEBwYXJhbSBpbmNsdWRlSGlkZGVuV3JpdGVzIC0gRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgb3Igbm90IHRvIGxheWVyIG9uIHdyaXRlcyB3aXRoIHZpc2libGUgc2V0IHRvIGZhbHNlXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgdHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICBpZiAoIXdyaXRlSWRzVG9FeGNsdWRlICYmICFpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZG93aW5nTm9kZSA9IGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGFkb3dpbmdOb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc3ViTWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgICAgIGlmIChjb21wb3VuZFdyaXRlSXNFbXB0eShzdWJNZXJnZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVNlcnZlckNhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2FjaGUgPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgIWNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKHN1Yk1lcmdlLCBuZXdFbXB0eVBhdGgoKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIHdvdWxkbid0IGhhdmUgYSBjb21wbGV0ZSBzbmFwc2hvdCwgc2luY2UgdGhlcmUncyBubyB1bmRlcmx5aW5nIGRhdGEgYW5kIG5vIGNvbXBsZXRlIHNoYWRvd1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllcmVkQ2FjaGUgPSBjb21wbGV0ZVNlcnZlckNhY2hlIHx8IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShzdWJNZXJnZSwgbGF5ZXJlZENhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IG1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgICAgIGlmICghaW5jbHVkZUhpZGRlbldyaXRlcyAmJiBjb21wb3VuZFdyaXRlSXNFbXB0eShtZXJnZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGNhY2hlIGlzIG51bGwsIGFuZCB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGUgY2FjaGUsIHdlIG5lZWQgdG8gcmV0dXJuIG51bGxcclxuICAgICAgICAgICAgaWYgKCFpbmNsdWRlSGlkZGVuV3JpdGVzICYmXHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVNlcnZlckNhY2hlID09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICFjb21wb3VuZFdyaXRlSGFzQ29tcGxldGVXcml0ZShtZXJnZSwgbmV3RW1wdHlQYXRoKCkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGZ1bmN0aW9uICh3cml0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHdyaXRlLnZpc2libGUgfHwgaW5jbHVkZUhpZGRlbldyaXRlcykgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgKCF3cml0ZUlkc1RvRXhjbHVkZSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIX53cml0ZUlkc1RvRXhjbHVkZS5pbmRleE9mKHdyaXRlLndyaXRlSWQpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAocGF0aENvbnRhaW5zKHdyaXRlLnBhdGgsIHRyZWVQYXRoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aENvbnRhaW5zKHRyZWVQYXRoLCB3cml0ZS5wYXRoKSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lcmdlQXRQYXRoID0gd3JpdGVUcmVlTGF5ZXJUcmVlXyh3cml0ZVRyZWUuYWxsV3JpdGVzLCBmaWx0ZXIsIHRyZWVQYXRoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KG1lcmdlQXRQYXRoLCBsYXllcmVkQ2FjaGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXaXRoIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhdHRlbXB0IHRvIHJldHVybiBhIGNoaWxkcmVuIG5vZGUgb2YgY2hpbGRyZW4gdGhhdCB3ZSBoYXZlIGNvbXBsZXRlIGRhdGEgZm9yLlxyXG4gKiBVc2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZpZXdzLCB0byBwcmUtZmlsbCB0aGVpciBjb21wbGV0ZSBldmVudCBjaGlsZHJlbiBzbmFwc2hvdC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVUcmVlLCB0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbikge1xyXG4gICAgbGV0IGNvbXBsZXRlQ2hpbGRyZW4gPSBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcclxuICAgIGNvbnN0IHRvcExldmVsU2V0ID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgdHJlZVBhdGgpO1xyXG4gICAgaWYgKHRvcExldmVsU2V0KSB7XHJcbiAgICAgICAgaWYgKCF0b3BMZXZlbFNldC5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgLy8gd2UncmUgc2hhZG93aW5nIGV2ZXJ5dGhpbmcuIFJldHVybiB0aGUgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIHRvcExldmVsU2V0LmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGNoaWxkTmFtZSwgY2hpbGRTbmFwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIGNoaWxkU25hcCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgICAgICAvLyBMYXllciBhbnkgY2hpbGRyZW4gd2UgaGF2ZSBvbiB0b3Agb2YgdGhpc1xyXG4gICAgICAgIC8vIFdlIGtub3cgd2UgZG9uJ3QgaGF2ZSBhIHRvcC1sZXZlbCBzZXQsIHNvIGp1c3QgZW51bWVyYXRlIGV4aXN0aW5nIGNoaWxkcmVuXHJcbiAgICAgICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICAgICAgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbi5mb3JFYWNoQ2hpbGQoUFJJT1JJVFlfSU5ERVgsIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gY29tcG91bmRXcml0ZUFwcGx5KGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUobWVyZ2UsIG5ldyBQYXRoKGNoaWxkTmFtZSkpLCBjaGlsZE5vZGUpO1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIEFkZCBhbnkgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBmcm9tIHRoZSBzZXRcclxuICAgICAgICBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihtZXJnZSkuZm9yRWFjaChuYW1lZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBsYXllciBvbiB0b3Agb2YuIExheWVyIG9uIGFueSBjaGlsZHJlbiB3ZSBoYXZlXHJcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgc25hcCBpZiB3ZSBoYXZlIGEgZGVmaW5lZCBkZWxldGVcclxuICAgICAgICBjb25zdCBtZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHRyZWVQYXRoKTtcclxuICAgICAgICBjb21wb3VuZFdyaXRlR2V0Q29tcGxldGVDaGlsZHJlbihtZXJnZSkuZm9yRWFjaChuYW1lZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiB0aGF0IHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCwgaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlXHJcbiAqIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxyXG4gKlxyXG4gKiBQb3NzaWJpbGl0aWVzOlxyXG4gKlxyXG4gKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcclxuICpcclxuICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50c1xyXG4gKlxyXG4gKiBFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3RcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZUNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVUcmVlLCB0cmVlUGF0aCwgY2hpbGRQYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICBhc3NlcnQoZXhpc3RpbmdFdmVudFNuYXAgfHwgZXhpc3RpbmdTZXJ2ZXJTbmFwLCAnRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0Jyk7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENoaWxkKHRyZWVQYXRoLCBjaGlsZFBhdGgpO1xyXG4gICAgaWYgKGNvbXBvdW5kV3JpdGVIYXNDb21wbGV0ZVdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCBwYXRoKSkge1xyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgY2FuIHByb2JhYmx5IGd1YXJhbnRlZSB0aGF0IHdlJ3JlIGluIGNhc2UgMiwgbWVhbmluZyBubyBldmVudHNcclxuICAgICAgICAvLyBNYXkgbmVlZCB0byBjaGVjayB2aXNpYmlsaXR5IHdoaWxlIGRvaW5nIHRoZSBmaW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGggY2FsbFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gTm8gY29tcGxldGUgc2hhZG93aW5nLiBXZSdyZSBlaXRoZXIgcGFydGlhbGx5IHNoYWRvd2luZyBvciBub3Qgc2hhZG93aW5nIGF0IGFsbC5cclxuICAgICAgICBjb25zdCBjaGlsZE1lcmdlID0gY29tcG91bmRXcml0ZUNoaWxkQ29tcG91bmRXcml0ZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICAgICAgaWYgKGNvbXBvdW5kV3JpdGVJc0VtcHR5KGNoaWxkTWVyZ2UpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBzaGFkb3dpbmcgYXQgYWxsLiBDYXNlIDFcclxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VydmVyU25hcC5nZXRDaGlsZChjaGlsZFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIGVmZmljaWVudCBpZiB0aGUgc2VydmVyTm9kZSArIHVwZGF0ZXMgZG9lc24ndCBjaGFuZ2UgdGhlIGV2ZW50U25hcFxyXG4gICAgICAgICAgICAvLyBIb3dldmVyIHRoaXMgaXMgdHJpY2t5IHRvIGZpbmQgb3V0LCBzaW5jZSB1c2VyIHVwZGF0ZXMgZG9uJ3QgbmVjZXNzYXJ5IGNoYW5nZSB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIHNuYXAsIGUuZy4gcHJpb3JpdHkgdXBkYXRlcyBvbiBlbXB0eSBub2Rlcywgb3IgZGVlcCBkZWxldGVzLiBBbm90aGVyIHNwZWNpYWwgY2FzZSBpcyBpZiB0aGUgc2VydmVyXHJcbiAgICAgICAgICAgIC8vIGFkZHMgbm9kZXMsIGJ1dCBkb2Vzbid0IGNoYW5nZSBhbnkgZXhpc3Rpbmcgd3JpdGVzLiBJdCBpcyB0aGVyZWZvcmUgbm90IGVub3VnaCB0b1xyXG4gICAgICAgICAgICAvLyBvbmx5IGNoZWNrIGlmIHRoZSB1cGRhdGVzIGNoYW5nZSB0aGUgc2VydmVyTm9kZS5cclxuICAgICAgICAgICAgLy8gTWF5YmUgY2hlY2sgaWYgdGhlIG1lcmdlIHRyZWUgY29udGFpbnMgdGhlc2Ugc3BlY2lhbCBjYXNlcyBhbmQgb25seSBkbyBhIGZ1bGwgb3ZlcndyaXRlIGluIHRoYXQgY2FzZT9cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVBcHBseShjaGlsZE1lcmdlLCBleGlzdGluZ1NlcnZlclNuYXAuZ2V0Q2hpbGQoY2hpbGRQYXRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cclxuICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XHJcbiAgICBjb25zdCBwYXRoID0gcGF0aENoaWxkKHRyZWVQYXRoLCBjaGlsZEtleSk7XHJcbiAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZSh3cml0ZVRyZWUudmlzaWJsZVdyaXRlcywgcGF0aCk7XHJcbiAgICBpZiAoc2hhZG93aW5nTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRvd2luZ05vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZXhpc3RpbmdTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRNZXJnZSA9IGNvbXBvdW5kV3JpdGVDaGlsZENvbXBvdW5kV3JpdGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZUFwcGx5KGNoaWxkTWVyZ2UsIGV4aXN0aW5nU2VydmVyU25hcC5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIG5vZGUgaWYgdGhlcmUgaXMgYSBjb21wbGV0ZSBvdmVyd3JpdGUgZm9yIHRoaXMgcGF0aC4gTW9yZSBzcGVjaWZpY2FsbHksIGlmIHRoZXJlIGlzIGEgd3JpdGUgYXRcclxuICogYSBoaWdoZXIgcGF0aCwgdGhpcyB3aWxsIHJldHVybiB0aGUgY2hpbGQgb2YgdGhhdCB3cml0ZSByZWxhdGl2ZSB0byB0aGUgd3JpdGUgYW5kIHRoaXMgcGF0aC5cclxuICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHdyaXRlIGF0IHRoaXMgcGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVNoYWRvd2luZ1dyaXRlKHdyaXRlVHJlZSwgcGF0aCkge1xyXG4gICAgcmV0dXJuIGNvbXBvdW5kV3JpdGVHZXRDb21wbGV0ZU5vZGUod3JpdGVUcmVlLnZpc2libGVXcml0ZXMsIHBhdGgpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxyXG4gKiB0aGUgd2luZG93LCBidXQgbWF5IG5vdyBiZSBpbiB0aGUgd2luZG93LlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWUsIHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XHJcbiAgICBsZXQgdG9JdGVyYXRlO1xyXG4gICAgY29uc3QgbWVyZ2UgPSBjb21wb3VuZFdyaXRlQ2hpbGRDb21wb3VuZFdyaXRlKHdyaXRlVHJlZS52aXNpYmxlV3JpdGVzLCB0cmVlUGF0aCk7XHJcbiAgICBjb25zdCBzaGFkb3dpbmdOb2RlID0gY29tcG91bmRXcml0ZUdldENvbXBsZXRlTm9kZShtZXJnZSwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHRvSXRlcmF0ZSA9IHNoYWRvd2luZ05vZGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb21wbGV0ZVNlcnZlckRhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgIHRvSXRlcmF0ZSA9IGNvbXBvdW5kV3JpdGVBcHBseShtZXJnZSwgY29tcGxldGVTZXJ2ZXJEYXRhKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIG5vIGNoaWxkcmVuIHRvIGl0ZXJhdGUgb25cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICB0b0l0ZXJhdGUgPSB0b0l0ZXJhdGUud2l0aEluZGV4KGluZGV4KTtcclxuICAgIGlmICghdG9JdGVyYXRlLmlzRW1wdHkoKSAmJiAhdG9JdGVyYXRlLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gW107XHJcbiAgICAgICAgY29uc3QgY21wID0gaW5kZXguZ2V0Q29tcGFyZSgpO1xyXG4gICAgICAgIGNvbnN0IGl0ZXIgPSByZXZlcnNlXHJcbiAgICAgICAgICAgID8gdG9JdGVyYXRlLmdldFJldmVyc2VJdGVyYXRvckZyb20oc3RhcnRQb3N0LCBpbmRleClcclxuICAgICAgICAgICAgOiB0b0l0ZXJhdGUuZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXgpO1xyXG4gICAgICAgIGxldCBuZXh0ID0gaXRlci5nZXROZXh0KCk7XHJcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgbm9kZXMubGVuZ3RoIDwgY291bnQpIHtcclxuICAgICAgICAgICAgaWYgKGNtcChuZXh0LCBzdGFydFBvc3QpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKG5leHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5leHQgPSBpdGVyLmdldE5leHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG5ld1dyaXRlVHJlZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmlzaWJsZVdyaXRlczogQ29tcG91bmRXcml0ZS5lbXB0eSgpLFxyXG4gICAgICAgIGFsbFdyaXRlczogW10sXHJcbiAgICAgICAgbGFzdFdyaXRlSWQ6IC0xXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBJZiBwb3NzaWJsZSwgcmV0dXJucyBhIGNvbXBsZXRlIGV2ZW50IGNhY2hlLCB1c2luZyB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBpZiBwb3NzaWJsZS4gSW4gYWRkaXRpb24sIGNhbiBiZSB1c2VkXHJcbiAqIHRvIGdldCBhIGNhY2hlIHRoYXQgaW5jbHVkZXMgaGlkZGVuIHdyaXRlcywgYW5kIGV4Y2x1ZGVzIGFyYml0cmFyeSB3cml0ZXMuIE5vdGUgdGhhdCBjdXN0b21pemluZyB0aGUgcmV0dXJuZWQgbm9kZVxyXG4gKiBjYW4gbGVhZCB0byBhIG1vcmUgZXhwZW5zaXZlIGNhbGN1bGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gd3JpdGVJZHNUb0V4Y2x1ZGUgLSBPcHRpb25hbCB3cml0ZXMgdG8gZXhjbHVkZS5cclxuICogQHBhcmFtIGluY2x1ZGVIaWRkZW5Xcml0ZXMgLSBEZWZhdWx0cyB0byBmYWxzZSwgd2hldGhlciBvciBub3QgdG8gbGF5ZXIgb24gd3JpdGVzIHdpdGggdmlzaWJsZSBzZXQgdG8gZmFsc2VcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcykge1xyXG4gICAgcmV0dXJuIHdyaXRlVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcyk7XHJcbn1cclxuLyoqXHJcbiAqIElmIHBvc3NpYmxlLCByZXR1cm5zIGEgY2hpbGRyZW4gbm9kZSBjb250YWluaW5nIGFsbCBvZiB0aGUgY29tcGxldGUgY2hpbGRyZW4gd2UgaGF2ZSBkYXRhIGZvci4gVGhlIHJldHVybmVkIGRhdGEgaXMgYVxyXG4gKiBtaXggb2YgdGhlIGdpdmVuIHNlcnZlciBkYXRhIGFuZCB3cml0ZSBkYXRhLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZVRyZWVSZWYsIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJDaGlsZHJlbik7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIHRoYXQgZWl0aGVyIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkIG9yIHRoZSBvdXRzdGFuZGluZyB3cml0ZXMgaGF2ZSB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCxcclxuICogaWYgYW55dGhpbmcsIG5lZWRzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxyXG4gKlxyXG4gKiBQb3NzaWJpbGl0aWVzOlxyXG4gKlxyXG4gKiAxLiBObyB3cml0ZXMgYXJlIHNoYWRvd2luZy4gRXZlbnRzIHNob3VsZCBiZSByYWlzZWQsIHRoZSBzbmFwIHRvIGJlIGFwcGxpZWQgY29tZXMgZnJvbSB0aGUgc2VydmVyIGRhdGFcclxuICpcclxuICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxyXG4gKlxyXG4gKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkXHJcbiAqXHJcbiAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdCwgdGhpcyBpcyB2YWxpZGF0ZWQgdmlhIGFuIGFzc2VydFxyXG4gKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gd3JpdGVUcmVlUmVmQ2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh3cml0ZVRyZWVSZWYsIHBhdGgsIGV4aXN0aW5nRXZlbnRTbmFwLCBleGlzdGluZ1NlcnZlclNuYXApIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlVHJlZVJlZi53cml0ZVRyZWUsIHdyaXRlVHJlZVJlZi50cmVlUGF0aCwgcGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSBub2RlIGlmIHRoZXJlIGlzIGEgY29tcGxldGUgb3ZlcndyaXRlIGZvciB0aGlzIHBhdGguIE1vcmUgc3BlY2lmaWNhbGx5LCBpZiB0aGVyZSBpcyBhIHdyaXRlIGF0XHJcbiAqIGEgaGlnaGVyIHBhdGgsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNoaWxkIG9mIHRoYXQgd3JpdGUgcmVsYXRpdmUgdG8gdGhlIHdyaXRlIGFuZCB0aGlzIHBhdGguXHJcbiAqIFJldHVybnMgbnVsbCBpZiB0aGVyZSBpcyBubyB3cml0ZSBhdCB0aGlzIHBhdGguXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWVSZWYsIHBhdGgpIHtcclxuICAgIHJldHVybiB3cml0ZVRyZWVTaGFkb3dpbmdXcml0ZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCBwYXRoQ2hpbGQod3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBwYXRoKSk7XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2hlbiBwcm9jZXNzaW5nIGNoaWxkIHJlbW92ZSBldmVudHMgb24gYSBxdWVyeS4gSWYgd2UgY2FuLCB3ZSBwdWxsIGluIGNoaWxkcmVuIHRoYXQgd2VyZSBvdXRzaWRlXHJcbiAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3dcclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNhbGNJbmRleGVkU2xpY2Uod3JpdGVUcmVlUmVmLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0luZGV4ZWRTbGljZSh3cml0ZVRyZWVSZWYud3JpdGVUcmVlLCB3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cclxuICogY29tcGxldGUgY2hpbGQgZm9yIHRoaXMgQ2hpbGRLZXkuXHJcbiAqL1xyXG5mdW5jdGlvbiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh3cml0ZVRyZWVSZWYsIGNoaWxkS2V5LCBleGlzdGluZ1NlcnZlckNhY2hlKSB7XHJcbiAgICByZXR1cm4gd3JpdGVUcmVlQ2FsY0NvbXBsZXRlQ2hpbGQod3JpdGVUcmVlUmVmLndyaXRlVHJlZSwgd3JpdGVUcmVlUmVmLnRyZWVQYXRoLCBjaGlsZEtleSwgZXhpc3RpbmdTZXJ2ZXJDYWNoZSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIFdyaXRlVHJlZVJlZiBmb3IgYSBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlVHJlZVJlZiwgY2hpbGROYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3V3JpdGVUcmVlUmVmKHBhdGhDaGlsZCh3cml0ZVRyZWVSZWYudHJlZVBhdGgsIGNoaWxkTmFtZSksIHdyaXRlVHJlZVJlZi53cml0ZVRyZWUpO1xyXG59XHJcbmZ1bmN0aW9uIG5ld1dyaXRlVHJlZVJlZihwYXRoLCB3cml0ZVRyZWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdHJlZVBhdGg6IHBhdGgsXHJcbiAgICAgICAgd3JpdGVUcmVlXHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIENoaWxkQ2hhbmdlQWNjdW11bGF0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jaGFuZ2VNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICB0cmFja0NoaWxkQ2hhbmdlKGNoYW5nZSkge1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSBjaGFuZ2UudHlwZTtcclxuICAgICAgICBjb25zdCBjaGlsZEtleSA9IGNoYW5nZS5jaGlsZE5hbWU7XHJcbiAgICAgICAgYXNzZXJ0KHR5cGUgPT09IFwiY2hpbGRfYWRkZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0FEREVEICovIHx8XHJcbiAgICAgICAgICAgIHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyB8fFxyXG4gICAgICAgICAgICB0eXBlID09PSBcImNoaWxkX3JlbW92ZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX1JFTU9WRUQgKi8sICdPbmx5IGNoaWxkIGNoYW5nZXMgc3VwcG9ydGVkIGZvciB0cmFja2luZycpO1xyXG4gICAgICAgIGFzc2VydChjaGlsZEtleSAhPT0gJy5wcmlvcml0eScsICdPbmx5IG5vbi1wcmlvcml0eSBjaGlsZCBjaGFuZ2VzIGNhbiBiZSB0cmFja2VkLicpO1xyXG4gICAgICAgIGNvbnN0IG9sZENoYW5nZSA9IHRoaXMuY2hhbmdlTWFwLmdldChjaGlsZEtleSk7XHJcbiAgICAgICAgaWYgKG9sZENoYW5nZSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRUeXBlID0gb2xkQ2hhbmdlLnR5cGU7XHJcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImNoaWxkX2FkZGVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9BRERFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfcmVtb3ZlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfUkVNT1ZFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLmRlbGV0ZShjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gXCJjaGlsZF9yZW1vdmVkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9SRU1PVkVEICovICYmXHJcbiAgICAgICAgICAgICAgICBvbGRUeXBlID09PSBcImNoaWxkX2NoYW5nZWRcIiAvKiBDaGFuZ2VUeXBlLkNISUxEX0NIQU5HRUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRSZW1vdmVkKGNoaWxkS2V5LCBvbGRDaGFuZ2Uub2xkU25hcCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9hZGRlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQURERUQgKi8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwLnNldChjaGlsZEtleSwgY2hhbmdlQ2hpbGRBZGRlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiY2hpbGRfY2hhbmdlZFwiIC8qIENoYW5nZVR5cGUuQ0hJTERfQ0hBTkdFRCAqLyAmJlxyXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PT0gXCJjaGlsZF9jaGFuZ2VkXCIgLyogQ2hhbmdlVHlwZS5DSElMRF9DSEFOR0VEICovKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZUNoaWxkQ2hhbmdlZChjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLm9sZFNuYXApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGFzc2VydGlvbkVycm9yKCdJbGxlZ2FsIGNvbWJpbmF0aW9uIG9mIGNoYW5nZXM6ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZSArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBvY2N1cnJlZCBhZnRlciAnICtcclxuICAgICAgICAgICAgICAgICAgICBvbGRDaGFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZU1hcC5zZXQoY2hpbGRLZXksIGNoYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q2hhbmdlcygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoYW5nZU1hcC52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIENvbXBsZXRlQ2hpbGRTb3VyY2UgdGhhdCBuZXZlciByZXR1cm5zIGFueSBhZGRpdGlvbmFsIGNoaWxkcmVuXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXHJcbmNsYXNzIE5vQ29tcGxldGVDaGlsZFNvdXJjZV8ge1xyXG4gICAgZ2V0Q29tcGxldGVDaGlsZChjaGlsZEtleSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2hpbGRBZnRlckNoaWxkKGluZGV4LCBjaGlsZCwgcmV2ZXJzZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UuXHJcbiAqL1xyXG5jb25zdCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UgPSBuZXcgTm9Db21wbGV0ZUNoaWxkU291cmNlXygpO1xyXG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IHVzZXMgYSBXcml0ZVRyZWUgaW4gYWRkaXRpb24gdG8gYW55IG90aGVyIHNlcnZlciBkYXRhIG9yXHJcbiAqIG9sZCBldmVudCBjYWNoZXMgYXZhaWxhYmxlIHRvIGNhbGN1bGF0ZSBjb21wbGV0ZSBjaGlsZHJlbi5cclxuICovXHJcbmNsYXNzIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Iod3JpdGVzXywgdmlld0NhY2hlXywgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZXNfID0gd3JpdGVzXztcclxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSB2aWV3Q2FjaGVfO1xyXG4gICAgICAgIHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPSBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXztcclxuICAgIH1cclxuICAgIGdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy52aWV3Q2FjaGVfLmV2ZW50Q2FjaGU7XHJcbiAgICAgICAgaWYgKG5vZGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyTm9kZSA9IHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gIT0gbnVsbFxyXG4gICAgICAgICAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8sIHRydWUsIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZpZXdDYWNoZV8uc2VydmVyQ2FjaGU7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh0aGlzLndyaXRlc18sIGNoaWxkS2V5LCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRDaGlsZEFmdGVyQ2hpbGQoaW5kZXgsIGNoaWxkLCByZXZlcnNlKSB7XHJcbiAgICAgICAgY29uc3QgY29tcGxldGVTZXJ2ZXJEYXRhID0gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyAhPSBudWxsXHJcbiAgICAgICAgICAgID8gdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlX1xyXG4gICAgICAgICAgICA6IHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh0aGlzLnZpZXdDYWNoZV8pO1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gd3JpdGVUcmVlUmVmQ2FsY0luZGV4ZWRTbGljZSh0aGlzLndyaXRlc18sIGNvbXBsZXRlU2VydmVyRGF0YSwgY2hpbGQsIDEsIHJldmVyc2UsIGluZGV4KTtcclxuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdWaWV3UHJvY2Vzc29yKGZpbHRlcikge1xyXG4gICAgcmV0dXJuIHsgZmlsdGVyIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlKSB7XHJcbiAgICBhc3NlcnQodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLmlzSW5kZXhlZCh2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleCgpKSwgJ0V2ZW50IHNuYXAgbm90IGluZGV4ZWQnKTtcclxuICAgIGFzc2VydCh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmlzSW5kZXhlZCh2aWV3UHJvY2Vzc29yLmZpbHRlci5nZXRJbmRleCgpKSwgJ1NlcnZlciBzbmFwIG5vdCBpbmRleGVkJyk7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5T3BlcmF0aW9uKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSkge1xyXG4gICAgY29uc3QgYWNjdW11bGF0b3IgPSBuZXcgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcigpO1xyXG4gICAgbGV0IG5ld1ZpZXdDYWNoZSwgZmlsdGVyU2VydmVyTm9kZTtcclxuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gT3BlcmF0aW9uVHlwZS5PVkVSV1JJVEUpIHtcclxuICAgICAgICBjb25zdCBvdmVyd3JpdGUgPSBvcGVyYXRpb247XHJcbiAgICAgICAgaWYgKG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVVzZXIpIHtcclxuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG92ZXJ3cml0ZS5wYXRoLCBvdmVyd3JpdGUuc25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFzc2VydChvdmVyd3JpdGUuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcclxuICAgICAgICAgICAgLy8gV2UgZmlsdGVyIHRoZSBub2RlIGlmIGl0J3MgYSB0YWdnZWQgdXBkYXRlIG9yIHRoZSBub2RlIGhhcyBiZWVuIHByZXZpb3VzbHkgZmlsdGVyZWQgIGFuZCB0aGVcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGlzIG5vdCBhdCB0aGUgcm9vdCBpbiB3aGljaCBjYXNlIGl0IGlzIG9rIChhbmQgbmVjZXNzYXJ5KSB0byBtYXJrIHRoZSBub2RlIHVuZmlsdGVyZWRcclxuICAgICAgICAgICAgLy8gYWdhaW5cclxuICAgICAgICAgICAgZmlsdGVyU2VydmVyTm9kZSA9XHJcbiAgICAgICAgICAgICAgICBvdmVyd3JpdGUuc291cmNlLnRhZ2dlZCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpICYmICFwYXRoSXNFbXB0eShvdmVyd3JpdGUucGF0aCkpO1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBvdmVyd3JpdGUucGF0aCwgb3ZlcndyaXRlLnNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTUVSR0UpIHtcclxuICAgICAgICBjb25zdCBtZXJnZSA9IG9wZXJhdGlvbjtcclxuICAgICAgICBpZiAobWVyZ2Uuc291cmNlLmZyb21Vc2VyKSB7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdQcm9jZXNzb3JBcHBseVVzZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXNzZXJ0KG1lcmdlLnNvdXJjZS5mcm9tU2VydmVyLCAnVW5rbm93biBzb3VyY2UuJyk7XHJcbiAgICAgICAgICAgIC8vIFdlIGZpbHRlciB0aGUgbm9kZSBpZiBpdCdzIGEgdGFnZ2VkIHVwZGF0ZSBvciB0aGUgbm9kZSBoYXMgYmVlbiBwcmV2aW91c2x5IGZpbHRlcmVkXHJcbiAgICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUgPVxyXG4gICAgICAgICAgICAgICAgbWVyZ2Uuc291cmNlLnRhZ2dlZCB8fCBvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGaWx0ZXJlZCgpO1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIG1lcmdlLnBhdGgsIG1lcmdlLmNoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFKSB7XHJcbiAgICAgICAgY29uc3QgYWNrVXNlcldyaXRlID0gb3BlcmF0aW9uO1xyXG4gICAgICAgIGlmICghYWNrVXNlcldyaXRlLnJldmVydCkge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yQWNrVXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIGFja1VzZXJXcml0ZS5hZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgYWNrVXNlcldyaXRlLnBhdGgsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvblR5cGUuTElTVEVOX0NPTVBMRVRFKSB7XHJcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld1Byb2Nlc3Nvckxpc3RlbkNvbXBsZXRlKHZpZXdQcm9jZXNzb3IsIG9sZFZpZXdDYWNoZSwgb3BlcmF0aW9uLnBhdGgsIHdyaXRlc0NhY2hlLCBhY2N1bXVsYXRvcik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBhc3NlcnRpb25FcnJvcignVW5rbm93biBvcGVyYXRpb24gdHlwZTogJyArIG9wZXJhdGlvbi50eXBlKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGNoYW5nZXMgPSBhY2N1bXVsYXRvci5nZXRDaGFuZ2VzKCk7XHJcbiAgICB2aWV3UHJvY2Vzc29yTWF5YmVBZGRWYWx1ZUV2ZW50KG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VzKTtcclxuICAgIHJldHVybiB7IHZpZXdDYWNoZTogbmV3Vmlld0NhY2hlLCBjaGFuZ2VzIH07XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3Nvck1heWJlQWRkVmFsdWVFdmVudChvbGRWaWV3Q2FjaGUsIG5ld1ZpZXdDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IGV2ZW50U25hcCA9IG5ld1ZpZXdDYWNoZS5ldmVudENhY2hlO1xyXG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGNvbnN0IGlzTGVhZk9yRW1wdHkgPSBldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSB8fCBldmVudFNuYXAuZ2V0Tm9kZSgpLmlzRW1wdHkoKTtcclxuICAgICAgICBjb25zdCBvbGRDb21wbGV0ZVNuYXAgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUpO1xyXG4gICAgICAgIGlmIChhY2N1bXVsYXRvci5sZW5ndGggPiAwIHx8XHJcbiAgICAgICAgICAgICFvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxyXG4gICAgICAgICAgICAoaXNMZWFmT3JFbXB0eSAmJiAhZXZlbnRTbmFwLmdldE5vZGUoKS5lcXVhbHMob2xkQ29tcGxldGVTbmFwKSkgfHxcclxuICAgICAgICAgICAgIWV2ZW50U25hcC5nZXROb2RlKCkuZ2V0UHJpb3JpdHkoKS5lcXVhbHMob2xkQ29tcGxldGVTbmFwLmdldFByaW9yaXR5KCkpKSB7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goY2hhbmdlVmFsdWUodmlld0NhY2hlR2V0Q29tcGxldGVFdmVudFNuYXAobmV3Vmlld0NhY2hlKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGNoYW5nZVBhdGgsIHdyaXRlc0NhY2hlLCBzb3VyY2UsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRFdmVudFNuYXAgPSB2aWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgIGlmICh3cml0ZVRyZWVSZWZTaGFkb3dpbmdXcml0ZSh3cml0ZXNDYWNoZSwgY2hhbmdlUGF0aCkgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIHdlIGhhdmUgYSBzaGFkb3dpbmcgd3JpdGUsIGlnbm9yZSBjaGFuZ2VzXHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxldCBuZXdFdmVudENhY2hlLCBzZXJ2ZXJOb2RlO1xyXG4gICAgICAgIGlmIChwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0aGlzIHBsYXlzIHdpdGggXCJzbGlkaW5nIGFjayB3aW5kb3dzXCJcclxuICAgICAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ0lmIGNoYW5nZSBwYXRoIGlzIGVtcHR5LCB3ZSBtdXN0IGhhdmUgY29tcGxldGUgc2VydmVyIGRhdGEnKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoaXMsIGJlY2F1c2Ugd2UgbmVlZCB0byBvbmx5IGFwcGx5IHdyaXRlcyB0byBjb21wbGV0ZSBjaGlsZHJlbiwgb3JcclxuICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGVuZCB1cCByYWlzaW5nIGV2ZW50cyBmb3IgaW5jb21wbGV0ZSBjaGlsZHJlbi4gSWYgdGhlIHNlcnZlciBkYXRhIGlzIGZpbHRlcmVkIGRlZXBcclxuICAgICAgICAgICAgICAgIC8vIHdyaXRlcyBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0byBiZSBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlQ2hpbGRyZW4gPSBzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZVxyXG4gICAgICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgICAgICA6IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGVFdmVudENoaWxkcmVuID0gd3JpdGVUcmVlUmVmQ2FsY0NvbXBsZXRlRXZlbnRDaGlsZHJlbih3cml0ZXNDYWNoZSwgY29tcGxldGVDaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlRnVsbE5vZGUodmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBjb21wbGV0ZUV2ZW50Q2hpbGRyZW4sIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlTm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNvbXBsZXRlTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHBhdGhHZXRGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICAgICAgYXNzZXJ0KHBhdGhHZXRMZW5ndGgoY2hhbmdlUGF0aCkgPT09IDEsIFwiQ2FuJ3QgaGF2ZSBhIHByaW9yaXR5IHdpdGggYWRkaXRpb25hbCBwYXRoIGNvbXBvbmVudHNcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRFdmVudE5vZGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgc2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBtaWdodCBoYXZlIG92ZXJ3cml0ZXMgZm9yIHRoaXMgcHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRQcmlvcml0eSA9IHdyaXRlVHJlZVJlZkNhbGNFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJPdmVyd3JpdGUod3JpdGVzQ2FjaGUsIGNoYW5nZVBhdGgsIG9sZEV2ZW50Tm9kZSwgc2VydmVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFByaW9yaXR5ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkRXZlbnROb2RlLCB1cGRhdGVkUHJpb3JpdHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJpb3JpdHkgZGlkbid0IGNoYW5nZSwga2VlcCBvbGQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VQYXRoID0gcGF0aFBvcEZyb250KGNoYW5nZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNoaWxkXHJcbiAgICAgICAgICAgICAgICBsZXQgbmV3RXZlbnRDaGlsZDtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRFdmVudFNuYXAuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50Q2hpbGRVcGRhdGUgPSB3cml0ZVRyZWVSZWZDYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKHdyaXRlc0NhY2hlLCBjaGFuZ2VQYXRoLCBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBzZXJ2ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRDaGlsZFVwZGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGV2ZW50Q2hpbGRVcGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBqdXN0IGtlZXAgdGhlIG9sZCBjaGlsZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZEtleSwgdmlld0NhY2hlLnNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChuZXdFdmVudENoaWxkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlQ2hpbGQob2xkRXZlbnRTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0V2ZW50Q2hpbGQsIGNoaWxkQ2hhbmdlUGF0aCwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBubyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUgb3Igbm8gY2hhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcCh2aWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBvbGRWaWV3Q2FjaGUsIGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZFNlcnZlclNuYXAgPSBvbGRWaWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBsZXQgbmV3U2VydmVyQ2FjaGU7XHJcbiAgICBjb25zdCBzZXJ2ZXJGaWx0ZXIgPSBmaWx0ZXJTZXJ2ZXJOb2RlXHJcbiAgICAgICAgPyB2aWV3UHJvY2Vzc29yLmZpbHRlclxyXG4gICAgICAgIDogdmlld1Byb2Nlc3Nvci5maWx0ZXIuZ2V0SW5kZXhlZEZpbHRlcigpO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KGNoYW5nZVBhdGgpKSB7XHJcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNlcnZlckZpbHRlci5maWx0ZXJzTm9kZXMoKSAmJiAhb2xkU2VydmVyU25hcC5pc0ZpbHRlcmVkKCkpIHtcclxuICAgICAgICAvLyB3ZSB3YW50IHRvIGZpbHRlciB0aGUgc2VydmVyIG5vZGUsIGJ1dCB3ZSBkaWRuJ3QgZmlsdGVyIHRoZSBzZXJ2ZXIgbm9kZSB5ZXQsIHNvIHNpbXVsYXRlIGEgZnVsbCB1cGRhdGVcclxuICAgICAgICBjb25zdCBuZXdTZXJ2ZXJOb2RlID0gb2xkU2VydmVyU25hcFxyXG4gICAgICAgICAgICAuZ2V0Tm9kZSgpXHJcbiAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlRnVsbE5vZGUob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld1NlcnZlck5vZGUsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgaWYgKCFvbGRTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JQYXRoKGNoYW5nZVBhdGgpICYmXHJcbiAgICAgICAgICAgIHBhdGhHZXRMZW5ndGgoY2hhbmdlUGF0aCkgPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHVwZGF0ZSBpbmNvbXBsZXRlIG5vZGVzIHdpdGggdXBkYXRlcyBpbnRlbmRlZCBmb3Igb3RoZXIgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHJldHVybiBvbGRWaWV3Q2FjaGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNoaWxkQ2hhbmdlUGF0aCA9IHBhdGhQb3BGcm9udChjaGFuZ2VQYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xyXG4gICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVDaGlsZChvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0NoaWxkTm9kZSwgY2hpbGRDaGFuZ2VQYXRoLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZVNlcnZlclNuYXAob2xkVmlld0NhY2hlLCBuZXdTZXJ2ZXJDYWNoZSwgb2xkU2VydmVyU25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fCBwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSwgc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xyXG4gICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JHZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50KHZpZXdQcm9jZXNzb3IsIG5ld1ZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBcHBseVVzZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgb2xkVmlld0NhY2hlLCBjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBjb25zdCBvbGRFdmVudFNuYXAgPSBvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZTtcclxuICAgIGxldCBuZXdWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGU7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBuZXcgV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNDYWNoZSwgb2xkVmlld0NhY2hlLCBjb21wbGV0ZUNhY2hlKTtcclxuICAgIGlmIChwYXRoSXNFbXB0eShjaGFuZ2VQYXRoKSkge1xyXG4gICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVGdWxsTm9kZShvbGRWaWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgbmV3Vmlld0NhY2hlID0gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKG9sZFZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgdHJ1ZSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRLZXkgPSBwYXRoR2V0RnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgaWYgKGNoaWxkS2V5ID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdmlld1Byb2Nlc3Nvci5maWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkVmlld0NhY2hlLmV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBjaGFuZ2VkU25hcCk7XHJcbiAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZVVwZGF0ZUV2ZW50U25hcChvbGRWaWV3Q2FjaGUsIG5ld0V2ZW50Q2FjaGUsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgb2xkRXZlbnRTbmFwLmlzRmlsdGVyZWQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZENoYW5nZVBhdGggPSBwYXRoUG9wRnJvbnQoY2hhbmdlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGxldCBuZXdDaGlsZDtcclxuICAgICAgICAgICAgaWYgKHBhdGhJc0VtcHR5KGNoaWxkQ2hhbmdlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIENoaWxkIG92ZXJ3cml0ZSwgd2UgY2FuIHJlcGxhY2UgdGhlIGNoaWxkXHJcbiAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoYW5nZWRTbmFwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gc291cmNlLmdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGhHZXRCYWNrKGNoaWxkQ2hhbmdlUGF0aCkgPT09ICcucHJpb3JpdHknICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5nZXRDaGlsZChwYXRoUGFyZW50KGNoaWxkQ2hhbmdlUGF0aCkpLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHJpb3JpdHkgdXBkYXRlIG9uIGFuIGVtcHR5IG5vZGUuIElmIHRoaXMgbm9kZSBleGlzdHMgb24gdGhlIHNlcnZlciwgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlcnZlciB3aWxsIHNlbmQgZG93biB0aGUgcHJpb3JpdHkgaW4gdGhlIHVwZGF0ZSwgc28gaWdub3JlIGZvciBub3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjaGlsZE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZS51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBjb21wbGV0ZSBjaGlsZCBub2RlIGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFvbGRDaGlsZC5lcXVhbHMobmV3Q2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFdmVudFNuYXAgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3Q2hpbGQsIGNoaWxkQ2hhbmdlUGF0aCwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVFdmVudFNuYXAob2xkVmlld0NhY2hlLCBuZXdFdmVudFNuYXAsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgdmlld1Byb2Nlc3Nvci5maWx0ZXIuZmlsdGVyc05vZGVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld1ZpZXdDYWNoZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQ2FjaGVIYXNDaGlsZCh2aWV3Q2FjaGUsIGNoaWxkS2V5KSB7XHJcbiAgICByZXR1cm4gdmlld0NhY2hlLmV2ZW50Q2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlVc2VyTWVyZ2Uodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIC8vIEhBQ0s6IEluIHRoZSBjYXNlIG9mIGEgbGltaXQgcXVlcnksIHRoZXJlIG1heSBiZSBzb21lIGNoYW5nZXMgdGhhdCBidW1wIHRoaW5ncyBvdXQgb2YgdGhlXHJcbiAgICAvLyB3aW5kb3cgbGVhdmluZyByb29tIGZvciBuZXcgaXRlbXMuICBJdCdzIGltcG9ydGFudCB3ZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgZmlyc3QsIHNvIHdlXHJcbiAgICAvLyBpdGVyYXRlIHRoZSBjaGFuZ2VzIHR3aWNlLCBmaXJzdCBwcm9jZXNzaW5nIGFueSB0aGF0IGFmZmVjdCBpdGVtcyBjdXJyZW50bHkgaW4gdmlldy5cclxuICAgIC8vIFRPRE86IEkgY29uc2lkZXIgYW4gaXRlbSBcImluIHZpZXdcIiBpZiBjYWNoZUhhc0NoaWxkIGlzIHRydWUsIHdoaWNoIGNoZWNrcyBib3RoIHRoZSBzZXJ2ZXJcclxuICAgIC8vIGFuZCBldmVudCBzbmFwLiAgSSdtIG5vdCBzdXJlIGlmIHRoaXMgd2lsbCByZXN1bHQgaW4gZWRnZSBjYXNlcyB3aGVuIGEgY2hpbGQgaXMgaW4gb25lIGJ1dFxyXG4gICAgLy8gbm90IHRoZSBvdGhlci5cclxuICAgIGxldCBjdXJWaWV3Q2FjaGUgPSB2aWV3Q2FjaGU7XHJcbiAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaCgocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICBjb25zdCB3cml0ZVBhdGggPSBwYXRoQ2hpbGQocGF0aCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBpZiAodmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQodmlld0NhY2hlLCBwYXRoR2V0RnJvbnQod3JpdGVQYXRoKSkpIHtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIGNoYW5nZWRDaGlsZHJlbi5mb3JlYWNoKChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlUGF0aCA9IHBhdGhDaGlsZChwYXRoLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIGlmICghdmlld1Byb2Nlc3NvckNhY2hlSGFzQ2hpbGQodmlld0NhY2hlLCBwYXRoR2V0RnJvbnQod3JpdGVQYXRoKSkpIHtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5VXNlck92ZXJ3cml0ZSh2aWV3UHJvY2Vzc29yLCBjdXJWaWV3Q2FjaGUsIHdyaXRlUGF0aCwgY2hpbGROb2RlLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjdXJWaWV3Q2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gdmlld1Byb2Nlc3NvckFwcGx5TWVyZ2Uodmlld1Byb2Nlc3Nvciwgbm9kZSwgbWVyZ2UpIHtcclxuICAgIG1lcmdlLmZvcmVhY2goKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgbm9kZSA9IG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNhY2hlIHlldCwgdGhpcyBtZXJnZSB3YXMgaW50ZW5kZWQgZm9yIGEgcHJldmlvdXNseSBsaXN0ZW4gaW4gdGhlIHNhbWUgbG9jYXRpb24uIElnbm9yZSBpdCBhbmRcclxuICAgIC8vIHdhaXQgZm9yIHRoZSBjb21wbGV0ZSBkYXRhIHVwZGF0ZSBjb21pbmcgc29vbi5cclxuICAgIGlmICh2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLmlzRW1wdHkoKSAmJlxyXG4gICAgICAgICF2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgLy8gSEFDSzogSW4gdGhlIGNhc2Ugb2YgYSBsaW1pdCBxdWVyeSwgdGhlcmUgbWF5IGJlIHNvbWUgY2hhbmdlcyB0aGF0IGJ1bXAgdGhpbmdzIG91dCBvZiB0aGVcclxuICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcclxuICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxyXG4gICAgLy8gVE9ETzogSSBjb25zaWRlciBhbiBpdGVtIFwiaW4gdmlld1wiIGlmIGNhY2hlSGFzQ2hpbGQgaXMgdHJ1ZSwgd2hpY2ggY2hlY2tzIGJvdGggdGhlIHNlcnZlclxyXG4gICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XHJcbiAgICAvLyBub3QgdGhlIG90aGVyLlxyXG4gICAgbGV0IGN1clZpZXdDYWNoZSA9IHZpZXdDYWNoZTtcclxuICAgIGxldCB2aWV3TWVyZ2VUcmVlO1xyXG4gICAgaWYgKHBhdGhJc0VtcHR5KHBhdGgpKSB7XHJcbiAgICAgICAgdmlld01lcmdlVHJlZSA9IGNoYW5nZWRDaGlsZHJlbjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZpZXdNZXJnZVRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKS5zZXRUcmVlKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgIHZpZXdNZXJnZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbCgoY2hpbGRLZXksIGNoaWxkVHJlZSkgPT4ge1xyXG4gICAgICAgIGlmIChzZXJ2ZXJOb2RlLmhhc0NoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZVxyXG4gICAgICAgICAgICAgICAgLmdldE5vZGUoKVxyXG4gICAgICAgICAgICAgICAgLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSB2aWV3UHJvY2Vzc29yQXBwbHlNZXJnZSh2aWV3UHJvY2Vzc29yLCBzZXJ2ZXJDaGlsZCwgY2hpbGRUcmVlKTtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgbmV3IFBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICB2aWV3TWVyZ2VUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkS2V5LCBjaGlsZE1lcmdlVHJlZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzVW5rbm93bkRlZXBNZXJnZSA9ICF2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSAmJlxyXG4gICAgICAgICAgICBjaGlsZE1lcmdlVHJlZS52YWx1ZSA9PT0gbnVsbDtcclxuICAgICAgICBpZiAoIXNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpICYmICFpc1Vua25vd25EZWVwTWVyZ2UpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2VydmVyQ2hpbGQgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgIC5nZXROb2RlKClcclxuICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gdmlld1Byb2Nlc3NvckFwcGx5TWVyZ2Uodmlld1Byb2Nlc3Nvciwgc2VydmVyQ2hpbGQsIGNoaWxkTWVyZ2VUcmVlKTtcclxuICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gdmlld1Byb2Nlc3NvckFwcGx5U2VydmVyT3ZlcndyaXRlKHZpZXdQcm9jZXNzb3IsIGN1clZpZXdDYWNoZSwgbmV3IFBhdGgoY2hpbGRLZXkpLCBuZXdDaGlsZCwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY3VyVmlld0NhY2hlO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdQcm9jZXNzb3JBY2tVc2VyV3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBhZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcikge1xyXG4gICAgaWYgKHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBhY2tQYXRoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgIH1cclxuICAgIC8vIE9ubHkgZmlsdGVyIHNlcnZlciBub2RlIGlmIGl0IGlzIGN1cnJlbnRseSBmaWx0ZXJlZFxyXG4gICAgY29uc3QgZmlsdGVyU2VydmVyTm9kZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0ZpbHRlcmVkKCk7XHJcbiAgICAvLyBFc3NlbnRpYWxseSB3ZSdsbCBqdXN0IGdldCBvdXIgZXhpc3Rpbmcgc2VydmVyIGNhY2hlIGZvciB0aGUgYWZmZWN0ZWQgcGF0aHMgYW5kIHJlLWFwcGx5IGl0IGFzIGEgc2VydmVyIHVwZGF0ZVxyXG4gICAgLy8gbm93IHRoYXQgaXQgd29uJ3QgYmUgc2hhZG93ZWQuXHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZTtcclxuICAgIGlmIChhZmZlY3RlZFRyZWUudmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYW4gb3ZlcndyaXRlLlxyXG4gICAgICAgIGlmICgocGF0aElzRW1wdHkoYWNrUGF0aCkgJiYgc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHx8XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlLmlzQ29tcGxldGVGb3JQYXRoKGFja1BhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJPdmVyd3JpdGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBhY2tQYXRoLCBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZ2V0Q2hpbGQoYWNrUGF0aCksIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhdGhJc0VtcHR5KGFja1BhdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBnb29meSBlZGdlIGNhc2Ugd2hlcmUgd2UgYXJlIGFja2luZyBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYnV0IGRvbid0IGhhdmUgZnVsbCBkYXRhLiAgV2VcclxuICAgICAgICAgICAgLy8gc2hvdWxkIGp1c3QgcmUtYXBwbHkgd2hhdGV2ZXIgd2UgaGF2ZSBpbiBvdXIgY2FjaGUgYXMgYSBtZXJnZS5cclxuICAgICAgICAgICAgbGV0IGNoYW5nZWRDaGlsZHJlbiA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZm9yRWFjaENoaWxkKEtFWV9JTkRFWCwgKG5hbWUsIG5vZGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbiA9IGNoYW5nZWRDaGlsZHJlbi5zZXQobmV3IFBhdGgobmFtZSksIG5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdQcm9jZXNzb3JBcHBseVNlcnZlck1lcmdlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgYWNrUGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUaGlzIGlzIGEgbWVyZ2UuXHJcbiAgICAgICAgbGV0IGNoYW5nZWRDaGlsZHJlbiA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGFmZmVjdGVkVHJlZS5mb3JlYWNoKChtZXJnZVBhdGgsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlckNhY2hlUGF0aCA9IHBhdGhDaGlsZChhY2tQYXRoLCBtZXJnZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoc2VydmVyQ2FjaGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENoaWxkcmVuID0gY2hhbmdlZENoaWxkcmVuLnNldChtZXJnZVBhdGgsIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChzZXJ2ZXJDYWNoZVBhdGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB2aWV3UHJvY2Vzc29yQXBwbHlTZXJ2ZXJNZXJnZSh2aWV3UHJvY2Vzc29yLCB2aWV3Q2FjaGUsIGFja1BhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yTGlzdGVuQ29tcGxldGUodmlld1Byb2Nlc3Nvciwgdmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgYWNjdW11bGF0b3IpIHtcclxuICAgIGNvbnN0IG9sZFNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICBjb25zdCBuZXdWaWV3Q2FjaGUgPSB2aWV3Q2FjaGVVcGRhdGVTZXJ2ZXJTbmFwKHZpZXdDYWNoZSwgb2xkU2VydmVyTm9kZS5nZXROb2RlKCksIG9sZFNlcnZlck5vZGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHwgcGF0aElzRW1wdHkocGF0aCksIG9sZFNlcnZlck5vZGUuaXNGaWx0ZXJlZCgpKTtcclxuICAgIHJldHVybiB2aWV3UHJvY2Vzc29yR2VuZXJhdGVFdmVudENhY2hlQWZ0ZXJTZXJ2ZXJFdmVudCh2aWV3UHJvY2Vzc29yLCBuZXdWaWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBOT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIGFjY3VtdWxhdG9yKTtcclxufVxyXG5mdW5jdGlvbiB2aWV3UHJvY2Vzc29yUmV2ZXJ0VXNlcldyaXRlKHZpZXdQcm9jZXNzb3IsIHZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XHJcbiAgICBsZXQgY29tcGxldGU7XHJcbiAgICBpZiAod3JpdGVUcmVlUmVmU2hhZG93aW5nV3JpdGUod3JpdGVzQ2FjaGUsIHBhdGgpICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gbmV3IFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgY29uc3Qgb2xkRXZlbnRDYWNoZSA9IHZpZXdDYWNoZS5ldmVudENhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICBsZXQgbmV3RXZlbnRDYWNoZTtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkocGF0aCkgfHwgcGF0aEdldEZyb250KHBhdGgpID09PSAnLnByaW9yaXR5Jykge1xyXG4gICAgICAgICAgICBsZXQgbmV3Tm9kZTtcclxuICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUod3JpdGVzQ2FjaGUsIHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3Q2FjaGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlckNoaWxkcmVuID0gdmlld0NhY2hlLnNlcnZlckNhY2hlLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgIGFzc2VydChzZXJ2ZXJDaGlsZHJlbiBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZSwgJ3NlcnZlckNoaWxkcmVuIHdvdWxkIGJlIGNvbXBsZXRlIGlmIGxlYWYgbm9kZScpO1xyXG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVzQ2FjaGUsIHNlcnZlckNoaWxkcmVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZTtcclxuICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZEV2ZW50Q2FjaGUsIG5ld05vZGUsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkS2V5ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgICAgICAgICBsZXQgbmV3Q2hpbGQgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVDaGlsZCh3cml0ZXNDYWNoZSwgY2hpbGRLZXksIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZSk7XHJcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZCA9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBvbGRFdmVudENhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUNoaWxkKG9sZEV2ZW50Q2FjaGUsIGNoaWxkS2V5LCBuZXdDaGlsZCwgcGF0aFBvcEZyb250KHBhdGgpLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCkuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBObyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUsIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lLCBpZiBhbnlcclxuICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB2aWV3UHJvY2Vzc29yLmZpbHRlci51cGRhdGVDaGlsZChvbGRFdmVudENhY2hlLCBjaGlsZEtleSwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIHBhdGhQb3BGcm9udChwYXRoKSwgc291cmNlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRDYWNoZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobmV3RXZlbnRDYWNoZS5pc0VtcHR5KCkgJiZcclxuICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgaGF2ZSByZXZlcnRlZCBhbGwgY2hpbGQgd3JpdGVzLiBNYXliZSB0aGUgb2xkIGV2ZW50IHdhcyBhIGxlYWYgbm9kZVxyXG4gICAgICAgICAgICAgICAgY29tcGxldGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlld0NhY2hlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGxldGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHZpZXdQcm9jZXNzb3IuZmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG5ld0V2ZW50Q2FjaGUsIGNvbXBsZXRlLCBhY2N1bXVsYXRvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcGxldGUgPVxyXG4gICAgICAgICAgICB2aWV3Q2FjaGUuc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkgfHxcclxuICAgICAgICAgICAgICAgIHdyaXRlVHJlZVJlZlNoYWRvd2luZ1dyaXRlKHdyaXRlc0NhY2hlLCBuZXdFbXB0eVBhdGgoKSkgIT0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdmlld0NhY2hlVXBkYXRlRXZlbnRTbmFwKHZpZXdDYWNoZSwgbmV3RXZlbnRDYWNoZSwgY29tcGxldGUsIHZpZXdQcm9jZXNzb3IuZmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQSB2aWV3IHJlcHJlc2VudHMgYSBzcGVjaWZpYyBsb2NhdGlvbiBhbmQgcXVlcnkgdGhhdCBoYXMgMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMuXHJcbiAqXHJcbiAqIEl0IGRvZXMgc2V2ZXJhbCB0aGluZ3M6XHJcbiAqICAtIE1haW50YWlucyB0aGUgbGlzdCBvZiBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxyXG4gKiAgLSBNYWludGFpbnMgYSBjYWNoZSBvZiB0aGUgZGF0YSB2aXNpYmxlIGZvciB0aGlzIGxvY2F0aW9uL3F1ZXJ5LlxyXG4gKiAgLSBBcHBsaWVzIG5ldyBvcGVyYXRpb25zICh2aWEgYXBwbHlPcGVyYXRpb24pLCB1cGRhdGVzIHRoZSBjYWNoZSwgYW5kIGJhc2VkIG9uIHRoZSBldmVudFxyXG4gKiAgICByZWdpc3RyYXRpb25zIHJldHVybnMgdGhlIHNldCBvZiBldmVudHMgdG8gYmUgcmFpc2VkLlxyXG4gKi9cclxuY2xhc3MgVmlldyB7XHJcbiAgICBjb25zdHJ1Y3RvcihxdWVyeV8sIGluaXRpYWxWaWV3Q2FjaGUpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18gPSBbXTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnF1ZXJ5Xy5fcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgY29uc3QgaW5kZXhGaWx0ZXIgPSBuZXcgSW5kZXhlZEZpbHRlcihwYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyID0gcXVlcnlQYXJhbXNHZXROb2RlRmlsdGVyKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JfID0gbmV3Vmlld1Byb2Nlc3NvcihmaWx0ZXIpO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXJ2ZXJDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuc2VydmVyQ2FjaGU7XHJcbiAgICAgICAgY29uc3QgaW5pdGlhbEV2ZW50Q2FjaGUgPSBpbml0aWFsVmlld0NhY2hlLmV2ZW50Q2FjaGU7XHJcbiAgICAgICAgLy8gRG9uJ3QgZmlsdGVyIHNlcnZlciBub2RlIHdpdGggb3RoZXIgZmlsdGVyIHRoYW4gaW5kZXgsIHdhaXQgZm9yIHRhZ2dlZCBsaXN0ZW5cclxuICAgICAgICBjb25zdCBzZXJ2ZXJTbmFwID0gaW5kZXhGaWx0ZXIudXBkYXRlRnVsbE5vZGUoQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIGluaXRpYWxTZXJ2ZXJDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50U25hcCA9IGZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbEV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcclxuICAgICAgICBjb25zdCBuZXdTZXJ2ZXJDYWNoZSA9IG5ldyBDYWNoZU5vZGUoc2VydmVyU25hcCwgaW5pdGlhbFNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpLCBpbmRleEZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XHJcbiAgICAgICAgY29uc3QgbmV3RXZlbnRDYWNoZSA9IG5ldyBDYWNoZU5vZGUoZXZlbnRTbmFwLCBpbml0aWFsRXZlbnRDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgZmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcclxuICAgICAgICB0aGlzLnZpZXdDYWNoZV8gPSBuZXdWaWV3Q2FjaGUobmV3RXZlbnRDYWNoZSwgbmV3U2VydmVyQ2FjaGUpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRHZW5lcmF0b3JfID0gbmV3IEV2ZW50R2VuZXJhdG9yKHRoaXMucXVlcnlfKTtcclxuICAgIH1cclxuICAgIGdldCBxdWVyeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeV87XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldFNlcnZlckNhY2hlKHZpZXcpIHtcclxuICAgIHJldHVybiB2aWV3LnZpZXdDYWNoZV8uc2VydmVyQ2FjaGUuZ2V0Tm9kZSgpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRDb21wbGV0ZU5vZGUodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXcudmlld0NhY2hlXyk7XHJcbn1cclxuZnVuY3Rpb24gdmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUodmlldywgcGF0aCkge1xyXG4gICAgY29uc3QgY2FjaGUgPSB2aWV3Q2FjaGVHZXRDb21wbGV0ZVNlcnZlclNuYXAodmlldy52aWV3Q2FjaGVfKTtcclxuICAgIGlmIChjYWNoZSkge1xyXG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgYSBcImxvYWRzQWxsRGF0YVwiIHZpZXcsIHRoZW4gY2FjaGUgaXNuJ3QgYWN0dWFsbHkgYSBjb21wbGV0ZSBjYWNoZSBhbmRcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNlZSBpZiBpdCBjb250YWlucyB0aGUgY2hpbGQgd2UncmUgaW50ZXJlc3RlZCBpbi5cclxuICAgICAgICBpZiAodmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkgfHxcclxuICAgICAgICAgICAgKCFwYXRoSXNFbXB0eShwYXRoKSAmJlxyXG4gICAgICAgICAgICAgICAgIWNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKHBhdGhHZXRGcm9udChwYXRoKSkuaXNFbXB0eSgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGUuZ2V0Q2hpbGQocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gdmlld0lzRW1wdHkodmlldykge1xyXG4gICAgcmV0dXJuIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGggPT09IDA7XHJcbn1cclxuZnVuY3Rpb24gdmlld0FkZEV2ZW50UmVnaXN0cmF0aW9uKHZpZXcsIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18ucHVzaChldmVudFJlZ2lzdHJhdGlvbik7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBldmVudFJlZ2lzdHJhdGlvbiAtIElmIG51bGwsIHJlbW92ZSBhbGwgY2FsbGJhY2tzLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm5zIENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cclxuICovXHJcbmZ1bmN0aW9uIHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcclxuICAgIGNvbnN0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgaWYgKGNhbmNlbEVycm9yKSB7XHJcbiAgICAgICAgYXNzZXJ0KGV2ZW50UmVnaXN0cmF0aW9uID09IG51bGwsICdBIGNhbmNlbCBzaG91bGQgY2FuY2VsIGFsbCBldmVudCByZWdpc3RyYXRpb25zLicpO1xyXG4gICAgICAgIGNvbnN0IHBhdGggPSB2aWV3LnF1ZXJ5Ll9wYXRoO1xyXG4gICAgICAgIHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5mb3JFYWNoKHJlZ2lzdHJhdGlvbiA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heWJlRXZlbnQgPSByZWdpc3RyYXRpb24uY3JlYXRlQ2FuY2VsRXZlbnQoY2FuY2VsRXJyb3IsIHBhdGgpO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnRzLnB1c2gobWF5YmVFdmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgIGxldCByZW1haW5pbmcgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zX1tpXTtcclxuICAgICAgICAgICAgaWYgKCFleGlzdGluZy5tYXRjaGVzKGV2ZW50UmVnaXN0cmF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goZXhpc3RpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50UmVnaXN0cmF0aW9uLmhhc0FueUNhbGxiYWNrKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIGp1c3QgdGhpcyBvbmVcclxuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5jb25jYXQodmlldy5ldmVudFJlZ2lzdHJhdGlvbnNfLnNsaWNlKGkgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18gPSByZW1haW5pbmc7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2aWV3LmV2ZW50UmVnaXN0cmF0aW9uc18gPSBbXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIE9wZXJhdGlvbiwgdXBkYXRlcyBvdXIgY2FjaGUsIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBldmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgY29tcGxldGVTZXJ2ZXJDYWNoZSkge1xyXG4gICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25UeXBlLk1FUkdFICYmXHJcbiAgICAgICAgb3BlcmF0aW9uLnNvdXJjZS5xdWVyeUlkICE9PSBudWxsKSB7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZUdldENvbXBsZXRlU2VydmVyU25hcCh2aWV3LnZpZXdDYWNoZV8pLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzJyk7XHJcbiAgICAgICAgYXNzZXJ0KHZpZXdDYWNoZUdldENvbXBsZXRlRXZlbnRTbmFwKHZpZXcudmlld0NhY2hlXyksICdNaXNzaW5nIGV2ZW50IGNhY2hlLCBldmVuIHRob3VnaCB3ZSBoYXZlIGEgc2VydmVyIGNhY2hlJyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbGRWaWV3Q2FjaGUgPSB2aWV3LnZpZXdDYWNoZV87XHJcbiAgICBjb25zdCByZXN1bHQgPSB2aWV3UHJvY2Vzc29yQXBwbHlPcGVyYXRpb24odmlldy5wcm9jZXNzb3JfLCBvbGRWaWV3Q2FjaGUsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpO1xyXG4gICAgdmlld1Byb2Nlc3NvckFzc2VydEluZGV4ZWQodmlldy5wcm9jZXNzb3JfLCByZXN1bHQudmlld0NhY2hlKTtcclxuICAgIGFzc2VydChyZXN1bHQudmlld0NhY2hlLnNlcnZlckNhY2hlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XHJcbiAgICAgICAgIW9sZFZpZXdDYWNoZS5zZXJ2ZXJDYWNoZS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgJ09uY2UgYSBzZXJ2ZXIgc25hcCBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIG5ldmVyIGdvIGJhY2snKTtcclxuICAgIHZpZXcudmlld0NhY2hlXyA9IHJlc3VsdC52aWV3Q2FjaGU7XHJcbiAgICByZXR1cm4gdmlld0dlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18odmlldywgcmVzdWx0LmNoYW5nZXMsIHJlc3VsdC52aWV3Q2FjaGUuZXZlbnRDYWNoZS5nZXROb2RlKCksIG51bGwpO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZXRJbml0aWFsRXZlbnRzKHZpZXcsIHJlZ2lzdHJhdGlvbikge1xyXG4gICAgY29uc3QgZXZlbnRTbmFwID0gdmlldy52aWV3Q2FjaGVfLmV2ZW50Q2FjaGU7XHJcbiAgICBjb25zdCBpbml0aWFsQ2hhbmdlcyA9IFtdO1xyXG4gICAgaWYgKCFldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50Tm9kZSA9IGV2ZW50U25hcC5nZXROb2RlKCk7XHJcbiAgICAgICAgZXZlbnROb2RlLmZvckVhY2hDaGlsZChQUklPUklUWV9JTkRFWCwgKGtleSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goY2hhbmdlQ2hpbGRBZGRlZChrZXksIGNoaWxkTm9kZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xyXG4gICAgICAgIGluaXRpYWxDaGFuZ2VzLnB1c2goY2hhbmdlVmFsdWUoZXZlbnRTbmFwLmdldE5vZGUoKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIGluaXRpYWxDaGFuZ2VzLCBldmVudFNuYXAuZ2V0Tm9kZSgpLCByZWdpc3RyYXRpb24pO1xyXG59XHJcbmZ1bmN0aW9uIHZpZXdHZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXNfKHZpZXcsIGNoYW5nZXMsIGV2ZW50Q2FjaGUsIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICBjb25zdCByZWdpc3RyYXRpb25zID0gZXZlbnRSZWdpc3RyYXRpb25cclxuICAgICAgICA/IFtldmVudFJlZ2lzdHJhdGlvbl1cclxuICAgICAgICA6IHZpZXcuZXZlbnRSZWdpc3RyYXRpb25zXztcclxuICAgIHJldHVybiBldmVudEdlbmVyYXRvckdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlcyh2aWV3LmV2ZW50R2VuZXJhdG9yXywgY2hhbmdlcywgZXZlbnRDYWNoZSwgcmVnaXN0cmF0aW9ucyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IHJlZmVyZW5jZUNvbnN0cnVjdG9yJDE7XHJcbi8qKlxyXG4gKiBTeW5jUG9pbnQgcmVwcmVzZW50cyBhIHNpbmdsZSBsb2NhdGlvbiBpbiBhIFN5bmNUcmVlIHdpdGggMSBvciBtb3JlIGV2ZW50IHJlZ2lzdHJhdGlvbnMsIG1lYW5pbmcgd2UgbmVlZCB0b1xyXG4gKiBtYWludGFpbiAxIG9yIG1vcmUgVmlld3MgYXQgdGhpcyBsb2NhdGlvbiB0byBjYWNoZSBzZXJ2ZXIgZGF0YSBhbmQgcmFpc2UgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBzZXJ2ZXIgY2hhbmdlc1xyXG4gKiBhbmQgdXNlciB3cml0ZXMgKHNldCwgdHJhbnNhY3Rpb24sIHVwZGF0ZSkuXHJcbiAqXHJcbiAqIEl0J3MgcmVzcG9uc2libGUgZm9yOlxyXG4gKiAgLSBNYWludGFpbmluZyB0aGUgc2V0IG9mIDEgb3IgbW9yZSB2aWV3cyBuZWNlc3NhcnkgYXQgdGhpcyBsb2NhdGlvbiAoYSBTeW5jUG9pbnQgd2l0aCAwIHZpZXdzIHNob3VsZCBiZSByZW1vdmVkKS5cclxuICogIC0gUHJveHlpbmcgdXNlciAvIHNlcnZlciBvcGVyYXRpb25zIHRvIHRoZSB2aWV3cyBhcyBhcHByb3ByaWF0ZSAoaS5lLiBhcHBseVNlcnZlck92ZXJ3cml0ZSxcclxuICogICAgYXBwbHlVc2VyT3ZlcndyaXRlLCBldGMuKVxyXG4gKi9cclxuY2xhc3MgU3luY1BvaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBWaWV3cyBiZWluZyB0cmFja2VkIGF0IHRoaXMgbG9jYXRpb24gaW4gdGhlIHRyZWUsIHN0b3JlZCBhcyBhIG1hcCB3aGVyZSB0aGUga2V5IGlzIGFcclxuICAgICAgICAgKiBxdWVyeUlkIGFuZCB0aGUgdmFsdWUgaXMgdGhlIFZpZXcgZm9yIHRoYXQgcXVlcnkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOT1RFOiBUaGlzIGxpc3Qgd2lsbCBiZSBxdWl0ZSBzbWFsbCAodXN1YWxseSAxLCBidXQgcGVyaGFwcyAyIG9yIDM7IGFueSBtb3JlIGlzIGFuIG9kZCB1c2UgY2FzZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52aWV3cyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRTZXRSZWZlcmVuY2VDb25zdHJ1Y3Rvcih2YWwpIHtcclxuICAgIGFzc2VydCghcmVmZXJlbmNlQ29uc3RydWN0b3IkMSwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XHJcbiAgICByZWZlcmVuY2VDb25zdHJ1Y3RvciQxID0gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xyXG4gICAgYXNzZXJ0KHJlZmVyZW5jZUNvbnN0cnVjdG9yJDEsICdSZWZlcmVuY2UudHMgaGFzIG5vdCBiZWVuIGxvYWRlZCcpO1xyXG4gICAgcmV0dXJuIHJlZmVyZW5jZUNvbnN0cnVjdG9yJDE7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50SXNFbXB0eShzeW5jUG9pbnQpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnQudmlld3Muc2l6ZSA9PT0gMDtcclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBvcGVyYXRpb24uc291cmNlLnF1ZXJ5SWQ7XHJcbiAgICBpZiAocXVlcnlJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgICAgIGFzc2VydCh2aWV3ICE9IG51bGwsICdTeW5jVHJlZSBnYXZlIHVzIGFuIG9wIGZvciBhbiBpbnZhbGlkIHF1ZXJ5LicpO1xyXG4gICAgICAgIHJldHVybiB2aWV3QXBwbHlPcGVyYXRpb24odmlldywgb3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgb3B0Q29tcGxldGVTZXJ2ZXJDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHZpZXdBcHBseU9wZXJhdGlvbih2aWV3LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudHM7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdldCBhIHZpZXcgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byByZXR1cm4gYSB2aWV3IGZvclxyXG4gKiBAcGFyYW0gd3JpdGVzQ2FjaGVcclxuICogQHBhcmFtIHNlcnZlckNhY2hlXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldFZpZXcoc3luY1BvaW50LCBxdWVyeSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlKSB7XHJcbiAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnQudmlld3MuZ2V0KHF1ZXJ5SWQpO1xyXG4gICAgaWYgKCF2aWV3KSB7XHJcbiAgICAgICAgLy8gVE9ETzogbWFrZSB3cml0ZXNDYWNoZSB0YWtlIGZsYWcgZm9yIGNvbXBsZXRlIHNlcnZlciBub2RlXHJcbiAgICAgICAgbGV0IGV2ZW50Q2FjaGUgPSB3cml0ZVRyZWVSZWZDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZUNvbXBsZXRlID8gc2VydmVyQ2FjaGUgOiBudWxsKTtcclxuICAgICAgICBsZXQgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGV2ZW50Q2FjaGUpIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2VydmVyQ2FjaGUgaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGUpIHtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZSA9IHdyaXRlVHJlZVJlZkNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4od3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKTtcclxuICAgICAgICAgICAgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudENhY2hlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2aWV3Q2FjaGUgPSBuZXdWaWV3Q2FjaGUobmV3IENhY2hlTm9kZShldmVudENhY2hlLCBldmVudENhY2hlQ29tcGxldGUsIGZhbHNlKSwgbmV3IENhY2hlTm9kZShzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSwgZmFsc2UpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZpZXcocXVlcnksIHZpZXdDYWNoZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmlldztcclxufVxyXG4vKipcclxuICogQWRkIGFuIGV2ZW50IGNhbGxiYWNrIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0gcXVlcnlcclxuICogQHBhcmFtIGV2ZW50UmVnaXN0cmF0aW9uXHJcbiAqIEBwYXJhbSB3cml0ZXNDYWNoZVxyXG4gKiBAcGFyYW0gc2VydmVyQ2FjaGUgLSBDb21wbGV0ZSBzZXJ2ZXIgY2FjaGUsIGlmIHdlIGhhdmUgaXQuXHJcbiAqIEBwYXJhbSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRHZXRWaWV3KHN5bmNQb2ludCwgcXVlcnksIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICBpZiAoIXN5bmNQb2ludC52aWV3cy5oYXMocXVlcnkuX3F1ZXJ5SWRlbnRpZmllcikpIHtcclxuICAgICAgICBzeW5jUG9pbnQudmlld3Muc2V0KHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIsIHZpZXcpO1xyXG4gICAgfVxyXG4gICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IG5vdywgd2UganVzdCBjcmVhdGVkIGFueXRoaW5nIHRoYXQgd2FzIG1pc3NpbmdcclxuICAgIHZpZXdBZGRFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICByZXR1cm4gdmlld0dldEluaXRpYWxFdmVudHModmlldywgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgZXZlbnQgY2FsbGJhY2socykuICBSZXR1cm4gY2FuY2VsRXZlbnRzIGlmIGEgY2FuY2VsRXJyb3IgaXMgc3BlY2lmaWVkLlxyXG4gKlxyXG4gKiBJZiBxdWVyeSBpcyB0aGUgZGVmYXVsdCBxdWVyeSwgd2UnbGwgY2hlY2sgYWxsIHZpZXdzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxyXG4gKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCB2aWV3KHMpLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCByZW1vdmUgYWxsIGNhbGxiYWNrcy5cclxuICogQHBhcmFtIGNhbmNlbEVycm9yIC0gSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyByZW1vdmVkIHF1ZXJpZXMgYW5kIGFueSBjYW5jZWwgZXZlbnRzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jUG9pbnRSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihzeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcclxuICAgIGNvbnN0IHF1ZXJ5SWQgPSBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgY29uc3QgaGFkQ29tcGxldGVWaWV3ID0gc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICBpZiAocXVlcnlJZCA9PT0gJ2RlZmF1bHQnKSB7XHJcbiAgICAgICAgLy8gV2hlbiB5b3UgZG8gcmVmLm9mZiguLi4pLCB3ZSBzZWFyY2ggYWxsIHZpZXdzIGZvciB0aGUgcmVnaXN0cmF0aW9uIHRvIHJlbW92ZS5cclxuICAgICAgICBmb3IgKGNvbnN0IFt2aWV3UXVlcnlJZCwgdmlld10gb2Ygc3luY1BvaW50LnZpZXdzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjYW5jZWxFdmVudHMgPSBjYW5jZWxFdmVudHMuY29uY2F0KHZpZXdSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbih2aWV3LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpKTtcclxuICAgICAgICAgICAgaWYgKHZpZXdJc0VtcHR5KHZpZXcpKSB7XHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnQudmlld3MuZGVsZXRlKHZpZXdRdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cclxuICAgICAgICAgICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNwZWNpZmljIHZpZXcuXHJcbiAgICAgICAgY29uc3QgdmlldyA9IHN5bmNQb2ludC52aWV3cy5nZXQocXVlcnlJZCk7XHJcbiAgICAgICAgaWYgKHZpZXcpIHtcclxuICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gY2FuY2VsRXZlbnRzLmNvbmNhdCh2aWV3UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24odmlldywgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSk7XHJcbiAgICAgICAgICAgIGlmICh2aWV3SXNFbXB0eSh2aWV3KSkge1xyXG4gICAgICAgICAgICAgICAgc3luY1BvaW50LnZpZXdzLmRlbGV0ZShxdWVyeUlkKTtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cclxuICAgICAgICAgICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2godmlldy5xdWVyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaGFkQ29tcGxldGVWaWV3ICYmICFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3luY1BvaW50KSkge1xyXG4gICAgICAgIC8vIFdlIHJlbW92ZWQgb3VyIGxhc3QgY29tcGxldGUgdmlldy5cclxuICAgICAgICByZW1vdmVkLnB1c2gobmV3IChzeW5jUG9pbnRHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpKShxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHJlbW92ZWQsIGV2ZW50czogY2FuY2VsRXZlbnRzIH07XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50R2V0UXVlcnlWaWV3cyhzeW5jUG9pbnQpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGlmICghdmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byB0aGUgZGVzaXJlZCBjb21wbGV0ZSBzbmFwc2hvdFxyXG4gKiBAcmV0dXJucyBBIGNvbXBsZXRlIGNhY2hlLCBpZiBpdCBleGlzdHNcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBwYXRoKSB7XHJcbiAgICBsZXQgc2VydmVyQ2FjaGUgPSBudWxsO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHN5bmNQb2ludC52aWV3cy52YWx1ZXMoKSkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUgfHwgdmlld0dldENvbXBsZXRlU2VydmVyQ2FjaGUodmlldywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VydmVyQ2FjaGU7XHJcbn1cclxuZnVuY3Rpb24gc3luY1BvaW50Vmlld0ZvclF1ZXJ5KHN5bmNQb2ludCwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhcmFtcyA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcztcclxuICAgIGlmIChwYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBxdWVyeUlkID0gcXVlcnkuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICByZXR1cm4gc3luY1BvaW50LnZpZXdzLmdldChxdWVyeUlkKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSkge1xyXG4gICAgcmV0dXJuIHN5bmNQb2ludFZpZXdGb3JRdWVyeShzeW5jUG9pbnQsIHF1ZXJ5KSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhzeW5jUG9pbnQpIHtcclxuICAgIHJldHVybiBzeW5jUG9pbnRHZXRDb21wbGV0ZVZpZXcoc3luY1BvaW50KSAhPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNQb2ludEdldENvbXBsZXRlVmlldyhzeW5jUG9pbnQpIHtcclxuICAgIGZvciAoY29uc3QgdmlldyBvZiBzeW5jUG9pbnQudmlld3MudmFsdWVzKCkpIHtcclxuICAgICAgICBpZiAodmlldy5xdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxubGV0IHJlZmVyZW5jZUNvbnN0cnVjdG9yO1xyXG5mdW5jdGlvbiBzeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKHZhbCkge1xyXG4gICAgYXNzZXJ0KCFyZWZlcmVuY2VDb25zdHJ1Y3RvciwgJ19fcmVmZXJlbmNlQ29uc3RydWN0b3IgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkJyk7XHJcbiAgICByZWZlcmVuY2VDb25zdHJ1Y3RvciA9IHZhbDtcclxufVxyXG5mdW5jdGlvbiBzeW5jVHJlZUdldFJlZmVyZW5jZUNvbnN0cnVjdG9yKCkge1xyXG4gICAgYXNzZXJ0KHJlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcclxuICAgIHJldHVybiByZWZlcmVuY2VDb25zdHJ1Y3RvcjtcclxufVxyXG4vKipcclxuICogU3RhdGljIHRyYWNrZXIgZm9yIG5leHQgcXVlcnkgdGFnLlxyXG4gKi9cclxubGV0IHN5bmNUcmVlTmV4dFF1ZXJ5VGFnXyA9IDE7XHJcbi8qKlxyXG4gKiBTeW5jVHJlZSBpcyB0aGUgY2VudHJhbCBjbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnQgY2FsbGJhY2sgcmVnaXN0cmF0aW9uLCBkYXRhIGNhY2hpbmcsIHZpZXdzXHJcbiAqIChxdWVyeSBwcm9jZXNzaW5nKSwgYW5kIGV2ZW50IGdlbmVyYXRpb24uICBUaGVyZSBhcmUgdHlwaWNhbGx5IHR3byBTeW5jVHJlZSBpbnN0YW5jZXMgZm9yXHJcbiAqIGVhY2ggUmVwbywgb25lIGZvciB0aGUgbm9ybWFsIEZpcmViYXNlIGRhdGEsIGFuZCBvbmUgZm9yIHRoZSAuaW5mbyBkYXRhLlxyXG4gKlxyXG4gKiBJdCBoYXMgYSBudW1iZXIgb2YgcmVzcG9uc2liaWxpdGllcywgaW5jbHVkaW5nOlxyXG4gKiAgLSBUcmFja2luZyBhbGwgdXNlciBldmVudCBjYWxsYmFja3MgKHJlZ2lzdGVyZWQgdmlhIGFkZEV2ZW50UmVnaXN0cmF0aW9uKCkgYW5kIHJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKCkpLlxyXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHVzZXIgc2V0KCksIHRyYW5zYWN0aW9uKCksIGFuZCB1cGRhdGUoKSBjYWxsc1xyXG4gKiAgICAoYXBwbHlVc2VyT3ZlcndyaXRlKCksIGFwcGx5VXNlck1lcmdlKCkpLlxyXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHNlcnZlciBkYXRhIGNoYW5nZXMgKGFwcGx5U2VydmVyT3ZlcndyaXRlKCksXHJcbiAqICAgIGFwcGx5U2VydmVyTWVyZ2UoKSkuXHJcbiAqICAtIEdlbmVyYXRpbmcgdXNlci1mYWNpbmcgZXZlbnRzIGZvciBzZXJ2ZXIgYW5kIHVzZXIgY2hhbmdlcyAoYWxsIG9mIHRoZSBhcHBseSogbWV0aG9kc1xyXG4gKiAgICByZXR1cm4gdGhlIHNldCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIHJhaXNlZCBhcyBhIHJlc3VsdCkuXHJcbiAqICAtIE1haW50YWluaW5nIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc2VydmVyIGxpc3RlbnMgdG8gZW5zdXJlIHdlIGFyZSBhbHdheXMgc3Vic2NyaWJlZFxyXG4gKiAgICB0byB0aGUgY29ycmVjdCBzZXQgb2YgcGF0aHMgYW5kIHF1ZXJpZXMgdG8gc2F0aXNmeSB0aGUgY3VycmVudCBzZXQgb2YgdXNlciBldmVudFxyXG4gKiAgICBjYWxsYmFja3MgKGxpc3RlbnMgYXJlIHN0YXJ0ZWQvc3RvcHBlZCB1c2luZyB0aGUgcHJvdmlkZWQgbGlzdGVuUHJvdmlkZXIpLlxyXG4gKlxyXG4gKiBOT1RFOiBBbHRob3VnaCBTeW5jVHJlZSB0cmFja3MgZXZlbnQgY2FsbGJhY2tzIGFuZCBjYWxjdWxhdGVzIGV2ZW50cyB0byByYWlzZSwgdGhlIGFjdHVhbFxyXG4gKiBldmVudHMgYXJlIHJldHVybmVkIHRvIHRoZSBjYWxsZXIgcmF0aGVyIHRoYW4gcmFpc2VkIHN5bmNocm9ub3VzbHkuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBTeW5jVHJlZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBsaXN0ZW5Qcm92aWRlcl8gLSBVc2VkIGJ5IFN5bmNUcmVlIHRvIHN0YXJ0IC8gc3RvcCBsaXN0ZW5pbmdcclxuICAgICAqICAgdG8gc2VydmVyIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxpc3RlblByb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfID0gbGlzdGVuUHJvdmlkZXJfO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyZWUgb2YgU3luY1BvaW50cy4gIFRoZXJlJ3MgYSBTeW5jUG9pbnQgYXQgYW55IGxvY2F0aW9uIHRoYXQgaGFzIDEgb3IgbW9yZSB2aWV3cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN5bmNQb2ludFRyZWVfID0gbmV3IEltbXV0YWJsZVRyZWUobnVsbCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB0cmVlIG9mIGFsbCBwZW5kaW5nIHVzZXIgd3JpdGVzICh1c2VyLWluaXRpYXRlZCBzZXQoKSdzLCB0cmFuc2FjdGlvbigpJ3MsIHVwZGF0ZSgpJ3MsIGV0Yy4pLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlVHJlZV8gPSBuZXdXcml0ZVRyZWUoKTtcclxuICAgICAgICB0aGlzLnRhZ1RvUXVlcnlNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5xdWVyeVRvVGFnTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSB0aGUgZGF0YSBjaGFuZ2VzIGZvciBhIHVzZXItZ2VuZXJhdGVkIHNldCgpIG9yIHRyYW5zYWN0aW9uKCkgY2FsbC5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUoc3luY1RyZWUsIHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpIHtcclxuICAgIC8vIFJlY29yZCBwZW5kaW5nIHdyaXRlLlxyXG4gICAgd3JpdGVUcmVlQWRkT3ZlcndyaXRlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoLCBuZXdEYXRhLCB3cml0ZUlkLCB2aXNpYmxlKTtcclxuICAgIGlmICghdmlzaWJsZSkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhzeW5jVHJlZSwgbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VVc2VyKCksIHBhdGgsIG5ld0RhdGEpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQXBwbHkgdGhlIGRhdGEgZnJvbSBhIHVzZXItZ2VuZXJhdGVkIHVwZGF0ZSgpIGNhbGxcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVVzZXJNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKSB7XHJcbiAgICAvLyBSZWNvcmQgcGVuZGluZyBtZXJnZS5cclxuICAgIHdyaXRlVHJlZUFkZE1lcmdlKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xyXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlVXNlcigpLCBwYXRoLCBjaGFuZ2VUcmVlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFja25vd2xlZGdlIGEgcGVuZGluZyB1c2VyIHdyaXRlIHRoYXQgd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFwcGx5VXNlck92ZXJ3cml0ZSgpIG9yIGFwcGx5VXNlck1lcmdlKCkuXHJcbiAqXHJcbiAqIEBwYXJhbSByZXZlcnQgLSBUcnVlIGlmIHRoZSBnaXZlbiB3cml0ZSBmYWlsZWQgYW5kIG5lZWRzIHRvIGJlIHJldmVydGVkXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQWNrVXNlcldyaXRlKHN5bmNUcmVlLCB3cml0ZUlkLCByZXZlcnQgPSBmYWxzZSkge1xyXG4gICAgY29uc3Qgd3JpdGUgPSB3cml0ZVRyZWVHZXRXcml0ZShzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgd3JpdGVJZCk7XHJcbiAgICBjb25zdCBuZWVkVG9SZWV2YWx1YXRlID0gd3JpdGVUcmVlUmVtb3ZlV3JpdGUoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHdyaXRlSWQpO1xyXG4gICAgaWYgKCFuZWVkVG9SZWV2YWx1YXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGFmZmVjdGVkVHJlZSA9IG5ldyBJbW11dGFibGVUcmVlKG51bGwpO1xyXG4gICAgICAgIGlmICh3cml0ZS5zbmFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gb3ZlcndyaXRlXHJcbiAgICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3RW1wdHlQYXRoKCksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWFjaCh3cml0ZS5jaGlsZHJlbiwgKHBhdGhTdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgICAgIGFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZS5zZXQobmV3IFBhdGgocGF0aFN0cmluZyksIHRydWUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgQWNrVXNlcldyaXRlKHdyaXRlLnBhdGgsIGFmZmVjdGVkVHJlZSwgcmV2ZXJ0KSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCBwYXRoLi5cclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVNlcnZlck92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgbmV3RGF0YSkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgT3ZlcndyaXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlcigpLCBwYXRoLCBuZXdEYXRhKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5U2VydmVyTWVyZ2Uoc3luY1RyZWUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbikge1xyXG4gICAgY29uc3QgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdChjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBuZXcgTWVyZ2UobmV3T3BlcmF0aW9uU291cmNlU2VydmVyKCksIHBhdGgsIGNoYW5nZVRyZWUpKTtcclxufVxyXG4vKipcclxuICogQXBwbHkgYSBsaXN0ZW4gY29tcGxldGUgZm9yIGEgcXVlcnlcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseUxpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBwYXRoKSB7XHJcbiAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18oc3luY1RyZWUsIG5ldyBMaXN0ZW5Db21wbGV0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXIoKSwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBhIGxpc3RlbiBjb21wbGV0ZSBmb3IgYSB0YWdnZWQgcXVlcnlcclxuICpcclxuICogQHJldHVybnMgRXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBwYXRoLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IExpc3RlbkNvbXBsZXRlKG5ld09wZXJhdGlvblNvdXJjZVNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgpO1xyXG4gICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBldmVudCBjYWxsYmFjayhzKS5cclxuICpcclxuICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCBxdWVyaWVzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxyXG4gKiBJZiBldmVudFJlZ2lzdHJhdGlvbiBpcyBudWxsLCB3ZSdsbCByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIHNwZWNpZmllZCBxdWVyeS9xdWVyaWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBJZiBudWxsLCBhbGwgY2FsbGJhY2tzIGFyZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gY2FuY2VsRXJyb3IgLSBJZiBhIGNhbmNlbEVycm9yIGlzIHByb3ZpZGVkLCBhcHByb3ByaWF0ZSBjYW5jZWwgZXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEBwYXJhbSBza2lwTGlzdGVuZXJEZWR1cCAtIFdoZW4gcGVyZm9ybWluZyBhIGBnZXQoKWAsIHdlIGRvbid0IGFkZCBhbnkgbmV3IGxpc3RlbmVycywgc28gbm9cclxuICogIGRlZHVwaW5nIG5lZWRzIHRvIHRha2UgcGxhY2UuIFRoaXMgZmxhZyBhbGxvd3MgdG9nZ2xpbmcgb2YgdGhhdCBiZWhhdmlvclxyXG4gKiBAcmV0dXJucyBDYW5jZWwgZXZlbnRzLCBpZiBjYW5jZWxFcnJvciB3YXMgcHJvdmlkZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yLCBza2lwTGlzdGVuZXJEZWR1cCA9IGZhbHNlKSB7XHJcbiAgICAvLyBGaW5kIHRoZSBzeW5jUG9pbnQgZmlyc3QuIFRoZW4gZGVhbCB3aXRoIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBtYXRjaGluZyBsaXN0ZW5lcnNcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGNvbnN0IG1heWJlU3luY1BvaW50ID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xyXG4gICAgbGV0IGNhbmNlbEV2ZW50cyA9IFtdO1xyXG4gICAgLy8gQSByZW1vdmFsIG9uIGEgZGVmYXVsdCBxdWVyeSBhZmZlY3RzIGFsbCBxdWVyaWVzIGF0IHRoYXQgbG9jYXRpb24uIEEgcmVtb3ZhbCBvbiBhbiBpbmRleGVkIHF1ZXJ5LCBldmVuIG9uZSB3aXRob3V0XHJcbiAgICAvLyBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgZG9lcyAqbm90KiBhZmZlY3QgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gU28gdGhpcyBjaGVjayBtdXN0IGJlIGZvciAnZGVmYXVsdCcsIGFuZFxyXG4gICAgLy8gbm90IGxvYWRzQWxsRGF0YSgpLlxyXG4gICAgaWYgKG1heWJlU3luY1BvaW50ICYmXHJcbiAgICAgICAgKHF1ZXJ5Ll9xdWVyeUlkZW50aWZpZXIgPT09ICdkZWZhdWx0JyB8fFxyXG4gICAgICAgICAgICBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkobWF5YmVTeW5jUG9pbnQsIHF1ZXJ5KSkpIHtcclxuICAgICAgICBjb25zdCByZW1vdmVkQW5kRXZlbnRzID0gc3luY1BvaW50UmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24obWF5YmVTeW5jUG9pbnQsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpO1xyXG4gICAgICAgIGlmIChzeW5jUG9pbnRJc0VtcHR5KG1heWJlU3luY1BvaW50KSkge1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHJlbW92ZWRBbmRFdmVudHMucmVtb3ZlZDtcclxuICAgICAgICBjYW5jZWxFdmVudHMgPSByZW1vdmVkQW5kRXZlbnRzLmV2ZW50cztcclxuICAgICAgICBpZiAoIXNraXBMaXN0ZW5lckRlZHVwKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBXZSBtYXkgaGF2ZSBqdXN0IHJlbW92ZWQgb25lIG9mIG1hbnkgbGlzdGVuZXJzIGFuZCBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIHdob2xlIHByb2Nlc3NcclxuICAgICAgICAgICAgICogV2UgbWF5IGFsc28gbm90IGhhdmUgcmVtb3ZlZCBhIGRlZmF1bHQgbGlzdGVuZXIsIGluIHdoaWNoIGNhc2UgYWxsIG9mIHRoZSBkZXNjZW5kYW50IGxpc3RlbmVycyBzaG91bGQgYWxyZWFkeSBiZVxyXG4gICAgICAgICAgICAgKiBwcm9wZXJseSBzZXQgdXAuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAvLyBTaW5jZSBpbmRleGVkIHF1ZXJpZXMgY2FuIHNoYWRvdyBpZiB0aGV5IGRvbid0IGhhdmUgb3RoZXIgcXVlcnkgY29uc3RyYWludHMsIGNoZWNrIGZvciBsb2Fkc0FsbERhdGEoKSwgaW5zdGVhZCBvZlxyXG4gICAgICAgICAgICAvLyBxdWVyeUlkID09PSAnZGVmYXVsdCdcclxuICAgICAgICAgICAgY29uc3QgcmVtb3ZpbmdEZWZhdWx0ID0gLTEgIT09XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkLmZpbmRJbmRleChxdWVyeSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBjb3ZlcmVkID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZmluZE9uUGF0aChwYXRoLCAocmVsYXRpdmVQYXRoLCBwYXJlbnRTeW5jUG9pbnQpID0+IHN5bmNQb2ludEhhc0NvbXBsZXRlVmlldyhwYXJlbnRTeW5jUG9pbnQpKTtcclxuICAgICAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCAmJiAhY292ZXJlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgcG90ZW50aWFsbHkgY2hpbGQgbGlzdGVuZXJzLiBEZXRlcm1pbmUgd2hhdCBpZiBhbnkgbGlzdGVucyB3ZSBuZWVkIHRvIHNlbmQgYmVmb3JlIGV4ZWN1dGluZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92YWxcclxuICAgICAgICAgICAgICAgIGlmICghc3VidHJlZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGZvbGQgb3ZlciBvdXIgc3VidHJlZSBhbmQgY29sbGVjdCB0aGUgbGlzdGVuZXJzIHRvIHNlbmRcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWaWV3cyA9IHN5bmNUcmVlQ29sbGVjdERpc3RpbmN0Vmlld3NGb3JTdWJUcmVlXyhzdWJ0cmVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBPaywgd2UndmUgY29sbGVjdGVkIGFsbCB0aGUgbGlzdGVucyB3ZSBuZWVkLiBTZXQgdGhlbSB1cC5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld1ZpZXdzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXdWaWV3c1tpXSwgbmV3UXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdGFydExpc3RlbmluZyhzeW5jVHJlZVF1ZXJ5Rm9yTGlzdGVuaW5nXyhuZXdRdWVyeSksIHN5bmNUcmVlVGFnRm9yUXVlcnkoc3luY1RyZWUsIG5ld1F1ZXJ5KSwgbGlzdGVuZXIuaGFzaEZuLCBsaXN0ZW5lci5vbkNvbXBsZXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlcmUncyBub3RoaW5nIGJlbG93IHVzLCBzbyBub3RoaW5nIHdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIG9uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhbnl0aGluZyBhbmQgd2UncmUgbm90IGNvdmVyZWQgYnkgYSBoaWdoZXIgdXAgbGlzdGVuLCB3ZSBuZWVkIHRvIHN0b3AgbGlzdGVuaW5nIG9uIHRoaXMgcXVlcnlcclxuICAgICAgICAgICAgLy8gVGhlIGFib3ZlIGJsb2NrIGhhcyB1cyBjb3ZlcmVkIGluIHRlcm1zIG9mIG1ha2luZyBzdXJlIHdlJ3JlIHNldCB1cCBvbiBsaXN0ZW5zIGxvd2VyIGluIHRoZSB0cmVlLlxyXG4gICAgICAgICAgICAvLyBBbHNvLCBub3RlIHRoYXQgaWYgd2UgaGF2ZSBhIGNhbmNlbEVycm9yLCBpdCdzIGFscmVhZHkgYmVlbiByZW1vdmVkIGF0IHRoZSBwcm92aWRlciBsZXZlbC5cclxuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkICYmIHJlbW92ZWQubGVuZ3RoID4gMCAmJiAhY2FuY2VsRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBkZWZhdWx0LCB0aGVuIHdlIHdlcmVuJ3QgbGlzdGVuaW5nIG9uIGFueSBvZiB0aGUgb3RoZXIgcXVlcmllcyBoZXJlLiBKdXN0IGNhbmNlbCB0aGUgb25lXHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LiBPdGhlcndpc2UsIHdlIG5lZWQgdG8gaXRlcmF0ZSB0aHJvdWdoIGFuZCBjYW5jZWwgZWFjaCBpbmRpdmlkdWFsIHF1ZXJ5XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdGFnIGRlZmF1bHQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdFRhZyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpLCBkZWZhdWx0VGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQuZm9yRWFjaCgocXVlcnlUb1JlbW92ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWdUb1JlbW92ZSA9IHN5bmNUcmVlLnF1ZXJ5VG9UYWdNYXAuZ2V0KHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeVRvUmVtb3ZlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9SZW1vdmUpLCB0YWdUb1JlbW92ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93LCBjbGVhciBhbGwgb2YgdGhlIHRhZ3Mgd2UncmUgdHJhY2tpbmcgZm9yIHRoZSByZW1vdmVkIGxpc3RlbnNcclxuICAgICAgICBzeW5jVHJlZVJlbW92ZVRhZ3NfKHN5bmNUcmVlLCByZW1vdmVkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYW5jZWxFdmVudHM7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShzeW5jVHJlZSwgcGF0aCwgc25hcCwgdGFnKSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlUXVlcnlLZXlGb3JUYWdfKHN5bmNUcmVlLCB0YWcpO1xyXG4gICAgaWYgKHF1ZXJ5S2V5ICE9IG51bGwpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG9wID0gbmV3IE92ZXJ3cml0ZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoLCBzbmFwKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gUXVlcnkgbXVzdCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBcHBseSBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gZm9yIHRoZSBzcGVjaWZpZWQgdGFnZ2VkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBFdmVudHMgdG8gcmFpc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZShzeW5jVHJlZSwgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB0YWcpIHtcclxuICAgIGNvbnN0IHF1ZXJ5S2V5ID0gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZyk7XHJcbiAgICBpZiAocXVlcnlLZXkpIHtcclxuICAgICAgICBjb25zdCByID0gc3luY1RyZWVQYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XHJcbiAgICAgICAgY29uc3QgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZVRyZWUgPSBJbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcclxuICAgICAgICBjb25zdCBvcCA9IG5ldyBNZXJnZShuZXdPcGVyYXRpb25Tb3VyY2VTZXJ2ZXJUYWdnZWRRdWVyeShxdWVyeUlkKSwgcmVsYXRpdmVQYXRoLCBjaGFuZ2VUcmVlKTtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZE9wZXJhdGlvbl8oc3luY1RyZWUsIHF1ZXJ5UGF0aCwgb3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSByZW1vdmVkIHRoZSBxdWVyeS4gTm8gYmlnIGRlYWwsIGlnbm9yZSB0aGUgdXBkYXRlXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEV2ZW50cyB0byByYWlzZS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24oc3luY1RyZWUsIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgc2tpcFNldHVwTGlzdGVuZXIgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgbGV0IHNlcnZlckNhY2hlID0gbnVsbDtcclxuICAgIGxldCBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPSBmYWxzZTtcclxuICAgIC8vIEFueSBjb3ZlcmluZyB3cml0ZXMgd2lsbCBuZWNlc3NhcmlseSBiZSBhdCB0aGUgcm9vdCwgc28gcmVhbGx5IGFsbCB3ZSBuZWVkIHRvIGZpbmQgaXMgdGhlIHNlcnZlciBjYWNoZS5cclxuICAgIC8vIENvbnNpZGVyIG9wdGltaXppbmcgdGhpcyBvbmNlIHRoZXJlJ3MgYSBiZXR0ZXIgdW5kZXJzdGFuZGluZyBvZiB3aGF0IGFjdHVhbCBiZWhhdmlvciB3aWxsIGJlLlxyXG4gICAgc3luY1RyZWUuc3luY1BvaW50VHJlZV8uZm9yZWFjaE9uUGF0aChwYXRoLCAocGF0aFRvU3luY1BvaW50LCBzcCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoVG9TeW5jUG9pbnQsIHBhdGgpO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID1cclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgfHwgc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzcCwgcmVsYXRpdmVQYXRoKTtcclxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxyXG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHNwKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChwYXRoKTtcclxuICAgIGlmICghc3luY1BvaW50KSB7XHJcbiAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludCgpO1xyXG4gICAgICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfID0gc3luY1RyZWUuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxyXG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgfHwgc3luY1BvaW50SGFzQ29tcGxldGVWaWV3KHN5bmNQb2ludCk7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgbGV0IHNlcnZlckNhY2hlQ29tcGxldGU7XHJcbiAgICBpZiAoc2VydmVyQ2FjaGUgIT0gbnVsbCkge1xyXG4gICAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHNlcnZlckNhY2hlID0gQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAgICAgc3VidHJlZS5mb3JlYWNoQ2hpbGQoKGNoaWxkTmFtZSwgY2hpbGRTeW5jUG9pbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoY2hpbGRTeW5jUG9pbnQsIG5ld0VtcHR5UGF0aCgpKTtcclxuICAgICAgICAgICAgaWYgKGNvbXBsZXRlQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjb21wbGV0ZUNhY2hlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgdmlld0FscmVhZHlFeGlzdHMgPSBzeW5jUG9pbnRWaWV3RXhpc3RzRm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICBpZiAoIXZpZXdBbHJlYWR5RXhpc3RzICYmICFxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHRyYWNrIGEgdGFnIGZvciB0aGlzIHF1ZXJ5XHJcbiAgICAgICAgY29uc3QgcXVlcnlLZXkgPSBzeW5jVHJlZU1ha2VRdWVyeUtleV8ocXVlcnkpO1xyXG4gICAgICAgIGFzc2VydCghc3luY1RyZWUucXVlcnlUb1RhZ01hcC5oYXMocXVlcnlLZXkpLCAnVmlldyBkb2VzIG5vdCBleGlzdCwgYnV0IHdlIGhhdmUgYSB0YWcnKTtcclxuICAgICAgICBjb25zdCB0YWcgPSBzeW5jVHJlZUdldE5leHRRdWVyeVRhZ18oKTtcclxuICAgICAgICBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLnNldChxdWVyeUtleSwgdGFnKTtcclxuICAgICAgICBzeW5jVHJlZS50YWdUb1F1ZXJ5TWFwLnNldCh0YWcsIHF1ZXJ5S2V5KTtcclxuICAgIH1cclxuICAgIGNvbnN0IHdyaXRlc0NhY2hlID0gd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIHBhdGgpO1xyXG4gICAgbGV0IGV2ZW50cyA9IHN5bmNQb2ludEFkZEV2ZW50UmVnaXN0cmF0aW9uKHN5bmNQb2ludCwgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpO1xyXG4gICAgaWYgKCF2aWV3QWxyZWFkeUV4aXN0cyAmJiAhZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3ICYmICFza2lwU2V0dXBMaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHZpZXcgPSBzeW5jUG9pbnRWaWV3Rm9yUXVlcnkoc3luY1BvaW50LCBxdWVyeSk7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50cztcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIGNvbXBsZXRlIGNhY2hlLCBpZiB3ZSBoYXZlIG9uZSwgb2YgdGhlIGRhdGEgYXQgYSBwYXJ0aWN1bGFyIHBhdGguIElmIHRoZSBsb2NhdGlvbiBkb2VzIG5vdCBoYXZlIGFcclxuICogbGlzdGVuZXIgYWJvdmUgaXQsIHdlIHdpbGwgZ2V0IGEgZmFsc2UgXCJudWxsXCIuIFRoaXMgc2hvdWxkbid0IGJlIGEgcHJvYmxlbSBiZWNhdXNlIHRyYW5zYWN0aW9ucyB3aWxsIGFsd2F5c1xyXG4gKiBoYXZlIGEgbGlzdGVuZXIgYWJvdmUsIGFuZCBhdG9taWMgb3BlcmF0aW9ucyB3b3VsZCBjb3JyZWN0bHkgc2hvdyBhIGppdHRlciBvZiA8aW5jcmVtZW50IHZhbHVlPiAtPlxyXG4gKiAgICAgPGluY3JlbWVudGVkIHRvdGFsPiBhcyB0aGUgd3JpdGUgaXMgYXBwbGllZCBsb2NhbGx5IGFuZCB0aGVuIGFja25vd2xlZGdlZCBhdCB0aGUgc2VydmVyLlxyXG4gKlxyXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsICppbmNsdWRlKiBoaWRkZW4gd3JpdGVzIGZyb20gdHJhbnNhY3Rpb24gd2l0aCBhcHBseUxvY2FsbHkgc2V0IHRvIGZhbHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBkYXRhIHdlIHdhbnRcclxuICogQHBhcmFtIHdyaXRlSWRzVG9FeGNsdWRlIC0gQSBzcGVjaWZpYyBzZXQgdG8gYmUgZXhjbHVkZWRcclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShzeW5jVHJlZSwgcGF0aCwgd3JpdGVJZHNUb0V4Y2x1ZGUpIHtcclxuICAgIGNvbnN0IGluY2x1ZGVIaWRkZW5TZXRzID0gdHJ1ZTtcclxuICAgIGNvbnN0IHdyaXRlVHJlZSA9IHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfO1xyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGUgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5maW5kT25QYXRoKHBhdGgsIChwYXRoU29GYXIsIHN5bmNQb2ludCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IG5ld1JlbGF0aXZlUGF0aChwYXRoU29GYXIsIHBhdGgpO1xyXG4gICAgICAgIGNvbnN0IHNlcnZlckNhY2hlID0gc3luY1BvaW50R2V0Q29tcGxldGVTZXJ2ZXJDYWNoZShzeW5jUG9pbnQsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJDYWNoZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB3cml0ZVRyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHdyaXRlVHJlZSwgcGF0aCwgc2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuU2V0cyk7XHJcbn1cclxuZnVuY3Rpb24gc3luY1RyZWVHZXRTZXJ2ZXJWYWx1ZShzeW5jVHJlZSwgcXVlcnkpIHtcclxuICAgIGNvbnN0IHBhdGggPSBxdWVyeS5fcGF0aDtcclxuICAgIGxldCBzZXJ2ZXJDYWNoZSA9IG51bGw7XHJcbiAgICAvLyBBbnkgY292ZXJpbmcgd3JpdGVzIHdpbGwgbmVjZXNzYXJpbHkgYmUgYXQgdGhlIHJvb3QsIHNvIHJlYWxseSBhbGwgd2UgbmVlZCB0byBmaW5kIGlzIHRoZSBzZXJ2ZXIgY2FjaGUuXHJcbiAgICAvLyBDb25zaWRlciBvcHRpbWl6aW5nIHRoaXMgb25jZSB0aGVyZSdzIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhY3R1YWwgYmVoYXZpb3Igd2lsbCBiZS5cclxuICAgIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmZvcmVhY2hPblBhdGgocGF0aCwgKHBhdGhUb1N5bmNQb2ludCwgc3ApID0+IHtcclxuICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBuZXdSZWxhdGl2ZVBhdGgocGF0aFRvU3luY1BvaW50LCBwYXRoKTtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9XHJcbiAgICAgICAgICAgIHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3AsIHJlbGF0aXZlUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIGxldCBzeW5jUG9pbnQgPSBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXy5nZXQocGF0aCk7XHJcbiAgICBpZiAoIXN5bmNQb2ludCkge1xyXG4gICAgICAgIHN5bmNQb2ludCA9IG5ldyBTeW5jUG9pbnQoKTtcclxuICAgICAgICBzeW5jVHJlZS5zeW5jUG9pbnRUcmVlXyA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnNldChwYXRoLCBzeW5jUG9pbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2VydmVyQ2FjaGUgPVxyXG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSB8fCBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IHNlcnZlckNhY2hlICE9IG51bGw7XHJcbiAgICBjb25zdCBzZXJ2ZXJDYWNoZU5vZGUgPSBzZXJ2ZXJDYWNoZUNvbXBsZXRlXHJcbiAgICAgICAgPyBuZXcgQ2FjaGVOb2RlKHNlcnZlckNhY2hlLCB0cnVlLCBmYWxzZSlcclxuICAgICAgICA6IG51bGw7XHJcbiAgICBjb25zdCB3cml0ZXNDYWNoZSA9IHdyaXRlVHJlZUNoaWxkV3JpdGVzKHN5bmNUcmVlLnBlbmRpbmdXcml0ZVRyZWVfLCBxdWVyeS5fcGF0aCk7XHJcbiAgICBjb25zdCB2aWV3ID0gc3luY1BvaW50R2V0VmlldyhzeW5jUG9pbnQsIHF1ZXJ5LCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlTm9kZS5nZXROb2RlKCkgOiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XHJcbiAgICByZXR1cm4gdmlld0dldENvbXBsZXRlTm9kZSh2aWV3KTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRoYXQgdmlzaXRzIGFsbCBkZXNjZW5kYW50IGFuZCBhbmNlc3RvciBTeW5jUG9pbnRzLCBhcHBseWluZyB0aGUgb3BlcmF0aW9uLlxyXG4gKlxyXG4gKiBOT1RFUzpcclxuICogLSBEZXNjZW5kYW50IFN5bmNQb2ludHMgd2lsbCBiZSB2aXNpdGVkIGZpcnN0IChzaW5jZSB3ZSByYWlzZSBldmVudHMgZGVwdGgtZmlyc3QpLlxyXG4gKlxyXG4gKiAtIFdlIGNhbGwgYXBwbHlPcGVyYXRpb24oKSBvbiBlYWNoIFN5bmNQb2ludCBwYXNzaW5nIHRocmVlIHRoaW5nczpcclxuICogICAxLiBBIHZlcnNpb24gb2YgdGhlIE9wZXJhdGlvbiB0aGF0IGhhcyBiZWVuIG1hZGUgcmVsYXRpdmUgdG8gdGhlIFN5bmNQb2ludCBsb2NhdGlvbi5cclxuICogICAyLiBBIFdyaXRlVHJlZVJlZiBvZiBhbnkgd3JpdGVzIHdlIGhhdmUgY2FjaGVkIGF0IHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXHJcbiAqICAgMy4gQSBzbmFwc2hvdCBOb2RlIHdpdGggY2FjaGVkIHNlcnZlciBkYXRhLCBpZiB3ZSBoYXZlIGl0LlxyXG4gKlxyXG4gKiAtIFdlIGNvbmNhdGVuYXRlIGFsbCBvZiB0aGUgZXZlbnRzIHJldHVybmVkIGJ5IGVhY2ggU3luY1BvaW50IGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKHN5bmNUcmVlLCBvcGVyYXRpb24pIHtcclxuICAgIHJldHVybiBzeW5jVHJlZUFwcGx5T3BlcmF0aW9uSGVscGVyXyhvcGVyYXRpb24sIHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLCBcclxuICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCwgd3JpdGVUcmVlQ2hpbGRXcml0ZXMoc3luY1RyZWUucGVuZGluZ1dyaXRlVHJlZV8sIG5ld0VtcHR5UGF0aCgpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZSBoZWxwZXIgZm9yIGFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzX1xyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGlmIChwYXRoSXNFbXB0eShvcGVyYXRpb24ucGF0aCkpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBjb25zdCBzeW5jUG9pbnQgPSBzeW5jUG9pbnRUcmVlLmdldChuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBjYWNoZWQgc2VydmVyIGRhdGEsIHNlZSBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gdGhpcyBTeW5jUG9pbnQuXHJcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBzeW5jUG9pbnRHZXRDb21wbGV0ZVNlcnZlckNhY2hlKHN5bmNQb2ludCwgbmV3RW1wdHlQYXRoKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAgICAgY29uc3QgY2hpbGROYW1lID0gcGF0aEdldEZyb250KG9wZXJhdGlvbi5wYXRoKTtcclxuICAgICAgICBjb25zdCBjaGlsZE9wZXJhdGlvbiA9IG9wZXJhdGlvbi5vcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkVHJlZSA9IHN5bmNQb2ludFRyZWUuY2hpbGRyZW4uZ2V0KGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkVHJlZSAmJiBjaGlsZE9wZXJhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGVcclxuICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVUcmVlUmVmQ2hpbGQod3JpdGVzQ2FjaGUsIGNoaWxkTmFtZSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkhlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1BvaW50QXBwbHlPcGVyYXRpb24oc3luY1BvaW50LCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRzO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlQXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KG5ld0VtcHR5UGF0aCgpKTtcclxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxyXG4gICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcclxuICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludEdldENvbXBsZXRlU2VydmVyQ2FjaGUoc3luY1BvaW50LCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICB9XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBzeW5jUG9pbnRUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoKGNoaWxkTmFtZSwgY2hpbGRUcmVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRTZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlXHJcbiAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICAgICAgY29uc3QgY2hpbGRXcml0ZXNDYWNoZSA9IHdyaXRlVHJlZVJlZkNoaWxkKHdyaXRlc0NhY2hlLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIGNvbnN0IGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XHJcbiAgICAgICAgaWYgKGNoaWxkT3BlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoc3luY1BvaW50KSB7XHJcbiAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlQ3JlYXRlTGlzdGVuZXJGb3JWaWV3XyhzeW5jVHJlZSwgdmlldykge1xyXG4gICAgY29uc3QgcXVlcnkgPSB2aWV3LnF1ZXJ5O1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoYXNoRm46ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSB2aWV3R2V0U2VydmVyQ2FjaGUodmlldykgfHwgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5oYXNoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkNvbXBsZXRlOiAoc3RhdHVzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3luY1RyZWVBcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHN5bmNUcmVlLCBxdWVyeS5fcGF0aCwgdGFnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZUFwcGx5TGlzdGVuQ29tcGxldGUoc3luY1RyZWUsIHF1ZXJ5Ll9wYXRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGEgbGlzdGVuIGZhaWxlZCwga2lsbCBhbGwgb2YgdGhlIGxpc3RlbmVycyBoZXJlLCBub3QganVzdCB0aGUgb25lIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBuZWVkIHRvIGJlIHNjb3BlZCB0byBqdXN0IHRoaXMgbGlzdGVuZXIgaWYgd2UgY2hhbmdlIHBlcm1pc3Npb25zIG9uIGZpbHRlcmVkIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yRm9yU2VydmVyQ29kZShzdGF0dXMsIHF1ZXJ5KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHN5bmNUcmVlLCBxdWVyeSwgXHJcbiAgICAgICAgICAgICAgICAvKmV2ZW50UmVnaXN0cmF0aW9uKi8gbnVsbCwgZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJuIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBxdWVyeS5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlVGFnRm9yUXVlcnkoc3luY1RyZWUsIHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBxdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XHJcbiAgICByZXR1cm4gc3luY1RyZWUucXVlcnlUb1RhZ01hcC5nZXQocXVlcnlLZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBHaXZlbiBhIHF1ZXJ5LCBjb21wdXRlcyBhIFwicXVlcnlLZXlcIiBzdWl0YWJsZSBmb3IgdXNlIGluIG91ciBxdWVyeVRvVGFnTWFwXy5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhxdWVyeSkge1xyXG4gICAgcmV0dXJuIHF1ZXJ5Ll9wYXRoLnRvU3RyaW5nKCkgKyAnJCcgKyBxdWVyeS5fcXVlcnlJZGVudGlmaWVyO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIHF1ZXJ5IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGFnLCBpZiB3ZSBoYXZlIG9uZVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVRdWVyeUtleUZvclRhZ18oc3luY1RyZWUsIHRhZykge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlLnRhZ1RvUXVlcnlNYXAuZ2V0KHRhZyk7XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgcXVlcnlLZXkgKGNyZWF0ZWQgYnkgbWFrZVF1ZXJ5S2V5KSwgcGFyc2UgaXQgYmFjayBpbnRvIGEgcGF0aCBhbmQgcXVlcnlJZC5cclxuICovXHJcbmZ1bmN0aW9uIHN5bmNUcmVlUGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpIHtcclxuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBxdWVyeUtleS5pbmRleE9mKCckJyk7XHJcbiAgICBhc3NlcnQoc3BsaXRJbmRleCAhPT0gLTEgJiYgc3BsaXRJbmRleCA8IHF1ZXJ5S2V5Lmxlbmd0aCAtIDEsICdCYWQgcXVlcnlLZXkuJyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHF1ZXJ5SWQ6IHF1ZXJ5S2V5LnN1YnN0cihzcGxpdEluZGV4ICsgMSksXHJcbiAgICAgICAgcGF0aDogbmV3IFBhdGgocXVlcnlLZXkuc3Vic3RyKDAsIHNwbGl0SW5kZXgpKVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQSBoZWxwZXIgbWV0aG9kIHRvIGFwcGx5IHRhZ2dlZCBvcGVyYXRpb25zXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZUFwcGx5VGFnZ2VkT3BlcmF0aW9uXyhzeW5jVHJlZSwgcXVlcnlQYXRoLCBvcGVyYXRpb24pIHtcclxuICAgIGNvbnN0IHN5bmNQb2ludCA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLmdldChxdWVyeVBhdGgpO1xyXG4gICAgYXNzZXJ0KHN5bmNQb2ludCwgXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO1xyXG4gICAgY29uc3Qgd3JpdGVzQ2FjaGUgPSB3cml0ZVRyZWVDaGlsZFdyaXRlcyhzeW5jVHJlZS5wZW5kaW5nV3JpdGVUcmVlXywgcXVlcnlQYXRoKTtcclxuICAgIHJldHVybiBzeW5jUG9pbnRBcHBseU9wZXJhdGlvbihzeW5jUG9pbnQsIG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG51bGwpO1xyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNvbGxhcHNlcyBtdWx0aXBsZSB1bmZpbHRlcmVkIHZpZXdzIGludG8gYSBzaW5nbGUgdmlldywgc2luY2Ugd2Ugb25seSBuZWVkIGEgc2luZ2xlXHJcbiAqIGxpc3RlbmVyIGZvciB0aGVtLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVDb2xsZWN0RGlzdGluY3RWaWV3c0ZvclN1YlRyZWVfKHN1YnRyZWUpIHtcclxuICAgIHJldHVybiBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICBpZiAobWF5YmVDaGlsZFN5bmNQb2ludCAmJiBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29tcGxldGVWaWV3ID0gc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gW2NvbXBsZXRlVmlld107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBObyBjb21wbGV0ZSB2aWV3IGhlcmUsIGZsYXR0ZW4gYW55IGRlZXBlciBsaXN0ZW5zIGludG8gYW4gYXJyYXlcclxuICAgICAgICAgICAgbGV0IHZpZXdzID0gW107XHJcbiAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3cyA9IHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkVmlld3MpID0+IHtcclxuICAgICAgICAgICAgICAgIHZpZXdzID0gdmlld3MuY29uY2F0KGNoaWxkVmlld3MpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHZpZXdzO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemVzIGEgcXVlcnkgdG8gYSBxdWVyeSB3ZSBzZW5kIHRoZSBzZXJ2ZXIgZm9yIGxpc3RlbmluZ1xyXG4gKlxyXG4gKiBAcmV0dXJucyBUaGUgbm9ybWFsaXplZCBxdWVyeVxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVRdWVyeUZvckxpc3RlbmluZ18ocXVlcnkpIHtcclxuICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMubG9hZHNBbGxEYXRhKCkgJiYgIXF1ZXJ5Ll9xdWVyeVBhcmFtcy5pc0RlZmF1bHQoKSkge1xyXG4gICAgICAgIC8vIFdlIHRyZWF0IHF1ZXJpZXMgdGhhdCBsb2FkIGFsbCBkYXRhIGFzIGRlZmF1bHQgcXVlcmllc1xyXG4gICAgICAgIC8vIENhc3QgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgcmVmKCkgdGVjaG5pY2FsbHkgcmV0dXJucyBGaXJlYmFzZSB3aGljaCBpcyBhY3R1YWxseSBmYi5hcGkuRmlyZWJhc2Ugd2hpY2ggaW5oZXJpdHNcclxuICAgICAgICAvLyBmcm9tIFF1ZXJ5XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoc3luY1RyZWVHZXRSZWZlcmVuY2VDb25zdHJ1Y3RvcigpKShxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHN5bmNUcmVlUmVtb3ZlVGFnc18oc3luY1RyZWUsIHF1ZXJpZXMpIHtcclxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcXVlcmllcy5sZW5ndGg7ICsraikge1xyXG4gICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeSA9IHF1ZXJpZXNbal07XHJcbiAgICAgICAgaWYgKCFyZW1vdmVkUXVlcnkuX3F1ZXJ5UGFyYW1zLmxvYWRzQWxsRGF0YSgpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGEgdGFnIGZvciB0aGlzXHJcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRRdWVyeUtleSA9IHN5bmNUcmVlTWFrZVF1ZXJ5S2V5XyhyZW1vdmVkUXVlcnkpO1xyXG4gICAgICAgICAgICBjb25zdCByZW1vdmVkUXVlcnlUYWcgPSBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmdldChyZW1vdmVkUXVlcnlLZXkpO1xyXG4gICAgICAgICAgICBzeW5jVHJlZS5xdWVyeVRvVGFnTWFwLmRlbGV0ZShyZW1vdmVkUXVlcnlLZXkpO1xyXG4gICAgICAgICAgICBzeW5jVHJlZS50YWdUb1F1ZXJ5TWFwLmRlbGV0ZShyZW1vdmVkUXVlcnlUYWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3RhdGljIGFjY2Vzc29yIGZvciBxdWVyeSB0YWdzLlxyXG4gKi9cclxuZnVuY3Rpb24gc3luY1RyZWVHZXROZXh0UXVlcnlUYWdfKCkge1xyXG4gICAgcmV0dXJuIHN5bmNUcmVlTmV4dFF1ZXJ5VGFnXysrO1xyXG59XHJcbi8qKlxyXG4gKiBGb3IgYSBnaXZlbiBuZXcgbGlzdGVuLCBtYW5hZ2UgdGhlIGRlLWR1cGxpY2F0aW9uIG9mIG91dHN0YW5kaW5nIHN1YnNjcmlwdGlvbnMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoaXMgbWV0aG9kIGNhbiByZXR1cm4gZXZlbnRzIHRvIHN1cHBvcnQgc3luY2hyb25vdXMgZGF0YSBzb3VyY2VzXHJcbiAqL1xyXG5mdW5jdGlvbiBzeW5jVHJlZVNldHVwTGlzdGVuZXJfKHN5bmNUcmVlLCBxdWVyeSwgdmlldykge1xyXG4gICAgY29uc3QgcGF0aCA9IHF1ZXJ5Ll9wYXRoO1xyXG4gICAgY29uc3QgdGFnID0gc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnkpO1xyXG4gICAgY29uc3QgbGlzdGVuZXIgPSBzeW5jVHJlZUNyZWF0ZUxpc3RlbmVyRm9yVmlld18oc3luY1RyZWUsIHZpZXcpO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWUubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgdGFnLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xyXG4gICAgY29uc3Qgc3VidHJlZSA9IHN5bmNUcmVlLnN5bmNQb2ludFRyZWVfLnN1YnRyZWUocGF0aCk7XHJcbiAgICAvLyBUaGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUgaGFzIG91ciBxdWVyeS4gV2UncmUgaGVyZSBiZWNhdXNlIHdlIGRlZmluaXRlbHkgbmVlZCB0byBzZW5kIGEgbGlzdGVuIGZvciB0aGF0LCBidXQgd2VcclxuICAgIC8vIG1heSBuZWVkIHRvIHNoYWRvdyBvdGhlciBsaXN0ZW5zIGFzIHdlbGwuXHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgYXNzZXJ0KCFzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcoc3VidHJlZS52YWx1ZSksIFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNoYWRvdyBldmVyeXRoaW5nIGF0IG9yIGJlbG93IHRoaXMgbG9jYXRpb24sIHRoaXMgaXMgYSBkZWZhdWx0IGxpc3RlbmVyLlxyXG4gICAgICAgIGNvbnN0IHF1ZXJpZXNUb1N0b3AgPSBzdWJ0cmVlLmZvbGQoKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApID0+IHtcclxuICAgICAgICAgICAgaWYgKCFwYXRoSXNFbXB0eShyZWxhdGl2ZVBhdGgpICYmXHJcbiAgICAgICAgICAgICAgICBtYXliZUNoaWxkU3luY1BvaW50ICYmXHJcbiAgICAgICAgICAgICAgICBzeW5jUG9pbnRIYXNDb21wbGV0ZVZpZXcobWF5YmVDaGlsZFN5bmNQb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbc3luY1BvaW50R2V0Q29tcGxldGVWaWV3KG1heWJlQ2hpbGRTeW5jUG9pbnQpLnF1ZXJ5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxyXG4gICAgICAgICAgICAgICAgbGV0IHF1ZXJpZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVlcmllcyA9IHF1ZXJpZXMuY29uY2F0KHN5bmNQb2ludEdldFF1ZXJ5Vmlld3MobWF5YmVDaGlsZFN5bmNQb2ludCkubWFwKHZpZXcgPT4gdmlldy5xdWVyeSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWFjaChjaGlsZE1hcCwgKF9rZXksIGNoaWxkUXVlcmllcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJpZXMgPSBxdWVyaWVzLmNvbmNhdChjaGlsZFF1ZXJpZXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcmllcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVlcmllc1RvU3RvcC5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBxdWVyeVRvU3RvcCA9IHF1ZXJpZXNUb1N0b3BbaV07XHJcbiAgICAgICAgICAgIHN5bmNUcmVlLmxpc3RlblByb3ZpZGVyXy5zdG9wTGlzdGVuaW5nKHN5bmNUcmVlUXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9TdG9wKSwgc3luY1RyZWVUYWdGb3JRdWVyeShzeW5jVHJlZSwgcXVlcnlUb1N0b3ApKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXZlbnRzO1xyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmNsYXNzIEV4aXN0aW5nVmFsdWVQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihub2RlXykge1xyXG4gICAgICAgIHRoaXMubm9kZV8gPSBub2RlXztcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5ub2RlXy5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRXhpc3RpbmdWYWx1ZVByb3ZpZGVyKGNoaWxkKTtcclxuICAgIH1cclxuICAgIG5vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV87XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN5bmNUcmVlLCBwYXRoKSB7XHJcbiAgICAgICAgdGhpcy5zeW5jVHJlZV8gPSBzeW5jVHJlZTtcclxuICAgICAgICB0aGlzLnBhdGhfID0gcGF0aDtcclxuICAgIH1cclxuICAgIGdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGhDaGlsZCh0aGlzLnBhdGhfLCBjaGlsZE5hbWUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyKHRoaXMuc3luY1RyZWVfLCBjaGlsZFBhdGgpO1xyXG4gICAgfVxyXG4gICAgbm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHRoaXMuc3luY1RyZWVfLCB0aGlzLnBhdGhfKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgcGxhY2Vob2xkZXJzIGZvciBkZWZlcnJlZCB2YWx1ZXMuXHJcbiAqL1xyXG5jb25zdCBnZW5lcmF0ZVdpdGhWYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XHJcbiAgICB2YWx1ZXMgPSB2YWx1ZXMgfHwge307XHJcbiAgICB2YWx1ZXNbJ3RpbWVzdGFtcCddID0gdmFsdWVzWyd0aW1lc3RhbXAnXSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbn07XHJcbi8qKlxyXG4gKiBWYWx1ZSB0byB1c2Ugd2hlbiBmaXJpbmcgbG9jYWwgZXZlbnRzLiBXaGVuIHdyaXRpbmcgc2VydmVyIHZhbHVlcywgZmlyZVxyXG4gKiBsb2NhbCBldmVudHMgd2l0aCBhbiBhcHByb3hpbWF0ZSB2YWx1ZSwgb3RoZXJ3aXNlIHJldHVybiB2YWx1ZSBhcy1pcy5cclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgZXhpc3RpbmdWYWwsIHNlcnZlclZhbHVlcykge1xyXG4gICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgYXNzZXJ0KCcuc3YnIGluIHZhbHVlLCAnVW5leHBlY3RlZCBsZWFmIG5vZGUgb3IgcHJpb3JpdHkgY29udGVudHMnKTtcclxuICAgIGlmICh0eXBlb2YgdmFsdWVbJy5zdiddID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSh2YWx1ZVsnLnN2J10sIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlWycuc3YnXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbXBsZXhEZWZlcnJlZFZhbHVlKHZhbHVlWycuc3YnXSwgZXhpc3RpbmdWYWwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMikpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXNvbHZlU2NhbGFyRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uIChvcCwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcykge1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZXNbJ3RpbWVzdGFtcCddO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgc2VydmVyIHZhbHVlOiAnICsgb3ApO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCByZXNvbHZlQ29tcGxleERlZmVycmVkVmFsdWUgPSBmdW5jdGlvbiAob3AsIGV4aXN0aW5nLCB1bnVzZWQpIHtcclxuICAgIGlmICghb3AuaGFzT3duUHJvcGVydHkoJ2luY3JlbWVudCcpKSB7XHJcbiAgICAgICAgYXNzZXJ0KGZhbHNlLCAnVW5leHBlY3RlZCBzZXJ2ZXIgdmFsdWU6ICcgKyBKU09OLnN0cmluZ2lmeShvcCwgbnVsbCwgMikpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGVsdGEgPSBvcFsnaW5jcmVtZW50J107XHJcbiAgICBpZiAodHlwZW9mIGRlbHRhICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGFzc2VydChmYWxzZSwgJ1VuZXhwZWN0ZWQgaW5jcmVtZW50IHZhbHVlOiAnICsgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXhpc3RpbmdOb2RlID0gZXhpc3Rpbmcubm9kZSgpO1xyXG4gICAgYXNzZXJ0KGV4aXN0aW5nTm9kZSAhPT0gbnVsbCAmJiB0eXBlb2YgZXhpc3RpbmdOb2RlICE9PSAndW5kZWZpbmVkJywgJ0V4cGVjdGVkIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFIGZvciBudWxscycpO1xyXG4gICAgLy8gSW5jcmVtZW50aW5nIGEgbm9uLW51bWJlciBzZXRzIHRoZSB2YWx1ZSB0byB0aGUgaW5jcmVtZW50ZWQgYW1vdW50XHJcbiAgICBpZiAoIWV4aXN0aW5nTm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICByZXR1cm4gZGVsdGE7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsZWFmID0gZXhpc3RpbmdOb2RlO1xyXG4gICAgY29uc3QgZXhpc3RpbmdWYWwgPSBsZWFmLmdldFZhbHVlKCk7XHJcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nVmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBkZWx0YTtcclxuICAgIH1cclxuICAgIC8vIE5vIG5lZWQgdG8gZG8gb3Zlci91bmRlcmZsb3cgYXJpdGhtZXRpYyBoZXJlIGJlY2F1c2UgSlMgb25seSBoYW5kbGVzIGZsb2F0cyB1bmRlciB0aGUgY292ZXJzXHJcbiAgICByZXR1cm4gZXhpc3RpbmdWYWwgKyBkZWx0YTtcclxufTtcclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgdHJlZSB3aXRoIHRoZVxyXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy5cclxuICogQHBhcmFtIHBhdGggLSBwYXRoIHRvIHdoaWNoIHdyaXRlIGlzIHJlbGF0aXZlXHJcbiAqIEBwYXJhbSBub2RlIC0gbmV3IGRhdGEgd3JpdHRlbiBhdCBwYXRoXHJcbiAqIEBwYXJhbSBzeW5jVHJlZSAtIGN1cnJlbnQgZGF0YVxyXG4gKi9cclxuY29uc3QgcmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlID0gZnVuY3Rpb24gKHBhdGgsIG5vZGUsIHN5bmNUcmVlLCBzZXJ2ZXJWYWx1ZXMpIHtcclxuICAgIHJldHVybiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBuZXcgRGVmZXJyZWRWYWx1ZVByb3ZpZGVyKHN5bmNUcmVlLCBwYXRoKSwgc2VydmVyVmFsdWVzKTtcclxufTtcclxuLyoqXHJcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgbm9kZSB3aXRoIHRoZVxyXG4gKiBzcGVjaWZpZWQgZ2VuZXJhdGVkIHJlcGxhY2VtZW50IHZhbHVlcy4gIElmIHRoZXJlIGFyZSBubyBzZXJ2ZXIgdmFsdWVzIGluIHRoZSBub2RlLFxyXG4gKiBpdCdsbCBiZSByZXR1cm5lZCBhcy1pcy5cclxuICovXHJcbmNvbnN0IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QgPSBmdW5jdGlvbiAobm9kZSwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcykge1xyXG4gICAgcmV0dXJuIHJlc29sdmVEZWZlcnJlZFZhbHVlKG5vZGUsIG5ldyBFeGlzdGluZ1ZhbHVlUHJvdmlkZXIoZXhpc3RpbmcpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG59O1xyXG5mdW5jdGlvbiByZXNvbHZlRGVmZXJyZWRWYWx1ZShub2RlLCBleGlzdGluZ1ZhbCwgc2VydmVyVmFsdWVzKSB7XHJcbiAgICBjb25zdCByYXdQcmkgPSBub2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICBjb25zdCBwcmlvcml0eSA9IHJlc29sdmVEZWZlcnJlZExlYWZWYWx1ZShyYXdQcmksIGV4aXN0aW5nVmFsLmdldEltbWVkaWF0ZUNoaWxkKCcucHJpb3JpdHknKSwgc2VydmVyVmFsdWVzKTtcclxuICAgIGxldCBuZXdOb2RlO1xyXG4gICAgaWYgKG5vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgY29uc3QgbGVhZk5vZGUgPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZURlZmVycmVkTGVhZlZhbHVlKGxlYWZOb2RlLmdldFZhbHVlKCksIGV4aXN0aW5nVmFsLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbGVhZk5vZGUuZ2V0VmFsdWUoKSB8fFxyXG4gICAgICAgICAgICBwcmlvcml0eSAhPT0gbGVhZk5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlKHZhbHVlLCBub2RlRnJvbUpTT04ocHJpb3JpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgbmV3Tm9kZSA9IGNoaWxkcmVuTm9kZTtcclxuICAgICAgICBpZiAocHJpb3JpdHkgIT09IGNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XHJcbiAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZVByaW9yaXR5KG5ldyBMZWFmTm9kZShwcmlvcml0eSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKFBSSU9SSVRZX0lOREVYLCAoY2hpbGROYW1lLCBjaGlsZE5vZGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGROb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWUoY2hpbGROb2RlLCBleGlzdGluZ1ZhbC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUpLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgICAgICBpZiAobmV3Q2hpbGROb2RlICE9PSBjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBuZXdOb2RlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXdOb2RlO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBBIGxpZ2h0LXdlaWdodCB0cmVlLCB0cmF2ZXJzYWJsZSBieSBwYXRoLiAgTm9kZXMgY2FuIGhhdmUgYm90aCB2YWx1ZXMgYW5kIGNoaWxkcmVuLlxyXG4gKiBOb2RlcyBhcmUgbm90IGVudW1lcmF0ZWQgKGJ5IGZvckVhY2hDaGlsZCkgdW5sZXNzIHRoZXkgaGF2ZSBhIHZhbHVlIG9yIG5vbi1lbXB0eVxyXG4gKiBjaGlsZHJlbi5cclxuICovXHJcbmNsYXNzIFRyZWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbmFtZSAtIE9wdGlvbmFsIG5hbWUgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gcGFyZW50IC0gT3B0aW9uYWwgcGFyZW50IG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSAtIE9wdGlvbmFsIG5vZGUgdG8gd3JhcC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSA9ICcnLCBwYXJlbnQgPSBudWxsLCBub2RlID0geyBjaGlsZHJlbjoge30sIGNoaWxkQ291bnQ6IDAgfSkge1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHN1Yi1UcmVlIGZvciB0aGUgZ2l2ZW4gcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBhdGhPYmogLSBQYXRoIHRvIGxvb2sgdXAuXHJcbiAqIEByZXR1cm5zIFRyZWUgZm9yIHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlU3ViVHJlZSh0cmVlLCBwYXRoT2JqKSB7XHJcbiAgICAvLyBUT0RPOiBSZXF1aXJlIHBhdGhPYmogdG8gYmUgUGF0aD9cclxuICAgIGxldCBwYXRoID0gcGF0aE9iaiBpbnN0YW5jZW9mIFBhdGggPyBwYXRoT2JqIDogbmV3IFBhdGgocGF0aE9iaik7XHJcbiAgICBsZXQgY2hpbGQgPSB0cmVlLCBuZXh0ID0gcGF0aEdldEZyb250KHBhdGgpO1xyXG4gICAgd2hpbGUgKG5leHQgIT09IG51bGwpIHtcclxuICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSBzYWZlR2V0KGNoaWxkLm5vZGUuY2hpbGRyZW4sIG5leHQpIHx8IHtcclxuICAgICAgICAgICAgY2hpbGRyZW46IHt9LFxyXG4gICAgICAgICAgICBjaGlsZENvdW50OiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjaGlsZCA9IG5ldyBUcmVlKG5leHQsIGNoaWxkLCBjaGlsZE5vZGUpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgbmV4dCA9IHBhdGhHZXRGcm9udChwYXRoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0cmVlIG5vZGUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBkYXRhIG9yIG51bGwgaWYgbm8gZGF0YSBleGlzdHMuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlR2V0VmFsdWUodHJlZSkge1xyXG4gICAgcmV0dXJuIHRyZWUubm9kZS52YWx1ZTtcclxufVxyXG4vKipcclxuICogU2V0cyBkYXRhIHRvIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlU2V0VmFsdWUodHJlZSwgdmFsdWUpIHtcclxuICAgIHRyZWUubm9kZS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRyZWUgaGFzIGFueSBjaGlsZHJlbi5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVIYXNDaGlsZHJlbih0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZS5ub2RlLmNoaWxkQ291bnQgPiAwO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBXaGV0aGUgcnRoZSB0cmVlIGlzIGVtcHR5IChubyB2YWx1ZSBvciBjaGlsZHJlbikuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlSXNFbXB0eSh0cmVlKSB7XHJcbiAgICByZXR1cm4gdHJlZUdldFZhbHVlKHRyZWUpID09PSB1bmRlZmluZWQgJiYgIXRyZWVIYXNDaGlsZHJlbih0cmVlKTtcclxufVxyXG4vKipcclxuICogQ2FsbHMgYWN0aW9uIGZvciBlYWNoIGNoaWxkIG9mIHRoaXMgdHJlZSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoQ2hpbGQodHJlZSwgYWN0aW9uKSB7XHJcbiAgICBlYWNoKHRyZWUubm9kZS5jaGlsZHJlbiwgKGNoaWxkLCBjaGlsZFRyZWUpID0+IHtcclxuICAgICAgICBhY3Rpb24obmV3IFRyZWUoY2hpbGQsIHRyZWUsIGNoaWxkVHJlZSkpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBub2RlJ3MgZGVzY2VuZGFudHMsIGNhbGxpbmcgYWN0aW9uIGZvciBlYWNoIG9uZS5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiAtIEFjdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggY2hpbGQuXHJcbiAqIEBwYXJhbSBpbmNsdWRlU2VsZiAtIFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gdGhpcyBub2RlIGFzIHdlbGwuIERlZmF1bHRzIHRvXHJcbiAqICAgZmFsc2UuXHJcbiAqIEBwYXJhbSBjaGlsZHJlbkZpcnN0IC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiBjaGlsZHJlbiBiZWZvcmUgY2FsbGluZyBpdCBvblxyXG4gKiAgIHBhcmVudC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVGb3JFYWNoRGVzY2VuZGFudCh0cmVlLCBhY3Rpb24sIGluY2x1ZGVTZWxmLCBjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICBpZiAoaW5jbHVkZVNlbGYgJiYgIWNoaWxkcmVuRmlyc3QpIHtcclxuICAgICAgICBhY3Rpb24odHJlZSk7XHJcbiAgICB9XHJcbiAgICB0cmVlRm9yRWFjaENoaWxkKHRyZWUsIGNoaWxkID0+IHtcclxuICAgICAgICB0cmVlRm9yRWFjaERlc2NlbmRhbnQoY2hpbGQsIGFjdGlvbiwgdHJ1ZSwgY2hpbGRyZW5GaXJzdCk7XHJcbiAgICB9KTtcclxuICAgIGlmIChpbmNsdWRlU2VsZiAmJiBjaGlsZHJlbkZpcnN0KSB7XHJcbiAgICAgICAgYWN0aW9uKHRyZWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYWxscyBhY3Rpb24gb24gZWFjaCBhbmNlc3RvciBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYWN0aW9uIC0gQWN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoIHBhcmVudDsgcmV0dXJuXHJcbiAqICAgdHJ1ZSB0byBhYm9ydC5cclxuICogQHBhcmFtIGluY2x1ZGVTZWxmIC0gV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC5cclxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgYWN0aW9uIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXHJcbiAqL1xyXG5mdW5jdGlvbiB0cmVlRm9yRWFjaEFuY2VzdG9yKHRyZWUsIGFjdGlvbiwgaW5jbHVkZVNlbGYpIHtcclxuICAgIGxldCBub2RlID0gaW5jbHVkZVNlbGYgPyB0cmVlIDogdHJlZS5wYXJlbnQ7XHJcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChhY3Rpb24obm9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgVGhlIHBhdGggb2YgdGhpcyB0cmVlIG5vZGUsIGFzIGEgUGF0aC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVHZXRQYXRoKHRyZWUpIHtcclxuICAgIHJldHVybiBuZXcgUGF0aCh0cmVlLnBhcmVudCA9PT0gbnVsbFxyXG4gICAgICAgID8gdHJlZS5uYW1lXHJcbiAgICAgICAgOiB0cmVlR2V0UGF0aCh0cmVlLnBhcmVudCkgKyAnLycgKyB0cmVlLm5hbWUpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIG9yIHJlbW92ZXMgdGhpcyBjaGlsZCBmcm9tIGl0cyBwYXJlbnQgYmFzZWQgb24gd2hldGhlciBpdCdzIGVtcHR5IG9yIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVVcGRhdGVQYXJlbnRzKHRyZWUpIHtcclxuICAgIGlmICh0cmVlLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRyZWVVcGRhdGVDaGlsZCh0cmVlLnBhcmVudCwgdHJlZS5uYW1lLCB0cmVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRkcyBvciByZW1vdmVzIHRoZSBwYXNzZWQgY2hpbGQgdG8gdGhpcyB0cmVlIG5vZGUsIGRlcGVuZGluZyBvbiB3aGV0aGVyIGl0J3MgZW1wdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGlsZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2hpbGQgdG8gdXBkYXRlLlxyXG4gKiBAcGFyYW0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gdXBkYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJlZVVwZGF0ZUNoaWxkKHRyZWUsIGNoaWxkTmFtZSwgY2hpbGQpIHtcclxuICAgIGNvbnN0IGNoaWxkRW1wdHkgPSB0cmVlSXNFbXB0eShjaGlsZCk7XHJcbiAgICBjb25zdCBjaGlsZEV4aXN0cyA9IGNvbnRhaW5zKHRyZWUubm9kZS5jaGlsZHJlbiwgY2hpbGROYW1lKTtcclxuICAgIGlmIChjaGlsZEVtcHR5ICYmIGNoaWxkRXhpc3RzKSB7XHJcbiAgICAgICAgZGVsZXRlIHRyZWUubm9kZS5jaGlsZHJlbltjaGlsZE5hbWVdO1xyXG4gICAgICAgIHRyZWUubm9kZS5jaGlsZENvdW50LS07XHJcbiAgICAgICAgdHJlZVVwZGF0ZVBhcmVudHModHJlZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghY2hpbGRFbXB0eSAmJiAhY2hpbGRFeGlzdHMpIHtcclxuICAgICAgICB0cmVlLm5vZGUuY2hpbGRyZW5bY2hpbGROYW1lXSA9IGNoaWxkLm5vZGU7XHJcbiAgICAgICAgdHJlZS5ub2RlLmNoaWxkQ291bnQrKztcclxuICAgICAgICB0cmVlVXBkYXRlUGFyZW50cyh0cmVlKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBrZXlzXHJcbiAqL1xyXG5jb25zdCBJTlZBTElEX0tFWV9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcL1xcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcclxuLyoqXHJcbiAqIFRydWUgZm9yIGludmFsaWQgRmlyZWJhc2UgcGF0aHMuXHJcbiAqIEFsbG93cyAnLycgaW4gcGF0aHMuXHJcbiAqL1xyXG5jb25zdCBJTlZBTElEX1BBVEhfUkVHRVhfID0gL1tcXFtcXF0uIyRcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XHJcbi8qKlxyXG4gKiBNYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIGFsbG93IGluIGxlYWYgdmFsdWVcclxuICovXHJcbmNvbnN0IE1BWF9MRUFGX1NJWkVfID0gMTAgKiAxMDI0ICogMTAyNDtcclxuY29uc3QgaXNWYWxpZEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCAhPT0gMCAmJiAhSU5WQUxJRF9LRVlfUkVHRVhfLnRlc3Qoa2V5KSk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcclxuICAgIHJldHVybiAodHlwZW9mIHBhdGhTdHJpbmcgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgcGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiZcclxuICAgICAgICAhSU5WQUxJRF9QQVRIX1JFR0VYXy50ZXN0KHBhdGhTdHJpbmcpKTtcclxufTtcclxuY29uc3QgaXNWYWxpZFJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcclxuICAgIGlmIChwYXRoU3RyaW5nKSB7XHJcbiAgICAgICAgLy8gQWxsb3cgJy8uaW5mby8nIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNWYWxpZFBhdGhTdHJpbmcocGF0aFN0cmluZyk7XHJcbn07XHJcbmNvbnN0IGlzVmFsaWRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xyXG4gICAgcmV0dXJuIChwcmlvcml0eSA9PT0gbnVsbCB8fFxyXG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcclxuICAgICAgICAodHlwZW9mIHByaW9yaXR5ID09PSAnbnVtYmVyJyAmJiAhaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpIHx8XHJcbiAgICAgICAgKHByaW9yaXR5ICYmXHJcbiAgICAgICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgY29udGFpbnMocHJpb3JpdHksICcuc3YnKSkpO1xyXG59O1xyXG4vKipcclxuICogUHJlLXZhbGlkYXRlIGEgZGF0dW0gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIEZpcmViYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcgPSBmdW5jdGlvbiAoZm5OYW1lLCB2YWx1ZSwgcGF0aCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFsaWRhdGVGaXJlYmFzZURhdGEoZXJyb3JQcmVmaXgoZm5OYW1lLCAndmFsdWUnKSwgdmFsdWUsIHBhdGgpO1xyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGUgYSBkYXRhIG9iamVjdCBjbGllbnQtc2lkZSBiZWZvcmUgc2VuZGluZyB0byBzZXJ2ZXIuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlRGF0YSA9IGZ1bmN0aW9uIChlcnJvclByZWZpeCwgZGF0YSwgcGF0aF8pIHtcclxuICAgIGNvbnN0IHBhdGggPSBwYXRoXyBpbnN0YW5jZW9mIFBhdGggPyBuZXcgVmFsaWRhdGlvblBhdGgocGF0aF8sIGVycm9yUHJlZml4KSA6IHBhdGhfO1xyXG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArICdjb250YWlucyB1bmRlZmluZWQgJyArIHZhbGlkYXRpb25QYXRoVG9FcnJvclN0cmluZyhwYXRoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAnY29udGFpbnMgYSBmdW5jdGlvbiAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgJyB3aXRoIGNvbnRlbnRzID0gJyArXHJcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyAnICtcclxuICAgICAgICAgICAgZGF0YS50b1N0cmluZygpICtcclxuICAgICAgICAgICAgJyAnICtcclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpKTtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIG1heCBsZWFmIHNpemUsIGJ1dCB0cnkgdG8gYXZvaWQgdGhlIHV0ZjggY29udmVyc2lvbiBpZiB3ZSBjYW4uXHJcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgZGF0YS5sZW5ndGggPiBNQVhfTEVBRl9TSVpFXyAvIDMgJiZcclxuICAgICAgICBzdHJpbmdMZW5ndGgoZGF0YSkgPiBNQVhfTEVBRl9TSVpFXykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXHJcbiAgICAgICAgICAgICdjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gJyArXHJcbiAgICAgICAgICAgIE1BWF9MRUFGX1NJWkVfICtcclxuICAgICAgICAgICAgJyB1dGY4IGJ5dGVzICcgK1xyXG4gICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICBcIiAoJ1wiICtcclxuICAgICAgICAgICAgZGF0YS5zdWJzdHJpbmcoMCwgNTApICtcclxuICAgICAgICAgICAgXCIuLi4nKVwiKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8gPSBQZXJmID0gQ29uc2lkZXIgY29tYmluaW5nIHRoZSByZWN1cnNpdmUgdmFsaWRhdGlvbiBvZiBrZXlzIGludG8gTm9kZUZyb21KU09OXHJcbiAgICAvLyB0byBzYXZlIGV4dHJhIHdhbGtpbmcgb2YgbGFyZ2Ugb2JqZWN0cy5cclxuICAgIGlmIChkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGxldCBoYXNEb3RWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBoYXNBY3R1YWxDaGlsZCA9IGZhbHNlO1xyXG4gICAgICAgIGVhY2goZGF0YSwgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJy52YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgIGhhc0RvdFZhbHVlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcucHJpb3JpdHknICYmIGtleSAhPT0gJy5zdicpIHtcclxuICAgICAgICAgICAgICAgIGhhc0FjdHVhbENoaWxkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJyBjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcpICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUGF0aFRvRXJyb3JTdHJpbmcocGF0aCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnLiAgS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhQdXNoKHBhdGgsIGtleSk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aCk7XHJcbiAgICAgICAgICAgIHZhbGlkYXRpb25QYXRoUG9wKHBhdGgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChoYXNEb3RWYWx1ZSAmJiBoYXNBY3R1YWxDaGlsZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgJyBjb250YWlucyBcIi52YWx1ZVwiIGNoaWxkICcgK1xyXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblBhdGhUb0Vycm9yU3RyaW5nKHBhdGgpICtcclxuICAgICAgICAgICAgICAgICcgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFByZS12YWxpZGF0ZSBwYXRocyBwYXNzZWQgaW4gdGhlIGZpcmViYXNlIGZ1bmN0aW9uLlxyXG4gKi9cclxuY29uc3QgdmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMgPSBmdW5jdGlvbiAoZXJyb3JQcmVmaXgsIG1lcmdlUGF0aHMpIHtcclxuICAgIGxldCBpLCBjdXJQYXRoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcclxuICAgICAgICBjb25zdCBrZXlzID0gcGF0aFNsaWNlKGN1clBhdGgpO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoa2V5c1tqXSA9PT0gJy5wcmlvcml0eScgJiYgaiA9PT0ga2V5cy5sZW5ndGggLSAxKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc1ZhbGlkS2V5KGtleXNbal0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgICAgICdjb250YWlucyBhbiBpbnZhbGlkIGtleSAoJyArXHJcbiAgICAgICAgICAgICAgICAgICAga2V5c1tqXSArXHJcbiAgICAgICAgICAgICAgICAgICAgJykgaW4gcGF0aCAnICtcclxuICAgICAgICAgICAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcuIEtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyAnICtcclxuICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGVjayB0aGF0IHVwZGF0ZSBrZXlzIGFyZSBub3QgZGVzY2VuZGFudHMgb2YgZWFjaCBvdGhlci5cclxuICAgIC8vIFdlIHJlbHkgb24gdGhlIHByb3BlcnR5IHRoYXQgc29ydGluZyBndWFyYW50ZWVzIHRoYXQgYW5jZXN0b3JzIGNvbWVcclxuICAgIC8vIHJpZ2h0IGJlZm9yZSBkZXNjZW5kYW50cy5cclxuICAgIG1lcmdlUGF0aHMuc29ydChwYXRoQ29tcGFyZSk7XHJcbiAgICBsZXQgcHJldlBhdGggPSBudWxsO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjdXJQYXRoID0gbWVyZ2VQYXRoc1tpXTtcclxuICAgICAgICBpZiAocHJldlBhdGggIT09IG51bGwgJiYgcGF0aENvbnRhaW5zKHByZXZQYXRoLCBjdXJQYXRoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xyXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGEgcGF0aCAnICtcclxuICAgICAgICAgICAgICAgIHByZXZQYXRoLnRvU3RyaW5nKCkgK1xyXG4gICAgICAgICAgICAgICAgJyB0aGF0IGlzIGFuY2VzdG9yIG9mIGFub3RoZXIgcGF0aCAnICtcclxuICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZQYXRoID0gY3VyUGF0aDtcclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIHByZS12YWxpZGF0ZSBhbiBvYmplY3QgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGZpcmViYXNlIGZ1bmN0aW9uIChcclxuICogbXVzdCBiZSBhbiBvYmplY3QgLSBlLmcuIGZvciBmaXJlYmFzZS51cGRhdGUoKSkuXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnID0gZnVuY3Rpb24gKGZuTmFtZSwgZGF0YSwgcGF0aCwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBlcnJvclByZWZpeCQxID0gZXJyb3JQcmVmaXgoZm5OYW1lLCAndmFsdWVzJyk7XHJcbiAgICBpZiAoIShkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JykgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCQxICsgJyBtdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBjaGlsZHJlbiB0byByZXBsYWNlLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbWVyZ2VQYXRocyA9IFtdO1xyXG4gICAgZWFjaChkYXRhLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1clBhdGggPSBuZXcgUGF0aChrZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4JDEsIHZhbHVlLCBwYXRoQ2hpbGQocGF0aCwgY3VyUGF0aCkpO1xyXG4gICAgICAgIGlmIChwYXRoR2V0QmFjayhjdXJQYXRoKSA9PT0gJy5wcmlvcml0eScpIHtcclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkUHJpb3JpdHkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgkMSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlIGZvciAnXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCInLCB3aGljaCBtdXN0IGJlIGEgdmFsaWQgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICdGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2VQYXRocy5wdXNoKGN1clBhdGgpO1xyXG4gICAgfSk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlTWVyZ2VQYXRocyhlcnJvclByZWZpeCQxLCBtZXJnZVBhdGhzKTtcclxufTtcclxuY29uc3QgdmFsaWRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChmbk5hbWUsIHByaW9yaXR5LCBvcHRpb25hbCkge1xyXG4gICAgaWYgKG9wdGlvbmFsICYmIHByaW9yaXR5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAncHJpb3JpdHknKSArXHJcbiAgICAgICAgICAgICdpcyAnICtcclxuICAgICAgICAgICAgcHJpb3JpdHkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICcsIGJ1dCBtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCAnICtcclxuICAgICAgICAgICAgJ3NlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XHJcbiAgICB9XHJcbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gYWxsb3cgaW1wb3J0aW5nIGRhdGEgd2l0aCBhIC5zdi5cclxuICAgIGlmICghaXNWYWxpZFByaW9yaXR5KHByaW9yaXR5KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsICdwcmlvcml0eScpICtcclxuICAgICAgICAgICAgJ211c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAnICtcclxuICAgICAgICAgICAgJyhhIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsKS4nKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVLZXkgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIGtleSwgb3B0aW9uYWwpIHtcclxuICAgIGlmIChvcHRpb25hbCAmJiBrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROYW1lKSArXHJcbiAgICAgICAgICAgICd3YXMgYW4gaW52YWxpZCBrZXkgPSBcIicgK1xyXG4gICAgICAgICAgICBrZXkgK1xyXG4gICAgICAgICAgICAnXCIuICBGaXJlYmFzZSBrZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xyXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZVBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE5hbWUsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKSB7XHJcbiAgICBpZiAob3B0aW9uYWwgJiYgcGF0aFN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TmFtZSkgK1xyXG4gICAgICAgICAgICAnd2FzIGFuIGludmFsaWQgcGF0aCA9IFwiJyArXHJcbiAgICAgICAgICAgIHBhdGhTdHJpbmcgK1xyXG4gICAgICAgICAgICAnXCIuIFBhdGhzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xyXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiW1wiLCBvciBcIl1cIicpO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCB2YWxpZGF0ZVJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROYW1lLCBwYXRoU3RyaW5nLCBvcHRpb25hbCkge1xyXG4gICAgaWYgKHBhdGhTdHJpbmcpIHtcclxuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cclxuICAgICAgICBwYXRoU3RyaW5nID0gcGF0aFN0cmluZy5yZXBsYWNlKC9eXFwvKlxcLmluZm8oXFwvfCQpLywgJy8nKTtcclxuICAgIH1cclxuICAgIHZhbGlkYXRlUGF0aFN0cmluZyhmbk5hbWUsIGFyZ3VtZW50TmFtZSwgcGF0aFN0cmluZywgb3B0aW9uYWwpO1xyXG59O1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCB2YWxpZGF0ZVdyaXRhYmxlUGF0aCA9IGZ1bmN0aW9uIChmbk5hbWUsIHBhdGgpIHtcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZm5OYW1lICsgXCIgZmFpbGVkID0gQ2FuJ3QgbW9kaWZ5IGRhdGEgdW5kZXIgLy5pbmZvL1wiKTtcclxuICAgIH1cclxufTtcclxuY29uc3QgdmFsaWRhdGVVcmwgPSBmdW5jdGlvbiAoZm5OYW1lLCBwYXJzZWRVcmwpIHtcclxuICAgIC8vIFRPRE8gPSBWYWxpZGF0ZSBzZXJ2ZXIgYmV0dGVyLlxyXG4gICAgY29uc3QgcGF0aFN0cmluZyA9IHBhcnNlZFVybC5wYXRoLnRvU3RyaW5nKCk7XHJcbiAgICBpZiAoISh0eXBlb2YgcGFyc2VkVXJsLnJlcG9JbmZvLmhvc3QgPT09ICdzdHJpbmcnKSB8fFxyXG4gICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0Lmxlbmd0aCA9PT0gMCB8fFxyXG4gICAgICAgICghaXNWYWxpZEtleShwYXJzZWRVcmwucmVwb0luZm8ubmFtZXNwYWNlKSAmJlxyXG4gICAgICAgICAgICBwYXJzZWRVcmwucmVwb0luZm8uaG9zdC5zcGxpdCgnOicpWzBdICE9PSAnbG9jYWxob3N0JykgfHxcclxuICAgICAgICAocGF0aFN0cmluZy5sZW5ndGggIT09IDAgJiYgIWlzVmFsaWRSb290UGF0aFN0cmluZyhwYXRoU3RyaW5nKSkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCAndXJsJykgK1xyXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIFVSTCBhbmQgJyArXHJcbiAgICAgICAgICAgICd0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO1xyXG4gICAgfVxyXG59O1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhlIGV2ZW50IHF1ZXVlIHNlcnZlcyBhIGZldyBwdXJwb3NlczpcclxuICogMS4gSXQgZW5zdXJlcyB3ZSBtYWludGFpbiBldmVudCBvcmRlciBpbiB0aGUgZmFjZSBvZiBldmVudCBjYWxsYmFja3MgZG9pbmcgb3BlcmF0aW9ucyB0aGF0IHJlc3VsdCBpbiBtb3JlXHJcbiAqICAgIGV2ZW50cyBiZWluZyBxdWV1ZWQuXHJcbiAqIDIuIHJhaXNlUXVldWVkRXZlbnRzKCkgaGFuZGxlcyBiZWluZyBjYWxsZWQgcmVlbnRyYW50bHkgbmljZWx5LiAgVGhhdCBpcywgaWYgaW4gdGhlIGNvdXJzZSBvZiByYWlzaW5nIGV2ZW50cyxcclxuICogICAgcmFpc2VRdWV1ZWRFdmVudHMoKSBpcyBjYWxsZWQgYWdhaW4sIHRoZSBcImlubmVyXCIgY2FsbCB3aWxsIHBpY2sgdXAgcmFpc2luZyBldmVudHMgd2hlcmUgdGhlIFwib3V0ZXJcIiBjYWxsXHJcbiAqICAgIGxlZnQgb2ZmLCBlbnN1cmluZyB0aGF0IHRoZSBldmVudHMgYXJlIHN0aWxsIHJhaXNlZCBzeW5jaHJvbm91c2x5IGFuZCBpbiBvcmRlci5cclxuICogMy4gWW91IGNhbiB1c2UgcmFpc2VFdmVudHNBdFBhdGggYW5kIHJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGggdG8gZW5zdXJlIG9ubHkgcmVsZXZhbnQgcHJldmlvdXNseS1xdWV1ZWRcclxuICogICAgZXZlbnRzIGFyZSByYWlzZWQgc3luY2hyb25vdXNseS5cclxuICpcclxuICogTk9URTogVGhpcyBjYW4gYWxsIGdvIGF3YXkgaWYvd2hlbiB3ZSBtb3ZlIHRvIGFzeW5jIGV2ZW50cy5cclxuICpcclxuICovXHJcbmNsYXNzIEV2ZW50UXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudExpc3RzXyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyByZWN1cnNpb24gZGVwdGggb2YgcmFpc2VRdWV1ZWRFdmVudHNfLCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfID0gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgbmV3IGV2ZW50cyB0byBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KSB7XHJcbiAgICAvLyBXZSBncm91cCBldmVudHMgYnkgcGF0aCwgc3RvcmluZyB0aGVtIGluIGEgc2luZ2xlIEV2ZW50TGlzdCwgdG8gbWFrZSBpdCBlYXNpZXIgdG8gc2tpcCBvdmVyIHRoZW0gcXVpY2tseS5cclxuICAgIGxldCBjdXJyTGlzdCA9IG51bGw7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50RGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gZXZlbnREYXRhTGlzdFtpXTtcclxuICAgICAgICBjb25zdCBwYXRoID0gZGF0YS5nZXRQYXRoKCk7XHJcbiAgICAgICAgaWYgKGN1cnJMaXN0ICE9PSBudWxsICYmICFwYXRoRXF1YWxzKHBhdGgsIGN1cnJMaXN0LnBhdGgpKSB7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XHJcbiAgICAgICAgICAgIGN1cnJMaXN0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJMaXN0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGN1cnJMaXN0ID0geyBldmVudHM6IFtdLCBwYXRoIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJMaXN0LmV2ZW50cy5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgaWYgKGN1cnJMaXN0KSB7XHJcbiAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzXy5wdXNoKGN1cnJMaXN0KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcylcclxuICogZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBuZXcgZXZlbnRzIGFyZSBhbGwgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxyXG4gKiBAcGFyYW0gZXZlbnREYXRhTGlzdCAtIFRoZSBuZXcgZXZlbnRzIHRvIHJhaXNlLlxyXG4gKi9cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoKGV2ZW50UXVldWUsIHBhdGgsIGV2ZW50RGF0YUxpc3QpIHtcclxuICAgIGV2ZW50UXVldWVRdWV1ZUV2ZW50cyhldmVudFF1ZXVlLCBldmVudERhdGFMaXN0KTtcclxuICAgIGV2ZW50UXVldWVSYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlKGV2ZW50UXVldWUsIGV2ZW50UGF0aCA9PiBwYXRoRXF1YWxzKGV2ZW50UGF0aCwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBRdWV1ZXMgdGhlIHNwZWNpZmllZCBldmVudHMgYW5kIHN5bmNocm9ub3VzbHkgcmFpc2VzIGFsbCBldmVudHMgKGluY2x1ZGluZyBwcmV2aW91c2x5IHF1ZXVlZCBvbmVzKSBmb3JcclxuICogbG9jYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHNwZWNpZmllZCBjaGFuZ2UgcGF0aCAoaS5lLiBhbGwgYW5jZXN0b3JzIGFuZCBkZXNjZW5kYW50cykuXHJcbiAqXHJcbiAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbmV3IGV2ZW50cyBhcmUgYWxsIHJlbGF0ZWQgKGFuY2VzdG9yIG9yIGRlc2NlbmRhbnQpIHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cclxuICpcclxuICogQHBhcmFtIGNoYW5nZWRQYXRoIC0gVGhlIHBhdGggdG8gcmFpc2UgZXZlbnRzIGZvci5cclxuICogQHBhcmFtIGV2ZW50RGF0YUxpc3QgLSBUaGUgZXZlbnRzIHRvIHJhaXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChldmVudFF1ZXVlLCBjaGFuZ2VkUGF0aCwgZXZlbnREYXRhTGlzdCkge1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKGV2ZW50UXVldWUsIGV2ZW50RGF0YUxpc3QpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgZXZlbnRQYXRoID0+IHBhdGhDb250YWlucyhldmVudFBhdGgsIGNoYW5nZWRQYXRoKSB8fFxyXG4gICAgICAgIHBhdGhDb250YWlucyhjaGFuZ2VkUGF0aCwgZXZlbnRQYXRoKSk7XHJcbn1cclxuZnVuY3Rpb24gZXZlbnRRdWV1ZVJhaXNlUXVldWVkRXZlbnRzTWF0Y2hpbmdQcmVkaWNhdGUoZXZlbnRRdWV1ZSwgcHJlZGljYXRlKSB7XHJcbiAgICBldmVudFF1ZXVlLnJlY3Vyc2lvbkRlcHRoXysrO1xyXG4gICAgbGV0IHNlbnRBbGwgPSB0cnVlO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudFF1ZXVlLmV2ZW50TGlzdHNfLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ID0gZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXTtcclxuICAgICAgICBpZiAoZXZlbnRMaXN0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50UGF0aCA9IGV2ZW50TGlzdC5wYXRoO1xyXG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGV2ZW50UGF0aCkpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TGlzdFJhaXNlKGV2ZW50UXVldWUuZXZlbnRMaXN0c19baV0pO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZS5ldmVudExpc3RzX1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZW50QWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoc2VudEFsbCkge1xyXG4gICAgICAgIGV2ZW50UXVldWUuZXZlbnRMaXN0c18gPSBbXTtcclxuICAgIH1cclxuICAgIGV2ZW50UXVldWUucmVjdXJzaW9uRGVwdGhfLS07XHJcbn1cclxuLyoqXHJcbiAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGxpc3QgYW5kIHJhaXNlcyBlYWNoIGV2ZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBldmVudExpc3RSYWlzZShldmVudExpc3QpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRMaXN0LmV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50RGF0YSA9IGV2ZW50TGlzdC5ldmVudHNbaV07XHJcbiAgICAgICAgaWYgKGV2ZW50RGF0YSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudExpc3QuZXZlbnRzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc3QgZXZlbnRGbiA9IGV2ZW50RGF0YS5nZXRFdmVudFJ1bm5lcigpO1xyXG4gICAgICAgICAgICBpZiAobG9nZ2VyKSB7XHJcbiAgICAgICAgICAgICAgICBsb2coJ2V2ZW50OiAnICsgZXZlbnREYXRhLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGV2ZW50Rm4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5jb25zdCBJTlRFUlJVUFRfUkVBU09OID0gJ3JlcG9faW50ZXJydXB0JztcclxuLyoqXHJcbiAqIElmIGEgdHJhbnNhY3Rpb24gZG9lcyBub3Qgc3VjY2VlZCBhZnRlciAyNSByZXRyaWVzLCB3ZSBhYm9ydCBpdC4gQW1vbmcgb3RoZXJcclxuICogdGhpbmdzIHRoaXMgZW5zdXJlIHRoYXQgaWYgdGhlcmUncyBldmVyIGEgYnVnIGNhdXNpbmcgYSBtaXNtYXRjaCBiZXR3ZWVuXHJcbiAqIGNsaWVudCAvIHNlcnZlciBoYXNoZXMgZm9yIHNvbWUgZGF0YSwgd2Ugd29uJ3QgcmV0cnkgaW5kZWZpbml0ZWx5LlxyXG4gKi9cclxuY29uc3QgTUFYX1RSQU5TQUNUSU9OX1JFVFJJRVMgPSAyNTtcclxuLyoqXHJcbiAqIEEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBkYXRhIHJlcG9zaXRvcnkuXHJcbiAqL1xyXG5jbGFzcyBSZXBvIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlcG9JbmZvXywgZm9yY2VSZXN0Q2xpZW50XywgYXV0aFRva2VuUHJvdmlkZXJfLCBhcHBDaGVja1Byb3ZpZGVyXykge1xyXG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xyXG4gICAgICAgIHRoaXMuZm9yY2VSZXN0Q2xpZW50XyA9IGZvcmNlUmVzdENsaWVudF87XHJcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XHJcbiAgICAgICAgdGhpcy5hcHBDaGVja1Byb3ZpZGVyXyA9IGFwcENoZWNrUHJvdmlkZXJfO1xyXG4gICAgICAgIHRoaXMuZGF0YVVwZGF0ZUNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLmV2ZW50UXVldWVfID0gbmV3IEV2ZW50UXVldWUoKTtcclxuICAgICAgICB0aGlzLm5leHRXcml0ZUlkXyA9IDE7XHJcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfID0gbnVsbDtcclxuICAgICAgICAvKiogQSBsaXN0IG9mIGRhdGEgcGllY2VzIGFuZCBwYXRocyB0byBiZSBzZXQgd2hlbiB0aGlzIGNsaWVudCBkaXNjb25uZWN0cy4gKi9cclxuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBuZXdTcGFyc2VTbmFwc2hvdFRyZWUoKTtcclxuICAgICAgICAvKiogU3RvcmVzIHF1ZXVlcyBvZiBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgZm9yIEZpcmViYXNlIGxvY2F0aW9ucy4gKi9cclxuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXyA9IG5ldyBUcmVlKCk7XHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgQHByaXZhdGUgYnV0IGl0J3MgdXNlZCBieSB0ZXN0X2FjY2Vzcy5qcyBhbmQgaW50ZXJuYWwuanNcclxuICAgICAgICB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXyA9IG51bGw7XHJcbiAgICAgICAgLy8gVGhpcyBrZXkgaXMgaW50ZW50aW9uYWxseSBub3QgdXBkYXRlZCBpZiBSZXBvSW5mbyBpcyBsYXRlciBjaGFuZ2VkIG9yIHJlcGxhY2VkXHJcbiAgICAgICAgdGhpcy5rZXkgPSB0aGlzLnJlcG9JbmZvXy50b1VSTFN0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgVVJMIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3Qgb2YgdGhpcyBGaXJlYmFzZS5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5yZXBvSW5mb18uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgKyB0aGlzLnJlcG9JbmZvXy5ob3N0KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXBvU3RhcnQocmVwbywgYXBwSWQsIGF1dGhPdmVycmlkZSkge1xyXG4gICAgcmVwby5zdGF0c18gPSBzdGF0c01hbmFnZXJHZXRDb2xsZWN0aW9uKHJlcG8ucmVwb0luZm9fKTtcclxuICAgIGlmIChyZXBvLmZvcmNlUmVzdENsaWVudF8gfHwgYmVpbmdDcmF3bGVkKCkpIHtcclxuICAgICAgICByZXBvLnNlcnZlcl8gPSBuZXcgUmVhZG9ubHlSZXN0Q2xpZW50KHJlcG8ucmVwb0luZm9fLCAocGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKTtcclxuICAgICAgICB9LCByZXBvLmF1dGhUb2tlblByb3ZpZGVyXywgcmVwby5hcHBDaGVja1Byb3ZpZGVyXyk7XHJcbiAgICAgICAgLy8gTWlub3IgaGFjazogRmlyZSBvbkNvbm5lY3QgaW1tZWRpYXRlbHksIHNpbmNlIHRoZXJlJ3Mgbm8gYWN0dWFsIGNvbm5lY3Rpb24uXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiByZXBvT25Db25uZWN0U3RhdHVzKHJlcG8sIC8qIGNvbm5lY3RTdGF0dXM9ICovIHRydWUpLCAwKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFZhbGlkYXRlIGF1dGhPdmVycmlkZVxyXG4gICAgICAgIGlmICh0eXBlb2YgYXV0aE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJyAmJiBhdXRoT3ZlcnJpZGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdXRoT3ZlcnJpZGUgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb2JqZWN0cyBhcmUgc3VwcG9ydGVkIGZvciBvcHRpb24gZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoYXV0aE92ZXJyaWRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF1dGhPdmVycmlkZSBwcm92aWRlZDogJyArIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fID0gbmV3IFBlcnNpc3RlbnRDb25uZWN0aW9uKHJlcG8ucmVwb0luZm9fLCBhcHBJZCwgKHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25EYXRhVXBkYXRlKHJlcG8sIHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZyk7XHJcbiAgICAgICAgfSwgKGNvbm5lY3RTdGF0dXMpID0+IHtcclxuICAgICAgICAgICAgcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCBjb25uZWN0U3RhdHVzKTtcclxuICAgICAgICB9LCAodXBkYXRlcykgPT4ge1xyXG4gICAgICAgICAgICByZXBvT25TZXJ2ZXJJbmZvVXBkYXRlKHJlcG8sIHVwZGF0ZXMpO1xyXG4gICAgICAgIH0sIHJlcG8uYXV0aFRva2VuUHJvdmlkZXJfLCByZXBvLmFwcENoZWNrUHJvdmlkZXJfLCBhdXRoT3ZlcnJpZGUpO1xyXG4gICAgICAgIHJlcG8uc2VydmVyXyA9IHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fO1xyXG4gICAgfVxyXG4gICAgcmVwby5hdXRoVG9rZW5Qcm92aWRlcl8uYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lcih0b2tlbiA9PiB7XHJcbiAgICAgICAgcmVwby5zZXJ2ZXJfLnJlZnJlc2hBdXRoVG9rZW4odG9rZW4pO1xyXG4gICAgfSk7XHJcbiAgICByZXBvLmFwcENoZWNrUHJvdmlkZXJfLmFkZFRva2VuQ2hhbmdlTGlzdGVuZXIocmVzdWx0ID0+IHtcclxuICAgICAgICByZXBvLnNlcnZlcl8ucmVmcmVzaEFwcENoZWNrVG9rZW4ocmVzdWx0LnRva2VuKTtcclxuICAgIH0pO1xyXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgbXVsdGlwbGUgUmVwb3MgZm9yIHRoZSBzYW1lIHJlcG9JbmZvIChpLmUuIHRoZXJlIGFyZSBtdWx0aXBsZSBGaXJlYmFzZS5Db250ZXh0cyBiZWluZyB1c2VkKSxcclxuICAgIC8vIHdlIG9ubHkgd2FudCB0byBjcmVhdGUgb25lIFN0YXRzUmVwb3J0ZXIuICBBcyBzdWNoLCB3ZSdsbCByZXBvcnQgc3RhdHMgb3ZlciB0aGUgZmlyc3QgUmVwbyBjcmVhdGVkLlxyXG4gICAgcmVwby5zdGF0c1JlcG9ydGVyXyA9IHN0YXRzTWFuYWdlckdldE9yQ3JlYXRlUmVwb3J0ZXIocmVwby5yZXBvSW5mb18sICgpID0+IG5ldyBTdGF0c1JlcG9ydGVyKHJlcG8uc3RhdHNfLCByZXBvLnNlcnZlcl8pKTtcclxuICAgIC8vIFVzZWQgZm9yIC5pbmZvLlxyXG4gICAgcmVwby5pbmZvRGF0YV8gPSBuZXcgU25hcHNob3RIb2xkZXIoKTtcclxuICAgIHJlcG8uaW5mb1N5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBpbmZvRXZlbnRzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSByZXBvLmluZm9EYXRhXy5nZXROb2RlKHF1ZXJ5Ll9wYXRoKTtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBwb3NzaWJseSBhIGhhY2ssIGJ1dCB3ZSBoYXZlIGRpZmZlcmVudCBzZW1hbnRpY3MgZm9yIC5pbmZvIGVuZHBvaW50cy4gV2UgZG9uJ3QgcmFpc2UgbnVsbCBldmVudHNcclxuICAgICAgICAgICAgLy8gb24gaW5pdGlhbCBkYXRhLi4uXHJcbiAgICAgICAgICAgIGlmICghbm9kZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIGluZm9FdmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnkuX3BhdGgsIG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgnb2snKTtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpbmZvRXZlbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcExpc3RlbmluZzogKCkgPT4geyB9XHJcbiAgICB9KTtcclxuICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sICdjb25uZWN0ZWQnLCBmYWxzZSk7XHJcbiAgICByZXBvLnNlcnZlclN5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZSh7XHJcbiAgICAgICAgc3RhcnRMaXN0ZW5pbmc6IChxdWVyeSwgdGFnLCBjdXJyZW50SGFzaEZuLCBvbkNvbXBsZXRlKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG8uc2VydmVyXy5saXN0ZW4ocXVlcnksIGN1cnJlbnRIYXNoRm4sIHRhZywgKHN0YXR1cywgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gb25Db21wbGV0ZShzdGF0dXMsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyBObyBzeW5jaHJvbm91cyBldmVudHMgZm9yIG5ldHdvcmstYmFja2VkIHN5bmMgdHJlZXNcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RvcExpc3RlbmluZzogKHF1ZXJ5LCB0YWcpID0+IHtcclxuICAgICAgICAgICAgcmVwby5zZXJ2ZXJfLnVubGlzdGVuKHF1ZXJ5LCB0YWcpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMsIHRha2luZyB0aGUgc2VydmVyIG9mZnNldCBpbnRvIGFjY291bnQgaWYgd2UgaGF2ZSBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvU2VydmVyVGltZShyZXBvKSB7XHJcbiAgICBjb25zdCBvZmZzZXROb2RlID0gcmVwby5pbmZvRGF0YV8uZ2V0Tm9kZShuZXcgUGF0aCgnLmluZm8vc2VydmVyVGltZU9mZnNldCcpKTtcclxuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldE5vZGUudmFsKCkgfHwgMDtcclxuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIG9mZnNldDtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGUgU2VydmVyVmFsdWVzIHVzaW5nIHNvbWUgdmFyaWFibGVzIGZyb20gdGhlIHJlcG8gb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pIHtcclxuICAgIHJldHVybiBnZW5lcmF0ZVdpdGhWYWx1ZXMoe1xyXG4gICAgICAgIHRpbWVzdGFtcDogcmVwb1NlcnZlclRpbWUocmVwbylcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxsZWQgYnkgcmVhbHRpbWUgd2hlbiB3ZSBnZXQgbmV3IG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9PbkRhdGFVcGRhdGUocmVwbywgcGF0aFN0cmluZywgZGF0YSwgaXNNZXJnZSwgdGFnKSB7XHJcbiAgICAvLyBGb3IgdGVzdGluZy5cclxuICAgIHJlcG8uZGF0YVVwZGF0ZUNvdW50Kys7XHJcbiAgICBjb25zdCBwYXRoID0gbmV3IFBhdGgocGF0aFN0cmluZyk7XHJcbiAgICBkYXRhID0gcmVwby5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfXHJcbiAgICAgICAgPyByZXBvLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18ocGF0aFN0cmluZywgZGF0YSlcclxuICAgICAgICA6IGRhdGE7XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgaWYgKGlzTWVyZ2UpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFnZ2VkQ2hpbGRyZW4gPSBtYXAoZGF0YSwgKHJhdykgPT4gbm9kZUZyb21KU09OKHJhdykpO1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgdGFnZ2VkQ2hpbGRyZW4sIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YWdnZWRTbmFwID0gbm9kZUZyb21KU09OKGRhdGEpO1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5VGFnZ2VkUXVlcnlPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHRhZ2dlZFNuYXAsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNNZXJnZSkge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZWRDaGlsZHJlbiA9IG1hcChkYXRhLCAocmF3KSA9PiBub2RlRnJvbUpTT04ocmF3KSk7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVBcHBseVNlcnZlck1lcmdlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgc25hcCA9IG5vZGVGcm9tSlNPTihkYXRhKTtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoLCBzbmFwKTtcclxuICAgIH1cclxuICAgIGxldCBhZmZlY3RlZFBhdGggPSBwYXRoO1xyXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBhIGxpc3RlbmVyIG91dHN0YW5kaW5nIGZvciBlYWNoIHRyYW5zYWN0aW9uLCByZWNlaXZpbmcgYW55IGV2ZW50c1xyXG4gICAgICAgIC8vIGlzIGEgcHJveHkgZm9yIHNvbWUgY2hhbmdlIGhhdmluZyBvY2N1cnJlZC5cclxuICAgICAgICBhZmZlY3RlZFBhdGggPSByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBhZmZlY3RlZFBhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uQ29ubmVjdFN0YXR1cyhyZXBvLCBjb25uZWN0U3RhdHVzKSB7XHJcbiAgICByZXBvVXBkYXRlSW5mbyhyZXBvLCAnY29ubmVjdGVkJywgY29ubmVjdFN0YXR1cyk7XHJcbiAgICBpZiAoY29ubmVjdFN0YXR1cyA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXBvUnVuT25EaXNjb25uZWN0RXZlbnRzKHJlcG8pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9PblNlcnZlckluZm9VcGRhdGUocmVwbywgdXBkYXRlcykge1xyXG4gICAgZWFjaCh1cGRhdGVzLCAoa2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHJlcG9VcGRhdGVJbmZvKHJlcG8sIGtleSwgdmFsdWUpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1VwZGF0ZUluZm8ocmVwbywgcGF0aFN0cmluZywgdmFsdWUpIHtcclxuICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aCgnLy5pbmZvLycgKyBwYXRoU3RyaW5nKTtcclxuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xyXG4gICAgcmVwby5pbmZvRGF0YV8udXBkYXRlU25hcHNob3QocGF0aCwgbmV3Tm9kZSk7XHJcbiAgICBjb25zdCBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uaW5mb1N5bmNUcmVlXywgcGF0aCwgbmV3Tm9kZSk7XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9HZXROZXh0V3JpdGVJZChyZXBvKSB7XHJcbiAgICByZXR1cm4gcmVwby5uZXh0V3JpdGVJZF8rKztcclxufVxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgYGdldFZhbHVlYCBpcyB0byByZXR1cm4gdGhlIGxhdGVzdCBrbm93biB2YWx1ZVxyXG4gKiBzYXRpc2Z5aW5nIGBxdWVyeWAuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIHdpbGwgZmlyc3QgY2hlY2sgZm9yIGluLW1lbW9yeSBjYWNoZWQgdmFsdWVzXHJcbiAqIGJlbG9uZ2luZyB0byBhY3RpdmUgbGlzdGVuZXJzLiBJZiB0aGV5IGFyZSBmb3VuZCwgc3VjaCB2YWx1ZXNcclxuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIG1vc3QgdXAtdG8tZGF0ZS5cclxuICpcclxuICogSWYgdGhlIGNsaWVudCBpcyBub3QgY29ubmVjdGVkLCB0aGlzIG1ldGhvZCB3aWxsIHdhaXQgdW50aWwgdGhlXHJcbiAqICByZXBvIGhhcyBlc3RhYmxpc2hlZCBhIGNvbm5lY3Rpb24gYW5kIHRoZW4gcmVxdWVzdCB0aGUgdmFsdWUgZm9yIGBxdWVyeWAuXHJcbiAqIElmIHRoZSBjbGllbnQgaXMgbm90IGFibGUgdG8gcmV0cmlldmUgdGhlIHF1ZXJ5IHJlc3VsdCBmb3IgYW5vdGhlciByZWFzb24sXHJcbiAqIGl0IHJlcG9ydHMgYW4gZXJyb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0byBzdXJmYWNlIGEgdmFsdWUgZm9yLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb0dldFZhbHVlKHJlcG8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgLy8gT25seSBhY3RpdmUgcXVlcmllcyBhcmUgY2FjaGVkLiBUaGVyZSBpcyBubyBwZXJzaXN0ZWQgY2FjaGUuXHJcbiAgICBjb25zdCBjYWNoZWQgPSBzeW5jVHJlZUdldFNlcnZlclZhbHVlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSk7XHJcbiAgICBpZiAoY2FjaGVkICE9IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVwby5zZXJ2ZXJfLmdldChxdWVyeSkudGhlbihwYXlsb2FkID0+IHtcclxuICAgICAgICBjb25zdCBub2RlID0gbm9kZUZyb21KU09OKHBheWxvYWQpLndpdGhJbmRleChxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmVsb3cgd2Ugc2ltdWxhdGUgdGhlIGFjdGlvbnMgb2YgYW4gYG9ubHlPbmNlYCBgb25WYWx1ZSgpYCBldmVudCB3aGVyZTpcclxuICAgICAgICAgKiBBZGQgYW4gZXZlbnQgcmVnaXN0cmF0aW9uLFxyXG4gICAgICAgICAqIFVwZGF0ZSBkYXRhIGF0IHRoZSBwYXRoLFxyXG4gICAgICAgICAqIFJhaXNlIGFueSBldmVudHMsXHJcbiAgICAgICAgICogQ2xlYW51cCB0aGUgU3luY1RyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHRydWUpO1xyXG4gICAgICAgIGxldCBldmVudHM7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5sb2Fkc0FsbERhdGEoKSkge1xyXG4gICAgICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFwcGx5U2VydmVyT3ZlcndyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeS5fcGF0aCwgbm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCB0YWcgPSBzeW5jVHJlZVRhZ0ZvclF1ZXJ5KHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSk7XHJcbiAgICAgICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcXVlcnkuX3BhdGgsIG5vZGUsIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogV2UgbmVlZCB0byByYWlzZSBldmVudHMgaW4gdGhlIHNjZW5hcmlvIHdoZXJlIGBnZXQoKWAgaXMgY2FsbGVkIGF0IGEgcGFyZW50IHBhdGgsIGFuZFxyXG4gICAgICAgICAqIHdoaWxlIHRoZSBgZ2V0KClgIGlzIHBlbmRpbmcsIGBvblZhbHVlYCBpcyBjYWxsZWQgYXQgYSBjaGlsZCBsb2NhdGlvbi4gV2hpbGUgZ2V0KCkgaXMgd2FpdGluZ1xyXG4gICAgICAgICAqIGZvciB0aGUgZGF0YSwgYG9uVmFsdWVgIHdpbGwgcmVnaXN0ZXIgYSBuZXcgZXZlbnQuIFRoZW4sIGdldCgpIHdpbGwgY29tZSBiYWNrLCBhbmQgdXBkYXRlIHRoZSBzeW5jVHJlZVxyXG4gICAgICAgICAqIGFuZCBpdHMgY29ycmVzcG9uZGluZyBzZXJ2ZXJDYWNoZSwgaW5jbHVkaW5nIHRoZSBjaGlsZCBsb2NhdGlvbiB3aGVyZSBgb25WYWx1ZWAgaXMgY2FsbGVkLiBUaGVuLFxyXG4gICAgICAgICAqIGBvblZhbHVlYCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50IGZyb20gdGhlIHNlcnZlciwgYnV0IGxvb2sgYXQgdGhlIHN5bmNUcmVlIGFuZCBzZWUgdGhhdCB0aGUgZGF0YSByZWNlaXZlZFxyXG4gICAgICAgICAqIGZyb20gdGhlIHNlcnZlciBpcyBhbHJlYWR5IGF0IHRoZSBTeW5jUG9pbnQsIGFuZCBzbyB0aGUgYG9uVmFsdWVgIGNhbGxiYWNrIHdpbGwgbmV2ZXIgZ2V0IGZpcmVkLlxyXG4gICAgICAgICAqIENhbGxpbmcgYGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKClgIGlzIHRoZSBjb3JyZWN0IHdheSB0byBwcm9wYWdhdGUgdGhlIGV2ZW50cyBhbmRcclxuICAgICAgICAgKiBlbnN1cmUgdGhlIGNvcnJlc3BvbmRpbmcgY2hpbGQgZXZlbnRzIHdpbGwgZ2V0IGZpcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG4gICAgICAgIHN5bmNUcmVlUmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9LCBlcnIgPT4ge1xyXG4gICAgICAgIHJlcG9Mb2cocmVwbywgJ2dldCBmb3IgcXVlcnkgJyArIHN0cmluZ2lmeShxdWVyeSkgKyAnIGZhaWxlZDogJyArIGVycik7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9TZXRXaXRoUHJpb3JpdHkocmVwbywgcGF0aCwgbmV3VmFsLCBuZXdQcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgcmVwb0xvZyhyZXBvLCAnc2V0Jywge1xyXG4gICAgICAgIHBhdGg6IHBhdGgudG9TdHJpbmcoKSxcclxuICAgICAgICB2YWx1ZTogbmV3VmFsLFxyXG4gICAgICAgIHByaW9yaXR5OiBuZXdQcmlvcml0eVxyXG4gICAgfSk7XHJcbiAgICAvLyBUT0RPOiBPcHRpbWl6ZSB0aGlzIGJlaGF2aW9yIHRvIGVpdGhlciAoYSkgc3RvcmUgZmxhZyB0byBza2lwIHJlc29sdmluZyB3aGVyZSBwb3NzaWJsZSBhbmQgLyBvclxyXG4gICAgLy8gKGIpIHN0b3JlIHVucmVzb2x2ZWQgcGF0aHMgb24gSlNPTiBwYXJzZVxyXG4gICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgY29uc3QgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT04obmV3VmFsLCBuZXdQcmlvcml0eSk7XHJcbiAgICBjb25zdCBleGlzdGluZyA9IHN5bmNUcmVlQ2FsY0NvbXBsZXRlRXZlbnRDYWNoZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCk7XHJcbiAgICBjb25zdCBuZXdOb2RlID0gcmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgZXhpc3RpbmcsIHNlcnZlclZhbHVlcyk7XHJcbiAgICBjb25zdCB3cml0ZUlkID0gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pO1xyXG4gICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUsIHdyaXRlSWQsIHRydWUpO1xyXG4gICAgZXZlbnRRdWV1ZVF1ZXVlRXZlbnRzKHJlcG8uZXZlbnRRdWV1ZV8sIGV2ZW50cyk7XHJcbiAgICByZXBvLnNlcnZlcl8ucHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZVVucmVzb2x2ZWQudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XHJcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHdhcm4oJ3NldCBhdCAnICsgcGF0aCArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2xlYXJFdmVudHMgPSBzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgd3JpdGVJZCwgIXN1Y2Nlc3MpO1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGNsZWFyRXZlbnRzKTtcclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gcmVwb0Fib3J0VHJhbnNhY3Rpb25zKHJlcG8sIHBhdGgpO1xyXG4gICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICAvLyBXZSBxdWV1ZWQgdGhlIGV2ZW50cyBhYm92ZSwgc28ganVzdCBmbHVzaCB0aGUgcXVldWUgaGVyZVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgYWZmZWN0ZWRQYXRoLCBbXSk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1VwZGF0ZShyZXBvLCBwYXRoLCBjaGlsZHJlblRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ3VwZGF0ZScsIHsgcGF0aDogcGF0aC50b1N0cmluZygpLCB2YWx1ZTogY2hpbGRyZW5Ub01lcmdlIH0pO1xyXG4gICAgLy8gU3RhcnQgd2l0aCBvdXIgZXhpc3RpbmcgZGF0YSBhbmQgbWVyZ2UgZWFjaCBjaGlsZCBpbnRvIGl0LlxyXG4gICAgbGV0IGVtcHR5ID0gdHJ1ZTtcclxuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgIGNvbnN0IGNoYW5nZWRDaGlsZHJlbiA9IHt9O1xyXG4gICAgZWFjaChjaGlsZHJlblRvTWVyZ2UsIChjaGFuZ2VkS2V5LCBjaGFuZ2VkVmFsdWUpID0+IHtcclxuICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgIGNoYW5nZWRDaGlsZHJlbltjaGFuZ2VkS2V5XSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShwYXRoQ2hpbGQocGF0aCwgY2hhbmdlZEtleSksIG5vZGVGcm9tSlNPTihjaGFuZ2VkVmFsdWUpLCByZXBvLnNlcnZlclN5bmNUcmVlXywgc2VydmVyVmFsdWVzKTtcclxuICAgIH0pO1xyXG4gICAgaWYgKCFlbXB0eSkge1xyXG4gICAgICAgIGNvbnN0IHdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJNZXJnZShyZXBvLnNlcnZlclN5bmNUcmVlXywgcGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKTtcclxuICAgICAgICBldmVudFF1ZXVlUXVldWVFdmVudHMocmVwby5ldmVudFF1ZXVlXywgZXZlbnRzKTtcclxuICAgICAgICByZXBvLnNlcnZlcl8ubWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XHJcbiAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICAgICAgd2FybigndXBkYXRlIGF0ICcgKyBwYXRoICsgJyBmYWlsZWQ6ICcgKyBzdGF0dXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNsZWFyRXZlbnRzID0gc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHdyaXRlSWQsICFzdWNjZXNzKTtcclxuICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWRQYXRoID0gY2xlYXJFdmVudHMubGVuZ3RoID4gMCA/IHJlcG9SZXJ1blRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKSA6IHBhdGg7XHJcbiAgICAgICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIGFmZmVjdGVkUGF0aCwgY2xlYXJFdmVudHMpO1xyXG4gICAgICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoYW5nZWRQYXRoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFmZmVjdGVkUGF0aCA9IHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoQ2hpbGQocGF0aCwgY2hhbmdlZFBhdGgpKTtcclxuICAgICAgICAgICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gV2UgcXVldWVkIHRoZSBldmVudHMgYWJvdmUsIHNvIGp1c3QgZmx1c2ggdGhlIHF1ZXVlIGhlcmVcclxuICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBbXSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsb2coXCJ1cGRhdGUoKSBjYWxsZWQgd2l0aCBlbXB0eSBkYXRhLiAgRG9uJ3QgZG8gYW55dGhpbmcuXCIpO1xyXG4gICAgICAgIHJlcG9DYWxsT25Db21wbGV0ZUNhbGxiYWNrKHJlcG8sIG9uQ29tcGxldGUsICdvaycsIHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIHN0b3JlZCB1cCBpbiB0aGUgb25EaXNjb25uZWN0XyB0cmVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1J1bk9uRGlzY29ubmVjdEV2ZW50cyhyZXBvKSB7XHJcbiAgICByZXBvTG9nKHJlcG8sICdvbkRpc2Nvbm5lY3RFdmVudHMnKTtcclxuICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgIGNvbnN0IHJlc29sdmVkT25EaXNjb25uZWN0VHJlZSA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUocmVwby5vbkRpc2Nvbm5lY3RfLCBuZXdFbXB0eVBhdGgoKSwgKHBhdGgsIG5vZGUpID0+IHtcclxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVEZWZlcnJlZFZhbHVlVHJlZShwYXRoLCBub2RlLCByZXBvLnNlcnZlclN5bmNUcmVlXywgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICBzcGFyc2VTbmFwc2hvdFRyZWVSZW1lbWJlcihyZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUsIHBhdGgsIHJlc29sdmVkKTtcclxuICAgIH0pO1xyXG4gICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgc3BhcnNlU25hcHNob3RUcmVlRm9yRWFjaFRyZWUocmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlLCBuZXdFbXB0eVBhdGgoKSwgKHBhdGgsIHNuYXApID0+IHtcclxuICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQXBwbHlTZXJ2ZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIHNuYXApKTtcclxuICAgICAgICBjb25zdCBhZmZlY3RlZFBhdGggPSByZXBvQWJvcnRUcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICAgICAgcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGFmZmVjdGVkUGF0aCk7XHJcbiAgICB9KTtcclxuICAgIHJlcG8ub25EaXNjb25uZWN0XyA9IG5ld1NwYXJzZVNuYXBzaG90VHJlZSgpO1xyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocmVwby5ldmVudFF1ZXVlXywgbmV3RW1wdHlQYXRoKCksIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb09uRGlzY29ubmVjdENhbmNlbChyZXBvLCBwYXRoLCBvbkNvbXBsZXRlKSB7XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0Q2FuY2VsKHBhdGgudG9TdHJpbmcoKSwgKHN0YXR1cywgZXJyb3JSZWFzb24pID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZUZvcmdldChyZXBvLm9uRGlzY29ubmVjdF8sIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9PbkRpc2Nvbm5lY3RTZXQocmVwbywgcGF0aCwgdmFsdWUsIG9uQ29tcGxldGUpIHtcclxuICAgIGNvbnN0IG5ld05vZGUgPSBub2RlRnJvbUpTT04odmFsdWUpO1xyXG4gICAgcmVwby5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0U2V0V2l0aFByaW9yaXR5KHJlcG8sIHBhdGgsIHZhbHVlLCBwcmlvcml0eSwgb25Db21wbGV0ZSkge1xyXG4gICAgY29uc3QgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTih2YWx1ZSwgcHJpb3JpdHkpO1xyXG4gICAgcmVwby5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCAoc3RhdHVzLCBlcnJvclJlYXNvbikgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgc3BhcnNlU25hcHNob3RUcmVlUmVtZW1iZXIocmVwby5vbkRpc2Nvbm5lY3RfLCBwYXRoLCBuZXdOb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiByZXBvT25EaXNjb25uZWN0VXBkYXRlKHJlcG8sIHBhdGgsIGNoaWxkcmVuVG9NZXJnZSwgb25Db21wbGV0ZSkge1xyXG4gICAgaWYgKGlzRW1wdHkoY2hpbGRyZW5Ub01lcmdlKSkge1xyXG4gICAgICAgIGxvZyhcIm9uRGlzY29ubmVjdCgpLnVwZGF0ZSgpIGNhbGxlZCB3aXRoIGVtcHR5IGRhdGEuICBEb24ndCBkbyBhbnl0aGluZy5cIik7XHJcbiAgICAgICAgcmVwb0NhbGxPbkNvbXBsZXRlQ2FsbGJhY2socmVwbywgb25Db21wbGV0ZSwgJ29rJywgdW5kZWZpbmVkKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXBvLnNlcnZlcl8ub25EaXNjb25uZWN0TWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIChzdGF0dXMsIGVycm9yUmVhc29uKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xyXG4gICAgICAgICAgICBlYWNoKGNoaWxkcmVuVG9NZXJnZSwgKGNoaWxkTmFtZSwgY2hpbGROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDaGlsZE5vZGUgPSBub2RlRnJvbUpTT04oY2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIHNwYXJzZVNuYXBzaG90VHJlZVJlbWVtYmVyKHJlcG8ub25EaXNjb25uZWN0XywgcGF0aENoaWxkKHBhdGgsIGNoaWxkTmFtZSksIG5ld0NoaWxkTm9kZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9BZGRFdmVudENhbGxiYWNrRm9yUXVlcnkocmVwbywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKSB7XHJcbiAgICBsZXQgZXZlbnRzO1xyXG4gICAgaWYgKHBhdGhHZXRGcm9udChxdWVyeS5fcGF0aCkgPT09ICcuaW5mbycpIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZUFkZEV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uaW5mb1N5bmNUcmVlXywgcXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IHN5bmNUcmVlQWRkRXZlbnRSZWdpc3RyYXRpb24ocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNBdFBhdGgocmVwby5ldmVudFF1ZXVlXywgcXVlcnkuX3BhdGgsIGV2ZW50cyk7XHJcbn1cclxuZnVuY3Rpb24gcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShyZXBvLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pIHtcclxuICAgIC8vIFRoZXNlIGFyZSBndWFyYW50ZWVkIG5vdCB0byByYWlzZSBldmVudHMsIHNpbmNlIHdlJ3JlIG5vdCBwYXNzaW5nIGluIGEgY2FuY2VsRXJyb3IuIEhvd2V2ZXIsIHdlIGNhbiBmdXR1cmUtcHJvb2ZcclxuICAgIC8vIGEgbGl0dGxlIGJpdCBieSBoYW5kbGluZyB0aGUgcmV0dXJuIHZhbHVlcyBhbnl3YXlzLlxyXG4gICAgbGV0IGV2ZW50cztcclxuICAgIGlmIChwYXRoR2V0RnJvbnQocXVlcnkuX3BhdGgpID09PSAnLmluZm8nKSB7XHJcbiAgICAgICAgZXZlbnRzID0gc3luY1RyZWVSZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihyZXBvLmluZm9TeW5jVHJlZV8sIHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBldmVudHMgPSBzeW5jVHJlZVJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHJlcG8uc2VydmVyU3luY1RyZWVfLCBxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24pO1xyXG4gICAgfVxyXG4gICAgZXZlbnRRdWV1ZVJhaXNlRXZlbnRzQXRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHF1ZXJ5Ll9wYXRoLCBldmVudHMpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcG9JbnRlcnJ1cHQocmVwbykge1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaW50ZXJydXB0KElOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9SZXN1bWUocmVwbykge1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8ucmVzdW1lKElOVEVSUlVQVF9SRUFTT04pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlcG9Mb2cocmVwbywgLi4udmFyQXJncykge1xyXG4gICAgbGV0IHByZWZpeCA9ICcnO1xyXG4gICAgaWYgKHJlcG8ucGVyc2lzdGVudENvbm5lY3Rpb25fKSB7XHJcbiAgICAgICAgcHJlZml4ID0gcmVwby5wZXJzaXN0ZW50Q29ubmVjdGlvbl8uaWQgKyAnOic7XHJcbiAgICB9XHJcbiAgICBsb2cocHJlZml4LCAuLi52YXJBcmdzKTtcclxufVxyXG5mdW5jdGlvbiByZXBvQ2FsbE9uQ29tcGxldGVDYWxsYmFjayhyZXBvLCBjYWxsYmFjaywgc3RhdHVzLCBlcnJvclJlYXNvbikge1xyXG4gICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgZXhjZXB0aW9uR3VhcmQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAoc3RhdHVzIHx8ICdlcnJvcicpLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZWFzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICc6ICcgKyBlcnJvclJlYXNvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdHJhbnNhY3Rpb24sIGFkZHMgaXQgdG8gdGhlIHRyYW5zYWN0aW9ucyB3ZSdyZSB0cmFja2luZywgYW5kXHJcbiAqIHNlbmRzIGl0IHRvIHRoZSBzZXJ2ZXIgaWYgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCBhdCB3aGljaCB0byBkbyB0cmFuc2FjdGlvbi5cclxuICogQHBhcmFtIHRyYW5zYWN0aW9uVXBkYXRlIC0gVXBkYXRlIGNhbGxiYWNrLlxyXG4gKiBAcGFyYW0gb25Db21wbGV0ZSAtIENvbXBsZXRpb24gY2FsbGJhY2suXHJcbiAqIEBwYXJhbSB1bndhdGNoZXIgLSBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHRyYW5zYWN0aW9uIG5vIGxvbmdlclxyXG4gKiBuZWVkIGRhdGEgdXBkYXRlcyBmb3IgYHBhdGhgLlxyXG4gKiBAcGFyYW0gYXBwbHlMb2NhbGx5IC0gV2hldGhlciBvciBub3QgdG8gbWFrZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyB2aXNpYmxlXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvU3RhcnRUcmFuc2FjdGlvbihyZXBvLCBwYXRoLCB0cmFuc2FjdGlvblVwZGF0ZSwgb25Db21wbGV0ZSwgdW53YXRjaGVyLCBhcHBseUxvY2FsbHkpIHtcclxuICAgIHJlcG9Mb2cocmVwbywgJ3RyYW5zYWN0aW9uIG9uICcgKyBwYXRoKTtcclxuICAgIC8vIEluaXRpYWxpemUgdHJhbnNhY3Rpb24uXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcclxuICAgICAgICBwYXRoLFxyXG4gICAgICAgIHVwZGF0ZTogdHJhbnNhY3Rpb25VcGRhdGUsXHJcbiAgICAgICAgb25Db21wbGV0ZSxcclxuICAgICAgICAvLyBPbmUgb2YgVHJhbnNhY3Rpb25TdGF0dXMgZW51bXMuXHJcbiAgICAgICAgc3RhdHVzOiBudWxsLFxyXG4gICAgICAgIC8vIFVzZWQgd2hlbiBjb21iaW5pbmcgdHJhbnNhY3Rpb25zIGF0IGRpZmZlcmVudCBsb2NhdGlvbnMgdG8gZmlndXJlIG91dFxyXG4gICAgICAgIC8vIHdoaWNoIG9uZSBnb2VzIGZpcnN0LlxyXG4gICAgICAgIG9yZGVyOiBMVUlER2VuZXJhdG9yKCksXHJcbiAgICAgICAgLy8gV2hldGhlciB0byByYWlzZSBsb2NhbCBldmVudHMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgYXBwbHlMb2NhbGx5LFxyXG4gICAgICAgIC8vIENvdW50IG9mIGhvdyBtYW55IHRpbWVzIHdlJ3ZlIHJldHJpZWQgdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgICAgIHJldHJ5Q291bnQ6IDAsXHJcbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2FsbCB0byBjbGVhbiB1cCBvdXIgLm9uKCkgbGlzdGVuZXIuXHJcbiAgICAgICAgdW53YXRjaGVyLFxyXG4gICAgICAgIC8vIFN0b3JlcyB3aHkgYSB0cmFuc2FjdGlvbiB3YXMgYWJvcnRlZC5cclxuICAgICAgICBhYm9ydFJlYXNvbjogbnVsbCxcclxuICAgICAgICBjdXJyZW50V3JpdGVJZDogbnVsbCxcclxuICAgICAgICBjdXJyZW50SW5wdXRTbmFwc2hvdDogbnVsbCxcclxuICAgICAgICBjdXJyZW50T3V0cHV0U25hcHNob3RSYXc6IG51bGwsXHJcbiAgICAgICAgY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQ6IG51bGxcclxuICAgIH07XHJcbiAgICAvLyBSdW4gdHJhbnNhY3Rpb24gaW5pdGlhbGx5LlxyXG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gcmVwb0dldExhdGVzdFN0YXRlKHJlcG8sIHBhdGgsIHVuZGVmaW5lZCk7XHJcbiAgICB0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCA9IGN1cnJlbnRTdGF0ZTtcclxuICAgIGNvbnN0IG5ld1ZhbCA9IHRyYW5zYWN0aW9uLnVwZGF0ZShjdXJyZW50U3RhdGUudmFsKCkpO1xyXG4gICAgaWYgKG5ld1ZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gQWJvcnQgdHJhbnNhY3Rpb24uXHJcbiAgICAgICAgdHJhbnNhY3Rpb24udW53YXRjaGVyKCk7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmF3ID0gbnVsbDtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25Db21wbGV0ZShudWxsLCBmYWxzZSwgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3VmFsLCB0cmFuc2FjdGlvbi5wYXRoKTtcclxuICAgICAgICAvLyBNYXJrIGFzIHJ1biBhbmQgYWRkIHRvIG91ciBxdWV1ZS5cclxuICAgICAgICB0cmFuc2FjdGlvbi5zdGF0dXMgPSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLztcclxuICAgICAgICBjb25zdCBxdWV1ZU5vZGUgPSB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZVF1ZXVlID0gdHJlZUdldFZhbHVlKHF1ZXVlTm9kZSkgfHwgW107XHJcbiAgICAgICAgbm9kZVF1ZXVlLnB1c2godHJhbnNhY3Rpb24pO1xyXG4gICAgICAgIHRyZWVTZXRWYWx1ZShxdWV1ZU5vZGUsIG5vZGVRdWV1ZSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHZpc2libGVEYXRhIGFuZCByYWlzZSBldmVudHNcclxuICAgICAgICAvLyBOb3RlOiBXZSBpbnRlbnRpb25hbGx5IHJhaXNlIGV2ZW50cyBhZnRlciB1cGRhdGluZyBhbGwgb2Ygb3VyXHJcbiAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSB1c2VyIGNvdWxkIHN0YXJ0IG5ldyB0cmFuc2FjdGlvbnMgZnJvbSB0aGVcclxuICAgICAgICAvLyBldmVudCBjYWxsYmFja3MuXHJcbiAgICAgICAgbGV0IHByaW9yaXR5Rm9yTm9kZTtcclxuICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbCA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgbmV3VmFsICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIGNvbnRhaW5zKG5ld1ZhbCwgJy5wcmlvcml0eScpKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XHJcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IHNhZmVHZXQobmV3VmFsLCAnLnByaW9yaXR5Jyk7XHJcbiAgICAgICAgICAgIGFzc2VydChpc1ZhbGlkUHJpb3JpdHkocHJpb3JpdHlGb3JOb2RlKSwgJ0ludmFsaWQgcHJpb3JpdHkgcmV0dXJuZWQgYnkgdHJhbnNhY3Rpb24uICcgK1xyXG4gICAgICAgICAgICAgICAgJ1ByaW9yaXR5IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gc3luY1RyZWVDYWxjQ29tcGxldGVFdmVudENhY2hlKHJlcG8uc2VydmVyU3luY1RyZWVfLCBwYXRoKSB8fFxyXG4gICAgICAgICAgICAgICAgQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XHJcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcnZlclZhbHVlcyA9IHJlcG9HZW5lcmF0ZVNlcnZlclZhbHVlcyhyZXBvKTtcclxuICAgICAgICBjb25zdCBuZXdOb2RlVW5yZXNvbHZlZCA9IG5vZGVGcm9tSlNPTihuZXdWYWwsIHByaW9yaXR5Rm9yTm9kZSk7XHJcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3Tm9kZVVucmVzb2x2ZWQsIGN1cnJlbnRTdGF0ZSwgc2VydmVyVmFsdWVzKTtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBuZXdOb2RlVW5yZXNvbHZlZDtcclxuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG5ld05vZGU7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQgPSByZXBvR2V0TmV4dFdyaXRlSWQocmVwbyk7XHJcbiAgICAgICAgY29uc3QgZXZlbnRzID0gc3luY1RyZWVBcHBseVVzZXJPdmVyd3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIG5ld05vZGUsIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cmFuc2FjdGlvbi5hcHBseUxvY2FsbHkpO1xyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgcmVwb1NlbmRSZWFkeVRyYW5zYWN0aW9ucyhyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSBleGNsdWRlU2V0cyAtIEEgc3BlY2lmaWMgc2V0IHRvIGV4Y2x1ZGVcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCBwYXRoLCBleGNsdWRlU2V0cykge1xyXG4gICAgcmV0dXJuIChzeW5jVHJlZUNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHBhdGgsIGV4Y2x1ZGVTZXRzKSB8fFxyXG4gICAgICAgIENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcclxufVxyXG4vKipcclxuICogU2VuZHMgYW55IGFscmVhZHktcnVuIHRyYW5zYWN0aW9ucyB0aGF0IGFyZW4ndCB3YWl0aW5nIGZvciBvdXRzdGFuZGluZ1xyXG4gKiB0cmFuc2FjdGlvbnMgdG8gY29tcGxldGUuXHJcbiAqXHJcbiAqIEV4dGVybmFsbHkgaXQncyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIGJ1dCBpdCBjYWxscyBpdHNlbGYgcmVjdXJzaXZlbHlcclxuICogd2l0aCBhIHBhcnRpY3VsYXIgdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byByZWN1cnNlIHRocm91Z2ggdGhlIHRyZWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlIC0gdHJhbnNhY3Rpb25RdWV1ZVRyZWUgbm9kZSB0byBzdGFydCBhdC5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgbm9kZSA9IHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKSB7XHJcbiAgICAvLyBCZWZvcmUgcmVjdXJzaW5nLCBtYWtlIHN1cmUgYW55IGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgYXJlIHJlbW92ZWQuXHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXBvUHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGUocmVwbywgbm9kZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodHJlZUdldFZhbHVlKG5vZGUpKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSByZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIG5vZGUpO1xyXG4gICAgICAgIGFzc2VydChxdWV1ZS5sZW5ndGggPiAwLCAnU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZScpO1xyXG4gICAgICAgIGNvbnN0IGFsbFJ1biA9IHF1ZXVlLmV2ZXJ5KCh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLyk7XHJcbiAgICAgICAgLy8gSWYgdGhleSdyZSBhbGwgcnVuIChhbmQgbm90IHNlbnQpLCB3ZSBjYW4gc2VuZCB0aGVtLiAgRWxzZSwgd2UgbXVzdCB3YWl0LlxyXG4gICAgICAgIGlmIChhbGxSdW4pIHtcclxuICAgICAgICAgICAgcmVwb1NlbmRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHRyZWVHZXRQYXRoKG5vZGUpLCBxdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHJlZUhhc0NoaWxkcmVuKG5vZGUpKSB7XHJcbiAgICAgICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgICAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIGNoaWxkTm9kZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdpdmVuIGEgbGlzdCBvZiBydW4gdHJhbnNhY3Rpb25zLCBzZW5kIHRoZW0gdG8gdGhlIHNlcnZlciBhbmQgdGhlbiBoYW5kbGVcclxuICogdGhlIHJlc3VsdCAoc3VjY2VzcyBvciBmYWlsdXJlKS5cclxuICpcclxuICogQHBhcmFtIHBhdGggLSBUaGUgbG9jYXRpb24gb2YgdGhlIHF1ZXVlLlxyXG4gKiBAcGFyYW0gcXVldWUgLSBRdWV1ZSBvZiB0cmFuc2FjdGlvbnMgdW5kZXIgdGhlIHNwZWNpZmllZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9TZW5kVHJhbnNhY3Rpb25RdWV1ZShyZXBvLCBwYXRoLCBxdWV1ZSkge1xyXG4gICAgLy8gTWFyayB0cmFuc2FjdGlvbnMgYXMgc2VudCBhbmQgaW5jcmVtZW50IHJldHJ5IGNvdW50IVxyXG4gICAgY29uc3Qgc2V0c1RvSWdub3JlID0gcXVldWUubWFwKHR4biA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHR4bi5jdXJyZW50V3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgY29uc3QgbGF0ZXN0U3RhdGUgPSByZXBvR2V0TGF0ZXN0U3RhdGUocmVwbywgcGF0aCwgc2V0c1RvSWdub3JlKTtcclxuICAgIGxldCBzbmFwVG9TZW5kID0gbGF0ZXN0U3RhdGU7XHJcbiAgICBjb25zdCBsYXRlc3RIYXNoID0gbGF0ZXN0U3RhdGUuaGFzaCgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHR4biA9IHF1ZXVlW2ldO1xyXG4gICAgICAgIGFzc2VydCh0eG4uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLywgJ3RyeVRvU2VuZFRyYW5zYWN0aW9uUXVldWVfOiBpdGVtcyBpbiBxdWV1ZSBzaG91bGQgYWxsIGJlIHJ1bi4nKTtcclxuICAgICAgICB0eG4uc3RhdHVzID0gMSAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UICovO1xyXG4gICAgICAgIHR4bi5yZXRyeUNvdW50Kys7XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGgsIHR4bi5wYXRoKTtcclxuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgdGhlIG91dHB1dCBzbmFwc2hvdCBtdXN0IGJlIGRlZmluZWQuXHJcbiAgICAgICAgc25hcFRvU2VuZCA9IHNuYXBUb1NlbmQudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoIC8qKiBAdHlwZSB7IU5vZGV9ICovLCB0eG4uY3VycmVudE91dHB1dFNuYXBzaG90UmF3KTtcclxuICAgIH1cclxuICAgIGNvbnN0IGRhdGFUb1NlbmQgPSBzbmFwVG9TZW5kLnZhbCh0cnVlKTtcclxuICAgIGNvbnN0IHBhdGhUb1NlbmQgPSBwYXRoO1xyXG4gICAgLy8gU2VuZCB0aGUgcHV0LlxyXG4gICAgcmVwby5zZXJ2ZXJfLnB1dChwYXRoVG9TZW5kLnRvU3RyaW5nKCksIGRhdGFUb1NlbmQsIChzdGF0dXMpID0+IHtcclxuICAgICAgICByZXBvTG9nKHJlcG8sICd0cmFuc2FjdGlvbiBwdXQgcmVzcG9uc2UnLCB7XHJcbiAgICAgICAgICAgIHBhdGg6IHBhdGhUb1NlbmQudG9TdHJpbmcoKSxcclxuICAgICAgICAgICAgc3RhdHVzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcclxuICAgICAgICAgICAgLy8gUXVldWUgdXAgdGhlIGNhbGxiYWNrcyBhbmQgZmlyZSB0aGVtIGFmdGVyIGNsZWFuaW5nIHVwIGFsbCBvZiBvdXJcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmVcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIG9yIHNldHMuXHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSAyIC8qIFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCAqLztcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5ldmVyIHVuc2V0IHRoZSBvdXRwdXQgc25hcHNob3QsIGFuZCBnaXZlbiB0aGF0IHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cmFuc2FjdGlvbiBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIGJlIHNldFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKCgpID0+IHF1ZXVlW2ldLm9uQ29tcGxldGUobnVsbCwgdHJ1ZSwgcXVldWVbaV0uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdyByZW1vdmUgdGhlIGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMuXHJcbiAgICAgICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCB0cmVlU3ViVHJlZShyZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXywgcGF0aCkpO1xyXG4gICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgcGVuZGluZyB0cmFuc2FjdGlvbnMgdGhhdCB3ZSBjYW4gbm93IHNlbmQuXHJcbiAgICAgICAgICAgIHJlcG9TZW5kUmVhZHlUcmFuc2FjdGlvbnMocmVwbywgcmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8pO1xyXG4gICAgICAgICAgICBldmVudFF1ZXVlUmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChyZXBvLmV2ZW50UXVldWVfLCBwYXRoLCBldmVudHMpO1xyXG4gICAgICAgICAgICAvLyBGaW5hbGx5LCB0cmlnZ2VyIG9uQ29tcGxldGUgY2FsbGJhY2tzLlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXhjZXB0aW9uR3VhcmQoY2FsbGJhY2tzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFyZSBubyBsb25nZXIgc2VudC4gIFVwZGF0ZSB0aGVpciBzdGF0dXMgYXBwcm9wcmlhdGVseS5cclxuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ2RhdGFzdGFsZScpIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSAzIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlNFTlRfTkVFRFNfQUJPUlQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDAgLyogVHJhbnNhY3Rpb25TdGF0dXMuUlVOICovO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oJ3RyYW5zYWN0aW9uIGF0ICcgKyBwYXRoVG9TZW5kLnRvU3RyaW5nKCkgKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5hYm9ydFJlYXNvbiA9IHN0YXR1cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXBvUmVydW5UcmFuc2FjdGlvbnMocmVwbywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgbGF0ZXN0SGFzaCk7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmRzIGFsbCB0cmFuc2FjdGlvbnMgZGVwZW5kZW50IG9uIHRoZSBkYXRhIGF0IGNoYW5nZWRQYXRoIGFuZCByZXJ1bnMgdGhlbS5cclxuICpcclxuICogU2hvdWxkIGJlIGNhbGxlZCBhbnkgdGltZSBjYWNoZWQgZGF0YSBjaGFuZ2VzLlxyXG4gKlxyXG4gKiBSZXR1cm4gdGhlIGhpZ2hlc3QgcGF0aCB0aGF0IHdhcyBhZmZlY3RlZCBieSByZXJ1bm5pbmcgdHJhbnNhY3Rpb25zLiBUaGlzXHJcbiAqIGlzIHRoZSBwYXRoIGF0IHdoaWNoIGV2ZW50cyBuZWVkIHRvIGJlIHJhaXNlZCBmb3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGFuZ2VkUGF0aCAtIFRoZSBwYXRoIGluIG1lcmdlZERhdGEgdGhhdCBjaGFuZ2VkLlxyXG4gKiBAcmV0dXJucyBUaGUgcm9vdG1vc3QgcGF0aCB0aGF0IHdhcyBhZmZlY3RlZCBieSByZXJ1bm5pbmcgdHJhbnNhY3Rpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb1JlcnVuVHJhbnNhY3Rpb25zKHJlcG8sIGNoYW5nZWRQYXRoKSB7XHJcbiAgICBjb25zdCByb290TW9zdFRyYW5zYWN0aW9uTm9kZSA9IHJlcG9HZXRBbmNlc3RvclRyYW5zYWN0aW9uTm9kZShyZXBvLCBjaGFuZ2VkUGF0aCk7XHJcbiAgICBjb25zdCBwYXRoID0gdHJlZUdldFBhdGgocm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUpO1xyXG4gICAgY29uc3QgcXVldWUgPSByZXBvQnVpbGRUcmFuc2FjdGlvblF1ZXVlKHJlcG8sIHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlKTtcclxuICAgIHJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUocmVwbywgcXVldWUsIHBhdGgpO1xyXG4gICAgcmV0dXJuIHBhdGg7XHJcbn1cclxuLyoqXHJcbiAqIERvZXMgYWxsIHRoZSB3b3JrIG9mIHJlcnVubmluZyB0cmFuc2FjdGlvbnMgKGFzIHdlbGwgYXMgY2xlYW5zIHVwIGFib3J0ZWRcclxuICogdHJhbnNhY3Rpb25zIGFuZCB3aGF0bm90KS5cclxuICpcclxuICogQHBhcmFtIHF1ZXVlIC0gVGhlIHF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB0byBydW4uXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdGhlIHF1ZXVlIGlzIGZvci5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9SZXJ1blRyYW5zYWN0aW9uUXVldWUocmVwbywgcXVldWUsIHBhdGgpIHtcclxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8hXHJcbiAgICB9XHJcbiAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgLy8gdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yXHJcbiAgICAvLyBzZXRzLlxyXG4gICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICBsZXQgZXZlbnRzID0gW107XHJcbiAgICAvLyBJZ25vcmUgYWxsIG9mIHRoZSBzZXRzIHdlJ3JlIGdvaW5nIHRvIHJlLXJ1bi5cclxuICAgIGNvbnN0IHR4bnNUb1JlcnVuID0gcXVldWUuZmlsdGVyKHEgPT4ge1xyXG4gICAgICAgIHJldHVybiBxLnN0YXR1cyA9PT0gMCAvKiBUcmFuc2FjdGlvblN0YXR1cy5SVU4gKi87XHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHNldHNUb0lnbm9yZSA9IHR4bnNUb1JlcnVuLm1hcChxID0+IHtcclxuICAgICAgICByZXR1cm4gcS5jdXJyZW50V3JpdGVJZDtcclxuICAgIH0pO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcXVldWVbaV07XHJcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gbmV3UmVsYXRpdmVQYXRoKHBhdGgsIHRyYW5zYWN0aW9uLnBhdGgpO1xyXG4gICAgICAgIGxldCBhYm9ydFRyYW5zYWN0aW9uID0gZmFsc2UsIGFib3J0UmVhc29uO1xyXG4gICAgICAgIGFzc2VydChyZWxhdGl2ZVBhdGggIT09IG51bGwsICdyZXJ1blRyYW5zYWN0aW9uc1VuZGVyTm9kZV86IHJlbGF0aXZlUGF0aCBzaG91bGQgbm90IGJlIG51bGwuJyk7XHJcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gNCAvKiBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCAqLykge1xyXG4gICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgYWJvcnRSZWFzb24gPSB0cmFuc2FjdGlvbi5hYm9ydFJlYXNvbjtcclxuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLykge1xyXG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ucmV0cnlDb3VudCA+PSBNQVhfVFJBTlNBQ1RJT05fUkVUUklFUykge1xyXG4gICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhYm9ydFJlYXNvbiA9ICdtYXhyZXRyeSc7XHJcbiAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIHJlcnVucyBhIHRyYW5zYWN0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHJlcG9HZXRMYXRlc3RTdGF0ZShyZXBvLCB0cmFuc2FjdGlvbi5wYXRoLCBzZXRzVG9JZ25vcmUpO1xyXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudElucHV0U25hcHNob3QgPSBjdXJyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0RhdGEgPSBxdWV1ZVtpXS51cGRhdGUoY3VycmVudE5vZGUudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3RGF0YSwgdHJhbnNhY3Rpb24ucGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0RhdGFOb2RlID0gbm9kZUZyb21KU09OKG5ld0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cGxpY2l0UHJpb3JpdHkgPSB0eXBlb2YgbmV3RGF0YSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKG5ld0RhdGEsICcucHJpb3JpdHknKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0V4cGxpY2l0UHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCB0aGUgb2xkIHByaW9yaXR5IGlmIHRoZXJlIHdhc24ndCBhIHByaW9yaXR5IGV4cGxpY2l0bHkgc3BlY2lmaWVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhTm9kZSA9IG5ld0RhdGFOb2RlLnVwZGF0ZVByaW9yaXR5KGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRXcml0ZUlkID0gdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyVmFsdWVzID0gcmVwb0dlbmVyYXRlU2VydmVyVmFsdWVzKHJlcG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGVSZXNvbHZlZCA9IHJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3RGF0YU5vZGUsIGN1cnJlbnROb2RlLCBzZXJ2ZXJWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld0RhdGFOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkID0gbmV3Tm9kZVJlc29sdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkID0gcmVwb0dldE5leHRXcml0ZUlkKHJlcG8pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE11dGF0ZXMgc2V0c1RvSWdub3JlIGluIHBsYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0c1RvSWdub3JlLnNwbGljZShzZXRzVG9JZ25vcmUuaW5kZXhPZihvbGRXcml0ZUlkKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFwcGx5VXNlck92ZXJ3cml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgdHJhbnNhY3Rpb24ucGF0aCwgbmV3Tm9kZVJlc29sdmVkLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJhbnNhY3Rpb24uYXBwbHlMb2NhbGx5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChzeW5jVHJlZUFja1VzZXJXcml0ZShyZXBvLnNlcnZlclN5bmNUcmVlXywgb2xkV3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSAnbm9kYXRhJztcclxuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNUcmVlQWNrVXNlcldyaXRlKHJlcG8uc2VydmVyU3luY1RyZWVfLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHBhdGgsIGV2ZW50cyk7XHJcbiAgICAgICAgZXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKGFib3J0VHJhbnNhY3Rpb24pIHtcclxuICAgICAgICAgICAgLy8gQWJvcnQuXHJcbiAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDIgLyogVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEICovO1xyXG4gICAgICAgICAgICAvLyBSZW1vdmluZyBhIGxpc3RlbmVyIGNhbiB0cmlnZ2VyIHBydW5pbmcgd2hpY2ggY2FuIG11Y2sgd2l0aFxyXG4gICAgICAgICAgICAvLyBtZXJnZWREYXRhL3Zpc2libGVEYXRhIChhcyBpdCBwcnVuZXMgZGF0YSkuIFNvIGRlZmVyIHRoZSB1bndhdGNoZXJcclxuICAgICAgICAgICAgLy8gdW50aWwgd2UncmUgZG9uZS5cclxuICAgICAgICAgICAgKGZ1bmN0aW9uICh1bndhdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodW53YXRjaGVyLCBNYXRoLmZsb29yKDApKTtcclxuICAgICAgICAgICAgfSkocXVldWVbaV0udW53YXRjaGVyKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLm9uQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhYm9ydFJlYXNvbiA9PT0gJ25vZGF0YScpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCgoKSA9PiBxdWV1ZVtpXS5vbkNvbXBsZXRlKG51bGwsIGZhbHNlLCBxdWV1ZVtpXS5jdXJyZW50SW5wdXRTbmFwc2hvdCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goKCkgPT4gcXVldWVbaV0ub25Db21wbGV0ZShuZXcgRXJyb3IoYWJvcnRSZWFzb24pLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2xlYW4gdXAgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cclxuICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCByZXBvLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XHJcbiAgICAvLyBOb3cgZmlyZSBjYWxsYmFja3MsIG5vdyB0aGF0IHdlJ3JlIGluIGEgZ29vZCwga25vd24gc3RhdGUuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XHJcbiAgICB9XHJcbiAgICAvLyBUcnkgdG8gc2VuZCB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0IHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICByZXBvU2VuZFJlYWR5VHJhbnNhY3Rpb25zKHJlcG8sIHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcm9vdG1vc3QgYW5jZXN0b3Igbm9kZSBvZiB0aGUgc3BlY2lmaWVkIHBhdGggdGhhdCBoYXMgYSBwZW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9uIG9uIGl0LCBvciBqdXN0IHJldHVybnMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBwYXRoIGlmIHRoZXJlIGFyZVxyXG4gKiBubyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvbiBhbnkgYW5jZXN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGxvY2F0aW9uIHRvIHN0YXJ0IGF0LlxyXG4gKiBAcmV0dXJucyBUaGUgcm9vdG1vc3Qgbm9kZSB3aXRoIGEgdHJhbnNhY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUocmVwbywgcGF0aCkge1xyXG4gICAgbGV0IGZyb250O1xyXG4gICAgLy8gU3RhcnQgYXQgdGhlIHJvb3QgYW5kIHdhbGsgZGVlcGVyIGludG8gdGhlIHRyZWUgdG93YXJkcyBwYXRoIHVudGlsIHdlXHJcbiAgICAvLyBmaW5kIGEgbm9kZSB3aXRoIHBlbmRpbmcgdHJhbnNhY3Rpb25zLlxyXG4gICAgbGV0IHRyYW5zYWN0aW9uTm9kZSA9IHJlcG8udHJhbnNhY3Rpb25RdWV1ZVRyZWVfO1xyXG4gICAgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB3aGlsZSAoZnJvbnQgIT09IG51bGwgJiYgdHJlZUdldFZhbHVlKHRyYW5zYWN0aW9uTm9kZSkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uTm9kZSA9IHRyZWVTdWJUcmVlKHRyYW5zYWN0aW9uTm9kZSwgZnJvbnQpO1xyXG4gICAgICAgIHBhdGggPSBwYXRoUG9wRnJvbnQocGF0aCk7XHJcbiAgICAgICAgZnJvbnQgPSBwYXRoR2V0RnJvbnQocGF0aCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25Ob2RlO1xyXG59XHJcbi8qKlxyXG4gKiBCdWlsZHMgdGhlIHF1ZXVlIG9mIGFsbCB0cmFuc2FjdGlvbnMgYXQgb3IgYmVsb3cgdGhlIHNwZWNpZmllZFxyXG4gKiB0cmFuc2FjdGlvbk5vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbk5vZGVcclxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBxdWV1ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9CdWlsZFRyYW5zYWN0aW9uUXVldWUocmVwbywgdHJhbnNhY3Rpb25Ob2RlKSB7XHJcbiAgICAvLyBXYWxrIGFueSBjaGlsZCB0cmFuc2FjdGlvbiBxdWV1ZXMgYW5kIGFnZ3JlZ2F0ZSB0aGVtIGludG8gYSBzaW5nbGUgcXVldWUuXHJcbiAgICBjb25zdCB0cmFuc2FjdGlvblF1ZXVlID0gW107XHJcbiAgICByZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlKHJlcG8sIHRyYW5zYWN0aW9uTm9kZSwgdHJhbnNhY3Rpb25RdWV1ZSk7XHJcbiAgICAvLyBTb3J0IHRoZW0gYnkgdGhlIG9yZGVyIHRoZSB0cmFuc2FjdGlvbnMgd2VyZSBjcmVhdGVkLlxyXG4gICAgdHJhbnNhY3Rpb25RdWV1ZS5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcik7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb25RdWV1ZTtcclxufVxyXG5mdW5jdGlvbiByZXBvQWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlKHJlcG8sIG5vZGUsIHF1ZXVlKSB7XHJcbiAgICBjb25zdCBub2RlUXVldWUgPSB0cmVlR2V0VmFsdWUobm9kZSk7XHJcbiAgICBpZiAobm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlUXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcXVldWUucHVzaChub2RlUXVldWVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRyZWVGb3JFYWNoQ2hpbGQobm9kZSwgY2hpbGQgPT4ge1xyXG4gICAgICAgIHJlcG9BZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGUocmVwbywgY2hpbGQsIHF1ZXVlKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmUgQ09NUExFVEVEIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGlzIG5vZGUgaW4gdGhlIHRyYW5zYWN0aW9uUXVldWVUcmVlXy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBub2RlKSB7XHJcbiAgICBjb25zdCBxdWV1ZSA9IHRyZWVHZXRWYWx1ZShub2RlKTtcclxuICAgIGlmIChxdWV1ZSkge1xyXG4gICAgICAgIGxldCB0byA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IDA7IGZyb20gPCBxdWV1ZS5sZW5ndGg7IGZyb20rKykge1xyXG4gICAgICAgICAgICBpZiAocXVldWVbZnJvbV0uc3RhdHVzICE9PSAyIC8qIFRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFRCAqLykge1xyXG4gICAgICAgICAgICAgICAgcXVldWVbdG9dID0gcXVldWVbZnJvbV07XHJcbiAgICAgICAgICAgICAgICB0bysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlLmxlbmd0aCA9IHRvO1xyXG4gICAgICAgIHRyZWVTZXRWYWx1ZShub2RlLCBxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUgOiB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgdHJlZUZvckVhY2hDaGlsZChub2RlLCBjaGlsZE5vZGUgPT4ge1xyXG4gICAgICAgIHJlcG9QcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZShyZXBvLCBjaGlsZE5vZGUpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEFib3J0cyBhbGwgdHJhbnNhY3Rpb25zIG9uIGFuY2VzdG9ycyBvciBkZXNjZW5kYW50cyBvZiB0aGUgc3BlY2lmaWVkIHBhdGguXHJcbiAqIENhbGxlZCB3aGVuIGRvaW5nIGEgc2V0KCkgb3IgdXBkYXRlKCkgc2luY2Ugd2UgY29uc2lkZXIgdGhlbSBpbmNvbXBhdGlibGVcclxuICogd2l0aCB0cmFuc2FjdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXRoIC0gUGF0aCBmb3Igd2hpY2ggd2Ugd2FudCB0byBhYm9ydCByZWxhdGVkIHRyYW5zYWN0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9BYm9ydFRyYW5zYWN0aW9ucyhyZXBvLCBwYXRoKSB7XHJcbiAgICBjb25zdCBhZmZlY3RlZFBhdGggPSB0cmVlR2V0UGF0aChyZXBvR2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGUocmVwbywgcGF0aCkpO1xyXG4gICAgY29uc3QgdHJhbnNhY3Rpb25Ob2RlID0gdHJlZVN1YlRyZWUocmVwby50cmFuc2FjdGlvblF1ZXVlVHJlZV8sIHBhdGgpO1xyXG4gICAgdHJlZUZvckVhY2hBbmNlc3Rvcih0cmFuc2FjdGlvbk5vZGUsIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlKHJlcG8sIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgdHJhbnNhY3Rpb25Ob2RlKTtcclxuICAgIHRyZWVGb3JFYWNoRGVzY2VuZGFudCh0cmFuc2FjdGlvbk5vZGUsIChub2RlKSA9PiB7XHJcbiAgICAgICAgcmVwb0Fib3J0VHJhbnNhY3Rpb25zT25Ob2RlKHJlcG8sIG5vZGUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWZmZWN0ZWRQYXRoO1xyXG59XHJcbi8qKlxyXG4gKiBBYm9ydCB0cmFuc2FjdGlvbnMgc3RvcmVkIGluIHRoaXMgdHJhbnNhY3Rpb24gcXVldWUgbm9kZS5cclxuICpcclxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGFib3J0IHRyYW5zYWN0aW9ucyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvQWJvcnRUcmFuc2FjdGlvbnNPbk5vZGUocmVwbywgbm9kZSkge1xyXG4gICAgY29uc3QgcXVldWUgPSB0cmVlR2V0VmFsdWUobm9kZSk7XHJcbiAgICBpZiAocXVldWUpIHtcclxuICAgICAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91clxyXG4gICAgICAgIC8vIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZSB0aGUgY2FsbGJhY2sgY291bGQgdHJpZ2dlciBtb3JlIHRyYW5zYWN0aW9uc1xyXG4gICAgICAgIC8vIG9yIHNldHMuXHJcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgLy8gR28gdGhyb3VnaCBxdWV1ZS4gIEFueSBhbHJlYWR5LXNlbnQgdHJhbnNhY3Rpb25zIG11c3QgYmUgbWFya2VkIGZvclxyXG4gICAgICAgIC8vIGFib3J0LCB3aGlsZSB0aGUgdW5zZW50IG9uZXMgY2FuIGJlIGltbWVkaWF0ZWx5IGFib3J0ZWQgYW5kIHJlbW92ZWQuXHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGxldCBsYXN0U2VudCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gMyAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UX05FRURTX0FCT1JUICovKSA7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXVlW2ldLnN0YXR1cyA9PT0gMSAvKiBUcmFuc2FjdGlvblN0YXR1cy5TRU5UICovKSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQobGFzdFNlbnQgPT09IGkgLSAxLCAnQWxsIFNFTlQgaXRlbXMgc2hvdWxkIGJlIGF0IGJlZ2lubmluZyBvZiBxdWV1ZS4nKTtcclxuICAgICAgICAgICAgICAgIGxhc3RTZW50ID0gaTtcclxuICAgICAgICAgICAgICAgIC8vIE1hcmsgdHJhbnNhY3Rpb24gZm9yIGFib3J0IHdoZW4gaXQgY29tZXMgYmFjay5cclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IDMgLyogVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVCAqLztcclxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmFib3J0UmVhc29uID0gJ3NldCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhc3NlcnQocXVldWVbaV0uc3RhdHVzID09PSAwIC8qIFRyYW5zYWN0aW9uU3RhdHVzLlJVTiAqLywgJ1VuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0Jyk7XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gYWJvcnQgaXQgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS51bndhdGNoZXIoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1RyZWVBY2tVc2VyV3JpdGUocmVwby5zZXJ2ZXJTeW5jVHJlZV8sIHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKHF1ZXVlW2ldLm9uQ29tcGxldGUuYmluZChudWxsLCBuZXcgRXJyb3IoJ3NldCcpLCBmYWxzZSwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsYXN0U2VudCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gV2UncmUgbm90IHdhaXRpbmcgZm9yIGFueSBzZW50IHRyYW5zYWN0aW9ucy4gIFdlIGNhbiBjbGVhciB0aGUgcXVldWUuXHJcbiAgICAgICAgICAgIHRyZWVTZXRWYWx1ZShub2RlLCB1bmRlZmluZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFuc2FjdGlvbnMgd2UgYWJvcnRlZC5cclxuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gbGFzdFNlbnQgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3cgZmlyZSB0aGUgY2FsbGJhY2tzLlxyXG4gICAgICAgIGV2ZW50UXVldWVSYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHJlcG8uZXZlbnRRdWV1ZV8sIHRyZWVHZXRQYXRoKG5vZGUpLCBldmVudHMpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4Y2VwdGlvbkd1YXJkKGNhbGxiYWNrc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbmZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aFN0cmluZykge1xyXG4gICAgbGV0IHBhdGhTdHJpbmdEZWNvZGVkID0gJyc7XHJcbiAgICBjb25zdCBwaWVjZXMgPSBwYXRoU3RyaW5nLnNwbGl0KCcvJyk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpZWNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChwaWVjZXNbaV0ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBsZXQgcGllY2UgPSBwaWVjZXNbaV07XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBwaWVjZSA9IGRlY29kZVVSSUNvbXBvbmVudChwaWVjZS5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICBwYXRoU3RyaW5nRGVjb2RlZCArPSAnLycgKyBwaWVjZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aFN0cmluZ0RlY29kZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIGtleSB2YWx1ZSBoYXNoXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWNvZGVRdWVyeShxdWVyeVN0cmluZykge1xyXG4gICAgY29uc3QgcmVzdWx0cyA9IHt9O1xyXG4gICAgaWYgKHF1ZXJ5U3RyaW5nLmNoYXJBdCgwKSA9PT0gJz8nKSB7XHJcbiAgICAgICAgcXVlcnlTdHJpbmcgPSBxdWVyeVN0cmluZy5zdWJzdHJpbmcoMSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcXVlcnlTdHJpbmcuc3BsaXQoJyYnKSkge1xyXG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qga3YgPSBzZWdtZW50LnNwbGl0KCc9Jyk7XHJcbiAgICAgICAgaWYgKGt2Lmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICByZXN1bHRzW2RlY29kZVVSSUNvbXBvbmVudChrdlswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KGt2WzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgcXVlcnkgc2VnbWVudCAnJHtzZWdtZW50fScgaW4gcXVlcnkgJyR7cXVlcnlTdHJpbmd9J2ApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbmNvbnN0IHBhcnNlUmVwb0luZm8gPSBmdW5jdGlvbiAoZGF0YVVSTCwgbm9kZUFkbWluKSB7XHJcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBwYXJzZURhdGFiYXNlVVJMKGRhdGFVUkwpLCBuYW1lc3BhY2UgPSBwYXJzZWRVcmwubmFtZXNwYWNlO1xyXG4gICAgaWYgKHBhcnNlZFVybC5kb21haW4gPT09ICdmaXJlYmFzZS5jb20nKSB7XHJcbiAgICAgICAgZmF0YWwocGFyc2VkVXJsLmhvc3QgK1xyXG4gICAgICAgICAgICAnIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuICcgK1xyXG4gICAgICAgICAgICAnUGxlYXNlIHVzZSA8WU9VUiBGSVJFQkFTRT4uZmlyZWJhc2Vpby5jb20gaW5zdGVhZCcpO1xyXG4gICAgfVxyXG4gICAgLy8gQ2F0Y2ggY29tbW9uIGVycm9yIG9mIHVuaW5pdGlhbGl6ZWQgbmFtZXNwYWNlIHZhbHVlLlxyXG4gICAgaWYgKCghbmFtZXNwYWNlIHx8IG5hbWVzcGFjZSA9PT0gJ3VuZGVmaW5lZCcpICYmXHJcbiAgICAgICAgcGFyc2VkVXJsLmRvbWFpbiAhPT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgICAgICBmYXRhbCgnQ2Fubm90IHBhcnNlIEZpcmViYXNlIHVybC4gUGxlYXNlIHVzZSBodHRwczovLzxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbScpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFwYXJzZWRVcmwuc2VjdXJlKSB7XHJcbiAgICAgICAgd2FybklmUGFnZUlzU2VjdXJlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB3ZWJTb2NrZXRPbmx5ID0gcGFyc2VkVXJsLnNjaGVtZSA9PT0gJ3dzJyB8fCBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3NzJztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcmVwb0luZm86IG5ldyBSZXBvSW5mbyhwYXJzZWRVcmwuaG9zdCwgcGFyc2VkVXJsLnNlY3VyZSwgbmFtZXNwYWNlLCB3ZWJTb2NrZXRPbmx5LCBub2RlQWRtaW4sIFxyXG4gICAgICAgIC8qcGVyc2lzdGVuY2VLZXk9Ki8gJycsIFxyXG4gICAgICAgIC8qaW5jbHVkZU5hbWVzcGFjZUluUXVlcnlQYXJhbXM9Ki8gbmFtZXNwYWNlICE9PSBwYXJzZWRVcmwuc3ViZG9tYWluKSxcclxuICAgICAgICBwYXRoOiBuZXcgUGF0aChwYXJzZWRVcmwucGF0aFN0cmluZylcclxuICAgIH07XHJcbn07XHJcbmNvbnN0IHBhcnNlRGF0YWJhc2VVUkwgPSBmdW5jdGlvbiAoZGF0YVVSTCkge1xyXG4gICAgLy8gRGVmYXVsdCB0byBlbXB0eSBzdHJpbmdzIGluIHRoZSBldmVudCBvZiBhIG1hbGZvcm1lZCBzdHJpbmcuXHJcbiAgICBsZXQgaG9zdCA9ICcnLCBkb21haW4gPSAnJywgc3ViZG9tYWluID0gJycsIHBhdGhTdHJpbmcgPSAnJywgbmFtZXNwYWNlID0gJyc7XHJcbiAgICAvLyBBbHdheXMgZGVmYXVsdCB0byBTU0wsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkLlxyXG4gICAgbGV0IHNlY3VyZSA9IHRydWUsIHNjaGVtZSA9ICdodHRwcycsIHBvcnQgPSA0NDM7XHJcbiAgICAvLyBEb24ndCBkbyBhbnkgdmFsaWRhdGlvbiBoZXJlLiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciB2YWxpZGF0aW5nIHRoZSByZXN1bHQgb2YgcGFyc2luZy5cclxuICAgIGlmICh0eXBlb2YgZGF0YVVSTCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyBQYXJzZSBzY2hlbWUuXHJcbiAgICAgICAgbGV0IGNvbG9uSW5kID0gZGF0YVVSTC5pbmRleE9mKCcvLycpO1xyXG4gICAgICAgIGlmIChjb2xvbkluZCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHNjaGVtZSA9IGRhdGFVUkwuc3Vic3RyaW5nKDAsIGNvbG9uSW5kIC0gMSk7XHJcbiAgICAgICAgICAgIGRhdGFVUkwgPSBkYXRhVVJMLnN1YnN0cmluZyhjb2xvbkluZCArIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXJzZSBob3N0LCBwYXRoLCBhbmQgcXVlcnkgc3RyaW5nLlxyXG4gICAgICAgIGxldCBzbGFzaEluZCA9IGRhdGFVUkwuaW5kZXhPZignLycpO1xyXG4gICAgICAgIGlmIChzbGFzaEluZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgc2xhc2hJbmQgPSBkYXRhVVJMLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHF1ZXN0aW9uTWFya0luZCA9IGRhdGFVUkwuaW5kZXhPZignPycpO1xyXG4gICAgICAgIGlmIChxdWVzdGlvbk1hcmtJbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHF1ZXN0aW9uTWFya0luZCA9IGRhdGFVUkwubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBob3N0ID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgTWF0aC5taW4oc2xhc2hJbmQsIHF1ZXN0aW9uTWFya0luZCkpO1xyXG4gICAgICAgIGlmIChzbGFzaEluZCA8IHF1ZXN0aW9uTWFya0luZCkge1xyXG4gICAgICAgICAgICAvLyBGb3IgcGF0aFN0cmluZywgcXVlc3Rpb25NYXJrSW5kIHdpbGwgYWx3YXlzIGNvbWUgYWZ0ZXIgc2xhc2hJbmRcclxuICAgICAgICAgICAgcGF0aFN0cmluZyA9IGRlY29kZVBhdGgoZGF0YVVSTC5zdWJzdHJpbmcoc2xhc2hJbmQsIHF1ZXN0aW9uTWFya0luZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IGRlY29kZVF1ZXJ5KGRhdGFVUkwuc3Vic3RyaW5nKE1hdGgubWluKGRhdGFVUkwubGVuZ3RoLCBxdWVzdGlvbk1hcmtJbmQpKSk7XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnQsIHVzZSBzY2hlbWUgZm9yIGRldGVybWluaW5nIGlmIGl0J3Mgc2VjdXJlLlxyXG4gICAgICAgIGNvbG9uSW5kID0gaG9zdC5pbmRleE9mKCc6Jyk7XHJcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcclxuICAgICAgICAgICAgc2VjdXJlID0gc2NoZW1lID09PSAnaHR0cHMnIHx8IHNjaGVtZSA9PT0gJ3dzcyc7XHJcbiAgICAgICAgICAgIHBvcnQgPSBwYXJzZUludChob3N0LnN1YnN0cmluZyhjb2xvbkluZCArIDEpLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb2xvbkluZCA9IGhvc3QubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBob3N0V2l0aG91dFBvcnQgPSBob3N0LnNsaWNlKDAsIGNvbG9uSW5kKTtcclxuICAgICAgICBpZiAoaG9zdFdpdGhvdXRQb3J0LnRvTG93ZXJDYXNlKCkgPT09ICdsb2NhbGhvc3QnKSB7XHJcbiAgICAgICAgICAgIGRvbWFpbiA9ICdsb2NhbGhvc3QnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChob3N0V2l0aG91dFBvcnQuc3BsaXQoJy4nKS5sZW5ndGggPD0gMikge1xyXG4gICAgICAgICAgICBkb21haW4gPSBob3N0V2l0aG91dFBvcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbnRlcnByZXQgdGhlIHN1YmRvbWFpbiBvZiBhIDMgb3IgbW9yZSBjb21wb25lbnQgVVJMIGFzIHRoZSBuYW1lc3BhY2UgbmFtZS5cclxuICAgICAgICAgICAgY29uc3QgZG90SW5kID0gaG9zdC5pbmRleE9mKCcuJyk7XHJcbiAgICAgICAgICAgIHN1YmRvbWFpbiA9IGhvc3Quc3Vic3RyaW5nKDAsIGRvdEluZCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgZG9tYWluID0gaG9zdC5zdWJzdHJpbmcoZG90SW5kICsgMSk7XHJcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBuYW1lc3BhY2VzIHRvIGxvd2VyY2FzZSB0byBzaGFyZSBzdG9yYWdlIC8gY29ubmVjdGlvbi5cclxuICAgICAgICAgICAgbmFtZXNwYWNlID0gc3ViZG9tYWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBbHdheXMgdHJlYXQgdGhlIHZhbHVlIG9mIHRoZSBgbnNgIGFzIHRoZSBuYW1lc3BhY2UgbmFtZSBpZiBpdCBpcyBwcmVzZW50LlxyXG4gICAgICAgIGlmICgnbnMnIGluIHF1ZXJ5UGFyYW1zKSB7XHJcbiAgICAgICAgICAgIG5hbWVzcGFjZSA9IHF1ZXJ5UGFyYW1zWyducyddO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaG9zdCxcclxuICAgICAgICBwb3J0LFxyXG4gICAgICAgIGRvbWFpbixcclxuICAgICAgICBzdWJkb21haW4sXHJcbiAgICAgICAgc2VjdXJlLFxyXG4gICAgICAgIHNjaGVtZSxcclxuICAgICAgICBwYXRoU3RyaW5nLFxyXG4gICAgICAgIG5hbWVzcGFjZVxyXG4gICAgfTtcclxufTtcblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLy8gTW9kZWxlZCBhZnRlciBiYXNlNjQgd2ViLXNhZmUgY2hhcnMsIGJ1dCBvcmRlcmVkIGJ5IEFTQ0lJLlxyXG5jb25zdCBQVVNIX0NIQVJTID0gJy0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xyXG4vKipcclxuICogRmFuY3kgSUQgZ2VuZXJhdG9yIHRoYXQgY3JlYXRlcyAyMC1jaGFyYWN0ZXIgc3RyaW5nIGlkZW50aWZpZXJzIHdpdGggdGhlXHJcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gKlxyXG4gKiAxLiBUaGV5J3JlIGJhc2VkIG9uIHRpbWVzdGFtcCBzbyB0aGF0IHRoZXkgc29ydCAqYWZ0ZXIqIGFueSBleGlzdGluZyBpZHMuXHJcbiAqIDIuIFRoZXkgY29udGFpbiA3Mi1iaXRzIG9mIHJhbmRvbSBkYXRhIGFmdGVyIHRoZSB0aW1lc3RhbXAgc28gdGhhdCBJRHMgd29uJ3RcclxuICogICAgY29sbGlkZSB3aXRoIG90aGVyIGNsaWVudHMnIElEcy5cclxuICogMy4gVGhleSBzb3J0ICpsZXhpY29ncmFwaGljYWxseSogKHNvIHRoZSB0aW1lc3RhbXAgaXMgY29udmVydGVkIHRvIGNoYXJhY3RlcnNcclxuICogICAgdGhhdCB3aWxsIHNvcnQgcHJvcGVybHkpLlxyXG4gKiA0LiBUaGV5J3JlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy4gRXZlbiBpZiB5b3UgZ2VuZXJhdGUgbW9yZSB0aGFuIG9uZSBpblxyXG4gKiAgICB0aGUgc2FtZSB0aW1lc3RhbXAsIHRoZSBsYXR0ZXIgb25lcyB3aWxsIHNvcnQgYWZ0ZXIgdGhlIGZvcm1lciBvbmVzLiBXZSBkb1xyXG4gKiAgICB0aGlzIGJ5IHVzaW5nIHRoZSBwcmV2aW91cyByYW5kb20gYml0cyBidXQgXCJpbmNyZW1lbnRpbmdcIiB0aGVtIGJ5IDEgKG9ubHlcclxuICogICAgaW4gdGhlIGNhc2Ugb2YgYSB0aW1lc3RhbXAgY29sbGlzaW9uKS5cclxuICovXHJcbmNvbnN0IG5leHRQdXNoSWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gVGltZXN0YW1wIG9mIGxhc3QgcHVzaCwgdXNlZCB0byBwcmV2ZW50IGxvY2FsIGNvbGxpc2lvbnMgaWYgeW91IHB1c2ggdHdpY2VcclxuICAgIC8vIGluIG9uZSBtcy5cclxuICAgIGxldCBsYXN0UHVzaFRpbWUgPSAwO1xyXG4gICAgLy8gV2UgZ2VuZXJhdGUgNzItYml0cyBvZiByYW5kb21uZXNzIHdoaWNoIGdldCB0dXJuZWQgaW50byAxMiBjaGFyYWN0ZXJzIGFuZFxyXG4gICAgLy8gYXBwZW5kZWQgdG8gdGhlIHRpbWVzdGFtcCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgd2l0aCBvdGhlciBjbGllbnRzLiBXZVxyXG4gICAgLy8gc3RvcmUgdGhlIGxhc3QgY2hhcmFjdGVycyB3ZSBnZW5lcmF0ZWQgYmVjYXVzZSBpbiB0aGUgZXZlbnQgb2YgYSBjb2xsaXNpb24sXHJcbiAgICAvLyB3ZSdsbCB1c2UgdGhvc2Ugc2FtZSBjaGFyYWN0ZXJzIGV4Y2VwdCBcImluY3JlbWVudGVkXCIgYnkgb25lLlxyXG4gICAgY29uc3QgbGFzdFJhbmRDaGFycyA9IFtdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICBjb25zdCBkdXBsaWNhdGVUaW1lID0gbm93ID09PSBsYXN0UHVzaFRpbWU7XHJcbiAgICAgICAgbGFzdFB1c2hUaW1lID0gbm93O1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVTdGFtcENoYXJzID0gbmV3IEFycmF5KDgpO1xyXG4gICAgICAgIGZvciAoaSA9IDc7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRpbWVTdGFtcENoYXJzW2ldID0gUFVTSF9DSEFSUy5jaGFyQXQobm93ICUgNjQpO1xyXG4gICAgICAgICAgICAvLyBOT1RFOiBDYW4ndCB1c2UgPDwgaGVyZSBiZWNhdXNlIGphdmFzY3JpcHQgd2lsbCBjb252ZXJ0IHRvIGludCBhbmQgbG9zZVxyXG4gICAgICAgICAgICAvLyB0aGUgdXBwZXIgYml0cy5cclxuICAgICAgICAgICAgbm93ID0gTWF0aC5mbG9vcihub3cgLyA2NCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFzc2VydChub3cgPT09IDAsICdDYW5ub3QgcHVzaCBhdCB0aW1lID09IDAnKTtcclxuICAgICAgICBsZXQgaWQgPSB0aW1lU3RhbXBDaGFycy5qb2luKCcnKTtcclxuICAgICAgICBpZiAoIWR1cGxpY2F0ZVRpbWUpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2NCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB0aW1lc3RhbXAgaGFzbid0IGNoYW5nZWQgc2luY2UgbGFzdCBwdXNoLCB1c2UgdGhlIHNhbWUgcmFuZG9tXHJcbiAgICAgICAgICAgIC8vIG51bWJlciwgZXhjZXB0IGluY3JlbWVudGVkIGJ5IDEuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDExOyBpID49IDAgJiYgbGFzdFJhbmRDaGFyc1tpXSA9PT0gNjM7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdFJhbmRDaGFyc1tpXSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICBpZCArPSBQVVNIX0NIQVJTLmNoYXJBdChsYXN0UmFuZENoYXJzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXNzZXJ0KGlkLmxlbmd0aCA9PT0gMjAsICduZXh0UHVzaElkOiBMZW5ndGggc2hvdWxkIGJlIDIwLicpO1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgIH07XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBAbGljZW5zZVxyXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgTExDXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIGRhdGEgbmVlZGVkIHRvIHJhaXNlIGFuIGV2ZW50XHJcbiAqL1xyXG5jbGFzcyBEYXRhRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gT25lIG9mOiB2YWx1ZSwgY2hpbGRfYWRkZWQsIGNoaWxkX2NoYW5nZWQsIGNoaWxkX21vdmVkLCBjaGlsZF9yZW1vdmVkXHJcbiAgICAgKiBAcGFyYW0gZXZlbnRSZWdpc3RyYXRpb24gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byB3aXRoIHRoZSBldmVudCBkYXRhLiBVc2VyIHByb3ZpZGVkXHJcbiAgICAgKiBAcGFyYW0gc25hcHNob3QgLSBUaGUgZGF0YSBiYWNraW5nIHRoZSBldmVudFxyXG4gICAgICogQHBhcmFtIHByZXZOYW1lIC0gT3B0aW9uYWwsIHRoZSBuYW1lIG9mIHRoZSBwcmV2aW91cyBjaGlsZCBmb3IgY2hpbGRfKiBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGV2ZW50VHlwZSwgZXZlbnRSZWdpc3RyYXRpb24sIHNuYXBzaG90LCBwcmV2TmFtZSkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24gPSBldmVudFJlZ2lzdHJhdGlvbjtcclxuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbiAgICAgICAgdGhpcy5wcmV2TmFtZSA9IHByZXZOYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0UGF0aCgpIHtcclxuICAgICAgICBjb25zdCByZWYgPSB0aGlzLnNuYXBzaG90LnJlZjtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlZi5fcGF0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWYucGFyZW50Ll9wYXRoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEV2ZW50VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFR5cGU7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbi5nZXRFdmVudFJ1bm5lcih0aGlzKTtcclxuICAgIH1cclxuICAgIHRvU3RyaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5nZXRQYXRoKCkudG9TdHJpbmcoKSArXHJcbiAgICAgICAgICAgICc6JyArXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRUeXBlICtcclxuICAgICAgICAgICAgJzonICtcclxuICAgICAgICAgICAgc3RyaW5naWZ5KHRoaXMuc25hcHNob3QuZXhwb3J0VmFsKCkpKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDYW5jZWxFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFJlZ2lzdHJhdGlvbiwgZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uID0gZXZlbnRSZWdpc3RyYXRpb247XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRQYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdGg7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xyXG4gICAgfVxyXG4gICAgZ2V0RXZlbnRSdW5uZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24uZ2V0RXZlbnRSdW5uZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnRvU3RyaW5nKCkgKyAnOmNhbmNlbCc7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBjbGFzcyB0aGF0IGNvbnZlcnRzIGV2ZW50cyBmcm9tIHRoZSBkYXRhYmFzZUBleHAgU0RLIHRvIHRoZSBsZWdhY3lcclxuICogRGF0YWJhc2UgU0RLLiBFdmVudHMgYXJlIG5vdCBjb252ZXJ0ZWQgZGlyZWN0bHkgYXMgZXZlbnQgcmVnaXN0cmF0aW9uIHJlbGllc1xyXG4gKiBvbiByZWZlcmVuY2UgY29tcGFyaXNvbiBvZiB0aGUgb3JpZ2luYWwgdXNlciBjYWxsYmFjayAoc2VlIGBtYXRjaGVzKClgKSBhbmRcclxuICogcmVsaWVzIG9uIGVxdWFsaXR5IG9mIHRoZSBsZWdhY3kgU0RLJ3MgYGNvbnRleHRgIG9iamVjdC5cclxuICovXHJcbmNsYXNzIENhbGxiYWNrQ29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihzbmFwc2hvdENhbGxiYWNrLCBjYW5jZWxDYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuc25hcHNob3RDYWxsYmFjayA9IHNuYXBzaG90Q2FsbGJhY2s7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgb25WYWx1ZShleHBEYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKSB7XHJcbiAgICAgICAgdGhpcy5zbmFwc2hvdENhbGxiYWNrLmNhbGwobnVsbCwgZXhwRGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSk7XHJcbiAgICB9XHJcbiAgICBvbkNhbmNlbChlcnJvcikge1xyXG4gICAgICAgIGFzc2VydCh0aGlzLmhhc0NhbmNlbENhbGxiYWNrLCAnUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrJyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsQ2FsbGJhY2suY2FsbChudWxsLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzQ2FuY2VsQ2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jYW5jZWxDYWxsYmFjaztcclxuICAgIH1cclxuICAgIG1hdGNoZXMob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc25hcHNob3RDYWxsYmFjayA9PT0gb3RoZXIuc25hcHNob3RDYWxsYmFjayB8fFxyXG4gICAgICAgICAgICAodGhpcy5zbmFwc2hvdENhbGxiYWNrLnVzZXJDYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrID09PVxyXG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnNuYXBzaG90Q2FsbGJhY2sudXNlckNhbGxiYWNrICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90Q2FsbGJhY2suY29udGV4dCA9PT0gb3RoZXIuc25hcHNob3RDYWxsYmFjay5jb250ZXh0KSk7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIFRoZSBgb25EaXNjb25uZWN0YCBjbGFzcyBhbGxvd3MgeW91IHRvIHdyaXRlIG9yIGNsZWFyIGRhdGEgd2hlbiB5b3VyIGNsaWVudFxyXG4gKiBkaXNjb25uZWN0cyBmcm9tIHRoZSBEYXRhYmFzZSBzZXJ2ZXIuIFRoZXNlIHVwZGF0ZXMgb2NjdXIgd2hldGhlciB5b3VyXHJcbiAqIGNsaWVudCBkaXNjb25uZWN0cyBjbGVhbmx5IG9yIG5vdCwgc28geW91IGNhbiByZWx5IG9uIHRoZW0gdG8gY2xlYW4gdXAgZGF0YVxyXG4gKiBldmVuIGlmIGEgY29ubmVjdGlvbiBpcyBkcm9wcGVkIG9yIGEgY2xpZW50IGNyYXNoZXMuXHJcbiAqXHJcbiAqIFRoZSBgb25EaXNjb25uZWN0YCBjbGFzcyBpcyBtb3N0IGNvbW1vbmx5IHVzZWQgdG8gbWFuYWdlIHByZXNlbmNlIGluXHJcbiAqIGFwcGxpY2F0aW9ucyB3aGVyZSBpdCBpcyB1c2VmdWwgdG8gZGV0ZWN0IGhvdyBtYW55IGNsaWVudHMgYXJlIGNvbm5lY3RlZCBhbmRcclxuICogd2hlbiBvdGhlciBjbGllbnRzIGRpc2Nvbm5lY3QuIFNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL29mZmxpbmUtY2FwYWJpbGl0aWVzIHwgRW5hYmxpbmcgT2ZmbGluZSBDYXBhYmlsaXRpZXMgaW4gSmF2YVNjcmlwdH1cclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIFRvIGF2b2lkIHByb2JsZW1zIHdoZW4gYSBjb25uZWN0aW9uIGlzIGRyb3BwZWQgYmVmb3JlIHRoZSByZXF1ZXN0cyBjYW4gYmVcclxuICogdHJhbnNmZXJyZWQgdG8gdGhlIERhdGFiYXNlIHNlcnZlciwgdGhlc2UgZnVuY3Rpb25zIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlXHJcbiAqIHdyaXRpbmcgYW55IGRhdGEuXHJcbiAqXHJcbiAqIE5vdGUgdGhhdCBgb25EaXNjb25uZWN0YCBvcGVyYXRpb25zIGFyZSBvbmx5IHRyaWdnZXJlZCBvbmNlLiBJZiB5b3Ugd2FudCBhblxyXG4gKiBvcGVyYXRpb24gdG8gb2NjdXIgZWFjaCB0aW1lIGEgZGlzY29ubmVjdCBvY2N1cnMsIHlvdSdsbCBuZWVkIHRvIHJlLWVzdGFibGlzaFxyXG4gKiB0aGUgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBlYWNoIHRpbWUgeW91IHJlY29ubmVjdC5cclxuICovXHJcbmNsYXNzIE9uRGlzY29ubmVjdCB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG8sIF9wYXRoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwbyA9IF9yZXBvO1xyXG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyBhbGwgcHJldmlvdXNseSBxdWV1ZWQgYG9uRGlzY29ubmVjdCgpYCBzZXQgb3IgdXBkYXRlIGV2ZW50cyBmb3IgdGhpc1xyXG4gICAgICogbG9jYXRpb24gYW5kIGFsbCBjaGlsZHJlbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHdyaXRlIGhhcyBiZWVuIHF1ZXVlZCBmb3IgdGhpcyBsb2NhdGlvbiB2aWEgYSBgc2V0KClgIG9yIGB1cGRhdGUoKWAgYXQgYVxyXG4gICAgICogcGFyZW50IGxvY2F0aW9uLCB0aGUgd3JpdGUgYXQgdGhpcyBsb2NhdGlvbiB3aWxsIGJlIGNhbmNlbGVkLCB0aG91Z2ggd3JpdGVzXHJcbiAgICAgKiB0byBzaWJsaW5nIGxvY2F0aW9ucyB3aWxsIHN0aWxsIG9jY3VyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RDYW5jZWwodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoZSBkYXRhIGF0IHRoaXMgbG9jYXRpb24gaXMgZGVsZXRlZCB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkXHJcbiAgICAgKiAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZSgpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnJlbW92ZScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFNldCh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBzZXQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aGVuIHRoZVxyXG4gICAgICogY2xpZW50IGlzIGRpc2Nvbm5lY3RlZCAoZHVlIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSxcclxuICAgICAqIG9yIG5ldHdvcmsgaXNzdWVzKS5cclxuICAgICAqXHJcbiAgICAgKiBgc2V0KClgIGlzIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBpbXBsZW1lbnRpbmcgXCJwcmVzZW5jZVwiIHN5c3RlbXMsIHdoZXJlIGFcclxuICAgICAqIHZhbHVlIHNob3VsZCBiZSBjaGFuZ2VkIG9yIGNsZWFyZWQgd2hlbiBhIHVzZXIgZGlzY29ubmVjdHMgc28gdGhhdCB0aGV5XHJcbiAgICAgKiBhcHBlYXIgXCJvZmZsaW5lXCIgdG8gb3RoZXIgdXNlcnMuIFNlZVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9vZmZsaW5lLWNhcGFiaWxpdGllcyB8IEVuYWJsaW5nIE9mZmxpbmUgQ2FwYWJpbGl0aWVzIGluIEphdmFTY3JpcHR9XHJcbiAgICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlIHRoYXQgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBhcmUgb25seSB0cmlnZ2VyZWQgb25jZS4gSWYgeW91IHdhbnQgYW5cclxuICAgICAqIG9wZXJhdGlvbiB0byBvY2N1ciBlYWNoIHRpbWUgYSBkaXNjb25uZWN0IG9jY3VycywgeW91J2xsIG5lZWQgdG8gcmUtZXN0YWJsaXNoXHJcbiAgICAgKiB0aGUgYG9uRGlzY29ubmVjdGAgb3BlcmF0aW9ucyBlYWNoIHRpbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBsb2NhdGlvbiBvbiBkaXNjb25uZWN0IChjYW5cclxuICAgICAqIGJlIGFuIG9iamVjdCwgYXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKS5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5zZXQnLCB0aGlzLl9wYXRoKTtcclxuICAgICAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnT25EaXNjb25uZWN0LnNldCcsIHZhbHVlLCB0aGlzLl9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcclxuICAgICAgICByZXBvT25EaXNjb25uZWN0U2V0KHRoaXMuX3JlcG8sIHRoaXMuX3BhdGgsIHZhbHVlLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbiBpcyBzZXQgdG8gdGhlIHNwZWNpZmllZCB2YWx1ZSBhbmQgcHJpb3JpdHlcclxuICAgICAqIHdoZW4gdGhlIGNsaWVudCBpcyBkaXNjb25uZWN0ZWQgKGR1ZSB0byBjbG9zaW5nIHRoZSBicm93c2VyLCBuYXZpZ2F0aW5nIHRvIGFcclxuICAgICAqIG5ldyBwYWdlLCBvciBuZXR3b3JrIGlzc3VlcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gdG8gdGhpcyBsb2NhdGlvbiBvbiBkaXNjb25uZWN0IChjYW5cclxuICAgICAqIGJlIGFuIG9iamVjdCwgYXJyYXksIHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvciBudWxsKS5cclxuICAgICAqIEBwYXJhbSBwcmlvcml0eSAtIFRoZSBwcmlvcml0eSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgb3IgbnVsbCkuXHJcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHN5bmNocm9uaXphdGlvbiB0byB0aGUgRGF0YWJhc2UgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIHNldFdpdGhQcmlvcml0eSh2YWx1ZSwgcHJpb3JpdHkpIHtcclxuICAgICAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIHRoaXMuX3BhdGgpO1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgdmFsdWUsIHRoaXMuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICB2YWxpZGF0ZVByaW9yaXR5KCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgICAgIHJlcG9PbkRpc2Nvbm5lY3RTZXRXaXRoUHJpb3JpdHkodGhpcy5fcmVwbywgdGhpcy5fcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBtdWx0aXBsZSB2YWx1ZXMgYXQgdGhpcyBsb2NhdGlvbiB3aGVuIHRoZSBjbGllbnQgaXMgZGlzY29ubmVjdGVkIChkdWVcclxuICAgICAqIHRvIGNsb3NpbmcgdGhlIGJyb3dzZXIsIG5hdmlnYXRpbmcgdG8gYSBuZXcgcGFnZSwgb3IgbmV0d29yayBpc3N1ZXMpLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBgdmFsdWVzYCBhcmd1bWVudCBjb250YWlucyBtdWx0aXBsZSBwcm9wZXJ0eS12YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmVcclxuICAgICAqIHdyaXR0ZW4gdG8gdGhlIERhdGFiYXNlIHRvZ2V0aGVyLiBFYWNoIGNoaWxkIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgYSBzaW1wbGVcclxuICAgICAqIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgXCJuYW1lXCIpIG9yIGEgcmVsYXRpdmUgcGF0aCAoZm9yIGV4YW1wbGUsIFwibmFtZS9maXJzdFwiKVxyXG4gICAgICogZnJvbSB0aGUgY3VycmVudCBsb2NhdGlvbiB0byB0aGUgZGF0YSB0byB1cGRhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQXMgb3Bwb3NlZCB0byB0aGUgYHNldCgpYCBtZXRob2QsIGB1cGRhdGUoKWAgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseSB1cGRhdGVcclxuICAgICAqIG9ubHkgdGhlIHJlZmVyZW5jZWQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbiAoaW5zdGVhZCBvZiByZXBsYWNpbmdcclxuICAgICAqIGFsbCB0aGUgY2hpbGQgcHJvcGVydGllcyBhdCB0aGUgY3VycmVudCBsb2NhdGlvbikuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIE9iamVjdCBjb250YWluaW5nIG11bHRpcGxlIHZhbHVlcy5cclxuICAgICAqIEByZXR1cm5zIFJlc29sdmVzIHdoZW4gc3luY2hyb25pemF0aW9uIHRvIHRoZSBEYXRhYmFzZSBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHZhbHVlcykge1xyXG4gICAgICAgIHZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QudXBkYXRlJywgdGhpcy5fcGF0aCk7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZygnT25EaXNjb25uZWN0LnVwZGF0ZScsIHZhbHVlcywgdGhpcy5fcGF0aCwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICAgICAgcmVwb09uRGlzY29ubmVjdFVwZGF0ZSh0aGlzLl9yZXBvLCB0aGlzLl9wYXRoLCB2YWx1ZXMsIGRlZmVycmVkLndyYXBDYWxsYmFjaygoKSA9PiB7IH0pKTtcclxuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUltcGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9yZXBvLCBfcGF0aCwgX3F1ZXJ5UGFyYW1zLCBfb3JkZXJCeUNhbGxlZCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG8gPSBfcmVwbztcclxuICAgICAgICB0aGlzLl9wYXRoID0gX3BhdGg7XHJcbiAgICAgICAgdGhpcy5fcXVlcnlQYXJhbXMgPSBfcXVlcnlQYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fb3JkZXJCeUNhbGxlZCA9IF9vcmRlckJ5Q2FsbGVkO1xyXG4gICAgfVxyXG4gICAgZ2V0IGtleSgpIHtcclxuICAgICAgICBpZiAocGF0aElzRW1wdHkodGhpcy5fcGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF0aEdldEJhY2sodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHJlZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgdGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXQgX3F1ZXJ5SWRlbnRpZmllcigpIHtcclxuICAgICAgICBjb25zdCBvYmogPSBxdWVyeVBhcmFtc0dldFF1ZXJ5T2JqZWN0KHRoaXMuX3F1ZXJ5UGFyYW1zKTtcclxuICAgICAgICBjb25zdCBpZCA9IE9iamVjdFRvVW5pcXVlS2V5KG9iaik7XHJcbiAgICAgICAgcmV0dXJuIGlkID09PSAne30nID8gJ2RlZmF1bHQnIDogaWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVlcnkgcGFyYW1ldGVycyB1c2VkIGJ5IHRoaXMgUXVlcnkuXHJcbiAgICAgKi9cclxuICAgIGdldCBfcXVlcnlPYmplY3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW1zR2V0UXVlcnlPYmplY3QodGhpcy5fcXVlcnlQYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgaXNFcXVhbChvdGhlcikge1xyXG4gICAgICAgIG90aGVyID0gZ2V0TW9kdWxhckluc3RhbmNlKG90aGVyKTtcclxuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFF1ZXJ5SW1wbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzYW1lUmVwbyA9IHRoaXMuX3JlcG8gPT09IG90aGVyLl9yZXBvO1xyXG4gICAgICAgIGNvbnN0IHNhbWVQYXRoID0gcGF0aEVxdWFscyh0aGlzLl9wYXRoLCBvdGhlci5fcGF0aCk7XHJcbiAgICAgICAgY29uc3Qgc2FtZVF1ZXJ5SWRlbnRpZmllciA9IHRoaXMuX3F1ZXJ5SWRlbnRpZmllciA9PT0gb3RoZXIuX3F1ZXJ5SWRlbnRpZmllcjtcclxuICAgICAgICByZXR1cm4gc2FtZVJlcG8gJiYgc2FtZVBhdGggJiYgc2FtZVF1ZXJ5SWRlbnRpZmllcjtcclxuICAgIH1cclxuICAgIHRvSlNPTigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcG8udG9TdHJpbmcoKSArIHBhdGhUb1VybEVuY29kZWRTdHJpbmcodGhpcy5fcGF0aCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyB0aGF0IG5vIG90aGVyIG9yZGVyIGJ5IGNhbGwgaGFzIGJlZW4gbWFkZVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksIGZuTmFtZSkge1xyXG4gICAgaWYgKHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiOiBZb3UgY2FuJ3QgY29tYmluZSBtdWx0aXBsZSBvcmRlckJ5IGNhbGxzLlwiKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHN0YXJ0L2VuZCB2YWx1ZXMgZm9yIHF1ZXJpZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKHBhcmFtcykge1xyXG4gICAgbGV0IHN0YXJ0Tm9kZSA9IG51bGw7XHJcbiAgICBsZXQgZW5kTm9kZSA9IG51bGw7XHJcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICBzdGFydE5vZGUgPSBwYXJhbXMuZ2V0SW5kZXhTdGFydFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XHJcbiAgICAgICAgZW5kTm9kZSA9IHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IEtFWV9JTkRFWCkge1xyXG4gICAgICAgIGNvbnN0IHRvb01hbnlBcmdzRXJyb3IgPSAnUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkga2V5LCB5b3UgbWF5IG9ubHkgcGFzcyBvbmUgYXJndW1lbnQgdG8gJyArXHJcbiAgICAgICAgICAgICdzdGFydEF0KCksIGVuZEF0KCksIG9yIGVxdWFsVG8oKS4nO1xyXG4gICAgICAgIGNvbnN0IHdyb25nQXJnVHlwZUVycm9yID0gJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IGtleSwgdGhlIGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgJyArXHJcbiAgICAgICAgICAgICdlbmRBdCgpLCBlbmRCZWZvcmUoKSwgb3IgZXF1YWxUbygpIG11c3QgYmUgYSBzdHJpbmcuJztcclxuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnROYW1lID0gcGFyYW1zLmdldEluZGV4U3RhcnROYW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChzdGFydE5hbWUgIT09IE1JTl9OQU1FKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodG9vTWFueUFyZ3NFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0Tm9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbmROYW1lID0gcGFyYW1zLmdldEluZGV4RW5kTmFtZSgpO1xyXG4gICAgICAgICAgICBpZiAoZW5kTmFtZSAhPT0gTUFYX05BTUUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZW5kTm9kZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gUFJJT1JJVFlfSU5ERVgpIHtcclxuICAgICAgICBpZiAoKHN0YXJ0Tm9kZSAhPSBudWxsICYmICFpc1ZhbGlkUHJpb3JpdHkoc3RhcnROb2RlKSkgfHxcclxuICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiAhaXNWYWxpZFByaW9yaXR5KGVuZE5vZGUpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5OiBXaGVuIG9yZGVyaW5nIGJ5IHByaW9yaXR5LCB0aGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgJyArXHJcbiAgICAgICAgICAgICAgICAnc3RhcnRBZnRlcigpIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHZhbGlkIHByaW9yaXR5IHZhbHVlICcgK1xyXG4gICAgICAgICAgICAgICAgJyhudWxsLCBhIG51bWJlciwgb3IgYSBzdHJpbmcpLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFzc2VydChwYXJhbXMuZ2V0SW5kZXgoKSBpbnN0YW5jZW9mIFBhdGhJbmRleCB8fFxyXG4gICAgICAgICAgICBwYXJhbXMuZ2V0SW5kZXgoKSA9PT0gVkFMVUVfSU5ERVgsICd1bmtub3duIGluZGV4IHR5cGUuJyk7XHJcbiAgICAgICAgaWYgKChzdGFydE5vZGUgIT0gbnVsbCAmJiB0eXBlb2Ygc3RhcnROb2RlID09PSAnb2JqZWN0JykgfHxcclxuICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiB0eXBlb2YgZW5kTm9kZSA9PT0gJ29iamVjdCcpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnk6IEZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBzdGFydEF0KCksIHN0YXJ0QWZ0ZXIoKSwgZW5kQXQoKSwgZW5kQmVmb3JlKCksIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8oKSBjYW5ub3QgYmUgYW4gb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmFsaWRhdGVzIHRoYXQgbGltaXQqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IGNvbWJpbmF0aW9uIG9mIHBhcmFtZXRlcnNcclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTGltaXQocGFyYW1zKSB7XHJcbiAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkgJiZcclxuICAgICAgICBwYXJhbXMuaGFzRW5kKCkgJiZcclxuICAgICAgICBwYXJhbXMuaGFzTGltaXQoKSAmJlxyXG4gICAgICAgICFwYXJhbXMuaGFzQW5jaG9yZWRMaW1pdCgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBzdGFydEFmdGVyKCksIGVuZEF0KCksIGVuZEJlZm9yZSgpLCBhbmQgbGltaXQoKS4gVXNlIFwiICtcclxuICAgICAgICAgICAgJ2xpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBSZWZlcmVuY2VJbXBsIGV4dGVuZHMgUXVlcnlJbXBsIHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihyZXBvLCBwYXRoKSB7XHJcbiAgICAgICAgc3VwZXIocmVwbywgcGF0aCwgbmV3IFF1ZXJ5UGFyYW1zKCksIGZhbHNlKTtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50UGF0aCA9IHBhdGhQYXJlbnQodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGggPT09IG51bGxcclxuICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgIDogbmV3IFJlZmVyZW5jZUltcGwodGhpcy5fcmVwbywgcGFyZW50UGF0aCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcm9vdCgpIHtcclxuICAgICAgICBsZXQgcmVmID0gdGhpcztcclxuICAgICAgICB3aGlsZSAocmVmLnBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZWYgPSByZWYucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVmO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBIGBEYXRhU25hcHNob3RgIGNvbnRhaW5zIGRhdGEgZnJvbSBhIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBbnkgdGltZSB5b3UgcmVhZCBkYXRhIGZyb20gdGhlIERhdGFiYXNlLCB5b3UgcmVjZWl2ZSB0aGUgZGF0YSBhcyBhXHJcbiAqIGBEYXRhU25hcHNob3RgLiBBIGBEYXRhU25hcHNob3RgIGlzIHBhc3NlZCB0byB0aGUgZXZlbnQgY2FsbGJhY2tzIHlvdSBhdHRhY2hcclxuICogd2l0aCBgb24oKWAgb3IgYG9uY2UoKWAuIFlvdSBjYW4gZXh0cmFjdCB0aGUgY29udGVudHMgb2YgdGhlIHNuYXBzaG90IGFzIGFcclxuICogSmF2YVNjcmlwdCBvYmplY3QgYnkgY2FsbGluZyB0aGUgYHZhbCgpYCBtZXRob2QuIEFsdGVybmF0aXZlbHksIHlvdSBjYW5cclxuICogdHJhdmVyc2UgaW50byB0aGUgc25hcHNob3QgYnkgY2FsbGluZyBgY2hpbGQoKWAgdG8gcmV0dXJuIGNoaWxkIHNuYXBzaG90c1xyXG4gKiAod2hpY2ggeW91IGNvdWxkIHRoZW4gY2FsbCBgdmFsKClgIG9uKS5cclxuICpcclxuICogQSBgRGF0YVNuYXBzaG90YCBpcyBhbiBlZmZpY2llbnRseSBnZW5lcmF0ZWQsIGltbXV0YWJsZSBjb3B5IG9mIHRoZSBkYXRhIGF0XHJcbiAqIGEgRGF0YWJhc2UgbG9jYXRpb24uIEl0IGNhbm5vdCBiZSBtb2RpZmllZCBhbmQgd2lsbCBuZXZlciBjaGFuZ2UgKHRvIG1vZGlmeVxyXG4gKiBkYXRhLCB5b3UgYWx3YXlzIGNhbGwgdGhlIGBzZXQoKWAgbWV0aG9kIG9uIGEgYFJlZmVyZW5jZWAgZGlyZWN0bHkpLlxyXG4gKi9cclxuY2xhc3MgRGF0YVNuYXBzaG90IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIF9ub2RlIC0gQSBTbmFwc2hvdE5vZGUgdG8gd3JhcC5cclxuICAgICAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdGhpcyBzbmFwc2hvdCBjYW1lIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gX2luZGV4IC0gVGhlIGl0ZXJhdGlvbiBvcmRlciBmb3IgdGhpcyBzbmFwc2hvdFxyXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihfbm9kZSwgXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb2NhdGlvbiBvZiB0aGlzIERhdGFTbmFwc2hvdC5cclxuICAgICAqL1xyXG4gICAgcmVmLCBfaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl9ub2RlID0gX25vZGU7XHJcbiAgICAgICAgdGhpcy5yZWYgPSByZWY7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSBfaW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHByaW9yaXR5IHZhbHVlIG9mIHRoZSBkYXRhIGluIHRoaXMgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAgICAgKiBvcmRpbmFyeSBwcm9wZXJ0aWVzIChzZWVcclxuICAgICAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8U29ydGluZyBhbmQgZmlsdGVyaW5nIGRhdGF9XHJcbiAgICAgKiApLlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJpb3JpdHkoKSB7XHJcbiAgICAgICAgLy8gdHlwZWNhc3QgaGVyZSBiZWNhdXNlIHdlIG5ldmVyIHJldHVybiBkZWZlcnJlZCB2YWx1ZXMgb3IgaW50ZXJuYWwgcHJpb3JpdGllcyAoTUFYX1BSSU9SSVRZKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLmdldFByaW9yaXR5KCkudmFsKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBrZXkgKGxhc3QgcGFydCBvZiB0aGUgcGF0aCkgb2YgdGhlIGxvY2F0aW9uIG9mIHRoaXMgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGxhc3QgdG9rZW4gaW4gYSBEYXRhYmFzZSBsb2NhdGlvbiBpcyBjb25zaWRlcmVkIGl0cyBrZXkuIEZvciBleGFtcGxlLFxyXG4gICAgICogXCJhZGFcIiBpcyB0aGUga2V5IGZvciB0aGUgL3VzZXJzL2FkYS8gbm9kZS4gQWNjZXNzaW5nIHRoZSBrZXkgb24gYW55XHJcbiAgICAgKiBgRGF0YVNuYXBzaG90YCB3aWxsIHJldHVybiB0aGUga2V5IGZvciB0aGUgbG9jYXRpb24gdGhhdCBnZW5lcmF0ZWQgaXQuXHJcbiAgICAgKiBIb3dldmVyLCBhY2Nlc3NpbmcgdGhlIGtleSBvbiB0aGUgcm9vdCBVUkwgb2YgYSBEYXRhYmFzZSB3aWxsIHJldHVyblxyXG4gICAgICogYG51bGxgLlxyXG4gICAgICovXHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZi5rZXk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNoaWxkIHByb3BlcnRpZXMgb2YgdGhpcyBgRGF0YVNuYXBzaG90YC4gKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ub2RlLm51bUNoaWxkcmVuKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYW5vdGhlciBgRGF0YVNuYXBzaG90YCBmb3IgdGhlIGxvY2F0aW9uIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBQYXNzaW5nIGEgcmVsYXRpdmUgcGF0aCB0byB0aGUgYGNoaWxkKClgIG1ldGhvZCBvZiBhIERhdGFTbmFwc2hvdCByZXR1cm5zXHJcbiAgICAgKiBhbm90aGVyIGBEYXRhU25hcHNob3RgIGZvciB0aGUgbG9jYXRpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwYXRoLiBUaGVcclxuICAgICAqIHJlbGF0aXZlIHBhdGggY2FuIGVpdGhlciBiZSBhIHNpbXBsZSBjaGlsZCBuYW1lIChmb3IgZXhhbXBsZSwgXCJhZGFcIikgb3IgYVxyXG4gICAgICogZGVlcGVyLCBzbGFzaC1zZXBhcmF0ZWQgcGF0aCAoZm9yIGV4YW1wbGUsIFwiYWRhL25hbWUvZmlyc3RcIikuIElmIHRoZSBjaGlsZFxyXG4gICAgICogbG9jYXRpb24gaGFzIG5vIGRhdGEsIGFuIGVtcHR5IGBEYXRhU25hcHNob3RgICh0aGF0IGlzLCBhIGBEYXRhU25hcHNob3RgXHJcbiAgICAgKiB3aG9zZSB2YWx1ZSBpcyBgbnVsbGApIGlzIHJldHVybmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXRoIC0gQSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBsb2NhdGlvbiBvZiBjaGlsZCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBjaGlsZChwYXRoKSB7XHJcbiAgICAgICAgY29uc3QgY2hpbGRQYXRoID0gbmV3IFBhdGgocGF0aCk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRSZWYgPSBjaGlsZCh0aGlzLnJlZiwgcGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU25hcHNob3QodGhpcy5fbm9kZS5nZXRDaGlsZChjaGlsZFBhdGgpLCBjaGlsZFJlZiwgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBgRGF0YVNuYXBzaG90YCBjb250YWlucyBhbnkgZGF0YS4gSXQgaXMgc2xpZ2h0bHkgbW9yZVxyXG4gICAgICogZWZmaWNpZW50IHRoYW4gdXNpbmcgYHNuYXBzaG90LnZhbCgpICE9PSBudWxsYC5cclxuICAgICAqL1xyXG4gICAgZXhpc3RzKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fbm9kZS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4cG9ydHMgdGhlIGVudGlyZSBjb250ZW50cyBvZiB0aGUgRGF0YVNuYXBzaG90IGFzIGEgSmF2YVNjcmlwdCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGBleHBvcnRWYWwoKWAgbWV0aG9kIGlzIHNpbWlsYXIgdG8gYHZhbCgpYCwgZXhjZXB0IHByaW9yaXR5IGluZm9ybWF0aW9uXHJcbiAgICAgKiBpcyBpbmNsdWRlZCAoaWYgYXZhaWxhYmxlKSwgbWFraW5nIGl0IHN1aXRhYmxlIGZvciBiYWNraW5nIHVwIHlvdXIgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgRGF0YVNuYXBzaG90J3MgY29udGVudHMgYXMgYSBKYXZhU2NyaXB0IHZhbHVlIChPYmplY3QsXHJcbiAgICAgKiAgIEFycmF5LCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYG51bGxgKS5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIGV4cG9ydFZhbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZS52YWwodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVudW1lcmF0ZXMgdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBpbiB0aGUgYERhdGFTbmFwc2hvdGAuXHJcbiAgICAgKlxyXG4gICAgICogQmVjYXVzZSBvZiB0aGUgd2F5IEphdmFTY3JpcHQgb2JqZWN0cyB3b3JrLCB0aGUgb3JkZXJpbmcgb2YgZGF0YSBpbiB0aGVcclxuICAgICAqIEphdmFTY3JpcHQgb2JqZWN0IHJldHVybmVkIGJ5IGB2YWwoKWAgaXMgbm90IGd1YXJhbnRlZWQgdG8gbWF0Y2ggdGhlXHJcbiAgICAgKiBvcmRlcmluZyBvbiB0aGUgc2VydmVyIG5vciB0aGUgb3JkZXJpbmcgb2YgYG9uQ2hpbGRBZGRlZCgpYCBldmVudHMuIFRoYXQgaXNcclxuICAgICAqIHdoZXJlIGBmb3JFYWNoKClgIGNvbWVzIGluIGhhbmR5LiBJdCBndWFyYW50ZWVzIHRoZSBjaGlsZHJlbiBvZiBhXHJcbiAgICAgKiBgRGF0YVNuYXBzaG90YCB3aWxsIGJlIGl0ZXJhdGVkIGluIHRoZWlyIHF1ZXJ5IG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIElmIG5vIGV4cGxpY2l0IGBvcmRlckJ5KigpYCBtZXRob2QgaXMgdXNlZCwgcmVzdWx0cyBhcmUgcmV0dXJuZWRcclxuICAgICAqIG9yZGVyZWQgYnkga2V5ICh1bmxlc3MgcHJpb3JpdGllcyBhcmUgdXNlZCwgaW4gd2hpY2ggY2FzZSwgcmVzdWx0cyBhcmVcclxuICAgICAqIHJldHVybmVkIGJ5IHByaW9yaXR5KS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNoaWxkIERhdGFTbmFwc2hvdC5cclxuICAgICAqIFRoZSBjYWxsYmFjayBjYW4gcmV0dXJuIHRydWUgdG8gY2FuY2VsIGZ1cnRoZXIgZW51bWVyYXRpb24uXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGVudW1lcmF0aW9uIHdhcyBjYW5jZWxlZCBkdWUgdG8geW91ciBjYWxsYmFjayByZXR1cm5pbmdcclxuICAgICAqIHRydWUuXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2goYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25vZGUuaXNMZWFmTm9kZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW5Ob2RlID0gdGhpcy5fbm9kZTtcclxuICAgICAgICAvLyBTYW5pdGl6ZSB0aGUgcmV0dXJuIHZhbHVlIHRvIGEgYm9vbGVhbi4gQ2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZCBoYXMgYSB3ZWlyZCByZXR1cm4gdHlwZS4uLlxyXG4gICAgICAgIHJldHVybiAhIWNoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQodGhpcy5faW5kZXgsIChrZXksIG5vZGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbihuZXcgRGF0YVNuYXBzaG90KG5vZGUsIGNoaWxkKHRoaXMucmVmLCBrZXkpLCBQUklPUklUWV9JTkRFWCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjaGlsZCBwYXRoIGhhcyAobm9uLW51bGwpIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdGggLSBBIHJlbGF0aXZlIHBhdGggdG8gdGhlIGxvY2F0aW9uIG9mIGEgcG90ZW50aWFsIGNoaWxkLlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIGRhdGEgZXhpc3RzIGF0IHRoZSBzcGVjaWZpZWQgY2hpbGQgcGF0aDsgZWxzZVxyXG4gICAgICogIGBmYWxzZWAuXHJcbiAgICAgKi9cclxuICAgIGhhc0NoaWxkKHBhdGgpIHtcclxuICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBuZXcgUGF0aChwYXRoKTtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX25vZGUuZ2V0Q2hpbGQoY2hpbGRQYXRoKS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGBEYXRhU25hcHNob3RgIGhhcyBhbnkgbm9uLWBudWxsYCBjaGlsZFxyXG4gICAgICogcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBZb3UgY2FuIHVzZSBgaGFzQ2hpbGRyZW4oKWAgdG8gZGV0ZXJtaW5lIGlmIGEgYERhdGFTbmFwc2hvdGAgaGFzIGFueVxyXG4gICAgICogY2hpbGRyZW4uIElmIGl0IGRvZXMsIHlvdSBjYW4gZW51bWVyYXRlIHRoZW0gdXNpbmcgYGZvckVhY2goKWAuIElmIGl0XHJcbiAgICAgKiBkb2Vzbid0LCB0aGVuIGVpdGhlciB0aGlzIHNuYXBzaG90IGNvbnRhaW5zIGEgcHJpbWl0aXZlIHZhbHVlICh3aGljaCBjYW4gYmVcclxuICAgICAqIHJldHJpZXZlZCB3aXRoIGB2YWwoKWApIG9yIGl0IGlzIGVtcHR5IChpbiB3aGljaCBjYXNlLCBgdmFsKClgIHdpbGwgcmV0dXJuXHJcbiAgICAgKiBgbnVsbGApLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBzbmFwc2hvdCBoYXMgYW55IGNoaWxkcmVuOyBlbHNlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBoYXNDaGlsZHJlbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fbm9kZS5pc0xlYWZOb2RlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl9ub2RlLmlzRW1wdHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydFZhbCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRyYWN0cyBhIEphdmFTY3JpcHQgdmFsdWUgZnJvbSBhIGBEYXRhU25hcHNob3RgLlxyXG4gICAgICpcclxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgZGF0YSBpbiBhIGBEYXRhU25hcHNob3RgLCB0aGUgYHZhbCgpYCBtZXRob2QgbWF5IHJldHVybiBhXHJcbiAgICAgKiBzY2FsYXIgdHlwZSAoc3RyaW5nLCBudW1iZXIsIG9yIGJvb2xlYW4pLCBhbiBhcnJheSwgb3IgYW4gb2JqZWN0LiBJdCBtYXlcclxuICAgICAqIGFsc28gcmV0dXJuIG51bGwsIGluZGljYXRpbmcgdGhhdCB0aGUgYERhdGFTbmFwc2hvdGAgaXMgZW1wdHkgKGNvbnRhaW5zIG5vXHJcbiAgICAgKiBkYXRhKS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgRGF0YVNuYXBzaG90J3MgY29udGVudHMgYXMgYSBKYXZhU2NyaXB0IHZhbHVlIChPYmplY3QsXHJcbiAgICAgKiAgIEFycmF5LCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgYG51bGxgKS5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuICAgIHZhbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZS52YWwoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICogUmV0dXJucyBhIGBSZWZlcmVuY2VgIHJlcHJlc2VudGluZyB0aGUgbG9jYXRpb24gaW4gdGhlIERhdGFiYXNlXHJcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3ZpZGVkIHBhdGguIElmIG5vIHBhdGggaXMgcHJvdmlkZWQsIHRoZSBgUmVmZXJlbmNlYFxyXG4gKiB3aWxsIHBvaW50IHRvIHRoZSByb290IG9mIHRoZSBEYXRhYmFzZS5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGRhdGFiYXNlIGluc3RhbmNlIHRvIG9idGFpbiBhIHJlZmVyZW5jZSBmb3IuXHJcbiAqIEBwYXJhbSBwYXRoIC0gT3B0aW9uYWwgcGF0aCByZXByZXNlbnRpbmcgdGhlIGxvY2F0aW9uIHRoZSByZXR1cm5lZFxyXG4gKiAgIGBSZWZlcmVuY2VgIHdpbGwgcG9pbnQuIElmIG5vdCBwcm92aWRlZCwgdGhlIHJldHVybmVkIGBSZWZlcmVuY2VgIHdpbGxcclxuICogICBwb2ludCB0byB0aGUgcm9vdCBvZiB0aGUgRGF0YWJhc2UuXHJcbiAqIEByZXR1cm5zIElmIGEgcGF0aCBpcyBwcm92aWRlZCwgYSBgUmVmZXJlbmNlYFxyXG4gKiAgIHBvaW50aW5nIHRvIHRoZSBwcm92aWRlZCBwYXRoLiBPdGhlcndpc2UsIGEgYFJlZmVyZW5jZWAgcG9pbnRpbmcgdG8gdGhlXHJcbiAqICAgcm9vdCBvZiB0aGUgRGF0YWJhc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWYoZGIsIHBhdGgpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ3JlZicpO1xyXG4gICAgcmV0dXJuIHBhdGggIT09IHVuZGVmaW5lZCA/IGNoaWxkKGRiLl9yb290LCBwYXRoKSA6IGRiLl9yb290O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgYFJlZmVyZW5jZWAgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBpbiB0aGUgRGF0YWJhc2VcclxuICogY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgRmlyZWJhc2UgVVJMLlxyXG4gKlxyXG4gKiBBbiBleGNlcHRpb24gaXMgdGhyb3duIGlmIHRoZSBVUkwgaXMgbm90IGEgdmFsaWQgRmlyZWJhc2UgRGF0YWJhc2UgVVJMIG9yIGl0XHJcbiAqIGhhcyBhIGRpZmZlcmVudCBkb21haW4gdGhhbiB0aGUgY3VycmVudCBgRGF0YWJhc2VgIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgYWxsIHF1ZXJ5IHBhcmFtZXRlcnMgKGBvcmRlckJ5YCwgYGxpbWl0VG9MYXN0YCwgZXRjLikgYXJlIGlnbm9yZWRcclxuICogYW5kIGFyZSBub3QgYXBwbGllZCB0byB0aGUgcmV0dXJuZWQgYFJlZmVyZW5jZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBkYXRhYmFzZSBpbnN0YW5jZSB0byBvYnRhaW4gYSByZWZlcmVuY2UgZm9yLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIEZpcmViYXNlIFVSTCBhdCB3aGljaCB0aGUgcmV0dXJuZWQgYFJlZmVyZW5jZWAgd2lsbFxyXG4gKiAgIHBvaW50LlxyXG4gKiBAcmV0dXJucyBBIGBSZWZlcmVuY2VgIHBvaW50aW5nIHRvIHRoZSBwcm92aWRlZFxyXG4gKiAgIEZpcmViYXNlIFVSTC5cclxuICovXHJcbmZ1bmN0aW9uIHJlZkZyb21VUkwoZGIsIHVybCkge1xyXG4gICAgZGIgPSBnZXRNb2R1bGFySW5zdGFuY2UoZGIpO1xyXG4gICAgZGIuX2NoZWNrTm90RGVsZXRlZCgncmVmRnJvbVVSTCcpO1xyXG4gICAgY29uc3QgcGFyc2VkVVJMID0gcGFyc2VSZXBvSW5mbyh1cmwsIGRiLl9yZXBvLnJlcG9JbmZvXy5ub2RlQWRtaW4pO1xyXG4gICAgdmFsaWRhdGVVcmwoJ3JlZkZyb21VUkwnLCBwYXJzZWRVUkwpO1xyXG4gICAgY29uc3QgcmVwb0luZm8gPSBwYXJzZWRVUkwucmVwb0luZm87XHJcbiAgICBpZiAoIWRiLl9yZXBvLnJlcG9JbmZvXy5pc0N1c3RvbUhvc3QoKSAmJlxyXG4gICAgICAgIHJlcG9JbmZvLmhvc3QgIT09IGRiLl9yZXBvLnJlcG9JbmZvXy5ob3N0KSB7XHJcbiAgICAgICAgZmF0YWwoJ3JlZkZyb21VUkwnICtcclxuICAgICAgICAgICAgJzogSG9zdCBuYW1lIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGRhdGFiYXNlOiAnICtcclxuICAgICAgICAgICAgJyhmb3VuZCAnICtcclxuICAgICAgICAgICAgcmVwb0luZm8uaG9zdCArXHJcbiAgICAgICAgICAgICcgYnV0IGV4cGVjdGVkICcgK1xyXG4gICAgICAgICAgICBkYi5fcmVwby5yZXBvSW5mb18uaG9zdCArXHJcbiAgICAgICAgICAgICcpJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVmKGRiLCBwYXJzZWRVUkwucGF0aC50b1N0cmluZygpKTtcclxufVxyXG4vKipcclxuICogR2V0cyBhIGBSZWZlcmVuY2VgIGZvciB0aGUgbG9jYXRpb24gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwYXRoLlxyXG4gKlxyXG4gKiBUaGUgcmVsYXRpdmUgcGF0aCBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlIGNoaWxkIG5hbWUgKGZvciBleGFtcGxlLCBcImFkYVwiKSBvclxyXG4gKiBhIGRlZXBlciBzbGFzaC1zZXBhcmF0ZWQgcGF0aCAoZm9yIGV4YW1wbGUsIFwiYWRhL25hbWUvZmlyc3RcIikuXHJcbiAqXHJcbiAqIEBwYXJhbSBwYXJlbnQgLSBUaGUgcGFyZW50IGxvY2F0aW9uLlxyXG4gKiBAcGFyYW0gcGF0aCAtIEEgcmVsYXRpdmUgcGF0aCBmcm9tIHRoaXMgbG9jYXRpb24gdG8gdGhlIGRlc2lyZWQgY2hpbGRcclxuICogICBsb2NhdGlvbi5cclxuICogQHJldHVybnMgVGhlIHNwZWNpZmllZCBjaGlsZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIGNoaWxkKHBhcmVudCwgcGF0aCkge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICBpZiAocGF0aEdldEZyb250KHBhcmVudC5fcGF0aCkgPT09IG51bGwpIHtcclxuICAgICAgICB2YWxpZGF0ZVJvb3RQYXRoU3RyaW5nKCdjaGlsZCcsICdwYXRoJywgcGF0aCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFsaWRhdGVQYXRoU3RyaW5nKCdjaGlsZCcsICdwYXRoJywgcGF0aCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2VJbXBsKHBhcmVudC5fcmVwbywgcGF0aENoaWxkKHBhcmVudC5fcGF0aCwgcGF0aCkpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIGBPbkRpc2Nvbm5lY3RgIG9iamVjdCAtIHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL29mZmxpbmUtY2FwYWJpbGl0aWVzIHwgRW5hYmxpbmcgT2ZmbGluZSBDYXBhYmlsaXRpZXMgaW4gSmF2YVNjcmlwdH1cclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIHVzZSBpdC5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSByZWZlcmVuY2UgdG8gYWRkIE9uRGlzY29ubmVjdCB0cmlnZ2VycyBmb3IuXHJcbiAqL1xyXG5mdW5jdGlvbiBvbkRpc2Nvbm5lY3QocmVmKSB7XHJcbiAgICByZWYgPSBnZXRNb2R1bGFySW5zdGFuY2UocmVmKTtcclxuICAgIHJldHVybiBuZXcgT25EaXNjb25uZWN0KHJlZi5fcmVwbywgcmVmLl9wYXRoKTtcclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIGEgbmV3IGNoaWxkIGxvY2F0aW9uIHVzaW5nIGEgdW5pcXVlIGtleSBhbmQgcmV0dXJucyBpdHNcclxuICogYFJlZmVyZW5jZWAuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIHBhdHRlcm4gZm9yIGFkZGluZyBkYXRhIHRvIGEgY29sbGVjdGlvbiBvZiBpdGVtcy5cclxuICpcclxuICogSWYgeW91IHByb3ZpZGUgYSB2YWx1ZSB0byBgcHVzaCgpYCwgdGhlIHZhbHVlIGlzIHdyaXR0ZW4gdG8gdGhlXHJcbiAqIGdlbmVyYXRlZCBsb2NhdGlvbi4gSWYgeW91IGRvbid0IHBhc3MgYSB2YWx1ZSwgbm90aGluZyBpcyB3cml0dGVuIHRvIHRoZVxyXG4gKiBkYXRhYmFzZSBhbmQgdGhlIGNoaWxkIHJlbWFpbnMgZW1wdHkgKGJ1dCB5b3UgY2FuIHVzZSB0aGUgYFJlZmVyZW5jZWBcclxuICogZWxzZXdoZXJlKS5cclxuICpcclxuICogVGhlIHVuaXF1ZSBrZXlzIGdlbmVyYXRlZCBieSBgcHVzaCgpYCBhcmUgb3JkZXJlZCBieSB0aGUgY3VycmVudCB0aW1lLCBzbyB0aGVcclxuICogcmVzdWx0aW5nIGxpc3Qgb2YgaXRlbXMgaXMgY2hyb25vbG9naWNhbGx5IHNvcnRlZC4gVGhlIGtleXMgYXJlIGFsc29cclxuICogZGVzaWduZWQgdG8gYmUgdW5ndWVzc2FibGUgKHRoZXkgY29udGFpbiA3MiByYW5kb20gYml0cyBvZiBlbnRyb3B5KS5cclxuICpcclxuICogU2VlIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNhcHBlbmRfdG9fYV9saXN0X29mX2RhdGEgfCBBcHBlbmQgdG8gYSBsaXN0IG9mIGRhdGF9LlxyXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlYmxvZy5jb20vMjAxNS8wMi90aGUtMjEyMC13YXlzLXRvLWVuc3VyZS11bmlxdWVfNjguaHRtbCB8IFRoZSAyXjEyMCBXYXlzIHRvIEVuc3VyZSBVbmlxdWUgSWRlbnRpZmllcnN9LlxyXG4gKlxyXG4gKiBAcGFyYW0gcGFyZW50IC0gVGhlIHBhcmVudCBsb2NhdGlvbi5cclxuICogQHBhcmFtIHZhbHVlIC0gT3B0aW9uYWwgdmFsdWUgdG8gYmUgd3JpdHRlbiBhdCB0aGUgZ2VuZXJhdGVkIGxvY2F0aW9uLlxyXG4gKiBAcmV0dXJucyBDb21iaW5lZCBgUHJvbWlzZWAgYW5kIGBSZWZlcmVuY2VgOyByZXNvbHZlcyB3aGVuIHdyaXRlIGlzIGNvbXBsZXRlLFxyXG4gKiBidXQgY2FuIGJlIHVzZWQgaW1tZWRpYXRlbHkgYXMgdGhlIGBSZWZlcmVuY2VgIHRvIHRoZSBjaGlsZCBsb2NhdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHB1c2gocGFyZW50LCB2YWx1ZSkge1xyXG4gICAgcGFyZW50ID0gZ2V0TW9kdWxhckluc3RhbmNlKHBhcmVudCk7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgncHVzaCcsIHBhcmVudC5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygncHVzaCcsIHZhbHVlLCBwYXJlbnQuX3BhdGgsIHRydWUpO1xyXG4gICAgY29uc3Qgbm93ID0gcmVwb1NlcnZlclRpbWUocGFyZW50Ll9yZXBvKTtcclxuICAgIGNvbnN0IG5hbWUgPSBuZXh0UHVzaElkKG5vdyk7XHJcbiAgICAvLyBwdXNoKCkgcmV0dXJucyBhIFRoZW5uYWJsZVJlZmVyZW5jZSB3aG9zZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFcclxuICAgIC8vIHJlZ3VsYXIgUmVmZXJlbmNlLiBXZSB1c2UgY2hpbGQoKSB0byBjcmVhdGUgaGFuZGxlcyB0byB0d28gZGlmZmVyZW50XHJcbiAgICAvLyByZWZlcmVuY2VzLiBUaGUgZmlyc3QgaXMgdHVybmVkIGludG8gYSBUaGVubmFibGVSZWZlcmVuY2UgYmVsb3cgYnkgYWRkaW5nXHJcbiAgICAvLyB0aGVuKCkgYW5kIGNhdGNoKCkgbWV0aG9kcyBhbmQgaXMgdXNlZCBhcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHB1c2goKS4gVGhlXHJcbiAgICAvLyBzZWNvbmQgcmVtYWlucyBhIHJlZ3VsYXIgUmVmZXJlbmNlIGFuZCBpcyB1c2VkIGFzIHRoZSBmdWxmaWxsZWQgdmFsdWUgb2ZcclxuICAgIC8vIHRoZSBmaXJzdCBUaGVubmFibGVSZWZlcmVuY2UuXHJcbiAgICBjb25zdCB0aGVubmFibGVQdXNoUmVmID0gY2hpbGQocGFyZW50LCBuYW1lKTtcclxuICAgIGNvbnN0IHB1c2hSZWYgPSBjaGlsZChwYXJlbnQsIG5hbWUpO1xyXG4gICAgbGV0IHByb21pc2U7XHJcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgIHByb21pc2UgPSBzZXQocHVzaFJlZiwgdmFsdWUpLnRoZW4oKCkgPT4gcHVzaFJlZik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHB1c2hSZWYpO1xyXG4gICAgfVxyXG4gICAgdGhlbm5hYmxlUHVzaFJlZi50aGVuID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSk7XHJcbiAgICB0aGVubmFibGVQdXNoUmVmLmNhdGNoID0gcHJvbWlzZS50aGVuLmJpbmQocHJvbWlzZSwgdW5kZWZpbmVkKTtcclxuICAgIHJldHVybiB0aGVubmFibGVQdXNoUmVmO1xyXG59XHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBkYXRhIGF0IHRoaXMgRGF0YWJhc2UgbG9jYXRpb24uXHJcbiAqXHJcbiAqIEFueSBkYXRhIGF0IGNoaWxkIGxvY2F0aW9ucyB3aWxsIGFsc28gYmUgZGVsZXRlZC5cclxuICpcclxuICogVGhlIGVmZmVjdCBvZiB0aGUgcmVtb3ZlIHdpbGwgYmUgdmlzaWJsZSBpbW1lZGlhdGVseSBhbmQgdGhlIGNvcnJlc3BvbmRpbmdcclxuICogZXZlbnQgJ3ZhbHVlJyB3aWxsIGJlIHRyaWdnZXJlZC4gU3luY2hyb25pemF0aW9uIG9mIHRoZSByZW1vdmUgdG8gdGhlXHJcbiAqIEZpcmViYXNlIHNlcnZlcnMgd2lsbCBhbHNvIGJlIHN0YXJ0ZWQsIGFuZCB0aGUgcmV0dXJuZWQgUHJvbWlzZSB3aWxsIHJlc29sdmVcclxuICogd2hlbiBjb21wbGV0ZS4gSWYgcHJvdmlkZWQsIHRoZSBvbkNvbXBsZXRlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXHJcbiAqIGFzeW5jaHJvbm91c2x5IGFmdGVyIHN5bmNocm9uaXphdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gcmVtb3ZlLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHJlbW92ZSBvbiBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmUocmVmKSB7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgncmVtb3ZlJywgcmVmLl9wYXRoKTtcclxuICAgIHJldHVybiBzZXQocmVmLCBudWxsKTtcclxufVxyXG4vKipcclxuICogV3JpdGVzIGRhdGEgdG8gdGhpcyBEYXRhYmFzZSBsb2NhdGlvbi5cclxuICpcclxuICogVGhpcyB3aWxsIG92ZXJ3cml0ZSBhbnkgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIGFuZCBhbGwgY2hpbGQgbG9jYXRpb25zLlxyXG4gKlxyXG4gKiBUaGUgZWZmZWN0IG9mIHRoZSB3cml0ZSB3aWxsIGJlIHZpc2libGUgaW1tZWRpYXRlbHksIGFuZCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiBldmVudHMgKFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLCBldGMuKSB3aWxsIGJlIHRyaWdnZXJlZC4gU3luY2hyb25pemF0aW9uIG9mXHJcbiAqIHRoZSBkYXRhIHRvIHRoZSBGaXJlYmFzZSBzZXJ2ZXJzIHdpbGwgYWxzbyBiZSBzdGFydGVkLCBhbmQgdGhlIHJldHVybmVkXHJcbiAqIFByb21pc2Ugd2lsbCByZXNvbHZlIHdoZW4gY29tcGxldGUuIElmIHByb3ZpZGVkLCB0aGUgYG9uQ29tcGxldGVgIGNhbGxiYWNrXHJcbiAqIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHN5bmNocm9uaXphdGlvbiBoYXMgZmluaXNoZWQuXHJcbiAqXHJcbiAqIFBhc3NpbmcgYG51bGxgIGZvciB0aGUgbmV3IHZhbHVlIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyBgcmVtb3ZlKClgOyBuYW1lbHksXHJcbiAqIGFsbCBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYW5kIGFsbCBjaGlsZCBsb2NhdGlvbnMgd2lsbCBiZSBkZWxldGVkLlxyXG4gKlxyXG4gKiBgc2V0KClgIHdpbGwgcmVtb3ZlIGFueSBwcmlvcml0eSBzdG9yZWQgYXQgdGhpcyBsb2NhdGlvbiwgc28gaWYgcHJpb3JpdHkgaXNcclxuICogbWVhbnQgdG8gYmUgcHJlc2VydmVkLCB5b3UgbmVlZCB0byB1c2UgYHNldFdpdGhQcmlvcml0eSgpYCBpbnN0ZWFkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgbW9kaWZ5aW5nIGRhdGEgd2l0aCBgc2V0KClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nIHRyYW5zYWN0aW9uc1xyXG4gKiBhdCB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZyBgc2V0KClgIGFuZFxyXG4gKiBgdHJhbnNhY3Rpb24oKWAgdG8gbW9kaWZ5IHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIEEgc2luZ2xlIGBzZXQoKWAgd2lsbCBnZW5lcmF0ZSBhIHNpbmdsZSBcInZhbHVlXCIgZXZlbnQgYXQgdGhlIGxvY2F0aW9uIHdoZXJlXHJcbiAqIHRoZSBgc2V0KClgIHdhcyBwZXJmb3JtZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgLSBUaGUgbG9jYXRpb24gdG8gd3JpdGUgdG8uXHJcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuIChzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb2JqZWN0LFxyXG4gKiAgIGFycmF5LCBvciBudWxsKS5cclxuICogQHJldHVybnMgUmVzb2x2ZXMgd2hlbiB3cml0ZSB0byBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXQocmVmLCB2YWx1ZSkge1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnc2V0JywgcmVmLl9wYXRoKTtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzZXQnLCB2YWx1ZSwgcmVmLl9wYXRoLCBmYWxzZSk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1NldFdpdGhQcmlvcml0eShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWUsIFxyXG4gICAgLypwcmlvcml0eT0qLyBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogU2V0cyBhIHByaW9yaXR5IGZvciB0aGUgZGF0YSBhdCB0aGlzIERhdGFiYXNlIGxvY2F0aW9uLlxyXG4gKlxyXG4gKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICogb3JkaW5hcnkgcHJvcGVydGllcyAoc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0aW5nX2FuZF9maWx0ZXJpbmdfZGF0YSB8IFNvcnRpbmcgYW5kIGZpbHRlcmluZyBkYXRhfVxyXG4gKiApLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIG9yIG51bGwpLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHdyaXRlIHRvIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldFByaW9yaXR5KHJlZiwgcHJpb3JpdHkpIHtcclxuICAgIHJlZiA9IGdldE1vZHVsYXJJbnN0YW5jZShyZWYpO1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3NldFByaW9yaXR5JywgcmVmLl9wYXRoKTtcclxuICAgIHZhbGlkYXRlUHJpb3JpdHkoJ3NldFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XHJcbiAgICByZXBvU2V0V2l0aFByaW9yaXR5KHJlZi5fcmVwbywgcGF0aENoaWxkKHJlZi5fcGF0aCwgJy5wcmlvcml0eScpLCBwcmlvcml0eSwgbnVsbCwgZGVmZXJyZWQud3JhcENhbGxiYWNrKCgpID0+IHsgfSkpO1xyXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlcyBkYXRhIHRoZSBEYXRhYmFzZSBsb2NhdGlvbi4gTGlrZSBgc2V0KClgIGJ1dCBhbHNvIHNwZWNpZmllcyB0aGVcclxuICogcHJpb3JpdHkgZm9yIHRoYXQgZGF0YS5cclxuICpcclxuICogQXBwbGljYXRpb25zIG5lZWQgbm90IHVzZSBwcmlvcml0eSBidXQgY2FuIG9yZGVyIGNvbGxlY3Rpb25zIGJ5XHJcbiAqIG9yZGluYXJ5IHByb3BlcnRpZXMgKHNlZVxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjc29ydGluZ19hbmRfZmlsdGVyaW5nX2RhdGEgfCBTb3J0aW5nIGFuZCBmaWx0ZXJpbmcgZGF0YX1cclxuICogKS5cclxuICpcclxuICogQHBhcmFtIHJlZiAtIFRoZSBsb2NhdGlvbiB0byB3cml0ZSB0by5cclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4gKHN0cmluZywgbnVtYmVyLCBib29sZWFuLCBvYmplY3QsXHJcbiAqICAgYXJyYXksIG9yIG51bGwpLlxyXG4gKiBAcGFyYW0gcHJpb3JpdHkgLSBUaGUgcHJpb3JpdHkgdG8gYmUgd3JpdHRlbiAoc3RyaW5nLCBudW1iZXIsIG9yIG51bGwpLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHdyaXRlIHRvIHNlcnZlciBpcyBjb21wbGV0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHNldFdpdGhQcmlvcml0eShyZWYsIHZhbHVlLCBwcmlvcml0eSkge1xyXG4gICAgdmFsaWRhdGVXcml0YWJsZVBhdGgoJ3NldFdpdGhQcmlvcml0eScsIHJlZi5fcGF0aCk7XHJcbiAgICB2YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnc2V0V2l0aFByaW9yaXR5JywgdmFsdWUsIHJlZi5fcGF0aCwgZmFsc2UpO1xyXG4gICAgdmFsaWRhdGVQcmlvcml0eSgnc2V0V2l0aFByaW9yaXR5JywgcHJpb3JpdHksIGZhbHNlKTtcclxuICAgIGlmIChyZWYua2V5ID09PSAnLmxlbmd0aCcgfHwgcmVmLmtleSA9PT0gJy5rZXlzJykge1xyXG4gICAgICAgIHRocm93ICdzZXRXaXRoUHJpb3JpdHkgZmFpbGVkOiAnICsgcmVmLmtleSArICcgaXMgYSByZWFkLW9ubHkgb2JqZWN0Lic7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1NldFdpdGhQcmlvcml0eShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWUsIHByaW9yaXR5LCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogV3JpdGVzIG11bHRpcGxlIHZhbHVlcyB0byB0aGUgRGF0YWJhc2UgYXQgb25jZS5cclxuICpcclxuICogVGhlIGB2YWx1ZXNgIGFyZ3VtZW50IGNvbnRhaW5zIG11bHRpcGxlIHByb3BlcnR5LXZhbHVlIHBhaXJzIHRoYXQgd2lsbCBiZVxyXG4gKiB3cml0dGVuIHRvIHRoZSBEYXRhYmFzZSB0b2dldGhlci4gRWFjaCBjaGlsZCBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlXHJcbiAqIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgXCJuYW1lXCIpIG9yIGEgcmVsYXRpdmUgcGF0aCAoZm9yIGV4YW1wbGUsXHJcbiAqIFwibmFtZS9maXJzdFwiKSBmcm9tIHRoZSBjdXJyZW50IGxvY2F0aW9uIHRvIHRoZSBkYXRhIHRvIHVwZGF0ZS5cclxuICpcclxuICogQXMgb3Bwb3NlZCB0byB0aGUgYHNldCgpYCBtZXRob2QsIGB1cGRhdGUoKWAgY2FuIGJlIHVzZSB0byBzZWxlY3RpdmVseSB1cGRhdGVcclxuICogb25seSB0aGUgcmVmZXJlbmNlZCBwcm9wZXJ0aWVzIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIChpbnN0ZWFkIG9mIHJlcGxhY2luZ1xyXG4gKiBhbGwgdGhlIGNoaWxkIHByb3BlcnRpZXMgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24pLlxyXG4gKlxyXG4gKiBUaGUgZWZmZWN0IG9mIHRoZSB3cml0ZSB3aWxsIGJlIHZpc2libGUgaW1tZWRpYXRlbHksIGFuZCB0aGUgY29ycmVzcG9uZGluZ1xyXG4gKiBldmVudHMgKCd2YWx1ZScsICdjaGlsZF9hZGRlZCcsIGV0Yy4pIHdpbGwgYmUgdHJpZ2dlcmVkLiBTeW5jaHJvbml6YXRpb24gb2ZcclxuICogdGhlIGRhdGEgdG8gdGhlIEZpcmViYXNlIHNlcnZlcnMgd2lsbCBhbHNvIGJlIHN0YXJ0ZWQsIGFuZCB0aGUgcmV0dXJuZWRcclxuICogUHJvbWlzZSB3aWxsIHJlc29sdmUgd2hlbiBjb21wbGV0ZS4gSWYgcHJvdmlkZWQsIHRoZSBgb25Db21wbGV0ZWAgY2FsbGJhY2tcclxuICogd2lsbCBiZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgc3luY2hyb25pemF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogQSBzaW5nbGUgYHVwZGF0ZSgpYCB3aWxsIGdlbmVyYXRlIGEgc2luZ2xlIFwidmFsdWVcIiBldmVudCBhdCB0aGUgbG9jYXRpb25cclxuICogd2hlcmUgdGhlIGB1cGRhdGUoKWAgd2FzIHBlcmZvcm1lZCwgcmVnYXJkbGVzcyBvZiBob3cgbWFueSBjaGlsZHJlbiB3ZXJlXHJcbiAqIG1vZGlmaWVkLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgbW9kaWZ5aW5nIGRhdGEgd2l0aCBgdXBkYXRlKClgIHdpbGwgY2FuY2VsIGFueSBwZW5kaW5nXHJcbiAqIHRyYW5zYWN0aW9ucyBhdCB0aGF0IGxvY2F0aW9uLCBzbyBleHRyZW1lIGNhcmUgc2hvdWxkIGJlIHRha2VuIGlmIG1peGluZ1xyXG4gKiBgdXBkYXRlKClgIGFuZCBgdHJhbnNhY3Rpb24oKWAgdG8gbW9kaWZ5IHRoZSBzYW1lIGRhdGEuXHJcbiAqXHJcbiAqIFBhc3NpbmcgYG51bGxgIHRvIGB1cGRhdGUoKWAgd2lsbCByZW1vdmUgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi5cclxuICpcclxuICogU2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZWJsb2cuY29tLzIwMTUvMDkvaW50cm9kdWNpbmctbXVsdGktbG9jYXRpb24tdXBkYXRlcy1hbmRfODYuaHRtbCB8IEludHJvZHVjaW5nIG11bHRpLWxvY2F0aW9uIHVwZGF0ZXMgYW5kIG1vcmV9LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIHdyaXRlIHRvLlxyXG4gKiBAcGFyYW0gdmFsdWVzIC0gT2JqZWN0IGNvbnRhaW5pbmcgbXVsdGlwbGUgdmFsdWVzLlxyXG4gKiBAcmV0dXJucyBSZXNvbHZlcyB3aGVuIHVwZGF0ZSBvbiBzZXJ2ZXIgaXMgY29tcGxldGUuXHJcbiAqL1xyXG5mdW5jdGlvbiB1cGRhdGUocmVmLCB2YWx1ZXMpIHtcclxuICAgIHZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmcoJ3VwZGF0ZScsIHZhbHVlcywgcmVmLl9wYXRoLCBmYWxzZSk7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgcmVwb1VwZGF0ZShyZWYuX3JlcG8sIHJlZi5fcGF0aCwgdmFsdWVzLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2soKCkgPT4geyB9KSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxyXG4vKipcclxuICogR2V0cyB0aGUgbW9zdCB1cC10by1kYXRlIHJlc3VsdCBmb3IgdGhpcyBxdWVyeS5cclxuICpcclxuICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHJ1bi5cclxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHJlc3VsdGluZyBEYXRhU25hcHNob3QgaWYgYSB2YWx1ZSBpc1xyXG4gKiBhdmFpbGFibGUsIG9yIHJlamVjdHMgaWYgdGhlIGNsaWVudCBpcyB1bmFibGUgdG8gcmV0dXJuIGEgdmFsdWUgKGUuZy4sIGlmIHRoZVxyXG4gKiBzZXJ2ZXIgaXMgdW5yZWFjaGFibGUgYW5kIHRoZXJlIGlzIG5vdGhpbmcgY2FjaGVkKS5cclxuICovXHJcbmZ1bmN0aW9uIGdldChxdWVyeSkge1xyXG4gICAgcXVlcnkgPSBnZXRNb2R1bGFySW5zdGFuY2UocXVlcnkpO1xyXG4gICAgY29uc3QgY2FsbGJhY2tDb250ZXh0ID0gbmV3IENhbGxiYWNrQ29udGV4dCgoKSA9PiB7IH0pO1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gbmV3IFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tDb250ZXh0KTtcclxuICAgIHJldHVybiByZXBvR2V0VmFsdWUocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpLnRoZW4obm9kZSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhU25hcHNob3Qobm9kZSwgbmV3IFJlZmVyZW5jZUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoKSwgcXVlcnkuX3F1ZXJ5UGFyYW1zLmdldEluZGV4KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgcmVnaXN0cmF0aW9uIGZvciAndmFsdWUnIGV2ZW50cy5cclxuICovXHJcbmNsYXNzIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ge1xyXG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2tDb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQgPSBjYWxsYmFja0NvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZXNwb25kc1RvKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIHJldHVybiBldmVudFR5cGUgPT09ICd2YWx1ZSc7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFdmVudChjaGFuZ2UsIHF1ZXJ5KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBxdWVyeS5fcXVlcnlQYXJhbXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICByZXR1cm4gbmV3IERhdGFFdmVudCgndmFsdWUnLCB0aGlzLCBuZXcgRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIG5ldyBSZWZlcmVuY2VJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCksIGluZGV4KSk7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcihldmVudERhdGEpIHtcclxuICAgICAgICBpZiAoZXZlbnREYXRhLmdldEV2ZW50VHlwZSgpID09PSAnY2FuY2VsJykge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25DYW5jZWwoZXZlbnREYXRhLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vblZhbHVlKGV2ZW50RGF0YS5zbmFwc2hvdCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlQ2FuY2VsRXZlbnQoZXJyb3IsIHBhdGgpIHtcclxuICAgICAgICBpZiAodGhpcy5jYWxsYmFja0NvbnRleHQuaGFzQ2FuY2VsQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvdGhlci5jYWxsYmFja0NvbnRleHQgfHwgIXRoaXMuY2FsbGJhY2tDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIHNwZWNpZmllZCwgd2UgY29uc2lkZXIgaXQgdG8gbWF0Y2ggYW55IGNhbGxiYWNrLlxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvdGhlci5jYWxsYmFja0NvbnRleHQubWF0Y2hlcyh0aGlzLmNhbGxiYWNrQ29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFzQW55Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tDb250ZXh0ICE9PSBudWxsO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSByZWdpc3RyYXRpb24gb2YgYSBjaGlsZF94IGV2ZW50LlxyXG4gKi9cclxuY2xhc3MgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihldmVudFR5cGUsIGNhbGxiYWNrQ29udGV4dCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tDb250ZXh0ID0gY2FsbGJhY2tDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgcmVzcG9uZHNUbyhldmVudFR5cGUpIHtcclxuICAgICAgICBsZXQgZXZlbnRUb0NoZWNrID0gZXZlbnRUeXBlID09PSAnY2hpbGRyZW5fYWRkZWQnID8gJ2NoaWxkX2FkZGVkJyA6IGV2ZW50VHlwZTtcclxuICAgICAgICBldmVudFRvQ2hlY2sgPVxyXG4gICAgICAgICAgICBldmVudFRvQ2hlY2sgPT09ICdjaGlsZHJlbl9yZW1vdmVkJyA/ICdjaGlsZF9yZW1vdmVkJyA6IGV2ZW50VG9DaGVjaztcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudFR5cGUgPT09IGV2ZW50VG9DaGVjaztcclxuICAgIH1cclxuICAgIGNyZWF0ZUNhbmNlbEV2ZW50KGVycm9yLCBwYXRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tDb250ZXh0Lmhhc0NhbmNlbENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FuY2VsRXZlbnQodGhpcywgZXJyb3IsIHBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlRXZlbnQoY2hhbmdlLCBxdWVyeSkge1xyXG4gICAgICAgIGFzc2VydChjaGFuZ2UuY2hpbGROYW1lICE9IG51bGwsICdDaGlsZCBldmVudHMgc2hvdWxkIGhhdmUgYSBjaGlsZE5hbWUuJyk7XHJcbiAgICAgICAgY29uc3QgY2hpbGRSZWYgPSBjaGlsZChuZXcgUmVmZXJlbmNlSW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgpLCBjaGFuZ2UuY2hpbGROYW1lKTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHF1ZXJ5Ll9xdWVyeVBhcmFtcy5nZXRJbmRleCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YUV2ZW50KGNoYW5nZS50eXBlLCB0aGlzLCBuZXcgRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIGNoaWxkUmVmLCBpbmRleCksIGNoYW5nZS5wcmV2TmFtZSk7XHJcbiAgICB9XHJcbiAgICBnZXRFdmVudFJ1bm5lcihldmVudERhdGEpIHtcclxuICAgICAgICBpZiAoZXZlbnREYXRhLmdldEV2ZW50VHlwZSgpID09PSAnY2FuY2VsJykge1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jYWxsYmFja0NvbnRleHQub25DYW5jZWwoZXZlbnREYXRhLmVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0aGlzLmNhbGxiYWNrQ29udGV4dC5vblZhbHVlKGV2ZW50RGF0YS5zbmFwc2hvdCwgZXZlbnREYXRhLnByZXZOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuZXZlbnRUeXBlID09PSBvdGhlci5ldmVudFR5cGUgJiZcclxuICAgICAgICAgICAgICAgICghdGhpcy5jYWxsYmFja0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICAhb3RoZXIuY2FsbGJhY2tDb250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja0NvbnRleHQubWF0Y2hlcyhvdGhlci5jYWxsYmFja0NvbnRleHQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGhhc0FueUNhbGxiYWNrKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuY2FsbGJhY2tDb250ZXh0O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksIGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zLCBvcHRpb25zKSB7XHJcbiAgICBsZXQgY2FuY2VsQ2FsbGJhY2s7XHJcbiAgICBpZiAodHlwZW9mIGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGNhbmNlbENhbGxiYWNrID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIG9wdGlvbnMgPSBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucztcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBjYW5jZWxDYWxsYmFjayA9IGNhbmNlbENhbGxiYWNrT3JMaXN0ZW5PcHRpb25zO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vbmx5T25jZSkge1xyXG4gICAgICAgIGNvbnN0IHVzZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGNvbnN0IG9uY2VDYWxsYmFjayA9IChkYXRhU25hcHNob3QsIHByZXZpb3VzQ2hpbGROYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICB1c2VyQ2FsbGJhY2soZGF0YVNuYXBzaG90LCBwcmV2aW91c0NoaWxkTmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBvbmNlQ2FsbGJhY2sudXNlckNhbGxiYWNrID0gY2FsbGJhY2sudXNlckNhbGxiYWNrO1xyXG4gICAgICAgIG9uY2VDYWxsYmFjay5jb250ZXh0ID0gY2FsbGJhY2suY29udGV4dDtcclxuICAgICAgICBjYWxsYmFjayA9IG9uY2VDYWxsYmFjaztcclxuICAgIH1cclxuICAgIGNvbnN0IGNhbGxiYWNrQ29udGV4dCA9IG5ldyBDYWxsYmFja0NvbnRleHQoY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrIHx8IHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBldmVudFR5cGUgPT09ICd2YWx1ZSdcclxuICAgICAgICA/IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrQ29udGV4dClcclxuICAgICAgICA6IG5ldyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50VHlwZSwgY2FsbGJhY2tDb250ZXh0KTtcclxuICAgIHJlcG9BZGRFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG4gICAgcmV0dXJuICgpID0+IHJlcG9SZW1vdmVFdmVudENhbGxiYWNrRm9yUXVlcnkocXVlcnkuX3JlcG8sIHF1ZXJ5LCBjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIG9uVmFsdWUocXVlcnksIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGFkZEV2ZW50TGlzdGVuZXIocXVlcnksICd2YWx1ZScsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZEFkZGVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfYWRkZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRDaGFuZ2VkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfY2hhbmdlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuZnVuY3Rpb24gb25DaGlsZE1vdmVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfbW92ZWQnLCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ2hpbGRSZW1vdmVkKHF1ZXJ5LCBjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2tPckxpc3Rlbk9wdGlvbnMsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBhZGRFdmVudExpc3RlbmVyKHF1ZXJ5LCAnY2hpbGRfcmVtb3ZlZCcsIGNhbGxiYWNrLCBjYW5jZWxDYWxsYmFja09yTGlzdGVuT3B0aW9ucywgb3B0aW9ucyk7XHJcbn1cclxuLyoqXHJcbiAqIERldGFjaGVzIGEgY2FsbGJhY2sgcHJldmlvdXNseSBhdHRhY2hlZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIGBvbiooKWAgKGBvblZhbHVlYCwgYG9uQ2hpbGRBZGRlZGApIGxpc3RlbmVyLlxyXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgcmVjb21tZW5kZWQgd2F5IHRvIHJlbW92ZSBhIGxpc3RlbmVyLiBJbnN0ZWFkLCBwbGVhc2UgdXNlIHRoZSByZXR1cm5lZCBjYWxsYmFjayBmdW5jdGlvbiBmcm9tXHJcbiAqIHRoZSByZXNwZWN0aXZlIGBvbipgIGNhbGxiYWNrcy5cclxuICpcclxuICogRGV0YWNoIGEgY2FsbGJhY2sgcHJldmlvdXNseSBhdHRhY2hlZCB3aXRoIGBvbiooKWAuIENhbGxpbmcgYG9mZigpYCBvbiBhIHBhcmVudCBsaXN0ZW5lclxyXG4gKiB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IHJlbW92ZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBvbiBjaGlsZCBub2RlcywgYG9mZigpYFxyXG4gKiBtdXN0IGFsc28gYmUgY2FsbGVkIG9uIGFueSBjaGlsZCBsaXN0ZW5lcnMgdG8gcmVtb3ZlIHRoZSBjYWxsYmFjay5cclxuICpcclxuICogSWYgYSBjYWxsYmFjayBpcyBub3Qgc3BlY2lmaWVkLCBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50VHlwZVxyXG4gKiB3aWxsIGJlIHJlbW92ZWQuIFNpbWlsYXJseSwgaWYgbm8gZXZlbnRUeXBlIGlzIHNwZWNpZmllZCwgYWxsIGNhbGxiYWNrc1xyXG4gKiBmb3IgdGhlIGBSZWZlcmVuY2VgIHdpbGwgYmUgcmVtb3ZlZC5cclxuICpcclxuICogSW5kaXZpZHVhbCBsaXN0ZW5lcnMgY2FuIGFsc28gYmUgcmVtb3ZlZCBieSBpbnZva2luZyB0aGVpciB1bnN1YnNjcmliZVxyXG4gKiBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0aGF0IHRoZSBsaXN0ZW5lciB3YXMgcmVnaXN0ZXJlZCB3aXRoLlxyXG4gKiBAcGFyYW0gZXZlbnRUeXBlIC0gT25lIG9mIHRoZSBmb2xsb3dpbmcgc3RyaW5nczogXCJ2YWx1ZVwiLCBcImNoaWxkX2FkZGVkXCIsXHJcbiAqIFwiY2hpbGRfY2hhbmdlZFwiLCBcImNoaWxkX3JlbW92ZWRcIiwgb3IgXCJjaGlsZF9tb3ZlZC5cIiBJZiBvbWl0dGVkLCBhbGwgY2FsbGJhY2tzXHJcbiAqIGZvciB0aGUgYFJlZmVyZW5jZWAgd2lsbCBiZSByZW1vdmVkLlxyXG4gKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3YXMgcGFzc2VkIHRvIGBvbigpYCBvclxyXG4gKiBgdW5kZWZpbmVkYCB0byByZW1vdmUgYWxsIGNhbGxiYWNrcy5cclxuICovXHJcbmZ1bmN0aW9uIG9mZihxdWVyeSwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xyXG4gICAgbGV0IGNvbnRhaW5lciA9IG51bGw7XHJcbiAgICBjb25zdCBleHBDYWxsYmFjayA9IGNhbGxiYWNrID8gbmV3IENhbGxiYWNrQ29udGV4dChjYWxsYmFjaykgOiBudWxsO1xyXG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gJ3ZhbHVlJykge1xyXG4gICAgICAgIGNvbnRhaW5lciA9IG5ldyBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uKGV4cENhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2ZW50VHlwZSkge1xyXG4gICAgICAgIGNvbnRhaW5lciA9IG5ldyBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50VHlwZSwgZXhwQ2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgcmVwb1JlbW92ZUV2ZW50Q2FsbGJhY2tGb3JRdWVyeShxdWVyeS5fcmVwbywgcXVlcnksIGNvbnRhaW5lcik7XHJcbn1cclxuLyoqXHJcbiAqIEEgYFF1ZXJ5Q29uc3RyYWludGAgaXMgdXNlZCB0byBuYXJyb3cgdGhlIHNldCBvZiBkb2N1bWVudHMgcmV0dXJuZWQgYnkgYVxyXG4gKiBEYXRhYmFzZSBxdWVyeS4gYFF1ZXJ5Q29uc3RyYWludGBzIGFyZSBjcmVhdGVkIGJ5IGludm9raW5nIHtAbGluayBlbmRBdH0sXHJcbiAqIHtAbGluayBlbmRCZWZvcmV9LCB7QGxpbmsgc3RhcnRBdH0sIHtAbGluayBzdGFydEFmdGVyfSwge0BsaW5rXHJcbiAqIGxpbWl0VG9GaXJzdH0sIHtAbGluayBsaW1pdFRvTGFzdH0sIHtAbGluayBvcmRlckJ5Q2hpbGR9LFxyXG4gKiB7QGxpbmsgb3JkZXJCeUNoaWxkfSwge0BsaW5rIG9yZGVyQnlLZXl9ICwge0BsaW5rIG9yZGVyQnlQcmlvcml0eX0gLFxyXG4gKiB7QGxpbmsgb3JkZXJCeVZhbHVlfSAgb3Ige0BsaW5rIGVxdWFsVG99IGFuZFxyXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8ge0BsaW5rIHF1ZXJ5fSB0byBjcmVhdGUgYSBuZXcgcXVlcnkgaW5zdGFuY2UgdGhhdFxyXG4gKiBhbHNvIGNvbnRhaW5zIHRoaXMgYFF1ZXJ5Q29uc3RyYWludGAuXHJcbiAqL1xyXG5jbGFzcyBRdWVyeUNvbnN0cmFpbnQge1xyXG59XHJcbmNsYXNzIFF1ZXJ5RW5kQXRDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlbmRBdCcsIHRoaXMuX3ZhbHVlLCBxdWVyeS5fcGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNFbmRBdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnZW5kQmVmb3JlIG9yIGVxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgcXVlcnkuX29yZGVyQnlDYWxsZWQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgYFF1ZXJ5Q29uc3RyYWludGAgd2l0aCB0aGUgc3BlY2lmaWVkIGVuZGluZyBwb2ludC5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgZW5kaW5nIHBvaW50IGlzIGluY2x1c2l2ZSwgc28gY2hpbGRyZW4gd2l0aCBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICogd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkuIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG9cclxuICogZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdFxyXG4gKiBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBhIGtleSBuYW1lIGxlc3MgdGhhbiBvciBlcXVhbFxyXG4gKiB0byB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGVuZEF0KClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuZCBhdC4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gZW5kIGF0LCBhbW9uZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgcHJldmlvdXNseVxyXG4gKiBzcGVjaWZpZWQgcHJpb3JpdHkuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhbGxvd2VkIGlmIG9yZGVyaW5nIGJ5IGNoaWxkLFxyXG4gKiB2YWx1ZSwgb3IgcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBlbmRBdCh2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnZW5kQXQnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRBdENvbnN0cmFpbnQodmFsdWUsIGtleSk7XHJcbn1cclxuY2xhc3MgUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdlbmRCZWZvcmUnLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc0VuZEJlZm9yZShxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNFbmQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZEJlZm9yZTogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQsICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VuZEJlZm9yZSBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBlbmRpbmcgcG9pbnQgKGV4Y2x1c2l2ZSkuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIGVuZGluZyBwb2ludCBpcyBleGNsdXNpdmUuIElmIG9ubHkgYSB2YWx1ZSBpcyBwcm92aWRlZCwgY2hpbGRyZW5cclxuICogd2l0aCBhIHZhbHVlIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkIHZhbHVlIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHF1ZXJ5LlxyXG4gKiBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gbXVzdCBoYXZlIGEgdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsXHJcbiAqIHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUgYW5kIGEga2V5IG5hbWUgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5kIGJlZm9yZS4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gZW5kIGJlZm9yZSwgYW1vbmcgdGhlIGNoaWxkcmVuIHdpdGggdGhlXHJcbiAqIHByZXZpb3VzbHkgc3BlY2lmaWVkIHByaW9yaXR5LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZiBvcmRlcmluZyBieVxyXG4gKiBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZW5kQmVmb3JlKHZhbHVlLCBrZXkpIHtcclxuICAgIHZhbGlkYXRlS2V5KCdlbmRCZWZvcmUnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFbmRCZWZvcmVDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5U3RhcnRBdENvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ3N0YXJ0QXQnLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zU3RhcnRBdChxdWVyeS5fcXVlcnlQYXJhbXMsIHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpO1xyXG4gICAgICAgIHZhbGlkYXRlTGltaXQobmV3UGFyYW1zKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNTdGFydCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RhcnRBdDogU3RhcnRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gc3RhcnRBdCwgJyArXHJcbiAgICAgICAgICAgICAgICAnc3RhcnRCZWZvcmUgb3IgZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUXVlcnlJbXBsKHF1ZXJ5Ll9yZXBvLCBxdWVyeS5fcGF0aCwgbmV3UGFyYW1zLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBgUXVlcnlDb25zdHJhaW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgc3RhcnRpbmcgcG9pbnQuXHJcbiAqXHJcbiAqIFVzaW5nIGBzdGFydEF0KClgLCBgc3RhcnRBZnRlcigpYCwgYGVuZEJlZm9yZSgpYCwgYGVuZEF0KClgIGFuZCBgZXF1YWxUbygpYFxyXG4gKiBhbGxvd3MgeW91IHRvIGNob29zZSBhcmJpdHJhcnkgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMgZm9yIHlvdXIgcXVlcmllcy5cclxuICpcclxuICogVGhlIHN0YXJ0aW5nIHBvaW50IGlzIGluY2x1c2l2ZSwgc28gY2hpbGRyZW4gd2l0aCBleGFjdGx5IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICogd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgcXVlcnkuIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG9cclxuICogZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdFxyXG4gKiBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBhIGtleSBuYW1lIGdyZWF0ZXIgdGhhbiBvclxyXG4gKiBlcXVhbCB0byB0aGUgc3BlY2lmaWVkIGtleS5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYHN0YXJ0QXQoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI2ZpbHRlcmluZ19kYXRhIHwgRmlsdGVyaW5nIGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RhcnQgYXQuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIHN0YXJ0IGF0LiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZlxyXG4gKiBvcmRlcmluZyBieSBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnRBdCh2YWx1ZSA9IG51bGwsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ3N0YXJ0QXQnLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh2YWx1ZSwga2V5KTtcclxufVxyXG5jbGFzcyBRdWVyeVN0YXJ0QWZ0ZXJDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2tleSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gX2tleTtcclxuICAgIH1cclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdzdGFydEFmdGVyJywgdGhpcy5fdmFsdWUsIHF1ZXJ5Ll9wYXRoLCBmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNTdGFydEFmdGVyKHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fdmFsdWUsIHRoaXMuX2tleSk7XHJcbiAgICAgICAgdmFsaWRhdGVMaW1pdChuZXdQYXJhbXMpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdGFydEFmdGVyOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0LCAnICtcclxuICAgICAgICAgICAgICAgICdzdGFydEFmdGVyLCBvciBlcXVhbFRvKS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIHF1ZXJ5Ll9vcmRlckJ5Q2FsbGVkKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHdpdGggdGhlIHNwZWNpZmllZCBzdGFydGluZyBwb2ludCAoZXhjbHVzaXZlKS5cclxuICpcclxuICogVXNpbmcgYHN0YXJ0QXQoKWAsIGBzdGFydEFmdGVyKClgLCBgZW5kQmVmb3JlKClgLCBgZW5kQXQoKWAgYW5kIGBlcXVhbFRvKClgXHJcbiAqIGFsbG93cyB5b3UgdG8gY2hvb3NlIGFyYml0cmFyeSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cyBmb3IgeW91ciBxdWVyaWVzLlxyXG4gKlxyXG4gKiBUaGUgc3RhcnRpbmcgcG9pbnQgaXMgZXhjbHVzaXZlLiBJZiBvbmx5IGEgdmFsdWUgaXMgcHJvdmlkZWQsIGNoaWxkcmVuXHJcbiAqIHdpdGggYSB2YWx1ZSBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBxdWVyeS5cclxuICogSWYgYSBrZXkgaXMgc3BlY2lmaWVkLCB0aGVuIGNoaWxkcmVuIG11c3QgaGF2ZSBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxyXG4gKiB0byB0aGUgc3BlY2lmaWVkIHZhbHVlIGFuZCBhIGEga2V5IG5hbWUgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQga2V5LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc3RhcnQgYWZ0ZXIuIFRoZSBhcmd1bWVudCB0eXBlIGRlcGVuZHMgb24gd2hpY2hcclxuICogYG9yZGVyQnkqKClgIGZ1bmN0aW9uIHdhcyB1c2VkIGluIHRoaXMgcXVlcnkuIFNwZWNpZnkgYSB2YWx1ZSB0aGF0IG1hdGNoZXNcclxuICogdGhlIGBvcmRlckJ5KigpYCB0eXBlLiBXaGVuIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBgb3JkZXJCeUtleSgpYCwgdGhlXHJcbiAqIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSBrZXkgLSBUaGUgY2hpbGQga2V5IHRvIHN0YXJ0IGFmdGVyLiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYWxsb3dlZCBpZlxyXG4gKiBvcmRlcmluZyBieSBjaGlsZCwgdmFsdWUsIG9yIHByaW9yaXR5LlxyXG4gKi9cclxuZnVuY3Rpb24gc3RhcnRBZnRlcih2YWx1ZSwga2V5KSB7XHJcbiAgICB2YWxpZGF0ZUtleSgnc3RhcnRBZnRlcicsICdrZXknLCBrZXksIHRydWUpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeVN0YXJ0QWZ0ZXJDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5TGltaXRUb0ZpcnN0Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfbGltaXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2xpbWl0ID0gX2xpbWl0O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Ll9xdWVyeVBhcmFtcy5oYXNMaW1pdCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbGltaXRUb0ZpcnN0OiBMaW1pdCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBsaW1pdFRvRmlyc3QgJyArXHJcbiAgICAgICAgICAgICAgICAnb3IgbGltaXRUb0xhc3QpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIHF1ZXJ5UGFyYW1zTGltaXRUb0ZpcnN0KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fbGltaXQpLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBpZiBsaW1pdGVkIHRvIHRoZSBmaXJzdCBzcGVjaWZpYyBudW1iZXJcclxuICogb2YgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIFRoZSBgbGltaXRUb0ZpcnN0KClgIG1ldGhvZCBpcyB1c2VkIHRvIHNldCBhIG1heGltdW0gbnVtYmVyIG9mIGNoaWxkcmVuIHRvIGJlXHJcbiAqIHN5bmNlZCBmb3IgYSBnaXZlbiBjYWxsYmFjay4gSWYgd2Ugc2V0IGEgbGltaXQgb2YgMTAwLCB3ZSB3aWxsIGluaXRpYWxseSBvbmx5XHJcbiAqIHJlY2VpdmUgdXAgdG8gMTAwIGBjaGlsZF9hZGRlZGAgZXZlbnRzLiBJZiB3ZSBoYXZlIGZld2VyIHRoYW4gMTAwIG1lc3NhZ2VzXHJcbiAqIHN0b3JlZCBpbiBvdXIgRGF0YWJhc2UsIGEgYGNoaWxkX2FkZGVkYCBldmVudCB3aWxsIGZpcmUgZm9yIGVhY2ggbWVzc2FnZS5cclxuICogSG93ZXZlciwgaWYgd2UgaGF2ZSBvdmVyIDEwMCBtZXNzYWdlcywgd2Ugd2lsbCBvbmx5IHJlY2VpdmUgYSBgY2hpbGRfYWRkZWRgXHJcbiAqIGV2ZW50IGZvciB0aGUgZmlyc3QgMTAwIG9yZGVyZWQgbWVzc2FnZXMuIEFzIGl0ZW1zIGNoYW5nZSwgd2Ugd2lsbCByZWNlaXZlXHJcbiAqIGBjaGlsZF9yZW1vdmVkYCBldmVudHMgZm9yIGVhY2ggaXRlbSB0aGF0IGRyb3BzIG91dCBvZiB0aGUgYWN0aXZlIGxpc3Qgc29cclxuICogdGhhdCB0aGUgdG90YWwgbnVtYmVyIHN0YXlzIGF0IDEwMC5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYGxpbWl0VG9GaXJzdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byBpbmNsdWRlIGluIHRoaXMgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaW1pdFRvRmlyc3QobGltaXQpIHtcclxuICAgIGlmICh0eXBlb2YgbGltaXQgIT09ICdudW1iZXInIHx8IE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fCBsaW1pdCA8PSAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBRdWVyeUxpbWl0VG9GaXJzdENvbnN0cmFpbnQobGltaXQpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5TGltaXRUb0xhc3RDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKF9saW1pdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XHJcbiAgICB9XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc0xpbWl0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW1pdFRvTGFzdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXRUb0ZpcnN0ICcgK1xyXG4gICAgICAgICAgICAgICAgJ29yIGxpbWl0VG9MYXN0KS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBxdWVyeVBhcmFtc0xpbWl0VG9MYXN0KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgdGhpcy5fbGltaXQpLCBxdWVyeS5fb3JkZXJCeUNhbGxlZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYFF1ZXJ5Q29uc3RyYWludGAgdGhhdCBpcyBsaW1pdGVkIHRvIHJldHVybiBvbmx5IHRoZSBsYXN0XHJcbiAqIHNwZWNpZmllZCBudW1iZXIgb2YgY2hpbGRyZW4uXHJcbiAqXHJcbiAqIFRoZSBgbGltaXRUb0xhc3QoKWAgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IGEgbWF4aW11bSBudW1iZXIgb2YgY2hpbGRyZW4gdG8gYmVcclxuICogc3luY2VkIGZvciBhIGdpdmVuIGNhbGxiYWNrLiBJZiB3ZSBzZXQgYSBsaW1pdCBvZiAxMDAsIHdlIHdpbGwgaW5pdGlhbGx5IG9ubHlcclxuICogcmVjZWl2ZSB1cCB0byAxMDAgYGNoaWxkX2FkZGVkYCBldmVudHMuIElmIHdlIGhhdmUgZmV3ZXIgdGhhbiAxMDAgbWVzc2FnZXNcclxuICogc3RvcmVkIGluIG91ciBEYXRhYmFzZSwgYSBgY2hpbGRfYWRkZWRgIGV2ZW50IHdpbGwgZmlyZSBmb3IgZWFjaCBtZXNzYWdlLlxyXG4gKiBIb3dldmVyLCBpZiB3ZSBoYXZlIG92ZXIgMTAwIG1lc3NhZ2VzLCB3ZSB3aWxsIG9ubHkgcmVjZWl2ZSBhIGBjaGlsZF9hZGRlZGBcclxuICogZXZlbnQgZm9yIHRoZSBsYXN0IDEwMCBvcmRlcmVkIG1lc3NhZ2VzLiBBcyBpdGVtcyBjaGFuZ2UsIHdlIHdpbGwgcmVjZWl2ZVxyXG4gKiBgY2hpbGRfcmVtb3ZlZGAgZXZlbnRzIGZvciBlYWNoIGl0ZW0gdGhhdCBkcm9wcyBvdXQgb2YgdGhlIGFjdGl2ZSBsaXN0IHNvXHJcbiAqIHRoYXQgdGhlIHRvdGFsIG51bWJlciBzdGF5cyBhdCAxMDAuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBsaW1pdFRvTGFzdCgpYCBpblxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvZGF0YWJhc2Uvd2ViL2xpc3RzLW9mLWRhdGEjZmlsdGVyaW5nX2RhdGEgfCBGaWx0ZXJpbmcgZGF0YX0uXHJcbiAqXHJcbiAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBub2RlcyB0byBpbmNsdWRlIGluIHRoaXMgcXVlcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBsaW1pdFRvTGFzdChsaW1pdCkge1xyXG4gICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHwgTWF0aC5mbG9vcihsaW1pdCkgIT09IGxpbWl0IHx8IGxpbWl0IDw9IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpbWl0VG9MYXN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgUXVlcnlMaW1pdFRvTGFzdENvbnN0cmFpbnQobGltaXQpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeUNoaWxkQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBjb25zdHJ1Y3RvcihfcGF0aCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcGF0aCA9IF9wYXRoO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGwocXVlcnksICdvcmRlckJ5Q2hpbGQnKTtcclxuICAgICAgICBjb25zdCBwYXJzZWRQYXRoID0gbmV3IFBhdGgodGhpcy5fcGF0aCk7XHJcbiAgICAgICAgaWYgKHBhdGhJc0VtcHR5KHBhcnNlZFBhdGgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3JkZXJCeUNoaWxkOiBjYW5ub3QgcGFzcyBpbiBlbXB0eSBwYXRoLiBVc2Ugb3JkZXJCeVZhbHVlKCkgaW5zdGVhZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBuZXcgUGF0aEluZGV4KHBhcnNlZFBhdGgpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIGluZGV4KTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSB0aGUgc3BlY2lmaWVkIGNoaWxkIGtleS5cclxuICpcclxuICogUXVlcmllcyBjYW4gb25seSBvcmRlciBieSBvbmUga2V5IGF0IGEgdGltZS4gQ2FsbGluZyBgb3JkZXJCeUNoaWxkKClgXHJcbiAqIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIHF1ZXJ5IGlzIGFuIGVycm9yLlxyXG4gKlxyXG4gKiBGaXJlYmFzZSBxdWVyaWVzIGFsbG93IHlvdSB0byBvcmRlciB5b3VyIGRhdGEgYnkgYW55IGNoaWxkIGtleSBvbiB0aGUgZmx5LlxyXG4gKiBIb3dldmVyLCBpZiB5b3Uga25vdyBpbiBhZHZhbmNlIHdoYXQgeW91ciBpbmRleGVzIHdpbGwgYmUsIHlvdSBjYW4gZGVmaW5lXHJcbiAqIHRoZW0gdmlhIHRoZSAuaW5kZXhPbiBydWxlIGluIHlvdXIgU2VjdXJpdHkgUnVsZXMgZm9yIGJldHRlciBwZXJmb3JtYW5jZS4gU2VlXHJcbiAqIHRoZXtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS9zZWN1cml0eS9pbmRleGluZy1kYXRhfVxyXG4gKiBydWxlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgb3JkZXJCeUNoaWxkKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9LlxyXG4gKlxyXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIG9yZGVyIGJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeUNoaWxkKHBhdGgpIHtcclxuICAgIGlmIChwYXRoID09PSAnJGtleScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogXCIka2V5XCIgaXMgaW52YWxpZC4gIFVzZSBvcmRlckJ5S2V5KCkgaW5zdGVhZC4nKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHBhdGggPT09ICckcHJpb3JpdHknKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcmRlckJ5Q2hpbGQ6IFwiJHByaW9yaXR5XCIgaXMgaW52YWxpZC4gIFVzZSBvcmRlckJ5UHJpb3JpdHkoKSBpbnN0ZWFkLicpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGF0aCA9PT0gJyR2YWx1ZScpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29yZGVyQnlDaGlsZDogXCIkdmFsdWVcIiBpcyBpbnZhbGlkLiAgVXNlIG9yZGVyQnlWYWx1ZSgpIGluc3RlYWQuJyk7XHJcbiAgICB9XHJcbiAgICB2YWxpZGF0ZVBhdGhTdHJpbmcoJ29yZGVyQnlDaGlsZCcsICdwYXRoJywgcGF0aCwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlDaGlsZENvbnN0cmFpbnQocGF0aCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5S2V5Q29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlLZXknKTtcclxuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBxdWVyeVBhcmFtc09yZGVyQnkocXVlcnkuX3F1ZXJ5UGFyYW1zLCBLRVlfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHRoZSBrZXkuXHJcbiAqXHJcbiAqIFNvcnRzIHRoZSByZXN1bHRzIG9mIGEgcXVlcnkgYnkgdGhlaXIgKGFzY2VuZGluZykga2V5IHZhbHVlcy5cclxuICpcclxuICogWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgYG9yZGVyQnlLZXkoKWAgaW5cclxuICoge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2RhdGFiYXNlL3dlYi9saXN0cy1vZi1kYXRhI3NvcnRfZGF0YSB8IFNvcnQgZGF0YX0uXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5S2V5KCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlLZXlDb25zdHJhaW50KCk7XHJcbn1cclxuY2xhc3MgUXVlcnlPcmRlckJ5UHJpb3JpdHlDb25zdHJhaW50IGV4dGVuZHMgUXVlcnlDb25zdHJhaW50IHtcclxuICAgIF9hcHBseShxdWVyeSkge1xyXG4gICAgICAgIHZhbGlkYXRlTm9QcmV2aW91c09yZGVyQnlDYWxsKHF1ZXJ5LCAnb3JkZXJCeVByaW9yaXR5Jyk7XHJcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0gcXVlcnlQYXJhbXNPcmRlckJ5KHF1ZXJ5Ll9xdWVyeVBhcmFtcywgUFJJT1JJVFlfSU5ERVgpO1xyXG4gICAgICAgIHZhbGlkYXRlUXVlcnlFbmRwb2ludHMobmV3UGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5SW1wbChxdWVyeS5fcmVwbywgcXVlcnkuX3BhdGgsIG5ld1BhcmFtcywgXHJcbiAgICAgICAgLypvcmRlckJ5Q2FsbGVkPSovIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgb3JkZXJzIGJ5IHByaW9yaXR5LlxyXG4gKlxyXG4gKiBBcHBsaWNhdGlvbnMgbmVlZCBub3QgdXNlIHByaW9yaXR5IGJ1dCBjYW4gb3JkZXIgY29sbGVjdGlvbnMgYnlcclxuICogb3JkaW5hcnkgcHJvcGVydGllcyAoc2VlXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9XHJcbiAqIGZvciBhbHRlcm5hdGl2ZXMgdG8gcHJpb3JpdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBvcmRlckJ5UHJpb3JpdHkoKSB7XHJcbiAgICByZXR1cm4gbmV3IFF1ZXJ5T3JkZXJCeVByaW9yaXR5Q29uc3RyYWludCgpO1xyXG59XHJcbmNsYXNzIFF1ZXJ5T3JkZXJCeVZhbHVlQ29uc3RyYWludCBleHRlbmRzIFF1ZXJ5Q29uc3RyYWludCB7XHJcbiAgICBfYXBwbHkocXVlcnkpIHtcclxuICAgICAgICB2YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbChxdWVyeSwgJ29yZGVyQnlWYWx1ZScpO1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmFtcyA9IHF1ZXJ5UGFyYW1zT3JkZXJCeShxdWVyeS5fcXVlcnlQYXJhbXMsIFZBTFVFX0lOREVYKTtcclxuICAgICAgICB2YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzKG5ld1BhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeUltcGwocXVlcnkuX3JlcG8sIHF1ZXJ5Ll9wYXRoLCBuZXdQYXJhbXMsIFxyXG4gICAgICAgIC8qb3JkZXJCeUNhbGxlZD0qLyB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBgUXVlcnlDb25zdHJhaW50YCB0aGF0IG9yZGVycyBieSB2YWx1ZS5cclxuICpcclxuICogSWYgdGhlIGNoaWxkcmVuIG9mIGEgcXVlcnkgYXJlIGFsbCBzY2FsYXIgdmFsdWVzIChzdHJpbmcsIG51bWJlciwgb3JcclxuICogYm9vbGVhbiksIHlvdSBjYW4gb3JkZXIgdGhlIHJlc3VsdHMgYnkgdGhlaXIgKGFzY2VuZGluZykgdmFsdWVzLlxyXG4gKlxyXG4gKiBZb3UgY2FuIHJlYWQgbW9yZSBhYm91dCBgb3JkZXJCeVZhbHVlKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNzb3J0X2RhdGEgfCBTb3J0IGRhdGF9LlxyXG4gKi9cclxuZnVuY3Rpb24gb3JkZXJCeVZhbHVlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBRdWVyeU9yZGVyQnlWYWx1ZUNvbnN0cmFpbnQoKTtcclxufVxyXG5jbGFzcyBRdWVyeUVxdWFsVG9WYWx1ZUNvbnN0cmFpbnQgZXh0ZW5kcyBRdWVyeUNvbnN0cmFpbnQge1xyXG4gICAgY29uc3RydWN0b3IoX3ZhbHVlLCBfa2V5KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcclxuICAgICAgICB0aGlzLl9rZXkgPSBfa2V5O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ2VxdWFsVG8nLCB0aGlzLl92YWx1ZSwgcXVlcnkuX3BhdGgsIGZhbHNlKTtcclxuICAgICAgICBpZiAocXVlcnkuX3F1ZXJ5UGFyYW1zLmhhc1N0YXJ0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcXVhbFRvOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0L3N0YXJ0QWZ0ZXIgb3IgJyArXHJcbiAgICAgICAgICAgICAgICAnZXF1YWxUbykuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChxdWVyeS5fcXVlcnlQYXJhbXMuaGFzRW5kKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlcXVhbFRvOiBFbmRpbmcgcG9pbnQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gZW5kQXQvZW5kQmVmb3JlIG9yICcgK1xyXG4gICAgICAgICAgICAgICAgJ2VxdWFsVG8pLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5RW5kQXRDb25zdHJhaW50KHRoaXMuX3ZhbHVlLCB0aGlzLl9rZXkpLl9hcHBseShuZXcgUXVlcnlTdGFydEF0Q29uc3RyYWludCh0aGlzLl92YWx1ZSwgdGhpcy5fa2V5KS5fYXBwbHkocXVlcnkpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIGBRdWVyeUNvbnN0cmFpbnRgIHRoYXQgaW5jbHVkZXMgY2hpbGRyZW4gdGhhdCBtYXRjaCB0aGUgc3BlY2lmaWVkXHJcbiAqIHZhbHVlLlxyXG4gKlxyXG4gKiBVc2luZyBgc3RhcnRBdCgpYCwgYHN0YXJ0QWZ0ZXIoKWAsIGBlbmRCZWZvcmUoKWAsIGBlbmRBdCgpYCBhbmQgYGVxdWFsVG8oKWBcclxuICogYWxsb3dzIHlvdSB0byBjaG9vc2UgYXJiaXRyYXJ5IHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzIGZvciB5b3VyIHF1ZXJpZXMuXHJcbiAqXHJcbiAqIFRoZSBvcHRpb25hbCBrZXkgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gZnVydGhlciBsaW1pdCB0aGUgcmFuZ2Ugb2YgdGhlXHJcbiAqIHF1ZXJ5LiBJZiBpdCBpcyBzcGVjaWZpZWQsIHRoZW4gY2hpbGRyZW4gdGhhdCBoYXZlIGV4YWN0bHkgdGhlIHNwZWNpZmllZFxyXG4gKiB2YWx1ZSBtdXN0IGFsc28gaGF2ZSBleGFjdGx5IHRoZSBzcGVjaWZpZWQga2V5IGFzIHRoZWlyIGtleSBuYW1lLiBUaGlzIGNhbiBiZVxyXG4gKiB1c2VkIHRvIGZpbHRlciByZXN1bHQgc2V0cyB3aXRoIG1hbnkgbWF0Y2hlcyBmb3IgdGhlIHNhbWUgdmFsdWUuXHJcbiAqXHJcbiAqIFlvdSBjYW4gcmVhZCBtb3JlIGFib3V0IGBlcXVhbFRvKClgIGluXHJcbiAqIHtAbGluayBodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vZG9jcy9kYXRhYmFzZS93ZWIvbGlzdHMtb2YtZGF0YSNmaWx0ZXJpbmdfZGF0YSB8IEZpbHRlcmluZyBkYXRhfS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIG1hdGNoIGZvci4gVGhlIGFyZ3VtZW50IHR5cGUgZGVwZW5kcyBvbiB3aGljaFxyXG4gKiBgb3JkZXJCeSooKWAgZnVuY3Rpb24gd2FzIHVzZWQgaW4gdGhpcyBxdWVyeS4gU3BlY2lmeSBhIHZhbHVlIHRoYXQgbWF0Y2hlc1xyXG4gKiB0aGUgYG9yZGVyQnkqKClgIHR5cGUuIFdoZW4gdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGBvcmRlckJ5S2V5KClgLCB0aGVcclxuICogdmFsdWUgbXVzdCBiZSBhIHN0cmluZy5cclxuICogQHBhcmFtIGtleSAtIFRoZSBjaGlsZCBrZXkgdG8gc3RhcnQgYXQsIGFtb25nIHRoZSBjaGlsZHJlbiB3aXRoIHRoZVxyXG4gKiBwcmV2aW91c2x5IHNwZWNpZmllZCBwcmlvcml0eS4gVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFsbG93ZWQgaWYgb3JkZXJpbmcgYnlcclxuICogY2hpbGQsIHZhbHVlLCBvciBwcmlvcml0eS5cclxuICovXHJcbmZ1bmN0aW9uIGVxdWFsVG8odmFsdWUsIGtleSkge1xyXG4gICAgdmFsaWRhdGVLZXkoJ2VxdWFsVG8nLCAna2V5Jywga2V5LCB0cnVlKTtcclxuICAgIHJldHVybiBuZXcgUXVlcnlFcXVhbFRvVmFsdWVDb25zdHJhaW50KHZhbHVlLCBrZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGltbXV0YWJsZSBpbnN0YW5jZSBvZiBgUXVlcnlgIHRoYXQgaXMgZXh0ZW5kZWQgdG8gYWxzbyBpbmNsdWRlXHJcbiAqIGFkZGl0aW9uYWwgcXVlcnkgY29uc3RyYWludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBxdWVyeSAtIFRoZSBRdWVyeSBpbnN0YW5jZSB0byB1c2UgYXMgYSBiYXNlIGZvciB0aGUgbmV3IGNvbnN0cmFpbnRzLlxyXG4gKiBAcGFyYW0gcXVlcnlDb25zdHJhaW50cyAtIFRoZSBsaXN0IG9mIGBRdWVyeUNvbnN0cmFpbnRgcyB0byBhcHBseS5cclxuICogQHRocm93cyBpZiBhbnkgb2YgdGhlIHByb3ZpZGVkIHF1ZXJ5IGNvbnN0cmFpbnRzIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIHRoZVxyXG4gKiBleGlzdGluZyBvciBuZXcgY29uc3RyYWludHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeShxdWVyeSwgLi4ucXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgbGV0IHF1ZXJ5SW1wbCA9IGdldE1vZHVsYXJJbnN0YW5jZShxdWVyeSk7XHJcbiAgICBmb3IgKGNvbnN0IGNvbnN0cmFpbnQgb2YgcXVlcnlDb25zdHJhaW50cykge1xyXG4gICAgICAgIHF1ZXJ5SW1wbCA9IGNvbnN0cmFpbnQuX2FwcGx5KHF1ZXJ5SW1wbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcXVlcnlJbXBsO1xyXG59XHJcbi8qKlxyXG4gKiBEZWZpbmUgcmVmZXJlbmNlIGNvbnN0cnVjdG9yIGluIHZhcmlvdXMgbW9kdWxlc1xyXG4gKlxyXG4gKiBXZSBhcmUgZG9pbmcgdGhpcyBoZXJlIHRvIGF2b2lkIHNldmVyYWwgY2lyY3VsYXJcclxuICogZGVwZW5kZW5jeSBpc3N1ZXNcclxuICovXHJcbnN5bmNQb2ludFNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKFJlZmVyZW5jZUltcGwpO1xyXG5zeW5jVHJlZVNldFJlZmVyZW5jZUNvbnN0cnVjdG9yKFJlZmVyZW5jZUltcGwpO1xuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyB2YXJpYWJsZSBpcyBhbHNvIGRlZmluZWQgaW4gdGhlIGZpcmViYXNlIE5vZGUuanMgQWRtaW4gU0RLLiBCZWZvcmVcclxuICogbW9kaWZ5aW5nIHRoaXMgZGVmaW5pdGlvbiwgY29uc3VsdCB0aGUgZGVmaW5pdGlvbiBpbjpcclxuICpcclxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWFkbWluLW5vZGVcclxuICpcclxuICogYW5kIG1ha2Ugc3VyZSB0aGUgdHdvIGFyZSBjb25zaXN0ZW50LlxyXG4gKi9cclxuY29uc3QgRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVF9WQVIgPSAnRklSRUJBU0VfREFUQUJBU0VfRU1VTEFUT1JfSE9TVCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCBjYWNoZXMgYFJlcG9gIGluc3RhbmNlcy5cclxuICovXHJcbmNvbnN0IHJlcG9zID0ge307XHJcbi8qKlxyXG4gKiBJZiB0cnVlLCBhbnkgbmV3IGBSZXBvYCB3aWxsIGJlIGNyZWF0ZWQgdG8gdXNlIGBSZWFkb25seVJlc3RDbGllbnRgIChmb3IgdGVzdGluZyBwdXJwb3NlcykuXHJcbiAqL1xyXG5sZXQgdXNlUmVzdENsaWVudCA9IGZhbHNlO1xyXG4vKipcclxuICogVXBkYXRlIGFuIGV4aXN0aW5nIGBSZXBvYCBpbiBwbGFjZSB0byBwb2ludCB0byBhIG5ldyBob3N0L3BvcnQuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXBvTWFuYWdlckFwcGx5RW11bGF0b3JTZXR0aW5ncyhyZXBvLCBob3N0LCBwb3J0LCB0b2tlblByb3ZpZGVyKSB7XHJcbiAgICByZXBvLnJlcG9JbmZvXyA9IG5ldyBSZXBvSW5mbyhgJHtob3N0fToke3BvcnR9YCwgXHJcbiAgICAvKiBzZWN1cmU9ICovIGZhbHNlLCByZXBvLnJlcG9JbmZvXy5uYW1lc3BhY2UsIHJlcG8ucmVwb0luZm9fLndlYlNvY2tldE9ubHksIHJlcG8ucmVwb0luZm9fLm5vZGVBZG1pbiwgcmVwby5yZXBvSW5mb18ucGVyc2lzdGVuY2VLZXksIHJlcG8ucmVwb0luZm9fLmluY2x1ZGVOYW1lc3BhY2VJblF1ZXJ5UGFyYW1zLCBcclxuICAgIC8qaXNVc2luZ0VtdWxhdG9yPSovIHRydWUpO1xyXG4gICAgaWYgKHRva2VuUHJvdmlkZXIpIHtcclxuICAgICAgICByZXBvLmF1dGhUb2tlblByb3ZpZGVyXyA9IHRva2VuUHJvdmlkZXI7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgZXZlciBiZSBjYWxsZWQgdG8gQ1JFQVRFIGEgbmV3IGRhdGFiYXNlIGluc3RhbmNlLlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwKGFwcCwgYXV0aFByb3ZpZGVyLCBhcHBDaGVja1Byb3ZpZGVyLCB1cmwsIG5vZGVBZG1pbikge1xyXG4gICAgbGV0IGRiVXJsID0gdXJsIHx8IGFwcC5vcHRpb25zLmRhdGFiYXNlVVJMO1xyXG4gICAgaWYgKGRiVXJsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoIWFwcC5vcHRpb25zLnByb2plY3RJZCkge1xyXG4gICAgICAgICAgICBmYXRhbChcIkNhbid0IGRldGVybWluZSBGaXJlYmFzZSBEYXRhYmFzZSBVUkwuIEJlIHN1cmUgdG8gaW5jbHVkZSBcIiArXHJcbiAgICAgICAgICAgICAgICAnIGEgUHJvamVjdCBJRCB3aGVuIGNhbGxpbmcgZmlyZWJhc2UuaW5pdGlhbGl6ZUFwcCgpLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2coJ1VzaW5nIGRlZmF1bHQgaG9zdCBmb3IgcHJvamVjdCAnLCBhcHAub3B0aW9ucy5wcm9qZWN0SWQpO1xyXG4gICAgICAgIGRiVXJsID0gYCR7YXBwLm9wdGlvbnMucHJvamVjdElkfS1kZWZhdWx0LXJ0ZGIuZmlyZWJhc2Vpby5jb21gO1xyXG4gICAgfVxyXG4gICAgbGV0IHBhcnNlZFVybCA9IHBhcnNlUmVwb0luZm8oZGJVcmwsIG5vZGVBZG1pbik7XHJcbiAgICBsZXQgcmVwb0luZm8gPSBwYXJzZWRVcmwucmVwb0luZm87XHJcbiAgICBsZXQgaXNFbXVsYXRvcjtcclxuICAgIGxldCBkYkVtdWxhdG9ySG9zdCA9IHVuZGVmaW5lZDtcclxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYpIHtcclxuICAgICAgICBkYkVtdWxhdG9ySG9zdCA9IHByb2Nlc3MuZW52W0ZJUkVCQVNFX0RBVEFCQVNFX0VNVUxBVE9SX0hPU1RfVkFSXTtcclxuICAgIH1cclxuICAgIGlmIChkYkVtdWxhdG9ySG9zdCkge1xyXG4gICAgICAgIGlzRW11bGF0b3IgPSB0cnVlO1xyXG4gICAgICAgIGRiVXJsID0gYGh0dHA6Ly8ke2RiRW11bGF0b3JIb3N0fT9ucz0ke3JlcG9JbmZvLm5hbWVzcGFjZX1gO1xyXG4gICAgICAgIHBhcnNlZFVybCA9IHBhcnNlUmVwb0luZm8oZGJVcmwsIG5vZGVBZG1pbik7XHJcbiAgICAgICAgcmVwb0luZm8gPSBwYXJzZWRVcmwucmVwb0luZm87XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpc0VtdWxhdG9yID0gIXBhcnNlZFVybC5yZXBvSW5mby5zZWN1cmU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhdXRoVG9rZW5Qcm92aWRlciA9IG5vZGVBZG1pbiAmJiBpc0VtdWxhdG9yXHJcbiAgICAgICAgPyBuZXcgRW11bGF0b3JUb2tlblByb3ZpZGVyKEVtdWxhdG9yVG9rZW5Qcm92aWRlci5PV05FUilcclxuICAgICAgICA6IG5ldyBGaXJlYmFzZUF1dGhUb2tlblByb3ZpZGVyKGFwcC5uYW1lLCBhcHAub3B0aW9ucywgYXV0aFByb3ZpZGVyKTtcclxuICAgIHZhbGlkYXRlVXJsKCdJbnZhbGlkIEZpcmViYXNlIERhdGFiYXNlIFVSTCcsIHBhcnNlZFVybCk7XHJcbiAgICBpZiAoIXBhdGhJc0VtcHR5KHBhcnNlZFVybC5wYXRoKSkge1xyXG4gICAgICAgIGZhdGFsKCdEYXRhYmFzZSBVUkwgbXVzdCBwb2ludCB0byB0aGUgcm9vdCBvZiBhIEZpcmViYXNlIERhdGFiYXNlICcgK1xyXG4gICAgICAgICAgICAnKG5vdCBpbmNsdWRpbmcgYSBjaGlsZCBwYXRoKS4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlcG8gPSByZXBvTWFuYWdlckNyZWF0ZVJlcG8ocmVwb0luZm8sIGFwcCwgYXV0aFRva2VuUHJvdmlkZXIsIG5ldyBBcHBDaGVja1Rva2VuUHJvdmlkZXIoYXBwLm5hbWUsIGFwcENoZWNrUHJvdmlkZXIpKTtcclxuICAgIHJldHVybiBuZXcgRGF0YWJhc2UocmVwbywgYXBwKTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIHRoZSByZXBvIGFuZCBtYWtlIHN1cmUgaXQgaXMgZGlzY29ubmVjdGVkLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcmVwb01hbmFnZXJEZWxldGVSZXBvKHJlcG8sIGFwcE5hbWUpIHtcclxuICAgIGNvbnN0IGFwcFJlcG9zID0gcmVwb3NbYXBwTmFtZV07XHJcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uLi5cclxuICAgIGlmICghYXBwUmVwb3MgfHwgYXBwUmVwb3NbcmVwby5rZXldICE9PSByZXBvKSB7XHJcbiAgICAgICAgZmF0YWwoYERhdGFiYXNlICR7YXBwTmFtZX0oJHtyZXBvLnJlcG9JbmZvX30pIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZC5gKTtcclxuICAgIH1cclxuICAgIHJlcG9JbnRlcnJ1cHQocmVwbyk7XHJcbiAgICBkZWxldGUgYXBwUmVwb3NbcmVwby5rZXldO1xyXG59XHJcbi8qKlxyXG4gKiBFbnN1cmVzIGEgcmVwbyBkb2Vzbid0IGFscmVhZHkgZXhpc3QgYW5kIHRoZW4gY3JlYXRlcyBvbmUgdXNpbmcgdGhlXHJcbiAqIHByb3ZpZGVkIGFwcC5cclxuICpcclxuICogQHBhcmFtIHJlcG9JbmZvIC0gVGhlIG1ldGFkYXRhIGFib3V0IHRoZSBSZXBvXHJcbiAqIEByZXR1cm5zIFRoZSBSZXBvIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBzZXJ2ZXIgLyByZXBvTmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyQ3JlYXRlUmVwbyhyZXBvSW5mbywgYXBwLCBhdXRoVG9rZW5Qcm92aWRlciwgYXBwQ2hlY2tQcm92aWRlcikge1xyXG4gICAgbGV0IGFwcFJlcG9zID0gcmVwb3NbYXBwLm5hbWVdO1xyXG4gICAgaWYgKCFhcHBSZXBvcykge1xyXG4gICAgICAgIGFwcFJlcG9zID0ge307XHJcbiAgICAgICAgcmVwb3NbYXBwLm5hbWVdID0gYXBwUmVwb3M7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVwbyA9IGFwcFJlcG9zW3JlcG9JbmZvLnRvVVJMU3RyaW5nKCldO1xyXG4gICAgaWYgKHJlcG8pIHtcclxuICAgICAgICBmYXRhbCgnRGF0YWJhc2UgaW5pdGlhbGl6ZWQgbXVsdGlwbGUgdGltZXMuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGZvcm1hdCBvZiB0aGUgZGF0YWJhc2UgVVJMIG1hdGNoZXMgd2l0aCBlYWNoIGRhdGFiYXNlKCkgY2FsbC4nKTtcclxuICAgIH1cclxuICAgIHJlcG8gPSBuZXcgUmVwbyhyZXBvSW5mbywgdXNlUmVzdENsaWVudCwgYXV0aFRva2VuUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIpO1xyXG4gICAgYXBwUmVwb3NbcmVwb0luZm8udG9VUkxTdHJpbmcoKV0gPSByZXBvO1xyXG4gICAgcmV0dXJuIHJlcG87XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlcyB1cyB0byB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24gZm9yIG5ldyBSZXBvcy5cclxuICovXHJcbmZ1bmN0aW9uIHJlcG9NYW5hZ2VyRm9yY2VSZXN0Q2xpZW50KGZvcmNlUmVzdENsaWVudCkge1xyXG4gICAgdXNlUmVzdENsaWVudCA9IGZvcmNlUmVzdENsaWVudDtcclxufVxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgRmlyZWJhc2UgUmVhbHRpbWUgRGF0YWJhc2UuXHJcbiAqL1xyXG5jbGFzcyBEYXRhYmFzZSB7XHJcbiAgICAvKiogQGhpZGVjb25zdHJ1Y3RvciAqL1xyXG4gICAgY29uc3RydWN0b3IoX3JlcG9JbnRlcm5hbCwgXHJcbiAgICAvKiogVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSBhc3NvY2lhdGVkIHdpdGggdGhpcyBSZWFsdGltZSBEYXRhYmFzZSBpbnN0YW5jZS4gKi9cclxuICAgIGFwcCkge1xyXG4gICAgICAgIHRoaXMuX3JlcG9JbnRlcm5hbCA9IF9yZXBvSW50ZXJuYWw7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgLyoqIFJlcHJlc2VudHMgYSBgRGF0YWJhc2VgIGluc3RhbmNlLiAqL1xyXG4gICAgICAgIHRoaXNbJ3R5cGUnXSA9ICdkYXRhYmFzZSc7XHJcbiAgICAgICAgLyoqIFRyYWNrIGlmIHRoZSBpbnN0YW5jZSBoYXMgYmVlbiB1c2VkIChyb290IG9yIHJlcG8gYWNjZXNzZWQpICovXHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2VTdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXQgX3JlcG8oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgcmVwb1N0YXJ0KHRoaXMuX3JlcG9JbnRlcm5hbCwgdGhpcy5hcHAub3B0aW9ucy5hcHBJZCwgdGhpcy5hcHAub3B0aW9uc1snZGF0YWJhc2VBdXRoVmFyaWFibGVPdmVycmlkZSddKTtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcG9JbnRlcm5hbDtcclxuICAgIH1cclxuICAgIGdldCBfcm9vdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3Jvb3RJbnRlcm5hbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290SW50ZXJuYWwgPSBuZXcgUmVmZXJlbmNlSW1wbCh0aGlzLl9yZXBvLCBuZXdFbXB0eVBhdGgoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290SW50ZXJuYWw7XHJcbiAgICB9XHJcbiAgICBfZGVsZXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290SW50ZXJuYWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVwb01hbmFnZXJEZWxldGVSZXBvKHRoaXMuX3JlcG8sIHRoaXMuYXBwLm5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBvSW50ZXJuYWwgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9yb290SW50ZXJuYWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBfY2hlY2tOb3REZWxldGVkKGFwaU5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdEludGVybmFsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKCdDYW5ub3QgY2FsbCAnICsgYXBpTmFtZSArICcgb24gYSBkZWxldGVkIGRhdGFiYXNlLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja1RyYW5zcG9ydEluaXQoKSB7XHJcbiAgICBpZiAoVHJhbnNwb3J0TWFuYWdlci5JU19UUkFOU1BPUlRfSU5JVElBTElaRUQpIHtcclxuICAgICAgICB3YXJuKCdUcmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC4gUGxlYXNlIGNhbGwgdGhpcyBmdW5jdGlvbiBiZWZvcmUgY2FsbGluZyByZWYgb3Igc2V0dGluZyB1cCBhIGxpc3RlbmVyJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEZvcmNlIHRoZSB1c2Ugb2Ygd2Vic29ja2V0cyBpbnN0ZWFkIG9mIGxvbmdQb2xsaW5nLlxyXG4gKi9cclxuZnVuY3Rpb24gZm9yY2VXZWJTb2NrZXRzKCkge1xyXG4gICAgY2hlY2tUcmFuc3BvcnRJbml0KCk7XHJcbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdygpO1xyXG59XHJcbi8qKlxyXG4gKiBGb3JjZSB0aGUgdXNlIG9mIGxvbmdQb2xsaW5nIGluc3RlYWQgb2Ygd2Vic29ja2V0cy4gVGhpcyB3aWxsIGJlIGlnbm9yZWQgaWYgd2Vic29ja2V0IHByb3RvY29sIGlzIHVzZWQgaW4gZGF0YWJhc2VVUkwuXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JjZUxvbmdQb2xsaW5nKCkge1xyXG4gICAgY2hlY2tUcmFuc3BvcnRJbml0KCk7XHJcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3coKTtcclxuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93KCk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGluc3RhbmNlIG9mIHRoZSBSZWFsdGltZSBEYXRhYmFzZSBTREsgdGhhdCBpcyBhc3NvY2lhdGVkXHJcbiAqIHdpdGggdGhlIHByb3ZpZGVkIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfS4gSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugd2l0aFxyXG4gKiB3aXRoIGRlZmF1bHQgc2V0dGluZ3MgaWYgbm8gaW5zdGFuY2UgZXhpc3RzIG9yIGlmIHRoZSBleGlzdGluZyBpbnN0YW5jZSB1c2VzXHJcbiAqIGEgY3VzdG9tIGRhdGFiYXNlIFVSTC5cclxuICpcclxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UgdGhhdCB0aGUgcmV0dXJuZWQgUmVhbHRpbWVcclxuICogRGF0YWJhc2UgaW5zdGFuY2UgaXMgYXNzb2NpYXRlZCB3aXRoLlxyXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCBvZiB0aGUgUmVhbHRpbWUgRGF0YWJhc2UgaW5zdGFuY2UgdG8gY29ubmVjdCB0by4gSWYgbm90XHJcbiAqIHByb3ZpZGVkLCB0aGUgU0RLIGNvbm5lY3RzIHRvIHRoZSBkZWZhdWx0IGluc3RhbmNlIG9mIHRoZSBGaXJlYmFzZSBBcHAuXHJcbiAqIEByZXR1cm5zIFRoZSBgRGF0YWJhc2VgIGluc3RhbmNlIG9mIHRoZSBwcm92aWRlZCBhcHAuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXREYXRhYmFzZShhcHAgPSBnZXRBcHAoKSwgdXJsKSB7XHJcbiAgICBjb25zdCBkYiA9IF9nZXRQcm92aWRlcihhcHAsICdkYXRhYmFzZScpLmdldEltbWVkaWF0ZSh7XHJcbiAgICAgICAgaWRlbnRpZmllcjogdXJsXHJcbiAgICB9KTtcclxuICAgIGlmICghZGIuX2luc3RhbmNlU3RhcnRlZCkge1xyXG4gICAgICAgIGNvbnN0IGVtdWxhdG9yID0gZ2V0RGVmYXVsdEVtdWxhdG9ySG9zdG5hbWVBbmRQb3J0KCdkYXRhYmFzZScpO1xyXG4gICAgICAgIGlmIChlbXVsYXRvcikge1xyXG4gICAgICAgICAgICBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcihkYiwgLi4uZW11bGF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYjtcclxufVxyXG4vKipcclxuICogTW9kaWZ5IHRoZSBwcm92aWRlZCBpbnN0YW5jZSB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBSZWFsdGltZSBEYXRhYmFzZVxyXG4gKiBlbXVsYXRvci5cclxuICpcclxuICogPHA+Tm90ZTogVGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHBlcmZvcm1pbmcgYW55IG90aGVyIG9wZXJhdGlvbi5cclxuICpcclxuICogQHBhcmFtIGRiIC0gVGhlIGluc3RhbmNlIHRvIG1vZGlmeS5cclxuICogQHBhcmFtIGhvc3QgLSBUaGUgZW11bGF0b3IgaG9zdCAoZXg6IGxvY2FsaG9zdClcclxuICogQHBhcmFtIHBvcnQgLSBUaGUgZW11bGF0b3IgcG9ydCAoZXg6IDgwODApXHJcbiAqIEBwYXJhbSBvcHRpb25zLm1vY2tVc2VyVG9rZW4gLSB0aGUgbW9jayBhdXRoIHRva2VuIHRvIHVzZSBmb3IgdW5pdCB0ZXN0aW5nIFNlY3VyaXR5IFJ1bGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25uZWN0RGF0YWJhc2VFbXVsYXRvcihkYiwgaG9zdCwgcG9ydCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCd1c2VFbXVsYXRvcicpO1xyXG4gICAgaWYgKGRiLl9pbnN0YW5jZVN0YXJ0ZWQpIHtcclxuICAgICAgICBmYXRhbCgnQ2Fubm90IGNhbGwgdXNlRW11bGF0b3IoKSBhZnRlciBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmVwbyA9IGRiLl9yZXBvSW50ZXJuYWw7XHJcbiAgICBsZXQgdG9rZW5Qcm92aWRlciA9IHVuZGVmaW5lZDtcclxuICAgIGlmIChyZXBvLnJlcG9JbmZvXy5ub2RlQWRtaW4pIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5tb2NrVXNlclRva2VuKSB7XHJcbiAgICAgICAgICAgIGZhdGFsKCdtb2NrVXNlclRva2VuIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIEFkbWluIFNESy4gRm9yIGNsaWVudCBhY2Nlc3Mgd2l0aCBtb2NrIHVzZXJzLCBwbGVhc2UgdXNlIHRoZSBcImZpcmViYXNlXCIgcGFja2FnZSBpbnN0ZWFkIG9mIFwiZmlyZWJhc2UtYWRtaW5cIi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9rZW5Qcm92aWRlciA9IG5ldyBFbXVsYXRvclRva2VuUHJvdmlkZXIoRW11bGF0b3JUb2tlblByb3ZpZGVyLk9XTkVSKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbnMubW9ja1VzZXJUb2tlbikge1xyXG4gICAgICAgIGNvbnN0IHRva2VuID0gdHlwZW9mIG9wdGlvbnMubW9ja1VzZXJUb2tlbiA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgPyBvcHRpb25zLm1vY2tVc2VyVG9rZW5cclxuICAgICAgICAgICAgOiBjcmVhdGVNb2NrVXNlclRva2VuKG9wdGlvbnMubW9ja1VzZXJUb2tlbiwgZGIuYXBwLm9wdGlvbnMucHJvamVjdElkKTtcclxuICAgICAgICB0b2tlblByb3ZpZGVyID0gbmV3IEVtdWxhdG9yVG9rZW5Qcm92aWRlcih0b2tlbik7XHJcbiAgICB9XHJcbiAgICAvLyBNb2RpZnkgdGhlIHJlcG8gdG8gYXBwbHkgZW11bGF0b3Igc2V0dGluZ3NcclxuICAgIHJlcG9NYW5hZ2VyQXBwbHlFbXVsYXRvclNldHRpbmdzKHJlcG8sIGhvc3QsIHBvcnQsIHRva2VuUHJvdmlkZXIpO1xyXG59XHJcbi8qKlxyXG4gKiBEaXNjb25uZWN0cyBmcm9tIHRoZSBzZXJ2ZXIgKGFsbCBEYXRhYmFzZSBvcGVyYXRpb25zIHdpbGwgYmUgY29tcGxldGVkXHJcbiAqIG9mZmxpbmUpLlxyXG4gKlxyXG4gKiBUaGUgY2xpZW50IGF1dG9tYXRpY2FsbHkgbWFpbnRhaW5zIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIHRvIHRoZSBEYXRhYmFzZVxyXG4gKiBzZXJ2ZXIsIHdoaWNoIHdpbGwgcmVtYWluIGFjdGl2ZSBpbmRlZmluaXRlbHkgYW5kIHJlY29ubmVjdCB3aGVuXHJcbiAqIGRpc2Nvbm5lY3RlZC4gSG93ZXZlciwgdGhlIGBnb09mZmxpbmUoKWAgYW5kIGBnb09ubGluZSgpYCBtZXRob2RzIG1heSBiZSB1c2VkXHJcbiAqIHRvIGNvbnRyb2wgdGhlIGNsaWVudCBjb25uZWN0aW9uIGluIGNhc2VzIHdoZXJlIGEgcGVyc2lzdGVudCBjb25uZWN0aW9uIGlzXHJcbiAqIHVuZGVzaXJhYmxlLlxyXG4gKlxyXG4gKiBXaGlsZSBvZmZsaW5lLCB0aGUgY2xpZW50IHdpbGwgbm8gbG9uZ2VyIHJlY2VpdmUgZGF0YSB1cGRhdGVzIGZyb20gdGhlXHJcbiAqIERhdGFiYXNlLiBIb3dldmVyLCBhbGwgRGF0YWJhc2Ugb3BlcmF0aW9ucyBwZXJmb3JtZWQgbG9jYWxseSB3aWxsIGNvbnRpbnVlIHRvXHJcbiAqIGltbWVkaWF0ZWx5IGZpcmUgZXZlbnRzLCBhbGxvd2luZyB5b3VyIGFwcGxpY2F0aW9uIHRvIGNvbnRpbnVlIGJlaGF2aW5nXHJcbiAqIG5vcm1hbGx5LiBBZGRpdGlvbmFsbHksIGVhY2ggb3BlcmF0aW9uIHBlcmZvcm1lZCBsb2NhbGx5IHdpbGwgYXV0b21hdGljYWxseVxyXG4gKiBiZSBxdWV1ZWQgYW5kIHJldHJpZWQgdXBvbiByZWNvbm5lY3Rpb24gdG8gdGhlIERhdGFiYXNlIHNlcnZlci5cclxuICpcclxuICogVG8gcmVjb25uZWN0IHRvIHRoZSBEYXRhYmFzZSBhbmQgYmVnaW4gcmVjZWl2aW5nIHJlbW90ZSBldmVudHMsIHNlZVxyXG4gKiBgZ29PbmxpbmUoKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYiAtIFRoZSBpbnN0YW5jZSB0byBkaXNjb25uZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ29PZmZsaW5lKGRiKSB7XHJcbiAgICBkYiA9IGdldE1vZHVsYXJJbnN0YW5jZShkYik7XHJcbiAgICBkYi5fY2hlY2tOb3REZWxldGVkKCdnb09mZmxpbmUnKTtcclxuICAgIHJlcG9JbnRlcnJ1cHQoZGIuX3JlcG8pO1xyXG59XHJcbi8qKlxyXG4gKiBSZWNvbm5lY3RzIHRvIHRoZSBzZXJ2ZXIgYW5kIHN5bmNocm9uaXplcyB0aGUgb2ZmbGluZSBEYXRhYmFzZSBzdGF0ZVxyXG4gKiB3aXRoIHRoZSBzZXJ2ZXIgc3RhdGUuXHJcbiAqXHJcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIGFmdGVyIGRpc2FibGluZyB0aGUgYWN0aXZlIGNvbm5lY3Rpb24gd2l0aFxyXG4gKiBgZ29PZmZsaW5lKClgLiBPbmNlIHJlY29ubmVjdGVkLCB0aGUgY2xpZW50IHdpbGwgdHJhbnNtaXQgdGhlIHByb3BlciBkYXRhXHJcbiAqIGFuZCBmaXJlIHRoZSBhcHByb3ByaWF0ZSBldmVudHMgc28gdGhhdCB5b3VyIGNsaWVudCBcImNhdGNoZXMgdXBcIlxyXG4gKiBhdXRvbWF0aWNhbGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gZGIgLSBUaGUgaW5zdGFuY2UgdG8gcmVjb25uZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ29PbmxpbmUoZGIpIHtcclxuICAgIGRiID0gZ2V0TW9kdWxhckluc3RhbmNlKGRiKTtcclxuICAgIGRiLl9jaGVja05vdERlbGV0ZWQoJ2dvT25saW5lJyk7XHJcbiAgICByZXBvUmVzdW1lKGRiLl9yZXBvKTtcclxufVxyXG5mdW5jdGlvbiBlbmFibGVMb2dnaW5nKGxvZ2dlciwgcGVyc2lzdGVudCkge1xyXG4gICAgZW5hYmxlTG9nZ2luZyQxKGxvZ2dlciwgcGVyc2lzdGVudCk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJEYXRhYmFzZSh2YXJpYW50KSB7XHJcbiAgICBzZXRTREtWZXJzaW9uKFNES19WRVJTSU9OJDEpO1xyXG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2RhdGFiYXNlJywgKGNvbnRhaW5lciwgeyBpbnN0YW5jZUlkZW50aWZpZXI6IHVybCB9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcclxuICAgICAgICBjb25zdCBhdXRoUHJvdmlkZXIgPSBjb250YWluZXIuZ2V0UHJvdmlkZXIoJ2F1dGgtaW50ZXJuYWwnKTtcclxuICAgICAgICBjb25zdCBhcHBDaGVja1Byb3ZpZGVyID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAtY2hlY2staW50ZXJuYWwnKTtcclxuICAgICAgICByZXR1cm4gcmVwb01hbmFnZXJEYXRhYmFzZUZyb21BcHAoYXBwLCBhdXRoUHJvdmlkZXIsIGFwcENoZWNrUHJvdmlkZXIsIHVybCk7XHJcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKS5zZXRNdWx0aXBsZUluc3RhbmNlcyh0cnVlKSk7XHJcbiAgICByZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbiwgdmFyaWFudCk7XHJcbiAgICAvLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc201LCBlc20yMDE3LCBjanM1LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxyXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuY29uc3QgU0VSVkVSX1RJTUVTVEFNUCA9IHtcclxuICAgICcuc3YnOiAndGltZXN0YW1wJ1xyXG59O1xyXG4vKipcclxuICogUmV0dXJucyBhIHBsYWNlaG9sZGVyIHZhbHVlIGZvciBhdXRvLXBvcHVsYXRpbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wICh0aW1lXHJcbiAqIHNpbmNlIHRoZSBVbml4IGVwb2NoLCBpbiBtaWxsaXNlY29uZHMpIGFzIGRldGVybWluZWQgYnkgdGhlIEZpcmViYXNlXHJcbiAqIHNlcnZlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXJ2ZXJUaW1lc3RhbXAoKSB7XHJcbiAgICByZXR1cm4gU0VSVkVSX1RJTUVTVEFNUDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhIHBsYWNlaG9sZGVyIHZhbHVlIHRoYXQgY2FuIGJlIHVzZWQgdG8gYXRvbWljYWxseSBpbmNyZW1lbnQgdGhlXHJcbiAqIGN1cnJlbnQgZGF0YWJhc2UgdmFsdWUgYnkgdGhlIHByb3ZpZGVkIGRlbHRhLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGVsdGEgLSB0aGUgYW1vdW50IHRvIG1vZGlmeSB0aGUgY3VycmVudCB2YWx1ZSBhdG9taWNhbGx5LlxyXG4gKiBAcmV0dXJucyBBIHBsYWNlaG9sZGVyIHZhbHVlIGZvciBtb2RpZnlpbmcgZGF0YSBhdG9taWNhbGx5IHNlcnZlci1zaWRlLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5jcmVtZW50KGRlbHRhKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgICcuc3YnOiB7XHJcbiAgICAgICAgICAgICdpbmNyZW1lbnQnOiBkZWx0YVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBsaWNlbnNlXHJcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIEEgdHlwZSBmb3IgdGhlIHJlc29sdmUgdmFsdWUgb2Yge0BsaW5rIHJ1blRyYW5zYWN0aW9ufS5cclxuICovXHJcbmNsYXNzIFRyYW5zYWN0aW9uUmVzdWx0IHtcclxuICAgIC8qKiBAaGlkZWNvbnN0cnVjdG9yICovXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgIC8qKiBXaGV0aGVyIHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VjY2Vzc2Z1bGx5IGNvbW1pdHRlZC4gKi9cclxuICAgIGNvbW1pdHRlZCwgXHJcbiAgICAvKiogVGhlIHJlc3VsdGluZyBkYXRhIHNuYXBzaG90LiAqL1xyXG4gICAgc25hcHNob3QpIHtcclxuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGNvbW1pdHRlZDtcclxuICAgICAgICB0aGlzLnNuYXBzaG90ID0gc25hcHNob3Q7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgb2JqZWN0LiAqL1xyXG4gICAgdG9KU09OKCkge1xyXG4gICAgICAgIHJldHVybiB7IGNvbW1pdHRlZDogdGhpcy5jb21taXR0ZWQsIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90LnRvSlNPTigpIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEF0b21pY2FsbHkgbW9kaWZpZXMgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi5cclxuICpcclxuICogQXRvbWljYWxseSBtb2RpZnkgdGhlIGRhdGEgYXQgdGhpcyBsb2NhdGlvbi4gVW5saWtlIGEgbm9ybWFsIGBzZXQoKWAsIHdoaWNoXHJcbiAqIGp1c3Qgb3ZlcndyaXRlcyB0aGUgZGF0YSByZWdhcmRsZXNzIG9mIGl0cyBwcmV2aW91cyB2YWx1ZSwgYHJ1blRyYW5zYWN0aW9uKClgIGlzXHJcbiAqIHVzZWQgdG8gbW9kaWZ5IHRoZSBleGlzdGluZyB2YWx1ZSB0byBhIG5ldyB2YWx1ZSwgZW5zdXJpbmcgdGhlcmUgYXJlIG5vXHJcbiAqIGNvbmZsaWN0cyB3aXRoIG90aGVyIGNsaWVudHMgd3JpdGluZyB0byB0aGUgc2FtZSBsb2NhdGlvbiBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gKlxyXG4gKiBUbyBhY2NvbXBsaXNoIHRoaXMsIHlvdSBwYXNzIGBydW5UcmFuc2FjdGlvbigpYCBhbiB1cGRhdGUgZnVuY3Rpb24gd2hpY2ggaXNcclxuICogdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGN1cnJlbnQgdmFsdWUgaW50byBhIG5ldyB2YWx1ZS4gSWYgYW5vdGhlciBjbGllbnRcclxuICogd3JpdGVzIHRvIHRoZSBsb2NhdGlvbiBiZWZvcmUgeW91ciBuZXcgdmFsdWUgaXMgc3VjY2Vzc2Z1bGx5IHdyaXR0ZW4sIHlvdXJcclxuICogdXBkYXRlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGggdGhlIG5ldyBjdXJyZW50IHZhbHVlLCBhbmQgdGhlXHJcbiAqIHdyaXRlIHdpbGwgYmUgcmV0cmllZC4gVGhpcyB3aWxsIGhhcHBlbiByZXBlYXRlZGx5IHVudGlsIHlvdXIgd3JpdGUgc3VjY2VlZHNcclxuICogd2l0aG91dCBjb25mbGljdCBvciB5b3UgYWJvcnQgdGhlIHRyYW5zYWN0aW9uIGJ5IG5vdCByZXR1cm5pbmcgYSB2YWx1ZSBmcm9tXHJcbiAqIHlvdXIgdXBkYXRlIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBOb3RlOiBNb2RpZnlpbmcgZGF0YSB3aXRoIGBzZXQoKWAgd2lsbCBjYW5jZWwgYW55IHBlbmRpbmcgdHJhbnNhY3Rpb25zIGF0XHJcbiAqIHRoYXQgbG9jYXRpb24sIHNvIGV4dHJlbWUgY2FyZSBzaG91bGQgYmUgdGFrZW4gaWYgbWl4aW5nIGBzZXQoKWAgYW5kXHJcbiAqIGBydW5UcmFuc2FjdGlvbigpYCB0byB1cGRhdGUgdGhlIHNhbWUgZGF0YS5cclxuICpcclxuICogTm90ZTogV2hlbiB1c2luZyB0cmFuc2FjdGlvbnMgd2l0aCBTZWN1cml0eSBhbmQgRmlyZWJhc2UgUnVsZXMgaW4gcGxhY2UsIGJlXHJcbiAqIGF3YXJlIHRoYXQgYSBjbGllbnQgbmVlZHMgYC5yZWFkYCBhY2Nlc3MgaW4gYWRkaXRpb24gdG8gYC53cml0ZWAgYWNjZXNzIGluXHJcbiAqIG9yZGVyIHRvIHBlcmZvcm0gYSB0cmFuc2FjdGlvbi4gVGhpcyBpcyBiZWNhdXNlIHRoZSBjbGllbnQtc2lkZSBuYXR1cmUgb2ZcclxuICogdHJhbnNhY3Rpb25zIHJlcXVpcmVzIHRoZSBjbGllbnQgdG8gcmVhZCB0aGUgZGF0YSBpbiBvcmRlciB0byB0cmFuc2FjdGlvbmFsbHlcclxuICogdXBkYXRlIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmIC0gVGhlIGxvY2F0aW9uIHRvIGF0b21pY2FsbHkgbW9kaWZ5LlxyXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25VcGRhdGUgLSBBIGRldmVsb3Blci1zdXBwbGllZCBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIHBhc3NlZFxyXG4gKiB0aGUgY3VycmVudCBkYXRhIHN0b3JlZCBhdCB0aGlzIGxvY2F0aW9uIChhcyBhIEphdmFTY3JpcHQgb2JqZWN0KS4gVGhlXHJcbiAqIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gdGhlIG5ldyB2YWx1ZSBpdCB3b3VsZCBsaWtlIHdyaXR0ZW4gKGFzIGEgSmF2YVNjcmlwdFxyXG4gKiBvYmplY3QpLiBJZiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCAoaS5lLiB5b3UgcmV0dXJuIHdpdGggbm8gYXJndW1lbnRzKSB0aGVcclxuICogdHJhbnNhY3Rpb24gd2lsbCBiZSBhYm9ydGVkIGFuZCB0aGUgZGF0YSBhdCB0aGlzIGxvY2F0aW9uIHdpbGwgbm90IGJlXHJcbiAqIG1vZGlmaWVkLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0cmFuc2FjdGlvbnMuXHJcbiAqIEByZXR1cm5zIEEgYFByb21pc2VgIHRoYXQgY2FuIG9wdGlvbmFsbHkgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBgb25Db21wbGV0ZWBcclxuICogY2FsbGJhY2sgdG8gaGFuZGxlIHN1Y2Nlc3MgYW5kIGZhaWx1cmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBydW5UcmFuc2FjdGlvbihyZWYsIFxyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG50cmFuc2FjdGlvblVwZGF0ZSwgb3B0aW9ucykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgcmVmID0gZ2V0TW9kdWxhckluc3RhbmNlKHJlZik7XHJcbiAgICB2YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgcmVmLl9wYXRoKTtcclxuICAgIGlmIChyZWYua2V5ID09PSAnLmxlbmd0aCcgfHwgcmVmLmtleSA9PT0gJy5rZXlzJykge1xyXG4gICAgICAgIHRocm93ICgnUmVmZXJlbmNlLnRyYW5zYWN0aW9uIGZhaWxlZDogJyArIHJlZi5rZXkgKyAnIGlzIGEgcmVhZC1vbmx5IG9iamVjdC4nKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGFwcGx5TG9jYWxseSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hcHBseUxvY2FsbHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XHJcbiAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xyXG4gICAgY29uc3QgcHJvbWlzZUNvbXBsZXRlID0gKGVycm9yLCBjb21taXR0ZWQsIG5vZGUpID0+IHtcclxuICAgICAgICBsZXQgZGF0YVNuYXBzaG90ID0gbnVsbDtcclxuICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGFTbmFwc2hvdCA9IG5ldyBEYXRhU25hcHNob3Qobm9kZSwgbmV3IFJlZmVyZW5jZUltcGwocmVmLl9yZXBvLCByZWYuX3BhdGgpLCBQUklPUklUWV9JTkRFWCk7XHJcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobmV3IFRyYW5zYWN0aW9uUmVzdWx0KGNvbW1pdHRlZCwgZGF0YVNuYXBzaG90KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEFkZCBhIHdhdGNoIHRvIG1ha2Ugc3VyZSB3ZSBnZXQgc2VydmVyIHVwZGF0ZXMuXHJcbiAgICBjb25zdCB1bndhdGNoZXIgPSBvblZhbHVlKHJlZiwgKCkgPT4geyB9KTtcclxuICAgIHJlcG9TdGFydFRyYW5zYWN0aW9uKHJlZi5fcmVwbywgcmVmLl9wYXRoLCB0cmFuc2FjdGlvblVwZGF0ZSwgcHJvbWlzZUNvbXBsZXRlLCB1bndhdGNoZXIsIGFwcGx5TG9jYWxseSk7XHJcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcclxufVxuXG4vKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcclxuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNpbXBsZUxpc3RlbiA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7XHJcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdxJywgeyBwOiBwYXRoU3RyaW5nIH0sIG9uQ29tcGxldGUpO1xyXG59O1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxyXG5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuZWNobyA9IGZ1bmN0aW9uIChkYXRhLCBvbkVjaG8pIHtcclxuICAgIHRoaXMuc2VuZFJlcXVlc3QoJ2VjaG8nLCB7IGQ6IGRhdGEgfSwgb25FY2hvKTtcclxufTtcclxuLy8gUmVhbFRpbWVDb25uZWN0aW9uIHByb3BlcnRpZXMgdGhhdCB3ZSB1c2UgaW4gdGVzdHMuXHJcbkNvbm5lY3Rpb247XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNvbnN0IGhpamFja0hhc2ggPSBmdW5jdGlvbiAobmV3SGFzaCkge1xyXG4gICAgY29uc3Qgb2xkUHV0ID0gUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dDtcclxuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xyXG4gICAgICAgIGlmIChoYXNoICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgaGFzaCA9IG5ld0hhc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2xkUHV0LmNhbGwodGhpcywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0ID0gb2xkUHV0O1xyXG4gICAgfTtcclxufTtcclxuUmVwb0luZm87XHJcbi8qKlxyXG4gKiBGb3JjZXMgdGhlIFJlcG9NYW5hZ2VyIHRvIGNyZWF0ZSBSZXBvcyB0aGF0IHVzZSBSZWFkb25seVJlc3RDbGllbnQgaW5zdGVhZCBvZiBQZXJzaXN0ZW50Q29ubmVjdGlvbi5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jb25zdCBmb3JjZVJlc3RDbGllbnQgPSBmdW5jdGlvbiAoZm9yY2VSZXN0Q2xpZW50KSB7XHJcbiAgICByZXBvTWFuYWdlckZvcmNlUmVzdENsaWVudChmb3JjZVJlc3RDbGllbnQpO1xyXG59O1xuXG4vKipcclxuICogRmlyZWJhc2UgUmVhbHRpbWUgRGF0YWJhc2VcclxuICpcclxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXHJcbiAqL1xyXG5yZWdpc3RlckRhdGFiYXNlKCk7XG5cbmV4cG9ydCB7IERhdGFTbmFwc2hvdCwgRGF0YWJhc2UsIE9uRGlzY29ubmVjdCwgUXVlcnlDb25zdHJhaW50LCBUcmFuc2FjdGlvblJlc3VsdCwgUXVlcnlJbXBsIGFzIF9RdWVyeUltcGwsIFF1ZXJ5UGFyYW1zIGFzIF9RdWVyeVBhcmFtcywgUmVmZXJlbmNlSW1wbCBhcyBfUmVmZXJlbmNlSW1wbCwgZm9yY2VSZXN0Q2xpZW50IGFzIF9URVNUX0FDQ0VTU19mb3JjZVJlc3RDbGllbnQsIGhpamFja0hhc2ggYXMgX1RFU1RfQUNDRVNTX2hpamFja0hhc2gsIHJlcG9NYW5hZ2VyRGF0YWJhc2VGcm9tQXBwIGFzIF9yZXBvTWFuYWdlckRhdGFiYXNlRnJvbUFwcCwgc2V0U0RLVmVyc2lvbiBhcyBfc2V0U0RLVmVyc2lvbiwgdmFsaWRhdGVQYXRoU3RyaW5nIGFzIF92YWxpZGF0ZVBhdGhTdHJpbmcsIHZhbGlkYXRlV3JpdGFibGVQYXRoIGFzIF92YWxpZGF0ZVdyaXRhYmxlUGF0aCwgY2hpbGQsIGNvbm5lY3REYXRhYmFzZUVtdWxhdG9yLCBlbmFibGVMb2dnaW5nLCBlbmRBdCwgZW5kQmVmb3JlLCBlcXVhbFRvLCBmb3JjZUxvbmdQb2xsaW5nLCBmb3JjZVdlYlNvY2tldHMsIGdldCwgZ2V0RGF0YWJhc2UsIGdvT2ZmbGluZSwgZ29PbmxpbmUsIGluY3JlbWVudCwgbGltaXRUb0ZpcnN0LCBsaW1pdFRvTGFzdCwgb2ZmLCBvbkNoaWxkQWRkZWQsIG9uQ2hpbGRDaGFuZ2VkLCBvbkNoaWxkTW92ZWQsIG9uQ2hpbGRSZW1vdmVkLCBvbkRpc2Nvbm5lY3QsIG9uVmFsdWUsIG9yZGVyQnlDaGlsZCwgb3JkZXJCeUtleSwgb3JkZXJCeVByaW9yaXR5LCBvcmRlckJ5VmFsdWUsIHB1c2gsIHF1ZXJ5LCByZWYsIHJlZkZyb21VUkwsIHJlbW92ZSwgcnVuVHJhbnNhY3Rpb24sIHNlcnZlclRpbWVzdGFtcCwgc2V0LCBzZXRQcmlvcml0eSwgc2V0V2l0aFByaW9yaXR5LCBzdGFydEFmdGVyLCBzdGFydEF0LCB1cGRhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbTIwMTcuanMubWFwXG4iLCJpbXBvcnQgeyB3cmFwcGVyIH0gZnJvbSBcIi4vaGVscGVyXCI7XG5cbmNvbnN0IF9kYXRhYmFzZToge1trZXk6IHN0cmluZ106IGFueSB9ID0ge307XG5cbi8vIGltcG9ydCB7IGluaXRpYWxpemVBcHAgYXMgX2luaXRpYWxpemVBcHAgfSBmcm9tIFwiZmlyZWJhc2UvYXBwXCI7XG4vLyBfZGIuaW5pdGlhbGl6ZUFwcCA9IHdyYXBwZXIoXCJpbml0aWFsaXplQXBwXCIsIF9pbml0aWFsaXplQXBwKTsgXG5cbmltcG9ydCB7IGdldERhdGFiYXNlIH0gZnJvbSBcImZpcmViYXNlL2RhdGFiYXNlXCI7XG5fZGF0YWJhc2UuZ2V0RGF0YWJhc2UgPSB3cmFwcGVyKFwiZ2V0RGF0YWJhc2VcIiwgZ2V0RGF0YWJhc2UpO1xuXG5pbXBvcnQgeyBvblZhbHVlIH0gZnJvbSBcImZpcmViYXNlL2RhdGFiYXNlXCI7XG5fZGF0YWJhc2Uub25WYWx1ZSA9IHdyYXBwZXIoXCJvblZhbHVlXCIsIG9uVmFsdWUpO1xuXG5pbXBvcnQgeyByZWYgfSBmcm9tIFwiZmlyZWJhc2UvZGF0YWJhc2VcIjtcbl9kYXRhYmFzZS5yZWYgPSB3cmFwcGVyKFwicmVmXCIsIHJlZik7XG5cbmltcG9ydCB7IERhdGFTbmFwc2hvdCB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiO1xuX2RhdGFiYXNlLkRhdGFTbmFwc2hvdCA9IERhdGFTbmFwc2hvdDtcblxuaW1wb3J0IHsgcHVzaCB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiO1xuX2RhdGFiYXNlLnB1c2ggPSB3cmFwcGVyKFwicHVzaFwiLCBwdXNoKTtcblxuaW1wb3J0IHsgb25DaGlsZEFkZGVkIH0gZnJvbSBcImZpcmViYXNlL2RhdGFiYXNlXCI7XG5fZGF0YWJhc2Uub25DaGlsZEFkZGVkID0gd3JhcHBlcihcIm9uQ2hpbGRBZGRlZFwiLCBvbkNoaWxkQWRkZWQpO1xuaW1wb3J0IHsgb25DaGlsZENoYW5nZWQgfSBmcm9tIFwiZmlyZWJhc2UvZGF0YWJhc2VcIjtcbl9kYXRhYmFzZS5vbkNoaWxkQ2hhbmdlZCA9IHdyYXBwZXIoXCJvbkNoaWxkQ2hhbmdlZFwiLCBvbkNoaWxkQ2hhbmdlZCk7XG5pbXBvcnQgeyBvbkNoaWxkUmVtb3ZlZCB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiO1xuX2RhdGFiYXNlLm9uQ2hpbGRSZW1vdmVkID0gd3JhcHBlcihcIm9uQ2hpbGRSZW1vdmVkXCIsIG9uQ2hpbGRSZW1vdmVkKTtcbmltcG9ydCB7IG9uQ2hpbGRNb3ZlZCB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiO1xuX2RhdGFiYXNlLm9uQ2hpbGRNb3ZlZCA9IHdyYXBwZXIoXCJvbkNoaWxkTW92ZWRcIiwgb25DaGlsZE1vdmVkKTtcblxuaW1wb3J0IHsgb3JkZXJCeUNoaWxkIH0gZnJvbSBcImZpcmViYXNlL2RhdGFiYXNlXCI7XG5fZGF0YWJhc2Uub3JkZXJCeUNoaWxkID0gd3JhcHBlcihcIm9yZGVyQnlDaGlsZFwiLCBvcmRlckJ5Q2hpbGQpO1xuaW1wb3J0IHsgb3JkZXJCeUtleSB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiO1xuX2RhdGFiYXNlLm9yZGVyQnlLZXkgPSB3cmFwcGVyKFwib3JkZXJCeUtleVwiLCBvcmRlckJ5S2V5KTtcbmltcG9ydCB7IG9yZGVyQnlWYWx1ZSB9IGZyb20gXCJmaXJlYmFzZS9kYXRhYmFzZVwiO1xuX2RhdGFiYXNlLm9yZGVyQnlWYWx1ZSA9IHdyYXBwZXIoXCJvcmRlckJ5VmFsdWVcIiwgb3JkZXJCeVZhbHVlKTtcblxuaW1wb3J0IHtRdWVyeX0gZnJvbSBcImZpcmViYXNlL2RhdGFiYXNlXCI7XG5sZXQgZzogUXVlcnk7XG5cblxuXG5leHBvcnQgY29uc3QgZGF0YWJhc2UgPSBfZGF0YWJhc2U7IiwiaW1wb3J0IHsgYXBwIGFzIF9hcHAgfSBmcm9tICcuL2FwcCc7XG5pbXBvcnQgeyBkYXRhYmFzZSBhcyBfZGF0YWJhc2UgfSBmcm9tICcuL2RhdGFiYXNlJztcblxuZXhwb3J0IGNvbnN0IGFwcCA9IF9hcHA7XG5leHBvcnQgY29uc3QgZGF0YWJhc2UgPSBfZGF0YWJhc2U7Il0sIm5hbWVzIjpbImlzVmFsaWRLZXkiLCJERUZBVUxUX0VOVFJZX05BTUUiLCJ2ZXJzaW9uJDEiLCJsb2dnZXIiLCJuYW1lJDEiLCJuYW1lIiwidmVyc2lvbiIsIlNES19WRVJTSU9OIiwiYXBwIiwiZGF0YWJhc2UiLCJfYXBwIiwiX2RhdGFiYXNlIl0sIm1hcHBpbmdzIjoiQUFBZ0IsU0FBQSxPQUFPLENBQWtDLElBQVksRUFBRSxRQUFtQyxFQUFBO0FBQ3pHLElBQUEsT0FBTyxD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QUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksVUFBVSxDQUFDO0FBQ3JELFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsQixZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbEIsU0FBUztBQUNULFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFVBQVUsQ0FBQztBQUMzRCxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxVQUFVLENBQUM7QUFDM0QsUUFBUSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksVUFBVSxDQUFDO0FBQzNELFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFVBQVUsQ0FBQztBQUMzRCxRQUFRLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxVQUFVLENBQUM7QUFDM0QsS0FBSztBQUNMLElBQUksTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUU7QUFDMUI7QUFDQSxRQUFRLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtBQUMzQixZQUFZLE9BQU87QUFDbkIsU0FBUztBQUNULFFBQVEsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO0FBQ2xDLFlBQVksTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDbEMsU0FBUztBQUNULFFBQVEsTUFBTSxnQkFB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QyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDO0FBQ3ZDLFlBQVksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEdBQUcsQ0FBQztBQUM3QyxZQUFZLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxHQUFHLENBQUM7QUFDdEMsU0FBUztBQUNULGFBQWE7QUFDYixZQUFZLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxHQUFHLENBQUM7QUFDdkMsWUFBWSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxDQUFDO0FBQzlDLFlBQVksR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEdBQUcsQ0FBQztBQUM3QyxZQUFZLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxHQUFHLENBQUM7QUFDdEMsU0FBUztBQUNULEtBQUs7QUFDTCxJQUFJLE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQyxDQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sWUFBWSxHQUFHLFVBQVUsR0FBRyxFQUFFO0FBQ3BDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2QsSUFBSSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtBQUN6QyxRQUFRLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsUUFBUSxJQUFJLENBQUMsR0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksV0FBVyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDaEQsUUFBUSxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUN2QixRQUFRLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0FBQzNCLFFBQVEsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDO0FBQzFELFFBQVEsSUFBSSxDQUFDLElBQUk7QUFDakIsWUFBWSxJQUFJLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDO0FBQ3ZELFFBQVEsSUFBSSxDQUFDLEtBQUs7QUFDbEIsWUFBWSxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssR0FBRyxTQUFTLENBQUMsVUFBVSxDQUFDO0FBQ3pELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDekMsUUFBUSxPQUFPLElBQUksUUFBUSxDQUFDLEdBQUcsSUFBSSxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxJQUFJLElBQUksR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxJQUFJLElBQUksR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3ZNLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQUssR0FBRztBQUNa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LEdBQUcsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM5RSxRQUFRLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNqRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZLEdBQUc7QUFDbkIsUUFBUSxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztBQUM5RSxRQUFRLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNoRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSSxVQUFVLEdBQUc7QUFDakIsUUFBUSxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQzlFLFFBQVEsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNqRixRQUFRLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDL0QsS0FBSztBQUNMO0FBQ0E7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RUFBRSxVQUFVLEVBQUUsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN6RCxDQUFDLENBQUM7QUFDRjtBQUNBLG9CQUFvQixDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBVSxJQUFJLEVBQUUsTUFBTSxFQUFFO0FBQzlELElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDbEQsQ0FBQyxDQUFDO0FBMEJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixFQUFFOztBQ2puYmxCLE1BQU0sU0FBUyxHQUEwQixFQUFFLENBQUM7QUFNNUMsU0FBUyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0FBRzVELFNBQVMsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUdoRCxTQUFTLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFHcEMsU0FBUyxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7QUFHdEMsU0FBUyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBR3ZDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsT0FBTyxDQUFDLGNBQWMsRUFBRSxZQUFZLENBQUMsQ0FBQztBQUUvRCxTQUFTLENBQUMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsQ0FBQztBQUVyRSxTQUFTLENBQUMsY0FBYyxHQUFHLE9BQU8sQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsQ0FBQztBQUVyRSxTQUFTLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxjQUFjLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFHL0QsU0FBUyxDQUFDLFlBQVksR0FBRyxPQUFPLENBQUMsY0FBYyxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBRS9ELFNBQVMsQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQztBQUV6RCxTQUFTLENBQUMsWUFBWSxHQUFHLE9BQU8sQ0FBQyxjQUFjLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFPeEQsTUFBTUMsVUFBUSxHQUFHLFNBQVM7O0FDeEMxQixNQUFNLEdBQUcsR0FBR0MsTUFBSztBQUNqQixNQUFNLFFBQVEsR0FBR0M7Ozs7IiwieF9nb29nbGVfaWdub3JlTGlzdCI6WzEsMiwzLDQsNSw2LDcsOV19
