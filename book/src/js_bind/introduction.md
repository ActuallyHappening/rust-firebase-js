# JS Bind
Compile-time checks for JavaScript linking in Rust. **WIP!**

If you want to use JavaScript from Rust, the best way is to use `wasm-bindgen` and `js-sys` to link to the JavaScript runtime.
However, there are a few potential problems with this approach:
```rust
#[wasm_bindgen(module = "final-bundle-esm.js")]
extern "C" {
		/// This function does something
		pub fn my_js_function();
}
```

## Problems:
<!-- TODO: Remove incorrect info -->
<!-- ### Documentation comments don't propogate
If you wanted to read the documentation of the function generated by `wasm-bindgen` `my_js_function`, you wouldn't see anything.
Maybe you can add a 'wrapper' function that calls the JS function and documents that, but that's a lot of boilerplate. -->

### Documentation tests don't work on `wasm32` targets
To test code written for `wasm32` targets, you must create an integration test file annotated with `#[wasm_bindgen_test]`.
These tests are therefor seperate from any potential inline documentation comments, rendering documentation tests useless (with current tooling) for `wasm32` targets.

### Multiple targets: `node` and `web` (and maybe `deno`)
If you want to target both `node` and `web` (and maybe `deno`), you have to write two seperate `wasm-bindgen` modules, one for each target, or conditionally compile the `wasm-bindgen(module = "foo.js")` attribute using feature flags.
This is because the module you import from Rust has to either be written in `es` syntax (e.g. `bundle-esm.js`) or `cjs` syntax (e.g. `bundle-cjs.js`), at compile time it must be decided which to link to.
Using features flags have one caviat: The most 'clean' way is to use mutually exclusive flags, e.g. `link-node` and `link-web`, of which only one or the other (not both, and not none) can be enabled.
To express this using conditional compilation with `wasm-bindgen`, the resulting code would be something like:
```rust
#[cfg_attr(feature = "link-node"), wasm_bindgen(module = "final-bundle-cjs.js")]
#[cfg_attr(feature = "link-web"), wasm_bindgen(module = "final-bundle-esm.js")]
extern "C" {
		/// This function does something
		pub fn my_js_function();
}
```
Then, if none (or both) features are enabled, the code will not compile, and the errors produced are ugly!

### Compile time JS checking is not guarenteed
Lets imagine we accidentally forgot to export `my_js_function` from `final-bundle-esm.js`, and we try to compile our Rust code.
The Rust will compile, but the resulting WASM will not work, because the JS function is not exported.
This can only be tested by actually running (and calling from Rust) every function we use in Rst, there is no compile-time checking from the Rust compiler.

### Can't use static analysis tools like `rollup`
If you were wrapping an existing `npm` library (say, `firebase`) and in Rust you only used a subset of the features available to you, unless you individually imported each function you used, the resulting `wasm-bindgen` module would contain all the functions from the `npm` library.
Example that manually imports only one function:
```js
import { one_func as _one_funct } from "some_package";
export const one_func = _one_func;
```
Run rollup on this and output bundle to `js/final-bundle.js`
```rust 
#[wasm_bindgen(module = "js/final-bundle.js")]
extern "C" {
		/// This function does something
		pub fn one_func();
}
```

The resulting `js/final-bundle.js` would be small (if `some_package` was rollup friendly, which most are).
Now imagine exporting hundreds of `js` functions from Rust, and you would have to manually import each one, which is a lot of boilerplate.

## Solutions:
<!-- ### Propogate documentation comments
Since the function generated by the `wasm-bindgen` macro is 'owned' by the macro, there is no way we can add documentation comments to it unless we modified the `wasm-bindgen` macro. -->
### Documentation tests
To solve the problem of documentation tests not working on `wasm32` targets, we can use the `wasm-bindgen-test` crate.
Then, if you apply an attribute proc-macro to the exported functions and types, the proc-macro can read the applied doc-comments and copy them into the `tests/` directory.

This is the rationale behind the `#[js_bind(test)]` attribute proc-macro.

### Multiple targets
If you have a config file (`/js-bind.toml`) that specifies the feature flag names and the js bundle paths, you can use an attribute proc-macro to generate the necessary code to conditionally compile the correct `wasm-bindgen` attribute.
This is the rationale behind the `#[js_bind(module)]` attribute proc-macro.

To specify this in the config file, you can write:
```toml
[[module]]
if = "link-node"
then = "js/bundle-cjs.js"

[[module]]
if = "link-web"
then = "js/bundle-esm.js"
```

### Compile time JS checking
If you manually write the `wasm-bindgen` module, you can use the `#[js_bind(check)]` attribute proc-macro to check that all the functions you use in Rust are exported from the JS module. <!-- TODO: NOT IMPLEMENTED -->
- TODO: This is not implemented as of yet, and no simple way to do so exists other than compile-time testing (which is OK but not ideal, `cargo test` exists for a seperate reason than `cargo build`)

The approach I take more often is to record the information necessary to generate the `js` code at compile time (in `/js-bind.lock`) and then generate the `js` every time `/js-bind.lock` is changed (from `build.rs` using 'cargo:rerun-if-changed=js-bind.lock').
This is the rationale behind the `#[js_bind(gen = "template name", mod = "mod_name")]` attribute proc-macro.

```toml
[[codegen]]
name = "top level func"
template = "
import { #name as _#name } from '#mod';
export const #name = _#name;
"
```

### Using `rollup`
Read the above section on compile time JS checking, because if you automatically generated the `js` code, you can use `rollup` to bundle only the functions you use in Rust!